<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>当然我在扯淡</title>
<link>http://www.yinwang.org/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sun, 16 Apr 2017 20:46:04 +0800</lastBuildDate>
<item>
<title>经验和洞察力</title>
<link>http://yinwang.org/blog-cn/2017/04/14/experience-and-insight</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;经验和洞察力&lt;/h2&gt;
                            &lt;p&gt;过去的事情，就让它已成云烟吧……&lt;/p&gt;

&lt;p&gt;很多人很在乎“经验”，比如号称自己在某领域有 30 年的经验，会用这样那样的技术。我觉得经验是有价值的，我也有经验，各个领域的都有点。然而我并不把经验放在很重要的位置，因为我拥有大部分人都缺乏而且忽视的一种东西：洞察力（insight）。&lt;/p&gt;

&lt;p&gt;每进入一个新的公司，我进入的几乎都是不同的领域。所以最开头的时候，我有可能对那个领域所知甚少。甚至有人觉得我没有经验，所以可以“教育”我。然而每一次他们都没有想到的是，我很快就掌握了他们的经验，并且经过提炼，抛弃其中的垃圾，很快的超越了他们，完成他们根本无法达到的目标。这就是洞察力的威力。&lt;/p&gt;

&lt;p&gt;举个亲身例子，很多人都有用线程的经验，可是有多少人知道线程的本质是什么？有多少人在头脑里有一幅画面，显示出多线程程序的各种动态特征？其实很少有人知道。这就是为什么很多人过度的使用线程并发，结果产生各种同步问题，竞争状态（race condition），死锁等现象。某公司的一片多线程代码，号称是“有非常多并发程序经验”的程序员写的。结果没多久我就发现里面其实含有非常微妙的竞争情况，会在非常小的概率随机发作。发现之后没过几天，已经卖出去用了两年多的产品，由于这个竞争情况，终于引发了严重的后果。有那么多并发编程经验的程序员，两年多都没有察觉这个竞争情况，而很少写多线程程序的我，不但发现了这个竞争，而且很快的想出了修复它的办法，这是为什么呢？靠的就是洞察力。我知道线程的本质，而这是经验不会告诉你的。&lt;/p&gt;

&lt;p&gt;什么是洞察力？洞察力就是透过现象看到本质的能力。有洞察力的人很容易得到经验，然而有经验的人却不一定有洞察力。再愚钝的人，总是可以通过大量的时间获取经验，然而就算你花再多的时间和精力，也难以得到洞察力。所以洞察力是比经验宝贵很多的东西。很难说清楚如何才能有洞察力，也很少有人会告诉你如何去得到它。当然，我也不会告诉你。&lt;/p&gt;

&lt;p&gt;看别人简历，经常会列出各种各样的技术经验，我看一眼就会的东西，也会在上面占个位置。由于这个原因，我把自己 Linkedin 上面曾经列出的“工作经验”全都删掉了。这些东西列在那里，对于我本身的价值，实在是一种贬低。我是一个身上不贴任何标签的，不能被任何头衔所局限的，真正有价值的人。&lt;/p&gt;

&lt;p&gt;经验虽然不是最重要的，然而还是有必要的。很多技术你不能完全不碰它，然而一碰就明白了。但如果没有实际的问题，你又会没有动力去接触那些技术。所以我一直在做的一件事情，就是接触各种技术，然后利用洞察力来获得越来越多的经验。回国之后的初期，我打算着手做自己的产品。同时，我想跟国内的各种公司或者个人做这样的交易。我利用洞察力帮助解决他们最棘手的，已有经验无法解决的难题，从而让我获得经验。当然，我不是作为公司的职工，而只是作为独立的顾问。对公司我会象征性的收取一定的费用，换句话，就是作为“职业杀手”。对于个人，他的问题必须对我也有启发意义。对此感兴趣的公司或者个人，可以跟我联系。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/14/experience-and-insight</guid>
<pubDate>Fri, 14 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>C 编译器优化过程中的 Bug</title>
<link>http://yinwang.org/blog-cn/2016/10/12/compiler-bug</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;C 编译器优化过程中的 Bug&lt;/h2&gt;
                            &lt;p&gt;一个朋友向我指出一个最近他们发现的 GCC 编译器优化过程（加上 -O3 选项）里的 bug，导致他们的产品出现非常诡异的行为。这使我想起以前见过的一个 GCC bug。当时很多人死活认为那种做法是正确的，跟他们说不清楚。简言之，这种有问题的优化，喜欢利用 C 语言的“未定义行为”（undefined behavior）进行推断，最后得到奇怪的结果。&lt;/p&gt;

&lt;p&gt;这类优化过程的推理方式都很类似，他们使用一种看似严密而巧妙的推理，例如：“现在有一个整数 &lt;code&gt;x&lt;/code&gt;，我们不知道它是多少。但 &lt;code&gt;x&lt;/code&gt; 出现在一个条件语句里面，如果 &lt;code&gt;x &amp;gt; 1&lt;/code&gt;，那么程序会进入未定义行为，所以我们可以断定 &lt;code&gt;x&lt;/code&gt; 的值必然小于或者等于 1，所以现在我们利用 &lt;code&gt;x ≤ 1&lt;/code&gt; 这个事实来对相关代码进行优化……”&lt;/p&gt;

&lt;p&gt;看似合理，然而它却是不正确的，你能看出来这样的推理错在何处吗？我一时想不起来之前具体的例子了（如果你知道的话告诉我）。上网搜了一下相关话题，发现这篇 Chris Lattner (LLVM 和 &lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/06/swift&quot;&gt;Swift 语言&lt;/a&gt; 的设计者) 写于 2011 年的&lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;文章&lt;/a&gt;。文中指出，编译器利用 C 语言的“未定义行为”进行优化，是合理的，对于性能是很重要的，并且举出这样一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void contains_null_check(int *P) {
  int dead = *P;
  if (P == 0)
    return;
  *P = 4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这例子跟我之前看到的 GCC bug 不大一样，但大致是类似的推理方式：这个函数依次经过这样两个优化步骤（RNCE 和 DCE），之后得出“等价”的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void contains_null_check_after_RNCE(int *P) {
  int dead = *P;
  if (false)  // P 在上一行被访问，所以这里 P 不可能是 null
    return;
  *P = 4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void contains_null_check_after_RNCE_and_DCE(int *P) {
  //int dead = *P;    // 死代码消除
  //if (false)        // 死代码
  //  return;         // 死代码
  *P = 4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他的推理方式是这样：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先，因为在 &lt;code&gt;int dead = *P&lt;/code&gt; 里面，指针 &lt;code&gt;P&lt;/code&gt; 的地址被访问，如果程序顺利通过了这一行而没有出现未定义行为（比如当掉），那么之后 &lt;code&gt;P&lt;/code&gt; 就不可能是 null，所以我们可以把 &lt;code&gt;P == 0&lt;/code&gt; 优化为 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为条件是 &lt;code&gt;false&lt;/code&gt;，所以整个 if 语句都是死代码，被删掉。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dead&lt;/code&gt; 变量赋值之后，没有被任何其它代码使用，所以对 &lt;code&gt;dead&lt;/code&gt; 的赋值是死代码，可以消去。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;最后函数就只剩下一行代码 &lt;code&gt;*P = 4&lt;/code&gt;。然而经我分析，发现这个优化转换是根本错误的做法（unsound 的变换），而不只是像他说的“存在安全隐患”。现在我来考考你，你知道这为什么是错的吗？值得庆幸的是，现在如果你把这代码输入到 Clang，就算加上 -O3 选项，它也不会给你进行这个优化。这也许说明 Lattner 的这个想法后来已经被 LLVM 团队抛弃。&lt;/p&gt;

&lt;p&gt;我写这篇文章的目的其实是想告诉你，不要盲目的相信编译器的作者们做出的变换都是正确的，无论它看起来多么的合理，只要打开优化之后你的程序出现奇葩的行为，你就不能排除编译器进行了错误优化的可能性。Lattner 指出这样的优化完全符合 C 语言的标准，这说明就算你符合国际标准，也有可能其实是错的。有时候，你是得相信自己的直觉……&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/10/12/compiler-bug</guid>
<pubDate>Wed, 12 Oct 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>对 Rust 语言的分析</title>
<link>http://yinwang.org/blog-cn/2016/09/18/rust</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;对 Rust 语言的分析&lt;/h2&gt;
                            &lt;p&gt;Rust 是一门最近比较热的语言，有很多人问过我对 Rust 的看法。由于我本人是一个语言专家，实现过几乎所有的语言特性，所以我不认为任何一种语言是新的。任何“新语言”对我来说，不过是把早已存在的语言特性（或者毛病），挑一些出来放在一起。所以一般情况下我都不会去评论别人设计的语言，甚至懒得看一眼，除非它历史悠久（比如像 C 或者 C++），或者它在工作中惹恼了我（像 Go 和 JavaScript 那样）。这就是为什么这些人问我 Rust 的问题，我一般都没有回复，或者一笔带过。&lt;/p&gt;

&lt;p&gt;不过最近有点闲，我想既然有人这么热衷于这种新语言，那我还是稍微凑下热闹，顺便分享一下我对某些常见的设计思路的看法。所以这篇文章虽然是在评论 Rust 的设计，它却不只是针对 Rust。它是针对某些语言特性，而不只是针对某一种语言。&lt;/p&gt;

&lt;p&gt;由于我这人性格很难闭门造车，所以现在我只是把这篇文章的开头发布出来，边写边更新。所以你要明白，这只是一个开端，我会按自己理解的进度对这篇文章进行更新。你看了之后，可以隔一段时间再回来看新的内容。如果有特别疑惑的问题，也可以发信来问，我会汇总之后把看法发布在这里。&lt;/p&gt;

&lt;h3&gt;变量声明语法&lt;/h3&gt;

&lt;p&gt;Rust 的&lt;a href=&quot;https://doc.rust-lang.org/book/variable-bindings.html&quot;&gt;变量声明&lt;/a&gt;跟 Scala 和 Swift 的很像。你用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的构造来声明一个新的变量。大部分时候 Rust 可以推导出变量的类型，所以你不一定需要写明它的类型。如果你真的要指明变量类型，需要这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x: i32 = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我看来这是丑陋的语法。本来语义是把变量 x 绑定到值 8，可是 x 和 8 之间却隔着一个“i32”，看起来像是把 8 赋值给了 i32……&lt;/p&gt;

&lt;p&gt;变量缺省都是不可变的，也就是不可赋值。你必须用一种特殊的构造&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let mut x = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来声明可变变量。这跟 Swift/Scala 的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;var&lt;/code&gt; 的区别是一样的，只是形式不大一样。&lt;/p&gt;

&lt;h3&gt;变量可以重复绑定&lt;/h3&gt;

&lt;p&gt;Rust 的变量定义有一个比其它语言更奇怪的地方，它可以让你在同一个作用域里面“重复绑定”同一个名字，甚至可以把它绑定到另外一个类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let mut x: i32 = 1;
x = 7;
let x = x; // 这两个 x 是两个不同的变量

let y = 4;
// 30 lines of code ...
let y = &quot;I can also be bound to text!&quot;;
// 30 lines of code ...
println!(&quot;y is {}&quot;, y);      // 定义在第二个 let y 的地方
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Yin 语言最初的设计里面，我也是允许这样的重复绑定的。第一个 y 和 第二个 y 是两个不同的变量，只不过它们碰巧叫同一个名字而已。你甚至可以在同一行出现两个 x，而它们其实是不同的变量！这难道不是一个很酷，很灵活，其他语言都没有的设计吗？后来我发现，虽然这实现起来没什么难度，可是这样做不但没有带来更大的方便性，反而可能引起程序的混淆不清。在同一个作用域里面，给两个不同的变量起同一个名字，这有什么用处呢？自找麻烦而已。&lt;/p&gt;

&lt;p&gt;比如上面的例子，在下面我们看到一个对变量 &lt;code&gt;y&lt;/code&gt; 的引用，它是在哪里定义的呢？你需要在头脑中对程序进行“数据流分析”，才能找到它定义的位置。从上面读起，我们看到 &lt;code&gt;let y = 4&lt;/code&gt;，然而这不一定是正确的定义，因为 &lt;code&gt;y&lt;/code&gt; 可以被重新绑定，所以我们必须继续往下看。30 行代码之后，我们看到了第二个对 &lt;code&gt;y&lt;/code&gt; 的绑定，可是我们仍然不能确定。继续往下扫，30行代码之后我们到了引用 &lt;code&gt;y&lt;/code&gt; 的地方，没有再看到其它对 &lt;code&gt;y&lt;/code&gt; 的绑定，所以我们才能确信第二个 let 是 &lt;code&gt;y&lt;/code&gt; 的定义位置，它是一个字符串。&lt;/p&gt;

&lt;p&gt;这难道不是很费事吗？更糟的是，这种人工扫描不是一次性的工作，每次看到这个变量，你都要疑惑一下它是什么东西，因为它可以被重新绑定，你必须重新确定一下它的定义。如果语言不允许在同一个作用域里面重复绑定同一个名字，你就根本不需要担心这个事情了。你只需要在作用域里面找到唯一的那个 &lt;code&gt;let y = ...&lt;/code&gt;，那就是它的定义。&lt;/p&gt;

&lt;p&gt;也许你会说，只有当有人滥用这个特性的时候，才会导致问题。然而语言设计的问题往往就在于，一旦你允许某种奇葩的用法，就一定会有人自作聪明去用。因为你无法确信别人是否会那样做，所以你随时都得提高警惕，而不能放松下心情来。&lt;/p&gt;

&lt;h3&gt;类型推导&lt;/h3&gt;

&lt;p&gt;另外一个很多人误解的地方是类型推导。在 Rust 和 C# 之类的语言里面，你不需要像 Java 那样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int x = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样显式的指出变量的类型，而是可以让编译器把类型推导出来。比如你写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x = 8;  // x 的类型推导为 i32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器的类型推导就可以知道 &lt;code&gt;x&lt;/code&gt; 的类型是 i32，而不需要你把“i32”写在那里。这似乎是一个很方便的东西。然而看过很多 C# 代码之后你发现，这看似方便，却让程序变得不好读。在看 C# 代码的时候，我经常看到一堆的变量定义，每一个的前面都是 var。我没法一眼就看出它们表示什么，是整数，bool，还是字符串，还是某个用户定义的类？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;var correct = ...;
var id = ...;
var slot = ...;
var user = ...;
var passwd = ...;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我需要把鼠标移到变量上面，让 Visual Studio 显示出它推导出来的类型，可是鼠标移开之后，我可能又忘了它是什么。有时候发现看同一片代码，都需要反复的做这件事，鼠标移来移去的。而且要是没有 Visual Studio，用其它编辑器，或者在 github 上看代码或者 code review 的时候，你就得不到这种信息了。很多 C# 程序员为了避免这个问题，开始用很长的变量名，把类型的名字加在变量名字里面去，这样一来反而更复杂了，却没有想到直接把类型写出来。所以这种形式的类型推导，看似先进或者方便，其实还不如直接在声明处写下变量的类型，就像 Java 那样。&lt;/p&gt;

&lt;p&gt;所以，虽然 Rust 在变量声明上似乎有更灵活的设计，然而我觉得 C 和 Java 之类的语言那样看似死板的方式其实更好。我建议不要使用 Rust 变量的重复绑定，避免使用类型推导，尽量明确的写出类型，以方便读者。如果你真的在乎代码的质量，就会发现大部分时候你的代码的读者是你自己，而不是别人，因为你需要反复的阅读和提炼你的代码。&lt;/p&gt;

&lt;h3&gt;动作的“返回值”&lt;/h3&gt;

&lt;p&gt;Rust 的文档说它是一种“&lt;a href=&quot;https://doc.rust-lang.org/book/functions.html#expressions-vs-statements&quot;&gt;大部分基于表达式&lt;/a&gt;”的语言，并且给出这样一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let mut y = 5;
let x = (y = 6);  // x has the value `()`, not `6`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;奇怪的是，这里变量 &lt;code&gt;x&lt;/code&gt; 会得到一个值，空的 tuple，&lt;code&gt;()&lt;/code&gt;。这种思路不大对，它是从像 OCaml 那样的语言照搬过来的，而 OCaml 本身就有问题。在 OCaml 里面，如果你使用 &lt;code&gt;print_string&lt;/code&gt;，那你会得到如下的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;print_string &quot;hello world!\n&quot;;;

hello world!
- : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，&lt;code&gt;print_string&lt;/code&gt; 是一个“动作”，它对应过程式语言里面的“statement”。就像 C 语言的 &lt;code&gt;printf&lt;/code&gt;。动作通常只产生“副作用”，而不返回值。在 OCaml 里面，为了“理论的优雅”，动作也会返回一个值，这个值叫做 &lt;code&gt;()&lt;/code&gt;。其实 &lt;code&gt;()&lt;/code&gt; 相当于 C 语言的 void。C 语言里面有 void 类型，然而它却不允许你声明一个 void 类型的变量。比如你写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int main()
{
  void x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序是没法编译通过的（试一试？）。让人惊讶的是，古老的 C 的做法其实是正确的，这里有比较深入的原因。如果你把一个类型看成是一个集合（比如 int 是机器整数的集合），那么 void 所表示的集合是个空集，它里面是不含有任何元素的。声明一个 void 类型的变量是没有任何意义的，因为它不可能有一个值。如果一个函数返回 void，你是没法把它赋值给一个变量的。&lt;/p&gt;

&lt;p&gt;可是在 Rust 里面，不但动作（比如 &lt;code&gt;y = 6&lt;/code&gt; ）会返回一个值 &lt;code&gt;()&lt;/code&gt;，你居然可以把这个值赋给一个变量。其实这是错误的作法。原因在于 &lt;code&gt;y = 6&lt;/code&gt; 只是一个“动作”，它只是把 6 放进变量 y 里面，这个动作发生了就发生了，它根本不应该返回一个值，它不应该可以出现在 &lt;code&gt;let x = (y = 6);&lt;/code&gt; 的右边。就算你牵强附会说 &lt;code&gt;y = 6&lt;/code&gt; 的返回值是 &lt;code&gt;()&lt;/code&gt;，这个值是没有任何用处的。更不要说使用空的 tuple 来表示这个值，会引起更大的类型混淆，因为 &lt;code&gt;()&lt;/code&gt; 本身有另外的，更有用的含义。&lt;/p&gt;

&lt;p&gt;你根本就不应该可以写 &lt;code&gt;let x = (y = 6);&lt;/code&gt; 这样的代码。只有当你犯错误或者逻辑不清晰的时候，才有可能把 &lt;code&gt;y = 6&lt;/code&gt; 当成一个值来用。Rust 允许你把这种毫无意义的返回值赋给一个变量，这种错误就没有被及时发现，反而能够通过变量传播到另外一个地方去。有时候这种错误会传播挺远，然后导致问题（运行时错误或者类型检查错误），可是当它出问题的时候，你就不大容易找到错误的起源了。&lt;/p&gt;

&lt;p&gt;这是很多语言的通病，特别是像 JavaScript 或者 PHP 之类的语言。它们把毫无意义或者牵强附会的结果（比如 undefined）到处传播，结果使错误很难被发现和追踪。&lt;/p&gt;

&lt;h3&gt;return 语句&lt;/h3&gt;

&lt;p&gt;Rust 的设计者似乎很推崇“面向表达式”的语言，所以在 Rust 里面你不需要直接写“return”这个语句。比如，这个&lt;a href=&quot;https://doc.rust-lang.org/book/functions.html#early-returns&quot;&gt;例子&lt;/a&gt;里面，你可以直接这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn add_one(x: i32) -&amp;gt; i32 {
    x + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回函数里的最后一个表达式，而不需要写 return 语句，这是函数式语言共有的特征。然而其实我觉得直接写 return 其实是更好的作法，像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn foo(x: i32) -&amp;gt; i32 {
    return x + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编程有一个容易引起问题的作法，叫做“不够明确”，总想让编译器自动去处理一些问题，在这里也是一样的问题。如果你隐性的返回函数里最后一个表达式，那么每一次看见这个函数，你都必须去搞清楚最后一个表达式是什么，这并不是每次都那么明显的。比如下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn main() {
    println!(&quot;{}&quot;, add_one(7));
}

fn add_one(x: i32) -&amp;gt; i32 {
  if (x &amp;lt; 5) {
      if (x &amp;lt; 10) {
        // 做很多事...
        x * 2
      } else {
        // 做很多事...
        x + 1
      }
  } else {
    // 做很多事...
    x / 2
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 if 语句里面有嵌套，每个分支又有好些代码，而且 if 语句又是最后一个语句，所以这个嵌套 if 的三个出口的最后一个表达式都是返回值。如果你写了“return”，那么你可以直接看有几个“return”，或者拿编辑器加亮一下，就知道这个函数有几个出口。然而现在没有了“return”这个关键字，你就必须把最后那个 if 语句自己看清楚了，找到每一个分支的“最后表达式”。很多时候这不是那么明显，你总需要找一下，而且这件事在读代码的时候总是反复做。&lt;/p&gt;

&lt;p&gt;所以对于返回值，我的建议是总是明确的写上“return”，就像第二个例子那样。Rust 的文档说这是“poor style”，那不是真的。有一个例外，那就是当函数体里面只有一条语句的时候，那个时候没有任何歧义哪一个是返回表达式。&lt;/p&gt;

&lt;p&gt;这个问题类似于重复绑定变量和类型推导的问题，属于一种“用户体验设计”问题。无论如何，编译器都很容易实现，然而不同样式的代码，对于人类阅读的工作量，是很不一样的。很多时候最省人力的做法并不是那种看来最聪明，最酷，打字量最少的办法，而是写得最明确，让读者省事的办法。人们常说，代码读的时候比写的时候多得多，所以要想语言好用省事，我们应该更加重视读的时候，而不是写的时候。&lt;/p&gt;

&lt;h3&gt;数组的可变性&lt;/h3&gt;

&lt;p&gt;Rust 的数组可变性标记，跟 Swift 犯了一样的错误。Swift 的问题，我已经在之前的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/06/swift&quot;&gt;文章&lt;/a&gt;有详细叙述，所以这里就不多说了。简言之，同一个标记能表示的可变性，要么针对数组指针，要么针对数组元素，应该只能选择其一。而在 Rust 里面，你只有一个地方可以放“mut”进去，所以要么数组指针和元素全部都可变，要么数组指针和元素都不可变。你没有办法制定一个不可变的数组指针，而它指向的数组的元素却是可变的。&lt;/p&gt;

&lt;p&gt;请对比下面两个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn main() {
    let m = [1, 2, 3];      // 指针和元素都不可变
    m[0] = 10;              // 出错
    m = [4, 5, 6];          // 也出错
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn main() {
    let mut m = [1, 2, 3];  // 指针和元素都可变
    m[0] = 10;              // 不出错
    m = [4, 5, 6];          // 也不出错
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;内存管理&lt;/h3&gt;

&lt;p&gt;Rust 号称实现了非常先进的内存管理机制，不需要垃圾回收（GC）或者引用计数（RC）就可以“静态”的管理内存的分配和释放。然而仔细思考之后你就会发现，这很可能是不切实际的梦想（或者广告）。内存的分配和释放（如果要及时释放的话），本身是一个动态的过程，无法用静态分析来实现。现在你说可以通过一些特殊的构造，特殊的指针和传值方式，静态的决定内存的回收时间，真的有可能吗？&lt;/p&gt;

&lt;p&gt;实际上在 IU 的时候，我有一个类似的梦。我曾经向我的教授们（Friedman，Dybvig）提出过 N 多种不需 GC 和 RC 就能静态管理内存的办法，结果每一次都被他们给我的小例子给打败了，以至于我很难相信有任何人可以想到比 GC 和 RC 更好的方法。&lt;/p&gt;

&lt;p&gt;Rust 那些炫酷的 move semantics, borrowing, lifetime 之类的概念加在一起，不但让语言变得复杂不堪，我感觉并不能从根本上解决内存管理问题。很多人在 blog 里面为这些概念热情洋溢地做宣传，显得自己很懂一样，拿一些玩具代码来演示，可是从没看到任何人说清楚这些东西为什么可以从根本上解决问题，能用到复杂一点的代码里面去。所以我觉得这些东西有“皇帝的新装”之嫌。&lt;/p&gt;

&lt;p&gt;连 Rust 自己的&lt;a href=&quot;https://doc.rust-lang.org/book/ownership.html#meta&quot;&gt;文档&lt;/a&gt;都说，你可能需要“fight with the borrow checker”。为了通过这些检查，你必须用很怪异的方式来写程序，随着问题复杂度的增加，就要求有更怪异的写法。如果用了 lifetime，很简单一个代码看起来就会是这种样子。真够烦的，我感觉我的眼睛都没法 parse 这段代码了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn foo&amp;lt;&#39;a, &#39;b&amp;gt;(x: &amp;amp;&#39;a str, y: &amp;amp;&#39;b str) -&amp;gt; &amp;amp;&#39;a str {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上一次我看 Rust 文档的时候，没发现有 lifetime 这概念。文档对此的介绍非常粗略，仔细看了也不知道他们在说些什么，更不要说相信这办法真的管用了。对不起，我根本不想去理解这些尖括号里的 &lt;code&gt;&#39;a&lt;/code&gt; 和 &lt;code&gt;&#39;b&lt;/code&gt; 是什么，除非你先向我证明这些东西真的能解决内存管理的问题。实际上这个 lifetime 我感觉像是跨过程静态分析时产生的一些标记，要知道静态分析是无法解决内存管理的问题的，我猜想这种 lifetime 在有递归函数的情况下就会遇到麻烦。&lt;/p&gt;

&lt;p&gt;实际上我最开头看 Rust 的时候，它号称只用 move semantics 和好几种不同的指针，就可以解决内存管理的问题。可是一旦有了那几种不同的指针，就已经复杂不堪了，比 C 语言还要麻烦，而且显然不能解决问题。Lifetime 恐怕是后来发现有新的问题解决不了才加进去的，可是我不知道他们这次是不是又少考虑了某些情况。&lt;/p&gt;

&lt;p&gt;Rust 的设计者显然受了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_logic&quot;&gt;Linear Logic&lt;/a&gt; 一类看似很酷的逻辑的启发和熏陶，想用类似的方式奇迹般的解决内存和资源的回收问题。然而研究过一阵子 Linear Logic 之后我发现，这个逻辑自己都没有解决任何问题，只不过给对象的引用方式施加了一些无端的限制，这样使得对象的引用计数是一个固定的值（1）。内存管理当然容易了，可是这样导致有很多程序你没法表达。&lt;/p&gt;

&lt;p&gt;开头让你感觉很有意思，似乎能解决一些小问题。到后来遇到大一点的实际问题的时候，你就发现需要引入越来越复杂的概念，使用越来越奇葩的写法，才能达到目的，而且你总是会在将来某个时候发现它没法解决的问题。因为这个问题很可能从根本上是无法解决的，所以每当遇到有超越现有能力的事情，你就得增加新的“绕过方法”（workaround）。缝缝补补，破败不堪。最后你发现，除了垃圾回收（GC）和引用计数（RC），内存管理还是没有其它更好更简单的办法。&lt;/p&gt;

&lt;p&gt;当然我的意见也许不是完全准确，可我真是没有时间去琢磨这么多乱七八糟，不知道管不管用的概念（特别是 lifetime），更不要说真的用它来构建大型的系统程序了。有用来理解这些概念，把程序改成奇葩样子的时间，我可能已经用 C 语言写出很好的手动内存管理代码了。如果你真的看进去理解了，发现这些东西可以用的话，告诉我一声！不过你必须说明原因，不要只告诉我“皇帝是穿了衣服的” :P&lt;/p&gt;

&lt;h3&gt;完&lt;/h3&gt;

&lt;p&gt;本来想写一个更详细的评价的，可是到了这个地方，我感觉已经失去兴趣了，困就一个字啊…… Rust 比 C 语言复杂太多，我很难想象用这样的语言来构造大型的操作系统。而构造系统程序，是 Rust 设计的初衷。说真的，写操作系统那样的程序，C 语言真的不算讨厌。用户空间的程序，Java，C# 和 Swift 完全可以胜任。所以我觉得 Rust 的市场空间恐怕非常狭小……&lt;/p&gt;

&lt;p&gt;（如果你喜欢这些内容，请付费5美元或者30人民币，谢谢！）&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/09/18/rust</guid>
<pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>支付宝的身份验证问题</title>
<link>http://yinwang.org/blog-cn/2016/09/16/alipay</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;支付宝的身份验证问题&lt;/h2&gt;
                            &lt;p&gt;我看到有人继续在向我之前的支付宝账号付费。其实现在的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费二维码&lt;/a&gt;已经改成了我父亲的账号，原因是因为支付宝的身份验证问题。&lt;/p&gt;

&lt;p&gt;我的支付宝账号是在国内的时候开通的，支付宝收到的博文付费，都是准备转给家人的。开始收费之后，向家人的账号转了一些钱。支付宝似乎有很严格的防盗验证，我开头不熟悉怕出问题，所以做了几个试验，把钱分成好几次转。最后一次的时候，发现支付宝说需要验证我的身份，还打开手机的相机，要做“人脸验证”。让我左边转一点，右边转一点…… 我的身份证是15年前办的了，当然现在不像了！最后验证没有通过，于是支付功能就被锁定了，再也无法向家人转账。解锁的方法只有联系客服，可是客服电话打了老半天，根本没人接……&lt;/p&gt;

&lt;p&gt;由于这个原因，我不能再用我自己的支付宝账号收费。开通新的账号又需要银行卡验证，而我的国内手机和U盾都丢了…… 国内的银行系统就是这么麻烦。&lt;/p&gt;

&lt;p&gt;所以没办法，只好把我父亲的支付宝二维码放了上去。请大家以后不要再向我的账号付费，直接转账给我父亲就可以了。谢谢！&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/09/16/alipay</guid>
<pubDate>Fri, 16 Sep 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>测试的道理</title>
<link>http://yinwang.org/blog-cn/2016/09/14/tests</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;测试的道理&lt;/h2&gt;
                            &lt;p&gt;在长期的程序语言研究和实际工作中，我摸索出了一些关于测试的道理。然而在我工作过的每一个公司，我发现绝大多数人都不明白这些道理，很多团队集体性的采用错误的做法而不自知。很多人把测试当成一种主义和教条，进行过度的测试，不必要的测试，不可靠的测试，并且把这些错误的做法传授给新手，造成恶性循环。本来目的是提高代码质量，结果不但没能达到目的，反而降低了代码质量，增大了工作量，大幅度延缓工程进度。&lt;/p&gt;

&lt;p&gt;我也写测试，但我的测试方式比“测试教条主义者”们的方式聪明很多。在我心目中，代码本身的地位大大的高于测试。我不忽视测试，但我不会本末倒置，过分强调测试，我并不推崇测试驱动开发（TDD）。我知道该测试什么，不该测试什么，什么时候该写测试，什么时候不该写，什么时候应该推迟测试，什么时候完全不需要测试。因为这个原因，再加上高强的编程能力，我多次完成别人认为在短时间不可能完成的任务，并且制造出质量非常高的代码。&lt;/p&gt;

&lt;h3&gt;测试的道理&lt;/h3&gt;

&lt;p&gt;现在我就把这些自己领悟到的关于测试的道理总结一下，其中有一些是鲜为人知或者被误解的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要以为你处处显示出“重视代码质量”的态度，就能提高代码质量。总有些人，以为自己知道“单元测试”（unit test），“集成测试”（integration test）这样的名词，就很懂编程，就可以教育其他人。可惜，光有态度和口号是不解决问题的，你还必须有实战的技巧，深入的见解和智慧，必须切实地知道应该怎么做。代码的质量不会因为你重视它就得到提升，也不会因为你采取了措施（比如测试，静态分析）就一定会得到改善。你必须知道什么时候该写测试，什么时候不该写测试，需要写测试的时候，要写什么样的测试。其实，提高代码质量唯一可行的手段不是写测试，而是反复的提炼自己的思维，写简单清晰的代码。如果你想真的提高代码质量，我的文章『&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy&quot;&gt;编程的智慧&lt;/a&gt;』是一个不错的出发点。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;真正的编程高手不会被测试捆住手脚。是的，你身边那个你认为“不很在乎测试”的家伙，也许是个比你更好的程序员。我喜欢把编程比喻成开赛车，而测试就是放在路边用来防撞的轮胎护栏……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-a66eb34628e32634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;护栏有时候是很有用，可以救命的，然而一个合格的车手，绝对不会一心想着有护栏保护，测试在编程活动中的地位也应该就是这样。优秀的车手会很快看见优雅而简单的路径，恰到好处地掌握速度和时机，直奔终点而去。护栏只是放在最危险的地段，让你出了意外不要死得太惨。护栏并不能让你成为好的车手，不能让你取得冠军。绝大多数时候，你的安全只有靠自己的技术，而不是护栏，你永远有办法可以撞死自己。测试的作用也是一样，即使有了很多的测试，代码的安全仍然只掌握在你的手里。你永远可以制造出新的 bug，而没有测试可以检测到它……&lt;/p&gt;

&lt;p&gt;通常情况下，一个合格的车手是根本碰不到这些护栏的，他们心里想的是更高的目标：快点到达终点。相比之下，一个不合格的车手，他经常撞到赛道外面去，所以在他的心里，护栏有着至高无上的地位，所以他总是跟别人宣扬护栏的重要性。他开车的时候为了防止犯错，要在他经过的路径两边密密麻麻摆上护栏，甚至把护栏摆到赛道中间，以确保自己的转弯幅度正确。他在护栏之间跌跌撞撞，最后只能算是勉强到达终点。鼓吹测试驱动开发的人，就是这种三流车手，这种人写再多的测试也不可能倒腾出可靠的代码来。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在程序和算法定型之前，不要写测试。TDD 的教条者喜欢跟你说，在写程序之前就应该先写测试。为什么写代码之前要写测试呢？这只是一种教条。这些人其实没有用自己的脑子思考过这个问题，而只是人云亦云，觉得这样“很酷”，符合潮流，或者以为这样做了别人就会认为自己是高手。实际上在程序框架完成，算法定型之前，你都不需要写测试。如果你想知道代码是否正确，用人工方式运行代码，看看结果足以。&lt;/p&gt;

&lt;p&gt;如果你发现编程初期需要保证的性质纷繁复杂，如此之多，不写测试你就没信心的话，那你还是想办法先提高下基本的编程技术吧：多做练习，简化代码，让代码更加模块化，看看我的『编程的智慧』或者『SICP』一类的东西。写测试并不能提高你的水平，正好相反，过早的写测试会捆住你的手脚，让你无法自由的修改代码和算法。如果你不能很快的修改代码，不能用直觉感觉到它的变化和结构，而是因为测试而处处卡顿，你的头脑里就不能产生所谓“&lt;a href=&quot;https://en.wikipedia.org/wiki/Flow_(psychology&quot;&gt;flow&lt;/a&gt;)”，就不能写出优雅的代码来，结果到最后你什么也没学会。只有在程序不再需要大幅度的改动之后，才是逐渐加入测试的时候。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要为了写测试而改变本来清晰的编程方式。很多人为了满足“覆盖”（coverage）的要求，为了可以测试到某些模块，或者为了使用 mock，而把本来简单清晰地代码改成更加复杂而混淆的形式，甚至采用大量 reflection。这样一来其实降低了代码的质量。本来很简单的代码，一眼看去就知道是否正确，可是现在你一眼看过去，到处都是为了方便测试而加进去的各种转接插头，再也无法感觉到代码。这些用来辅助测试的代码，阻碍了你对代码进行直觉思维，而如果你不能把代码的逻辑完全映射在头脑里（进而产生直觉），你是很难写出真正可靠的代码的。&lt;/p&gt;

&lt;p&gt;有些 C# 程序员，为了测试而加入大量的 interface 和 reflection，因为这样可以在测试的时候很方便的把一片代码替换成 mock。结果你就发现这程序里每个类都有一个配套的 interface，还需要写另外一个 mock 类，去实现这个 interface。这样一来，不但代码变得复杂难以理解，而且还损失了 Visual Studio 的协助功能：你不再能按一个键（F12）就直接跳转到方法的定义，而需要先跳到对应的 interface 方法，然后再找到正确的实现。所以你不再能够在代码里面快速的跳转浏览。这种方便性的损失，会大幅度降低头脑产生整体理解的机会。而且为了 mock，每一个构造函数调用都得换成一个含有 reflection 的构造，使得编译器的静态类型检查无法确保类型正确，增加运行时出错的可能性，出错信息还难以理解，得不偿失的后果。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要测试“实现细节”，因为那等同于把代码写两遍。测试应该只描述程序需要满足的“基本性质”（比如 sqrt(4) 应该等于 2），而不是去描述“实现细节”（比如具体的开平方算法的步骤）。有些人的测试过于详细，甚至把代码的每个实现步骤都兢兢业业的进行测试：第一步必须做A，第二步必须做B，第三步必须做C…… 还有些人喜欢给 UI 写测试，他们的测试里经常这样写：如果你浏览到这个页面，那么你应该在标题栏看见这行字……&lt;/p&gt;

&lt;p&gt;仔细想一下就会发现，这种作法本质上不过是把代码（或者UI）写了两遍而已。本来代码里面明白写着：先做A，再做B，再做C。UI 描述文件里面明白写着：标题栏里面是这些内容。你有什么必要在测试里把它们全都再检查一遍呢？这根本没有增加任何可靠性：你在代码里会犯错，你把同样的逻辑换种形式再写一遍，难道就不会错了吗？&lt;/p&gt;

&lt;p&gt;这就像某些脑子秀逗的人，他出门时总是担心门没锁好，关门之后要推推拉拉好几次，确认门是锁上了的。还没走几步，他仍然在怀疑门没锁好，又走回去推推拉拉好几次，却始终不能放心 :P 这种做法非但不能保证代码的正确，反而给修改代码制造了障碍。理所当然，你把同一段代码写了两遍，每当要修改代码，你就得修改两次！这样的测试就像紧箍咒一样，把代码压得密不透风。每一次修改代码，都会导致很多测试失败，以至于这些测试都不得不重写。本质上就是把代码修改了两遍，只不过更加痛苦一些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并不是每修复一个 bug 都需要写测试。很多公司都流传一个常见的教条，就是认为每修复一个 bug，都需要为它写测试，用于确保这个 bug 不再发生。甚至有人要求你这样修复一个 bug：先写一个测试，重现这个 bug，然后修复它，确保测试通过。这种思维其实是一种生搬硬套的教条主义，它会严重的减慢工程的进度，而代码的质量却不会得到提高。写测试之前，你应该仔细的思考一个问题：这个 bug 有多大可能会在同一个地方再次发生？很多低级错误一旦被看出来之后，它就不大可能在同一个地方再次出现。在这种情况下，你只需手工验证一下 bug 消失了就可以。&lt;/p&gt;

&lt;p&gt;为不可能再出现的 bug 大费周折，写 reproducer，构造各种数据结构去验证它，保证它下次不会再出现，其实是多此一举。同样的低级错误就算再出现，也很可能不在同一个地方。写测试不但不能保证它不再发生，而且浪费你很多时间。这测试在每次 build 的时候都会消耗时间，每次编译都因为这些测试多花几分钟，累积起来之后，你就发现工程进度明显减慢。只有当发现已有的测试没有抓住程序必须满足的重要性质时，你才应该写新的测试。你不应该是为这个 bug 而写测试，而是为代码的性质而写测试。这个测试的内容不应该只是防止这个 bug 再次发生，而是要确保 bug 所反映出来的，之前缺失的“性质”得到保证。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免使用 mock，特别是多层的 mock。很多人写测试都喜欢用很多 mock，堆积很多层，以为只有这样才能测试到路径比较深的模块。其实这样不但非常繁琐费事，而且多层的 mock 往往不能产生足够多样化的输入，不能覆盖各种边界情况。如果你发现测试需要进行多层的 mock，那你应该考虑一下，也许你需要的不是 mock，而是改写代码，让它更加模块化。如果你的代码足够模块化，你不应该需要多层的 mock 来测试它。你只需要为每一个模块准备一些输入（包括边界情况），确保它们的输出符合要求。然后你把这些模块像管道一样连接起来，形成一个更大的模块，测试它也符合输入输出要求，以此类推。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要过分重视“测试自动化”，人工测试也是测试。写测试，这个词往往隐含了“自动运行”的含义，也就是假设了要不经人工操作，完全自动的测试。打一个命令，它过一会就会告诉你哪些地方有问题。然而，人们往往忽略了“人工测试”。他们没有意识到，人工去试验，去观察，也是一种测试。所以你就发现这样的情况，由于自动测试在很多时候非常难以构造（比如，如果你要测试一段复杂的交互式GUI代码的响应），很多人花了很多时间，利用各种测试框架和工具，甚至遥控 WEB 浏览器去做一些自动操作，花太多时间却发现各种不可靠，没法测到很多东西。&lt;/p&gt;

&lt;p&gt;其实换一个思路，他们只需要花几分钟的时间，就可以用人工的方式观察到很多深入的问题。过分的重视测试自动化的原因，往往在于一个不切实际的假设，他们假设错误会频繁的再次发生，所以自动化了可以省下人的力气。但是其实，一旦一个 bug 被修好，它反复出现的机会不会很大的。过分的要求测试自动化，不但延缓了工程进度，让程序员恼火，效率低下，而且失去了人工测试的精确性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免写太长，太耗时的测试。很多人写测试，叽里呱啦很长一串，到后来再看的时候，他已经不记得自己当时想测什么了。有些人本来用很小的输入就可以测试到需要的性质，他却总喜欢给一个很大的输入，下意识的以为这样更加靠谱，结果这测试每次都会消耗大量的 build 时间，而其实达到的效果跟很小的输入没有任何区别。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个测试只测试一个方面，避免重复测试。有些人一个测试测很多内容，结果每次那个测试失败，都搞不清楚到底是哪个部件出了问题。有些人为了“放心”，喜欢在多个测试里面“附带”测某些他认为相关的部件，结果每次那个部件出问题，就发现好多个测试失败。如果一个测试只测一个方面，不重复测同一个部件，那么你就可以很快的根据失败的测试，发现出问题的部件和位置。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免通过比较字符串来进行测试。很多人写测试的时候，喜欢通过打印出一些东西，然后使用字符串比较的方式来决定输出是否符合要求。一个常见的做法是把输出打印成格式化的 JSON，然后对比两个文本。甚至有人 JSON 都不用，直接就比较 printf 输出的结果。这种测试是非常脆弱的。因为字符串输出的格式往往会发生微小的变化，比如有人在里面加了一个空格之类的。把这种字符串作为标准输出，进行字符串比较，很容易因为微小的改动而使大量测试失败，导致很多的测试需要做不必要的修改。正确的做法，应该是进行结构化的比较，如果你要把标准结果存成 JSON，那么你应该先 parse 出 JSON 所表示的对象，然后再进行结构化的对比。PySonar2 的测试就是这样的做法，所以相当的稳定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“测试能帮助后来人”的误区。每当指出测试教条主义的错误，就会有人出来说：“测试不是为了你自己，而是为了你走了以后，以后进来的人不犯错误。” 首先，这种人根本没有看清楚我在说什么，因为我从来没有反对过合理的测试。其次，这种“测试能帮助后来人”，其实是没有经过实践检验，站不住脚的说法。如果你的代码写得很乱，就算你测试再多，后来人也无法理解，反倒被莫名其妙的测试失败给弄得更糊涂，不知道是自己错了还是测试错了。我已经说过了，测试不能完全保证代码不被改错，实际上它们防止代码被改错的作用是非常弱的。无论如何，后来人都必须理解原来的代码的逻辑，知道它在做什么，否则他们不可能做出正确的修改，就算你有再严密的测试也一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   举一个亲身的例子。我在 Google 做出 PySonar 之后，最后一个测试都没写。第二次我回到 Google，我的上司 Steve Yegge 对我说：“你走了之后，我改了一些你的代码，真是太清晰，太好把握了，修改你的代码是一种快乐！” 这说明什么问题呢？我并不是说你可以不写测试，但这个例子说明，测试对于后来人的作用，并不是你有些人想象的那么大。创造清晰的代码才是解决这个问题的关键。&lt;/p&gt;

&lt;p&gt;   这种怕人突然走了，代码无法维护的想法，导致了一些人对测试过分的重视，但测试却不能解决这种问题。相反，如果测试太繁琐，做不必要的测试，反而容易让员工不满，容易走人，去加入在这方面更加有见地的公司。有些公司以为有了测试，就可以随便打发人走，这种想法是大错特错的。你需要明白的一个事情是，代码永远是属于写出它的那个人的，就算有测试也一样。如果核心人物真的走了，就算你有再多的测试也没用的，所以解决的方法就是把他们留住！一个有远见的公司总是通过其他的手段解决这个问题，比如优待和尊重员工，创造良好的氛围，使得他们没那么快想走。另外，公司必须注意知识的传承，防止某些代码只有一个人理解。&lt;/p&gt;

&lt;h3&gt;案例分析&lt;/h3&gt;

&lt;p&gt;有人会疑问，我凭什么可以给别人讲这些经验，我自己为此有什么成功的案例呢？所以现在来讲讲我做过的几个东西，以及我亲眼目睹的测试教条主义者们的失败案例。&lt;/p&gt;

&lt;h4&gt;Google&lt;/h4&gt;

&lt;p&gt;很多人可能听说过我在 &lt;a href=&quot;http://www.yinwang.org/blog-%EF%BC%8Ccn/2014/12/31/google-story&quot;&gt;Google&lt;/a&gt; 做的 PySonar。当时 Google 的队友们战战兢兢，说这么高难复杂的东西要从头做起，几乎是不可能的。特别是某位队友，一开头就吵着要我写测试，一直吵到最后，烦死我了。他们为什么这么担心呢？因为对 Python 做类型推导是非常高难度的代码，需要相当复杂的数据结构和算法，需要精通 Python 的语义实现。&lt;/p&gt;

&lt;p&gt;作为一个训练有素的专家，我没有在乎他们的咋呼，没有信他们的教条。我按照自己的方式组织代码，进行精密的思考，设计和推理，最终在三个月之内做出了非常优雅，正确，高性能，而又容易维护的代码。PySonar 到现在仍然是世界上最先进的 Python 类型推导和索引系统，被多家公司采用，用于处理数以百万计的 Python 代码。，&lt;/p&gt;

&lt;p&gt;如果我当时按照 Google 队友的要求，采用已有的开源代码，或者过早的写了测试，别说无法在三个月的实习时间之内完成这个东西，就算折腾好几年也没有可能。&lt;/p&gt;

&lt;h4&gt;Shape Security&lt;/h4&gt;

&lt;p&gt;这种思维方式最近的成功实例，是给 Shape Security 做的一个先进的 JavaScript 混淆器（obfuscator）和对集群（cluster）管理系统的改进。不要小看了这个 JS 混淆器，它的混淆能力要比 uglify 之类的开源工具强很多，也快很多。它不但包含了 uglify 的变量换名等基本功能，而且含有专门针对人类和编译器的复杂化，使得没人能看出一点线索这个程序到底要干什么，让最先进的 JS 编译器也无法把它简化。&lt;/p&gt;

&lt;p&gt;其实这个混淆器也是一种编译器，只不过它把 JavaScript 翻译成不可读的形式。在这个项目中，由于失之毫厘就可以差之千里，我采用了从 Chez Scheme 编译器学过来的，非常严密的测试方法。对每一个编译器的步骤（pass），我都给它设计一些正好可以测到这个步骤的输入代码（比如，具有函数定义的，for循环，try-catch的，等等）。Pass 输出的代码，经过 JavaScript 解释器执行，把结果跟原来程序的执行结果对比。每一个测试程序，经过每一个 pass，输出的中间结果都跟标准结果进行对比，如果错了就表明那个 pass 有问题，出错的小程序会指出大概是哪一个部分出了问题。遵循小巧，不冗余，不重复的原则，我总共只写了40多个非常小的 JavaScript 程序。由于这些测试涵盖了 JavaScript 的所有构造而且几乎不重复，它们能够准确的定位到错误的改动。最后，这个 JS 混淆器能够正确的转换像 AngularJS 那么大的项目，确保语义的正确，让人完全无法读懂，而且能有效地防止被优化器（比如 Closure Compiler）简化掉。&lt;/p&gt;

&lt;p&gt;相比之下，过度鼓吹测试和可靠性的人，并没能制造出这么高质量的混淆器。其实在我进入团队之前，里面的两三位高手已经做了一个混淆器，项目延续了好多个月。这片代码一直没能发布给客户用，因为它的换名部件总是会在某些情况下输出错误的代码，修改了好多次仍然会出错。不是100%的正确，这对于程序语言的转换器来说，是不可接受的。换名只是我的混淆器里的一个步骤，它还包含大概十个类似的步骤，可以把代码进行各种转换。&lt;/p&gt;

&lt;p&gt;在实现换名器的时候，队友们让我直接拿他们以前写的换名代码过来，把 bug 修好就可以。然而看了代码之后，我发现这代码没法修，因为它采用了错误的思路，缝缝补补也不可能达到100%的正确，而且明显效率低下，所以我决定自己重写一个。由于轻车熟路，我只花了一下午的时间，就完成了一个正确的换名器，它完全符合 JavaScript 的语义，各种奇葩的作用域规则，而且结构非常简单。说白了，这个换名器也是一种&lt;a href=&quot;http://www.yinwang.org/blog-cn/2012/08/01/interpreter&quot;&gt;解释器&lt;/a&gt;。对解释器的深刻理解，让我可以很容易的写出任何语言的换名器。&lt;/p&gt;

&lt;p&gt;不幸的是，历史再次重演了 ;) 队友们听说我花一下午重写了一个换名器，非常紧张，咋呼地跟我说：“你知道我们的换名器是花了多少个月的时间做出来的吗？你知道我们写了多少测试来保证它的正确性吗？你现在一下午做出来一个新的，你如何能保证它的正确！” 我不知道他们怎么好意思说出这样的话来，因为事实是，他们花了这么多个月，耗费这么多人力，写了这么多的测试，做出来的换名器却仍然有 bug，没法用。当我把我写的测试和几个大点的 open source 项目（AngularJS, Backbone 等）放进他们的换名器之后，就发现有些地方出问题了，而所有的测试和 open source 项目通过我的换名器，却得到完全正确的代码。另外经过性能测试，我的换名器速度要快四倍的样子。所以就像 &lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/02/18/dijkstra-interview&quot;&gt;Dijkstra&lt;/a&gt; 所说：“最优雅的程序往往也是最高效的。”&lt;/p&gt;

&lt;p&gt;结束这个项目之后，我换了一个团队（cluster团队），这个团队的人要好很多，低调而且幽默。Shape Security 的产品（Shape Shifter）里面包含一个高可靠（HA）集群管理系统，它可以通过网络，选举 leader，构建一个高容错的并行处理集群。这个集群管理系统一直以来都是公司里很复杂，却是可靠性要求最高的一个部件，一旦出问题就可能有灾难性的后果。确实，它当时可靠性非常高，从来没出过问题。但由于历史原因，它的代码过度复杂而缺乏模块化，以至于很难扩展来应付新的客户需求。我进入这个新团队的任务，就是对它进行大规模的简化，模块化和扩展，让它满足新的需求。&lt;/p&gt;

&lt;p&gt;在这个项目中，由于代码的改动幅度很大，在同事和部门领导的理解，信任和支持下，我们决定直接抛弃已有的测试，完全靠严格而及时的 code review，逻辑推理，推敲讨论，手工试验来保证代码的正确。在我修改代码的同时，一位更熟悉已有代码的队友一直通过 git 默默监视着我的每一次改动，根据他自己的经验来判断我的改动是否偏离了原来的语义，及时与我交流和讨论。由于这种灵活而严格的方式，工程不到两个月就完成了。改进后的代码不但更加模块化，更可扩展，适应了新的需求，而且仍然非常可靠。假设部门领导是“测试教条主义者”，不允许抛弃已有的测试，这样的项目是绝对不可能如期完成的。然而在当今世界遇到这样领导的机会，恐怕十个人里面不到一个吧。&lt;/p&gt;

&lt;h4&gt;Coverity&lt;/h4&gt;

&lt;p&gt;最后，我举一个由于测试方式不当而非常失败的案例，那就是 Coverity 的 Java 静态分析产品。我承认 Coverity 的 C 和 C++ 分析器也许是非常好的，然而 Java 的分析器，很难说。当我进入 Coverity 的时候，同事们已经忍受了整整一年的管理层的威逼和高压，超时过劳工作，写出了基本的新产品和很多的测试。可是由于技术债太多，再多的测试也没能保证产品的可靠性。&lt;/p&gt;

&lt;p&gt;我的任务就是利用我深入的 PL 知识，不停的修补前人留下来的各种蹊跷 bug。有些 bug 需要运行20多分钟之后才出现，一次还看不出是怎么回事，所以修起来非常耗时。有时候我只好趴在电脑前面养神，时不时的睁眼看看结果。Coverity 是如此的在乎测试，他们要求每修复一个 bug 你就必须写出新的测试。测试必须能够如实的重现 bug 的现象，修复之后测试必须能够通过。这看似一个很在乎代码质量的做法，然而它不但没能保证产品的稳定可靠，而且大幅度的减慢了工程进度，并且造成员工的疲惫和不满。&lt;/p&gt;

&lt;p&gt;有一次他们分配给我一个 bug：在分析一个中型项目的时候，分析器似乎进入了死循环，好几个小时都不能完成。因为 Coverity 的全局静态分析，其实就是某种图遍历算法。当这个图里面有回路的时候，你就必须小心，如果不问青红皂白就递归进去，就可能进入死循环。避免死循环的办法很简单，你构造一个图节点的集合（Set），然后把它传递到函数里面作为参数。 每当访问一个节点，你先检查这个节点是否已经在这个集合里，如果在你就直接返回，否则你就把这个节点加入到集合里，然后递归处理这个节点的子节点。它的 C++ 代码大概就像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void traverse(Node node, Set&amp;lt;Node&amp;gt; &amp;amp;visited)
{
  if (visited.contains(node)) {
    return;
  } else {
    visited.add(node);
    process_node(node, visited);   // 里面会递归调用 traverse
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看代码之后我发现，代码其实没有进入“死循环”，而是进入了指数复杂度的计算，所以很久都不能完成。这是因为写这函数的人不小心，或者没有理解 C++ 的函数参数缺省是传值（做拷贝）而不是传引用，所以他忘了打那个“&amp;amp;”，所以函数被递归调用的时候不是传递原来的集合，而是做了一个拷贝。每一次递归调用&lt;code&gt;traverse&lt;/code&gt;，visited 都得到一个新的拷贝，所以返回之后，visited 的值就恢复到之前的状态，就像 node 被自动 remove 了一样。所以这个函数仍然会在某种情况下再次访问这个节点。这样的代码不会进入死循环，然而在某种特殊的图结构下，这会造成指数级的时间复杂度（请想一下这是什么样的一种图）。&lt;/p&gt;

&lt;p&gt;本来很明显的一个图论算法问题，加一个“&amp;amp;”就修好了，手工试验也发现问题消失了。然而 Coverity 的测试教条主义者们（包括写出这 bug 的那人自己），吵着闹着，严肃命令我必须写出测试，构造出可以造成这种后果的数据结构，确保这个 bug 不会再重新出现。&lt;/p&gt;

&lt;p&gt;为一个我根本不会犯的错误写测试，而且它不可能再次发生，这不是很搞笑吗？就算你写了测试，也不能保证同样的事情不再发生。如果你不小心漏掉“&amp;amp;”，下次同样的问题还会发生，并且发生在另外的地方，而你却没有给那块代码写测试，所以给这个 bug 写测试，并不能防止同样的问题再次发生。这就像一个技术不过关的赛车手，他在别人不大可能撞车的地方撞了车，然后就要求赛场在那个地方装上轮胎护栏。可是下一次，这个车手又会在另一个其他人都不会撞车地方撞车……&lt;/p&gt;

&lt;p&gt;稍微有点图论常识，熟悉 C++ 基本概念的人，都不会犯这种错误。防止这种问题，只有靠个人的技术和经验，而不能靠测试。防止它再次发生的最好办法，恐怕是开个会把这个问题讲清楚，让大家理解，下次不要再犯。所以给这个 bug 写测试，完全是多此一举。跟队友们讲解了这个原理，他们听了之后，仿佛什么都没有听到一样，仍然强硬的要求：“可是你还是得写这个测试，因为这是我们的规定！你知道要是出了 bug，送一个销售工程师去客户那里，要花多少钱吗……” 无语了。&lt;/p&gt;

&lt;p&gt;Coverity 的 Java 分析，就是经常因为这种测试教条主义，使得项目进展及其痛苦和缓慢，却仍然 bug 百出。Coverity 的其他的问题，还包括我上面指出的，写重复的测试，一个测试测太多东西，使用字符串比较来做测试，等等。你恐怕很难想象，一个制造旨在提高代码质量的产品的公司，自己代码的质量是这样维护的 :P&lt;/p&gt;

&lt;h3&gt;完&lt;/h3&gt;

&lt;p&gt;由于绝大多数人对测试的误解如此之深，测试教条主义的流毒如此之广，导致许许多多优秀的程序员沉沦在繁琐的测试驱动开发中，无法舒展自己的长处。为了大家有一个轻松，顺利又可靠的工作环境，我希望大家多多转发这篇文章，改变这个行业的陋习。我希望大家在工程中理性的对待测试，而不是盲目的写测试，只有这样才能更好更快的完成项目。&lt;/p&gt;

&lt;p&gt;（由于这篇文章包含了我很多年的经验和深入的见解，希望你觉得有收获的话为此付费。建议价格是5美元，或者30人民币。【&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费方式&lt;/a&gt;】）&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/09/14/tests</guid>
<pubDate>Wed, 14 Sep 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Tesla autopilot 引起致命车祸</title>
<link>http://yinwang.org/blog-cn/2016/07/10/tesla-autopilot-fatal-crash</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;Tesla autopilot 引起致命车祸&lt;/h2&gt;
                            &lt;p&gt;好一段时间没关心 Tesla 了，今天才发现他们的 autopilot 终于引起了&lt;a href=&quot;http://www.pbs.org/newshour/rundown/deadly-tesla-crash-exposes-confusion-over-automated-driving&quot;&gt;致命的车祸&lt;/a&gt;。这场 Model S 撞上18轮大卡车的车祸，发生于5月7号，距今已经两个月了。 Tesla 把这事隐瞒了两个月之久，直到现在美国国家公路交通安全管理局（NHTSA）开始调查此事，才迫不得已公之于众。由于 Tesla 没有及时向政府监管部门报告事实，政府正在考虑对 Tesla 公司采取法律行动。&lt;/p&gt;

&lt;p&gt;本来都懒得再提 Tesla 这公司的名字，但是由于 Tesla 对于这起车祸态度极不端正，不但隐瞒事实，而且继续找各种借口为 autopilot 开脱罪名，让这玩具级别的技术继续危害无辜开车人的安全，很多人（包括新闻机构）对此的分析很多都抓不住关键，所以我不得不再出来说几句。&lt;/p&gt;

&lt;p&gt;死者名叫 &lt;a href=&quot;http://www.legacy.com/obituaries/ohio/obituary.aspx?pid=179994314&quot;&gt;Joshua Brown&lt;/a&gt;，40岁，曾作为炸弹专家，服役美国海军11年之久。退役以后成立了自己的技术公司，近段时间热衷于 Tesla 的电动车技术，还建立了一个 YouTube 频道，用于演示自己的 Tesla 车子。所以可以说，Joshua 对 Tesla 的 autopilot 使用方法已经很熟悉了。然而这不幸的事件，恰恰就发生在这个专家用户和热心人身上。&lt;/p&gt;

&lt;p&gt;Tesla 方面称，那天 Joshua 行驶在佛罗里达州一条中间有隔离带的公路上，符合规定的启用了 autopilot。行车途中，前方有一辆18轮卡车左转，由于卡车车厢是白色的，后面的天空也是白色，所以 autopilot 没发现这个卡车，没有进行刹车，最后 Model S 撞上卡车，车主身亡。白色卡车衬托在白色天空上，所以 autopilot 就把卡车当成空气，这是个什么情况……&lt;/p&gt;

&lt;p&gt;先不说这技术有什么问题，出了这种事情，Tesla 对此&lt;a href=&quot;https://www.teslamotors.com/en_GB/blog/tragic-loss&quot;&gt;反应&lt;/a&gt;让人非常的失望。不但没有基本的自我检查，反而各种狡辩，把责任全都推到用户身上。首先，他们从统计的角度，说明 Tesla 车引起死亡的比例，比其它车子小很多。然后旁敲侧击地想说明，就算是那人自己开车，也不能避免这种车祸。最后他们再三的强调，autopilot 的说明书已经声明，功能还不成熟，如果看到要出事而没有及时接管，你们自己负责！&lt;/p&gt;

&lt;p&gt;这些都是 Tesla 老一套的诡辩方法。首先，Tesla 的死亡比例比其它车要小，并不能掩盖 autopilot 存在严重问题的事实。死亡比例小可能跟 Tesla 的技术没有很大关系，Tesla 是新公司，车都很新所以不容易出机械故障，而且买 Tesla 的都是有钱人，受过良好的教育，懂技术，所以一般不会乱开。那这种死亡比例，跟老牌子的车比是不公平的。其他牌子的车总数比 Tesla 多太多了，很多车子都十几二十年老掉牙，开车的各种人都有，酒鬼也有，老汉也有，罪犯也有，当然事故比例就上去了。如果你只看其它牌子最近几年的新车和豪华车，死亡比例拿来算一下，就很小。&lt;/p&gt;

&lt;p&gt;如果你光看 autopilot 导航的总里程数，事故比例恐怕就上去了，因为很多 Tesla 用户可能没有启用 autopilot，或者用的很少。Autopilot 不是第一次引起车祸了，之前我的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/01/10/tesla-autopilot&quot;&gt;另一篇文章&lt;/a&gt;已经提到，由于它的视觉技术不成熟，引发了许多险些发生车祸的情况，而且最近引起了好多次真正的车祸。要知道微小的比例落在一个人头上，就等于100%的不幸。等你因为 autopilot 而受害，才会发现 Tesla 摆出来的那些统计数字，对你其实毫无意义。也许，它确实造福了全人类，可惜死伤的人是你或者你的家人，而且那是因为 autopilot 极其弱智的判断错误…… 你会因为统计数字很安全而饶了 Tesla 吗？&lt;/p&gt;

&lt;p&gt;另外 Tesla 喜欢旁敲侧击的指出 autopilot 的驾驶能力高于人类，而事实并不是那样。你怎么能证明人开车不能避免这车祸？Tesla 说：“驾驶员和 autopilot 都没有看到卡车。” 你们怎么知道驾驶员没有看见卡车？那可是18轮的大卡车！说白色的侧面车厢映在白色的天空，所以人看不见它，这不是搞笑吗。&lt;/p&gt;

&lt;p&gt;一个东西是白色的，不等于它是看不见的，一个不透明的东西会挡住后面的景物，这一点人是很清楚的。白色的物体也会有反光，纹理会跟天空不一样，人可以通过这种反光感知它的存在。卡车不止有白色的侧面，还有黑色的轮子，车头上有烟囱，车窗，油箱，…… 各种其它颜色的附件。为了让其他人在夜间能看到车厢的大小，大卡车必须在车厢的八个角上都安装红色的警示灯，这些灯在白天不亮的时候也看得见的。就算天空是白色，人也是不可能看不见它，把卡车当成空气的。所以我猜真实情况是，驾驶员发现 autopilot 判断错误，想接管过来，但已经来不及了。要知道这个反应时间也许不到一秒！人死了，当然死无对证。&lt;/p&gt;

&lt;p&gt;从多次的事故现象中，我分析出这样一个规律，虽然 Tesla 声称 Model S 上装备了雷达和声呐，但是 autopilot 的操作却似乎仅靠摄像头的“像素”，通过神经网络进行图像分析，所以它才会连18轮大卡车这么巨型的东西都没有发现，在路上看到个树影还以为是障碍物…… 这些都是人根本不会犯的奇葩错误。我请大家不要对自动驾驶技术过于乐观，急于求成。机器视觉在某些地方是很有用的技术，然而它要能被用于自动驾车，还有非常长的路要走。&lt;/p&gt;

&lt;p&gt;Tesla 确实警告过人们，说这个技术还不成熟，你必须把手一直放在方向盘上，准备随时接管，然而这并不能免除 Tesla 的责任。首先，Tesla 根本就不应该把不成熟的技术发布出来，而且大肆宣传，搞得大家以为它很先进很可靠似的，争相试用。其次，说明书上的警告，在法律上也许是没有效力的。你要求别人随时接管，那么你必须在可能判断错误的时候给出警示，而且给人足够的响应时间，才能算是合理。&lt;/p&gt;

&lt;p&gt;Autopilot 的设计是有严重问题的。它操纵着车子，却不给人解释自己看见了什么，准备进行什么操作，在道路情况超越了自己能力的时候，也不给人提示，以至于人根本不知道它出了问题，不能及时接管。要知道，车在直走的时候，autopilot 是否判断正确，人往往是看不出来的。一辆没有 autopilot（只有普通  cruise  control）的车子，跟一辆启用了  autopilot 的车子，在匀速直线运动的时候，人是无法察觉出任何区别的。可是人知道 autopilot 会自动刹车，而普通的  cruise  control 不能，所以人就会期望有 autopilot 的车子会刹车。等你发现它一声不吭，前面有障碍物却没有刹车，才会知道它有判断错误，可是那个时候就已经晚了。&lt;/p&gt;

&lt;p&gt;所以在这种情况下，Tesla 虽然事先有“免责声明”，把责任全都推在用户头上，在法庭上其实仍然可以败诉，因为他们对用户提出的要求是不切实际的，没有人能够在上述 autopilot 判断错误情况下及时的接管过来。我建议这起车祸死者的家属把 Tesla 告上法庭，要求巨额赔偿。我也建议所有 Tesla 的车主，为了对自己和他人的生命负责，请关闭 autopilot 这个功能！Tesla 根本就不懂如何设计自动驾驶系统，技术不过硬，设计有缺陷，基本就是个玩具。生命很宝贵，用自己的生命来给所谓的“新技术”做试验品，是不值得的。&lt;/p&gt;

&lt;p&gt;珍爱生命，远离 autopilot！&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/07/10/tesla-autopilot-fatal-crash</guid>
<pubDate>Sun, 10 Jul 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Google Maps的设计问题</title>
<link>http://yinwang.org/blog-cn/2016/07/05/google-maps</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;Google Maps的设计问题&lt;/h2&gt;
                            &lt;p&gt;我开车的时候喜欢用 Google Maps 导航。虽然我对 Google 这公司挺有意见，然而 Google Maps 确实是好东西。比较过其他几个导航软件（Waze，Scout Maps）之后，我发现 Google Maps 在大部分时候还是表现最好的一个。&lt;/p&gt;

&lt;p&gt;然而这并不等于它的设计是没有问题的。Google Maps 时不时的会改变设计，有些地方改进了，另外一些地方却可能被改得还不如以前。我已经不止一次的向 Google Maps team 提出反馈意见。&lt;/p&gt;

&lt;p&gt;现在我就把最近烦扰我的一个问题讲一下。我已经通过 app 给 Google Maps team 发送了 feedback，但我希望这种设计问题引起足够的重视，所以也在这里说一下。&lt;/p&gt;

&lt;p&gt;这个最近发现的问题是，Google Maps 显示的公路号码字体太小。它把州际公路（interstate）之类的公路号码，显示成路牌上的样式。比如下面的这个 Interstate 880，被显示成带有弧形花边，红蓝底色的路牌样式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-d0dfc31379ac5331.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;这看似美观，平时在手机上看貌似没什么问题，然而在开车的时候你就会发现，里面的号码很难看清楚。其原因是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;把带有这个花边的路牌嵌入到导航提示里面之后，由于整个路牌的高度和旁边字体的高度一样，公路号码“880”的字体，比旁边的字小了很多（请比较“880”和“North”的大小）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在开车的时候，手机架在机座上，离眼睛有一定距离，而且由于车速很快，你只有不超过一秒钟的安全时间可以去瞄手机。所以我经常发现瞄一眼是根本没法看清楚这个花边里面的号码（880）的，你得盯着手机看好一会儿。有时候我把头凑近手机，都很不容易看清楚。这对于开车的人是一个不小的干扰，可能会引起交通事故。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;湾区的很多高速公路号码只差一个数字，比如 280，380，680，880…… 这么小的字体，很容易看不清楚这号码到底是哪一个！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;实际上你观察一下真正的路牌，就会发现公路号码的字体，跟旁边文字的比例，并不是像 Google Maps 上那个样子。请观察下图中的路牌，号码“280”和“101”的字体，和旁边的文字“SOUTH”，“TO”，“NORTH”，“San Francisco”其实是一样大，甚至更大一些。加上 INTERSTATE 的盾形花边，这个标志的尺寸比旁边的文字要大很多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-43f9258afbc7373a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;所以 Google Maps 一片好心，想把公路号码做得很“形象”和“直观”，做得像路牌的样子，结果比例不对，帮了倒忙。对此我提出的建议是：&lt;/p&gt;

&lt;p&gt;方式1：不要把公路号码显示为路牌的样式，直接使用像“I-440”这样的文本来显示路名。很少有人会在乎公路号码的样式是否美观，他们只在意是否能清楚地看到号码，所以这可能是最好的选择。很多其他导航软件和专用 GPS 设备（比如 Waze，Garmin）都是直接采用文本显示公路号码。&lt;/p&gt;

&lt;p&gt;方式2：保留路牌样式，但是需要把路牌的尺寸增加到真正的路牌字体比例，也就是说让路牌里的号码跟旁边的字体大小一样。这个方式放到 Google Maps 的导航提示里面，恐怕会让导航提示的宽度变大，占用更多屏幕空间，所以虽然也许可行，但可能不如第一种方式。&lt;/p&gt;

&lt;h3&gt;其它一些问题&lt;/h3&gt;

&lt;p&gt;当然，字体大小并不是我发现的 Google Maps 唯一的问题。它还有其他一些小问题，有一些我已经向 Google Maps 的 team 提供了反馈，已经修复，还有一些仍然存在。现在我把这些小问题指出来，其中一些相当的讨厌：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[已修复] Google Maps 曾经在一段时间采用这样一种设计：当它通过对交通信息进行分析，得知有另一条时间更短的路线，它会弹出一个窗口，询问用户是否要选择这条更快的路（Yes/No?）。这个窗口有十几秒的延时，到时间之后如果你没有按屏幕，窗口会自动消失，并且自动选择新的路线。&lt;/p&gt;

&lt;p&gt;缺省选择新的路线，是一个很不合理的设计。在开车的时候，你必须集中注意力在路上，几乎没有时间去相应弹出的窗口。而且这个窗口字体和按钮都很小，开车人可能根本没时间去读里面的内容，即使读了也不容易按中正确的按钮。到时间没有动作，导航系统自动切换到新的路线，而不是保留用户最初的选择。未经允许改变用户的路线选择，可以说是一个反人类的设计。&lt;/p&gt;

&lt;p&gt;我及时向 Google Maps 团队提供了强烈的反馈，这个问题已经改变。现在缺省的选择是保留原来的路线。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[还存在] Google Maps 有时候会忽然重新计算并且改变原来的路线。改变的原因也许是因为开车人没有按原路线走，然而这有可能不是开车人的意愿。举一个例子，从南湾地区去三藩市方向，有两条高速公路可以走：280 和 101。白天我一般会选择 280，因为 280 车不多，而且风景优美一些。我会在 Google Maps 界面选择 280 的路线。&lt;/p&gt;

&lt;p&gt;然而当我开出停车场，在第一个路口由于 GPS 的方向还未适应过来，我有可能转错方向。这个时候 Google Maps 会根据我的方向重新计算路线，这时候它很有可能自动把整个路线换成走 101，而不再是 280。由于最初的方向错误而换掉整体要走的高速公路，是非常不合理的。你以为它会按你原来的选择走 280，结果最后发现它把你带到了 101 的入口……&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/07/05/google-maps</guid>
<pubDate>Tue, 05 Jul 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>养生节目带来的危害</title>
<link>http://yinwang.org/blog-cn/2016/06/28/yangsheng</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;养生节目带来的危害&lt;/h2&gt;
                            &lt;p&gt;国内总是流行各种各样的“养生节目”，深受中老年人的欢迎。比如我爸妈，有时无聊了，就会转发给我一些养生节目，比如这个：『&lt;a href=&quot;http://v.qq.com/x/cover/kieigw8nv6q7fj0/b0016b9qoy1.html&quot;&gt;多喝白开水带来的危害&lt;/a&gt;』。这节目说，有人得了过敏性鼻炎，喷嚏鼻涕不断，严重脱发，头都半秃了，虚弱无力，性能力衰退…… 最后专家得出结论，是因为他每天早上喝一杯凉水导致的！&lt;/p&gt;

&lt;p&gt;据我观察，这些养生节目里面的理论，基本可以归为两种：好的和新的。可惜好的理论都不新，新的理论都不好。&lt;/p&gt;

&lt;h3&gt;好的理论&lt;/h3&gt;

&lt;p&gt;第一类理论，就是把人们早已熟悉的，久经考验的常识，比如早晚要刷牙之类的，拿来包装成“新理论”。这些理论当然错不到哪里去，然而却是每个人从小都已熟知的。现在挂着“专家”头衔的人出来一宣传，这些斯通见惯的常识，忽然间被老人家们当成了最新的研究成果。&lt;/p&gt;

&lt;p&gt;我遇到的这种例子挺多的。有时候父母给我发个信息，说你要注意这个那个习惯啊，不然会得什么什么样的病…… 这本来就是我从小就已经知道并且照办的事情，而且我还记得当年这东西就是我爸妈教给我的。现在让这帮“养生专家”一忽悠，倒像个新鲜事，又拿出来讲一遍，好像别人不知道一样…… “专家”的威力就是这么强大 :P&lt;/p&gt;

&lt;h3&gt;新的理论&lt;/h3&gt;

&lt;p&gt;第二类理论，就是胡编乱造出一些“新理论”，却没有经过科学实验证实。『&lt;a href=&quot;http://v.qq.com/x/cover/kieigw8nv6q7fj0/b0016b9qoy1.html&quot;&gt;多喝白开水带来的危害&lt;/a&gt;』就属于这一种情况。通常这种理论把问题的原因归结为某一个生活习惯（比如早上喝一杯凉水），而忽略所有其它引起问题的因素。这些理论的问题在于，它们通过臆断，得出错误的“因果关系”。&lt;/p&gt;

&lt;p&gt;据我了解，过敏性鼻炎，脱发等问题，很多都是因为基因遗传，跟人平时的生活习惯几乎没有关系。现在有一个人出现了过敏性鼻炎和脱发，而且碰巧这人早上起来喜欢喝一杯凉水，于是专家就得出一个可笑的结论：一定是喝凉水引起了过敏性鼻炎和脱发。&lt;/p&gt;

&lt;p&gt;养生专家们很喜欢把健康问题跟某些不起眼的习惯挂钩，这样就可以创造一些惊人的理论，却无法验证其真实性。他们可以说，就是因为你这个小小的习惯，导致了如此严重的健康问题。这样一来，他们就可以告诉你吃什么，不吃什么，做什么，不做什么。每过一段时间，这些人都会换一套不同的说法，让你感觉有新东西出来，却没发现这些其实跟之前的说法自相矛盾。老年人记性不好，看不出破绽，有些人为了健康不惜一切，仿佛活着就是为了不停地研究如何才能继续活着…… 这就是这帮养生专家和养生节目得以生存的关键。&lt;/p&gt;

&lt;p&gt;得出喝凉水引起了鼻炎，脱发，身体虚弱这样的结论，且不说它看起来有没有可能，你必须先经过科学实验。你不能只看一个人，因为数据量太小，很可能是偶然巧合，没法建立因果关系。所以实验必须要有两组人进行对照，就是所谓“对照实验”。一组人早上喝一杯凉水，另外一组人不喝。过一段时间，分析这两组人里面出现上述问题的人的比例，如果喝凉水的人大部分出现了问题，而不喝凉水的人大部分没有出现问题，你才有可以得出“喝凉水导致鼻炎和脱发”这样的结论。&lt;/p&gt;

&lt;p&gt;显然，这个节目里的专家并没有经过实验，而是引用（滥用）『黄帝内经』里面的各种阴阳理论。说早上阳气上升，喝一杯凉水把阳气给浇灭了，怎么能不得病哪！这显然是完全不科学，不负责任的说法。实际上这套阴阳理论是如此的模棱两可，跟占星学如出一辙，你可以利用这些说法来解释世界上的几乎任何现象！不管遇到好事还是坏事，同样的一句话，可以同时支持两种完全相反的结果。为什么它可以这样呢？因为这些说法本来模棱两可，所以不同的人从不同的角度去解释它，发现都是说得通的。&lt;/p&gt;

&lt;p&gt;这些养生节目，经常把严重身体问题的起因，归结为某些生活上的小习惯，吃什么，不吃什么之类，很容易让人忽略真正的起因，更加严重的因素，这属于一种误导。中老年人看了这些节目，往往盲目的认为坚持或者改变生活上的一些小习惯，就可以避免或者修正一些严重的身体疾患，结果耽误了真正科学研究出来的补救办法。在这种意义上，养生节目是有危害性的。我建议中老年人少看这种节目，多跟真正的医生了解科学的医疗知识。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/06/28/yangsheng</guid>
<pubDate>Tue, 28 Jun 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>IT业给世界带来的危机</title>
<link>http://yinwang.org/blog-cn/2016/06/20/it-and-society</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;IT业给世界带来的危机&lt;/h2&gt;
                            &lt;p&gt;昨天写了文章之后，回忆起这几年在湾区的经历，觉得自己是一个很不幸的人。然而就在今天，我的自怜奇妙的转换成了另一种感情，因为我看到了更不幸的人……&lt;/p&gt;

&lt;p&gt;正在女朋友 Cinny 的父母家吃饭，忽然窗外来了一个人。仔细一看，是个约莫十来岁年纪的漂亮白人女孩，她说：“亲爱的，你们想要一些刚从树上摘下来的新鲜李子吗？” 据女朋友妈妈介绍，她是邻居的女儿。之后我尝了一个李子，颜色已经黑透了，非常新鲜非常甜！&lt;/p&gt;

&lt;p&gt;随后我和 Cinny 出去散步。在她家的对面，耸立着两栋高大华丽的豪宅，看那样子，价值恐怕超过200万美元。两栋豪宅的中间，夹着一间样式非常不搭调的便宜小矮屋。这屋子周围被篱笆围了起来，可以看见里面种了很多的植物。在那门口的无花果树下，赫然出现这样的一个牌子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-fbcae0ac0fa13486.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;它说：“请不要摘我的无花果。我失去了我的工作，需要依靠自己种的食物为生。我是一个生物学家，如果你知道有任何的工作，请告诉我。谢谢！” 这树上还挂着好几个类似的牌子，从它们看来，这位生物学家已经失业一年了……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-18fdd10a61af7c99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Cinny 说，吃饭时给我们送果子来的女孩，就是这家的孩子。我想起她甜美的笑容，不禁一阵心酸！哎，谁才是真正可怜的人？我之前在无病呻吟些什么啊……&lt;/p&gt;

&lt;p&gt;这些年来湾区的 IT 业大量的扩张，Apple，Google 等公司不停地在附近建新的办公楼。IT 业的过度发展，导致了其它行业的衰落，让附近土生土长的居民生存困难。本来公司的扩张应该引起经济的流通，社区的繁荣，人气的高涨，结果每当像 Google 这样的公司提供免费餐饮，附近就会有多少店铺关门，又有多少人失业，成为一片荒漠……&lt;/p&gt;

&lt;p&gt;是的，大家节省外出买饭的时间能为公司赚很多钱，自己也节省了不少开支。但是这些公司真的回报了社会吗？新闻早已经曝光，这些大公司利用美国税法的漏洞，每一家每年都导致政府少收上亿美元的税钱。没有收到税，就没法给这些丢了工作的人发福利，以至于他们落魄到这种地步。&lt;/p&gt;

&lt;p&gt;Cinny 告诉我，这家人可能也要卖掉房子，搬到别州去了。之前有好些邻居已经搬走了，其中有一些以前在附近开小店，卖很好吃的东西。现在这些儿时的美好回忆，都已经不在了……&lt;/p&gt;

&lt;p&gt;我们一直盲目的以为技术会改善人们的生活，很多人总是试图做一些 O2O 服务，甚至研制机器人和自动车，这样可以代替许多人的劳动。如果这些技术真的能代替繁重或者危险的劳动，那确实好。可是如果发明这些技术的公司不回报社会，反而想办法钻法律的漏洞避税，那就变得有害了。在创造这些技术的同时，我们有想过因为它们而失去工作，而又因为公司不交税，不回报社会而变卖房产，颠沛流离的无辜人们吗？&lt;/p&gt;

&lt;p&gt;作为一个 IT 人，我们不得不思考，这是不是一种无情的掠夺，我们是不是害虫？当我们帮助雇主掠夺了别人的工作之后，我们自己会不会就是下一个被社会抛弃，丢掉工作的人？“&lt;a href=&quot;http://baike.baidu.com/view/1140346.htm&quot;&gt;独乐乐，与人乐乐，孰乐乎？不若与人。&lt;/a&gt;” 我们在思考如何发展自己事业的同时，也应该思考如何回报社会了。否则我们面对的将是一片毫无生气的荒原，我们不会再看到幸福的笑脸……&lt;/p&gt;

&lt;p&gt;有人说这一切都是资本主义造的孽，而不能怪 IT 业。不过由于 IT 存在高度的“智能”和“自动”，它已经开始给资本主义的社会关系带来灾难性的影响。有位大胡子说，无产阶级是资本主义的掘墓人，那么我说，IT 业就是资本主义的定时炸弹，它离爆炸的那一天已经不远了。&lt;/p&gt;

&lt;p&gt;我想我们应该都能做点什么…… 话说，如果你知道湾区有招生物学家的工作，请联系我！&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/06/20/it-and-society</guid>
<pubDate>Mon, 20 Jun 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Java 有值类型吗？</title>
<link>http://yinwang.org/blog-cn/2016/06/08/java-value-type</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;Java 有值类型吗？&lt;/h2&gt;
                            &lt;p&gt;有人看了我之前的文章『&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/06/swift&quot;&gt;Swift 语言的设计错误&lt;/a&gt;』，问我：“你说 Java 只有引用类型（reference type），但是根据 Java 的&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html&quot;&gt;官方文档&lt;/a&gt;，Java 也有值类型（value type）和引用类型的区别的。比如 int，boolean 等原始类型就是值类型。” 现在我来解释一下这个问题。&lt;/p&gt;

&lt;p&gt;Java 有值类型，原始类型 int，boolean 等是值类型，其实是长久以来的一种误解，它混淆了实现和语义的区别。不要以为 Java 的官方文档那样写就是权威定论，就可以说“王垠不懂” :) 当你认为王垠不懂一个初级问题的时候，都需要三思，因为他可能是大智若愚…… 看了我下面的论述，也许你会发现自己应该怀疑的是，Java 的设计者到底有没有搞明白这个问题 :P&lt;/p&gt;

&lt;p&gt;胡扯结束，现在来说正事。Java，Scheme 等语言的原始类型，比如 char，int，boolean，double 等，在“实现”上确实是通过值（而不是引用，或者叫指针）直接传递的，然而这完全是一种为了效率的优化（叫做 inlining）。这种优化对于程序员应该是不可见的。Java 继承了 Scheme/Lisp 的衣钵，它们在“语义”上其实是没有值类型的。&lt;/p&gt;

&lt;p&gt;这不是天方夜谭，为了理解这一点，你可以做一个很有意思的思维实验。现在你把 Java 里面所有的原始类型都“想象”成引用类型，也就是说，所有的 int, boolean 等原始类型的变量都不包含实际的数据，而是引用（或者叫指针），指向堆上分配的数据。然后你会发现这样“改造后”的 Java，仍然符合现有 Java 代码里能看到的一切现象。也就是说，原始类型被作为值类型还是引用类型，对于程序员完全没有区别。&lt;/p&gt;

&lt;p&gt;举个简单的例子，如果我们把 int 的实现变成完全的引用，然后来看这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int x = 1;    // x指向内存地址A，内容是整数1
int y = x;    // y指向同样的内存地址A，内容是整数1
x = 2;        // x指向另一个内存地址B，内容是整数2。y仍然指向地址A，内容是1。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们改造后的 Java 里面 int 全部是引用，所以第一行定义的 &lt;code&gt;x&lt;/code&gt; 并不包含一个整数，而是一个引用，它指向堆里分配的一块内存，这个空间的内容是整数 1。在第二行，我们定 int 变量 &lt;code&gt;y&lt;/code&gt;，当然它也是一个引用，它的值跟 &lt;code&gt;x&lt;/code&gt; 一样，所以 &lt;code&gt;y&lt;/code&gt; 也指向同一个地址，里面的内容是同一个整数：1。在第三行，我们对 &lt;code&gt;x&lt;/code&gt; 这个引用赋值。你会发现一个很有意思的现象，虽然 &lt;code&gt;x&lt;/code&gt; 指向了 2，&lt;code&gt;y&lt;/code&gt; 却仍然指向 1。对 &lt;code&gt;x&lt;/code&gt; 赋值并没能改变 &lt;code&gt;y&lt;/code&gt; 指向的内容，这种情况就跟 int 是值类型的时候一模一样！所以现在虽然 int 变量全部是引用，你却不能实现共享地址的引用能做的事情：对 &lt;code&gt;x&lt;/code&gt; 进行某种操作，导致 &lt;code&gt;y&lt;/code&gt; 指向的内容也发生改变。&lt;/p&gt;

&lt;p&gt;出现这个现象的原因是，虽然现在 int 成了引用类型，你却并不能对它进行引用类型所特有（而值类型没有）的操作。这样的操作包括：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;deref。就像 C 语言里的 &lt;code&gt;*&lt;/code&gt; 操作符。&lt;/li&gt;
&lt;li&gt;成员赋值。就像对 C struct 成员的 &lt;code&gt;x.foo = 2&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在 Java 里，你没法写像 C 语言的 &lt;code&gt;*x = 2&lt;/code&gt; 这样的代码，因为 Java 没有提供 deref 操作符 &lt;code&gt;*&lt;/code&gt;。你也没法通过 &lt;code&gt;x.foo = 2&lt;/code&gt; 这样的语句改变 &lt;code&gt;x&lt;/code&gt; 所指向的内存数据（内容是1）的一部分，因为 int 是一个原始类型。最后你发现，你只能写 &lt;code&gt;x = 2&lt;/code&gt;，也就是改变 &lt;code&gt;x&lt;/code&gt; 这个引用本身的指向。&lt;code&gt;x = 2&lt;/code&gt; 执行之后，原来数字 1 所在的内存空间并没有变成 2，只不过 x 指向了新的地址，那里装着数字 2 而已。指向 1 的其它引用变量比如 &lt;code&gt;y&lt;/code&gt;，不会因为你进行了 &lt;code&gt;x = 2&lt;/code&gt; 这个操作而看到 2，它们仍然看到原来那个1……&lt;/p&gt;

&lt;p&gt;在这种 int 是引用的 Java 里，你对 int 变量 &lt;code&gt;x&lt;/code&gt; 能做的事情只有两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读出它的值。&lt;/li&gt;
&lt;li&gt;对它进行赋值，使它指向另一个地方。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这两种事情，就跟你能对值类型能做的两件事情没有区别。这就是为什么你没法通过对 &lt;code&gt;x&lt;/code&gt; 的操作而改变 &lt;code&gt;y&lt;/code&gt; 表示的值。所以不管 int 在实现上是传递值还是传递引用，它们在语义上都是等价的。也就是说，原始类型是值类型还是引用类型，对于程序员来说完全没有区别。你完全可以把 Java 所有的原始类型都想成引用类型，之后你能对它们做的事情，你的编程思路和方式，都不会因此有任何的改变。&lt;/p&gt;

&lt;p&gt;从这个角度来看，Java 在语义上是没有值类型的。值类型和引用类型如果同时并存，程序员必须能够在语义上感觉到它们的不同，然而不管原始类型是值类型还是引用类型，作为程序员，你无法感觉到任何的不同。所以你完全可以认为 Java 只有引用类型，把原始类型全都当成引用类型来用，虽然它们确实是用值实现的。&lt;/p&gt;

&lt;p&gt;一个在语义上有值类型的语言（比如 C#，Go 和 Swift）必须具有以下两种特性之一（或者两者都有），程序员才能感觉到值类型的存在：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;deref 操作。这使得你可以用 &lt;code&gt;*x = 2&lt;/code&gt; 这样的语句来改变引用指向的内容，导致共享地址的其它引用看到新的值。你没法通过 &lt;code&gt;x = 2&lt;/code&gt; 让其他值变量得到新的值，所以你感觉到值类型的存在。&lt;/li&gt;
&lt;li&gt;像 struct 这样的“值组合类型”。你可以通过 &lt;code&gt;x.foo = 2&lt;/code&gt; 这样的成员赋值改变引用数据（比如 class object）的一部分，使得共享地址的其它引用看到新的值。你没法通过成员赋值让另一个 struct 变量得到新的值，所以你感觉到值类型的存在。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;实际上，所有的数据都是引用类型就是 Scheme 和 Java 最初的设计原理。原始类型用值来传递数据只是一种性能优化（叫做 inlining），它对于程序员应该是透明（看不见）的。那些在面试时喜欢问“Java 是否所有数据都是引用”，然后当你回答“是”的时候纠正你说“int，boolean 是值类型”的人，都是本本主义者。&lt;/p&gt;

&lt;h3&gt;思考题&lt;/h3&gt;

&lt;p&gt;有人指出，Java 的引用类型可以是 null，而原始类型不行，所以引用类型和值类型还是有区别的。但是其实这并不能否认本文指出的观点，你可以想想这是为什么吗？&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/06/08/java-value-type</guid>
<pubDate>Wed, 08 Jun 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Swift 语言的设计错误</title>
<link>http://yinwang.org/blog-cn/2016/06/06/swift</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;Swift 语言的设计错误&lt;/h2&gt;
                            &lt;p&gt;在『&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy&quot;&gt;编程的智慧&lt;/a&gt;』一文中，我分析和肯定了 Swift 语言的 optional type 设计，但这并不等于 Swift 语言的整体设计是完美没有问题的。其实 Swift 1.0 刚出来的时候，我就发现它的 array 可变性设计存在严重的错误。Swift 2.0 修正了这个问题，然而他们的修正方法却没有击中要害，所以导致了其它的问题。这个错误一直延续到今天。&lt;/p&gt;

&lt;p&gt;Swift 1.0 试图利用 var 和 let 的区别来指定 array 成员的可变性，然而其实 var 和 let 只能指定 array reference 的可变性，而不能指定 array 成员的可变性。举个例子，Swift 1.0 试图实现这样的语义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]

// 可以对 array 成员赋值
shoppingList[0] = &quot;Salad&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;let shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]

// 不能对 array 成员赋值，报错
shoppingList[0] = &quot;Salad&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是错误的。在 Swift 1.0 里面，array 像其它的 object 一样，是一种“reference type”。为了理解这个问题，你应该清晰地区分 array reference 和 array 成员的区别。在这个例子里，&lt;code&gt;shoppingList&lt;/code&gt; 是一个 array reference，而 &lt;code&gt;shoppingList[0]&lt;/code&gt; 是访问一个 array 成员，这两者有着非常大的不同。&lt;/p&gt;

&lt;p&gt;var 和 let 本来是用于指定 &lt;code&gt;shoppingList&lt;/code&gt; 这个 reference 是否可变，也就是决定 &lt;code&gt;shoppingList&lt;/code&gt; 是否可以指向另一个 array 对象。正确的用法应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]

// 可以对 array reference 赋值
shoppingList = [&quot;Salad&quot;, &quot;Noodles&quot;]

// 可以对 array 成员赋值
shoppingList[0] = &quot;Salad&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;let shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]

// 不能对 array reference 赋值，报错
shoppingList = [&quot;Salad&quot;, &quot;Noodles&quot;]

// let 不能限制对 array 成员赋值，不报错
shoppingList[0] = &quot;Salad&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说你可以用 var 和 let 来限制 &lt;code&gt;shoppingList&lt;/code&gt; 这个 reference 的可变性，而不能用来限制 &lt;code&gt;shoppingList[0]&lt;/code&gt; 这样的成员访问的可变性。&lt;/p&gt;

&lt;p&gt;var 和 let 一旦被用于指定 array reference 的可变性，就不再能用于指定 array 成员的可变性。实际上 var 和 let 用于局部变量定义的时候，只能指定栈上数据的可变性。如果你理解 reference 是放在栈（stack）上的，而 Swift 1.0 的 array 是放在堆（heap）上的，就会明白array 成员（一种堆数据）可变性，必须用另外的方式来指定，而不能用 var 和 let。&lt;/p&gt;

&lt;p&gt;很多古老的语言都已经看清楚了这个问题，它们明确的用两种不同的方式来指定栈和堆数据的可变性。C++ 程序员都知道 &lt;code&gt;int const *&lt;/code&gt; 和 &lt;code&gt;int * const&lt;/code&gt; 的区别。Objective C 程序员都知道 &lt;code&gt;NSArray&lt;/code&gt; 和 &lt;code&gt;NSMutableArray&lt;/code&gt; 的区别。我不知道为什么 Swift 的设计者看不到这个问题，试图用同样的关键字（var 和 let）来指定栈和堆两种不同位置数据的可变性。实际上，不可变数组和可变数组，应该使用两种不同的类型来表示，就像 Objective C 的 &lt;code&gt;NSArray&lt;/code&gt; 和 &lt;code&gt;NSMutableArray&lt;/code&gt; 那样，而不应该使用 var 和 let 来区分。&lt;/p&gt;

&lt;p&gt;Swift 2.0 修正了这个问题，然而可惜的是，它的修正方式是错误的。Swift 2.0 做出了一个离谱的改动，它把 array 从 reference type 变成了所谓 value type，也就是说把整个 array 放在栈上，而不是堆上。这貌似解决了以上的问题，由于 array 成了 value type，那么  &lt;code&gt;shoppingList&lt;/code&gt; 就不是  reference，而代表整个 array 本身。所以在 array 是 value type 的情况下，你确实可以用 var 和 let 来决定它的成员是否可变。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]

// 不能对 array 成员赋值，因为 shoppingList 是 value type
// 它表示整个 array 而不是一个指针
// 这个 array 的任何一部分都不可变
shoppingList[0] = &quot;Salad&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这看似一个可行的解决方案，然而它却没有击中要害。这是一种削足适履的做法，它带来了另外的问题。把 array 作为 value type，使得每一次对 array 变量的赋值或者参数传递，都必须进行拷贝。你没法让两个变量指向同一个 array，也就是说 array 不再能被共享。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = [1, 2, 3]

// a 的内容被拷贝给 b
// a 和 b 是两个不同的 array，有相同的内容
var b = a   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这违反了程序员对于数组这种大型结构的心理模型，他们不再能清晰方便的对 array 进行思考。由于 array 会被不经意的自动拷贝，很容易犯错误。数组拷贝需要大量时间，就算接收者不修改它也必须拷贝，所以效率上有很大影响。不能共享同一个 array，在里面读写数据，是一个很大的功能缺失。由于这个原因，没有任何其它现代语言（Java，C#，……）把 array 作为 value type。&lt;/p&gt;

&lt;p&gt;如果你看透了 value type 的实质，就会发现这整个概念的存在，在具有垃圾回收（GC）的现代语言里，几乎是没有意义的。有些新语言比如 Swift 和 Rust，试图利用 value type 来解决内存管理的效率问题，然而它带来的性能提升其实是微乎其微的，给程序员带来的麻烦和困扰却是有目共睹的。完全使用 reference type 的语言（比如 Java，Scheme，Python），程序员不需要思考 value type 和 reference type 的区别，大大简化和加速了编程的思维过程。Java 不但有非常高效的 GC，还可以利用 escape analysis 自动把某些堆数据放在栈上，程序员不需要思考就可以达到 value type 带来的那么一点点性能提升。相比之下，Swift，Rust 和 C# 的 value type 制造的更多是麻烦，而没有带来实在的性能优势。&lt;/p&gt;

&lt;p&gt;Swift 1.0 犯下这种我一眼就看出来的低级错误，你也许从中发现了一个道理：编译器专家并不等于程序语言专家。很多经验老到的程序语言专家一看到 Swift 最初的 array 设计，就知道那是错的。只要团队里有一个语言专家指出了这个问题，就不需要这样反复的修改折腾。为什么 Swift 直到 1.0 发布都没有发现这个问题，到了 2.0 修正却仍然是错的？我猜这是因为 Apple 并没有聘请到合格的程序语言专家来进行 Swift 的设计，或者有合格的人，然而他们的建议却没有被领导采纳。Swift 的首席设计师是 Chris Lattner，也就是 LLVM 的设计者。他是不错的编译器专家，然而在程序语言设计方面，恐怕只能算业余水平。编译器和程序语言，真的是两个非常不同的领域。Apple 的领导们以为好的编译器作者就能设计出好的程序语言，以至于让 Chris Lattner 做了总设计师。&lt;/p&gt;

&lt;p&gt;Swift 团队不像 Go 语言团队完全是一知半解的外行，他们在语言方面确实有一定的基础，所以 Swift 在大体上不会有特别严重的问题。然而可以看出来这些人功力还不够深厚，略带年轻人的自负，浮躁，盲目的创新和借鉴精神。有些设计并不是出自自己深入的见解，而只是“借鉴”其它语言的做法，所以可能犯下经验丰富的语言专家根本不会犯的错误。第一次就应该做对的事情，却需要经过多次返工。以至于每出一个新的版本，就出现一些“不兼容改动”，导致老版本语言写出来的代码不再能用。这个趋势在 Swift 3.0 还要继续。由于 Apple 的统治地位，这种情况对于 Swift 语言也许不是世界末日，然而它确实犯了语言设计的大忌。一个好的语言可以缺少一些特性，但它绝不应该加入错误的设计，导致日后出现不兼容的改变。我希望 Apple 能够早日招募到资深一些的语言设计专家，虚心采纳他们的建议。BTW，如果 Apple 支付足够多的费用，我倒可以考虑兼职做他们的语言设计顾问 ;-)&lt;/p&gt;

&lt;h3&gt;Java 有 value type 吗？&lt;/h3&gt;

&lt;p&gt;有人看了以上的内容，问我：“你说 Java 只有 reference type，但是根据 Java 的&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html&quot;&gt;官方文档&lt;/a&gt;，Java 也有 value type 和 reference type 的区别的。” 由于这个问题相当的有趣，我另外写了一篇&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/08/java-value-type&quot;&gt;文章&lt;/a&gt;来回答这个问题。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/06/06/swift</guid>
<pubDate>Mon, 06 Jun 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>我的 tweet 系统</title>
<link>http://yinwang.org/blog-cn/2016/05/25/my-tweet</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;我的 tweet 系统&lt;/h2&gt;
                            &lt;p&gt;有时候灵光乍现，却又不想写成完整的文章，所以尝试过使用 twitter 和微博，然而最终我发现它们有各种缺点。所以我想出一个圡办法：自己手动整理一个列表，把想说的放进去，加上日期，就算是我的 tweet 系统。&lt;/p&gt;

&lt;p&gt;这个系统有一系列强大的功能：无法 follow 或订阅，不能评论，不方便转载。可以随意修改，随意排序，不限字数。不能随时随地增加内容，防止成瘾。心诚的人必须主动来这里看，理解更深入，自动过滤心理不正常的人，等等…… 这是迄今为止最好最完善的 social network 系统。本系统的座右铭是：我想写 tweet，所以我就写了。你们想看就看，不想看就算了。&lt;/p&gt;

&lt;p&gt;请点击&lt;a href=&quot;http://www.yinwang.org/tweet.html&quot;&gt;这里&lt;/a&gt;访问我的 tweet 系统。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/05/25/my-tweet</guid>
<pubDate>Wed, 25 May 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>正面思维的误区</title>
<link>http://yinwang.org/blog-cn/2016/05/22/positive-thinking</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;正面思维的误区&lt;/h2&gt;
                            &lt;p&gt;有些人喜欢宣扬所谓“正面思维”（positive thinking），而不顾事实真相。每当你批评一些事情，他们就会拿出正面思维这个万能法宝来压制你，说：“你这人怎么这么 negative？要 positive，要看到事物好的方面才对！”&lt;/p&gt;

&lt;p&gt;比如这次有人说：“你把之前每个东家都喷了一遍。这里面难道就没有你自己的问题吗？” 我只能说，如果它们真的就是那么恶劣，那我有什么办法呢？由于没来得及选择，连续进入好几家问题公司，其实很正常。我不是一个完美的人，然而在公司的人际关系上，我可以说是仁至义尽了。我没架子，容易相处，这点很多同事都知道，甚至厨师和扫地大妈都知道。然而我绝对不是好欺负的。&lt;/p&gt;

&lt;p&gt;像 Coverity，Sourcegraph 这类极品，欺压员工，无耻利用，行为极其恶劣，难道我还能说它们好话不成？我的心理不知道要扭曲到什么程度，才能发掘出他们好的地方来。这些公司的恶劣行径，严重损害了员工的身心健康，伤害了他们的事业发展，在某种程度上可以说是犯罪行为，没有把这些人告上法庭就已经不错了。关于这些公司，有很多骇人听闻的细节我还没有说出来，我保留对这些进行进一步揭露的权利。&lt;/p&gt;

&lt;p&gt;然而这不是今天的主题，我今天想谈的是所谓“正面思维”。很多人没有意识到，盲目的正面思维，其实是一个很严重的问题。正面并没有什么问题，快乐是好事，然而它们应该是结果，而不应该是目的。如果一个社会需要刻意去提倡“正面”和“快乐”，去宣扬它们，通过舆论压力或者暴力，迫使每个人都“正面思维”，那就有严重问题了。文化大革命的时候，人们的思维可真是很正面啊，各种歌颂…… 你要是敢说任何不好听的话，立即被打成反革命右派。可是今天，我发现这种文革似的“正面思潮”，又有抬头之势。其实，它在美国已经泛滥成灾，以至于有人专门写了一本书来批判这种“正面思维”：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Bright-sided-Relentless-Promotion-Positive-Undermined-ebook/dp/B002SKDGQ0&quot;&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-28fd151402f7b345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当你遇到困难的时候，美国人喜欢说：“别担心，一切都会好起来的……”，“要专注于事物好的方面……”，“只要你努力，就会有好结果……”，“困难是临时的，面包会有的，Go 语言会改进的……”，“危机会过去的，经济会持续增长的⋯⋯”，“美国是世界上最伟大的国家，上帝保佑美利坚……” 看看这本书，你就知道这些说法有多大的欺骗性。整个美国，其实都沉浸在人们不切实际的“正面幻想”之中。&lt;/p&gt;

&lt;p&gt;“正面思维”跟美国的剥削制度和资本主义，是密不可分的。美国总是宣称自己是民主自由的国家。听到这个，比美国民主和自由很多的国家，都笑了。一个真正民主自由的国家，有什么必要反复的宣称自己是民主和自由的呢？事实上，美国是一个剥削和压迫非常严重的国家，美国人民并不幸福。实际上，正面思维就是剥削者想出来，用于安抚人民，让人安心做廉价劳动力的工具。一些所谓“成功人士”，总是鼓励大家要上进，要看到事物好的方面，说失业是一种福分，要安于现状，一步一步奋斗，往上爬！然后呢，自己却在背后玩弄权术，利用人们的正面不设防的心理，招摇撞骗，投机取巧，贬低人的价值，压低雇员工资，让别人加班加点，动作慢了随时开掉。自己却不劳而获，靠着一口官腔（所谓“领导才能”）飞黄腾达。&lt;/p&gt;

&lt;p&gt;在美国，正面思维是一个产业。号称“快乐民族”的美国人，每年消耗掉世界上三分之二的抗抑郁症药物。美国出产层出不穷的正面思维和“成功学”书籍，DVD，以及其他产品：『&lt;a href=&quot;https://en.wikipedia.org/wiki/How_to_Win_Friends_and_Influence_People&quot;&gt;人性的弱点&lt;/a&gt;』，『&lt;a href=&quot;https://en.wikipedia.org/wiki/Chicken_Soup_for_the_Soul&quot;&gt;心灵的鸡汤&lt;/a&gt;』，『&lt;a href=&quot;https://en.wikipedia.org/wiki/Who_Moved_My_Cheese%3F&quot;&gt;谁动了我的奶酪&lt;/a&gt;』，『&lt;a href=&quot;https://en.wikipedia.org/wiki/The_Secret_(book&quot;&gt;秘密&lt;/a&gt;)』…… 出产成千上万的所谓人生导师，职场教练，宗教领袖，知心大妈，心理医生，鸡汤和蛇油贩子…… 他们的谋生方式，就是训练你如何正面思维，抑制负面情绪。这些人不能给你任何切实可行改善生活的办法，而只是告诉你，如何才能把生活的挫折，社会的不合理，不公平，都想成自己的思想有问题，或者自己不够努力，不够好。不论遇到什么样的不幸或者不公正待遇，你都不能抱怨抗议，反而还得“心存感激”，因为你活着就是上帝最好的恩赐。这也就是为什么美国有个节日叫“感恩节”，除了美国及其附庸加拿大，世界上没有其它国家庆祝感恩节。&lt;/p&gt;

&lt;p&gt;美国的正面思维产业是如此的发达，甚至产生了一门学科，叫做“正面心理学”。哈佛大学还开设了红极一时的『&lt;a href=&quot;https://positivepsychologyprogram.com/harvard-positive-psychology-course-1504&quot;&gt;正面心理学&lt;/a&gt;』课程（所谓“幸福课”）。我当年看了一阵子这课的&lt;a href=&quot;https://www.youtube.com/watch?v=K8qpn6kNfPc&amp;amp;list=PL28D16304BA57DD7E&quot;&gt;视频&lt;/a&gt;，发现它真的很不寻常。课程进行到将近一半，教授仍然在做一般课程第一堂课的那种“动员工作”。没有传授任何切实可行的方法，只是反反复复地试图说服你，为什么你应该学正面心理学…… 老师啊，我坐在你课堂上半学期了，你还在告诉我为什么应该上你的课？！后来我发现，这个学科很像传销。它并不能让人快乐起来，然而它确实能教会你如何说服别人来上这门课，能把你训练成跟老师一样的“幸福课推销员”，然后你又可以去训练下一代的推销员…… 最后大家都成了推销员，然而推销员自己并不快乐，因为他们没有真正的产品和客户。&lt;/p&gt;

&lt;p&gt;你知道为什么自从小布什做总统以来，美国的正面思维产业越来越红火了吗？因为小布什本来就是拉拉队长（cheerleader）出生，他以前的工作就是给大家加油鼓气的。小布什要求美国人民，一定要正面，一定要认为美国是世界上最伟大的国家，一定要认为美国人民是上帝的宠儿！;-)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-8c0c6feb3e7cffc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;在 Cornell 和 Google 的时候，我饱尝了盲目的正面思维所带来的危害。Cornell 这学校有个奇怪的现象，跟同学聊天时，如果你想打听某个教授的学术或者为人，得到的回应必然是：“他好牛！” “好厉害！” “非常聪明！” 之类的语言。你听不到任何人说不好的方面，比如：“他讲课像是背书”，“他的研究没有实质意义”，“他的学生都很累”之类的负面信息。所以在 Cornell，你无法从同学那里得到任何信息，每个人都饱尝了与某些教授打交道的辛酸，可是每个人都把那些秘密藏在心底。他们对你说：“嗯，他很厉害，他的研究很伟大……”&lt;/p&gt;

&lt;p&gt;这种铺天盖地的正面信息，是无益甚至有害的。如果你只听到正面的声音，那你就无法做出正确的决定。这就像你在网上买东西，如果只看正面的评价，那你很可能买到有问题的商品。正确的作法，应该是正面负面的信息都看。特别是负面的信息，必须仔细看。它们可以告诉你，这个产品有哪些烦扰其他人的缺陷，会不会影响到你的使用。一般我在网上如果被一个产品吸引，我首先看的是一颗星的评价，因为给一颗星的人，一般是恨透了这个产品。当然里面有些无知或者不知好歹的人，你可以忽略，但是大部分人会告诉你，他们不喜欢这个产品的具体原因。我很会分析这些评价，这就是为什么我家里的很多产品，都是非常好用的。&lt;/p&gt;

&lt;p&gt;Cornell 这个学校，就是缺乏这种有益的负面评价。你总是听说每个教授都很牛，人都很好，…… 然而当你真正跟他们接触，就发现事实并非如此。你一次次的跳入火坑，然后才开始希望，要是开头的时候听到一些负面的信息，该多好。可是每个人表面上都是那么的 positive，每个人都认为 negative 是错误的心理，每个人都在强装笑容。这是一个多么可怕的地方！&lt;/p&gt;

&lt;p&gt;Google 的气氛非常类似于 Cornell。Google 员工吃饭时，谈论每个项目或者团队，都带着玫瑰色的光环，仿佛 Google 做的一切都是美好的，先进的，有前途的。在每个星期的 TGIF（Tell Googlers It&#39;s Friday）大会上，founder 们都在大讲台上宣布各种好消息，而对坏消息闭口不提或者一笔带过。下面的 Google 员工们群情激昂，对一些小不点的事情各种欢呼鼓掌尖叫，跟传销大会似的。事实上，Google 内部有许多穷途末路的项目。表面看上去很厉害的样子，等你进去才发现是死路一条，垂死挣扎。项目领导平时紧紧张张，生怕上面来人调查，把自己的项目杀掉。在公司内部搞各种政治，东拉西扯建立各种依赖关系，这样自己的项目才得以生存。&lt;/p&gt;

&lt;p&gt;这种虚伪的正面氛围，存在于很多的美国公司，员工每个星期都被领导打各种鸡血针，保持激昂向上的状态。我曾经跟英国，法国，德国，意大利，瑞典，波兰等国家的同事聊天，他们都暗自嘲笑美国人，说过度正面，传销式的群情激昂，吃错药了一样，确实是美国文化的一大特色。欧洲人比较务实，不搞这套，好的就说好，坏的就批评或者嘲笑，直率坦荡。当然，我不能说所有美国公司都有这种问题，所以我仍然存在希望，找到稍微实在点的公司。&lt;/p&gt;

&lt;p&gt;盲目的正面思维，忽略问题，并不能解决问题。你必须看到负面的事实，才有可能避免困难，得到好的结果。正面思维和浮夸的气氛，正在侵蚀 Google 和很多其它美国公司。为了看清楚正面思维的危害性，我推荐你看看这本书，名叫『负面思维的威力』：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.amazon.com/Power-Negative-Thinking-Unconventional-Achieving/dp/054402771X&quot;&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-f879b3a439066457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200&quot;&gt;&lt;/a&gt;&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/05/22/positive-thinking</guid>
<pubDate>Sun, 22 May 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>关于博文的自愿付费方式</title>
<link>http://yinwang.org/blog-cn/2016/04/13/pay-blog</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;关于博文的自愿付费方式&lt;/h2&gt;
                            &lt;p&gt;曾经有很多人跟我建议，给我的博文里面加上付款的链接，这样我花费的时间可以得到一些回报。我一直很高尚的样子，不愿意为此收费。然而，根据经济学的原理，这是有害社会的 :P 经济的原理是这样，有价值的事物，应该在经济上受到相应的支持，这样好的东西才能受到鼓励，发扬光大，不好的东西才可能被人忘记。&lt;/p&gt;

&lt;p&gt;所以现在我决定，给我觉得价值比较大的文章加上大概的价格，这样喜欢文章的人可以自愿付费，当然也可以不付费。谢谢你的支持！&lt;/p&gt;

&lt;p&gt;【&lt;a href=&quot;http://paypal.me/yinwang0/5&quot;&gt;PayPal付款链接&lt;/a&gt;】&lt;/p&gt;

&lt;p&gt;支付宝二维码（收款人是我父亲的账号mantianxing）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/alipay.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/04/13/pay-blog</guid>
<pubDate>Wed, 13 Apr 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>我为什么不再做PL人</title>
<link>http://yinwang.org/blog-cn/2016/03/31/no-longer-pl</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;我为什么不再做PL人&lt;/h2&gt;
                            &lt;p&gt;我不做程序语言（PL）的工作已经半年了。在这半年里，我变得快乐了很多，对世界也有了新的观点。现在我想来讲一讲，我为什么不想再做PL的工作和研究。我只希望这些观点可以给正在做PL，或者考虑进入这个领域的人们，作为一份参考。&lt;/p&gt;

&lt;h3&gt;学校里的PL人&lt;/h3&gt;

&lt;p&gt;PL看似计算机科学最精髓的部分，事实确实也是这样的。没有任何一个其它领域，可以让你对程序的本质形成如此深入的领悟，然而这并不等于你就应该进入PL的博士班。这是为什么呢？&lt;/p&gt;

&lt;h4&gt;炒冷饭&lt;/h4&gt;

&lt;p&gt;PL这个领域几十年来，已经发展到了非常成熟的阶段。这里面的问题，要么在20年前已经被人解决掉了，要么就是类似“&lt;a href=&quot;https://en.wikipedia.org/wiki/Halting_problem&quot;&gt;停机问题&lt;/a&gt;”一样，不可能解决的问题。然而，博士毕业却要求你发表“创新”的论文，那怎么办呢？于是你就只有扯淡，把别人已经解决的问题换个名字，或者制造一些看似新鲜却不管用的概念，在大会上煞有介事的宣讲。俗话说就是“炒冷饭”。&lt;/p&gt;

&lt;p&gt;最开头进入这个领域的时候，你可能不觉得是这样，因为似乎有那么多的东西可以学习，那么多的大牛可以瞻仰，那么多的新鲜名词，什么“lambda calculus”啊，“语义”啊，各种各样的“类型系统”啊，这样那样的“逻辑”…… 可是时间久了，看透了，你就发现一些这个圈子里的规律。&lt;/p&gt;

&lt;h4&gt;崇拜古人&lt;/h4&gt;

&lt;p&gt;几乎每篇PL领域的论文，里面必有一页弯弯曲曲，让人看花眼的逻辑公式。程序语言的论文，不是用程序来描述，而是用一些老古董的逻辑符号，像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-eae6c6cd2eecfb4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;图1：PL论文里的公式&quot;&gt;&lt;/p&gt;

&lt;p&gt;绝大部分PL领域的专家们，似乎都酷爱逻辑符号，视逻辑学家高人一等。这种崇尚古人的倾向，使得PL专家们看不见这些符号背后，类似电路一样的直觉。他们看不见逻辑学的历史局限，所以他们也许能够发展和扩充一个理论，却无法创造一个新的。&lt;/p&gt;

&lt;p&gt;说到古人，却并不是所有古人都这么晦涩。如果你考古一下就会发现，其实现代逻辑学的鼻祖&lt;a href=&quot;https://en.wikipedia.org/wiki/Gottlob_Frege&quot;&gt;Gottlob Frege&lt;/a&gt;最初的论文里，是没有这些稀奇古怪的符号的。他整篇论文都在画图，一些像电路一样的东西。比如下图，就是Frege的创始论文《&lt;a href=&quot;https://en.wikipedia.org/wiki/Begriffsschrift&quot;&gt;Begriffsschrift&lt;/a&gt;》里最复杂的“公式”之一：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-80571c70a82c1850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200&quot; alt=&quot;图2：Frege的“公式”&quot;&gt;&lt;/p&gt;

&lt;p&gt;你可以把这里的每根线理解成一根电线。图1里那些诡异的逻辑符号，都是一些好事的后人（比如&lt;a href=&quot;https://en.wikipedia.org/wiki/Gerhard_Gentzen&quot;&gt;Gentzen&lt;/a&gt;）加进去的，最后搞得乌七八糟，失去了Frege理论的简单性。所以PL专家们虽然崇尚古人，却没有发现大部分古人，其实并没能获得鼻祖Frege的真传。&lt;/p&gt;

&lt;p&gt;如果你看透了那些公式，自己动手实现过各种解释器，就会发现PL论文里的那些公式，其实相当于解释器的代码，只不过是用一种叫做“XX逻辑”的晦涩的语言写出来的。逻辑，其实本质上是一种相当落伍的程序语言。如果你精通解释器的代码，也许就会发现，这些公式其实用非常蹩脚的方式，实现了哈希表等数据结构。逻辑语言只运行于逻辑学家的脑子里面，用它写出的代码一样可能有bug，而且由于这语言如此障眼难读，而且没有debugger，所以bug非常难发现。逻辑学家们成天为自己的设计失误和bug伤透了脑筋，PL专家们却认为他们具有数学的美感，是比自己聪明的高人 :)&lt;/p&gt;

&lt;p&gt;所以当你看透了所有这些，就会发现PL的学术界，其实反反复复在解决一些早已经解决了的问题，只不过给它们起了不同的名字，使用不同的方式来描述。有时候好几个子领域，其实解决的是同一个问题，然而每个子领域的人，却都说自己的问题在本质上是不一样的，号称自己是那个子领域的鼻祖。甚至有人在20多年的时间里，制造出一代又一代的PhD和教授职位。他们的理论一代代的更新，最后却无法解决实际的问题。所谓的“控制流分析”（control-flow analysis，CFA），就是这样的一个子领域。&lt;/p&gt;

&lt;h4&gt;不知道谁是真的高人&lt;/h4&gt;

&lt;p&gt;进入一个领域做研究，你总该知道那些人是真正厉害的。可惜的是，PL这个领域里，你往往不知道谁是真正掌握了精髓的学者，甚至好几年之后你仍然蒙在鼓里。我的历史教训是，写教科书的人，往往不是最聪明，最理解本质的。真正深刻的PL研究者，你可能根本没听说过他们的名字。&lt;/p&gt;

&lt;p&gt;一般程序员提到PL，就会跟“编译器”这个领域混淆在一起，就会想起大学时候上编译器课，看《&lt;a href=&quot;http://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811&quot;&gt;龙书&lt;/a&gt;》时焦头烂额的情景。然后由于&lt;a href=&quot;https://en.wikipedia.org/wiki/Stockholm_syndrome&quot;&gt;斯德哥尔摩综合症&lt;/a&gt;，他们就会崇拜龙书的作者们。直到遇到了真正厉害的PL专家，你才发现编译器这个领域，跟PL根本是两回事，它其实比PL要低一个档次，里面充满了死记硬背的知识甚至误导。龙书的作者，其实也不是最厉害的编译器作者，他们更不是合格的PL专家。&lt;/p&gt;

&lt;p&gt;上过“正统”的PL课程的学生，往往用一本经典大部头教材叫《&lt;a href=&quot;https://mitpress.mit.edu/index.php?q=books/types-and-programming-languages&quot;&gt;TAPL&lt;/a&gt;》，然后就会误认为此书的作者是最厉害的PL专家，然而他们再一次被名气给蒙蔽了。TAPL这书其实不但照本宣科，没有揭示实质，而且冗长没有选择，有用的没用的过时的理论，一股脑的灌输给你。等你研究到了所谓“交集类型”（intersection types），看到TAPL作者当年的博士论文才发现，其实他把简单的问题搞复杂了，而且那些理论几乎完全不能实用。真正厉害的intersection types专家，其实默默无闻的待在Boston University，而且研究到最后，intersection types这个领域其实被他们证明为完全不能实用。&lt;/p&gt;

&lt;p&gt;由于TAPL这本书，以及&lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language&quot;&gt;ML&lt;/a&gt;)，Haskell等语言在PL界的“&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%99%BD%E8%B1%A1&quot;&gt;白象&lt;/a&gt;”地位，于是很多人又对&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley-Milner&lt;/a&gt;类型系统（HM）充满了崇敬之情，以为HM系统的发明者&lt;a href=&quot;https://en.wikipedia.org/wiki/Robin_Milner&quot;&gt;Robin Milner&lt;/a&gt;是最厉害的PL学者。他的确不错，然而等你随手就能实现出HM系统，看清了它的实质，就会发现所有这样能够“倒推”出类型的系统，其实都具有很大的局限性。&lt;/p&gt;

&lt;p&gt;HM系统的“&lt;a href=&quot;https://en.wikipedia.org/wiki/Unification_(computer_science&quot;&gt;unification&lt;/a&gt;)”机制，依赖于数学上的“&lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;等价关系&lt;/a&gt;”，所以它不可能兼容子类型（subtyping）关系。原因很简单：因为子类型没有交换性，不是一个等价关系。而子类型关系却是对现实世界进行直观的建模所必不可少的，于是你就发现Haskell这类基于HM系统的语言，为了弥补这些缺陷而出现各种“扩展”，却永远无法达到简单和直观。一开头就错了，所以无论Haskell如何发展，这个缺陷也无法弥补。如果没有了HM系统，Haskell就不再是Haskell。&lt;/p&gt;

&lt;p&gt;Robin Milner的另外一个贡献&lt;a href=&quot;https://en.wikipedia.org/wiki/%CE%A0-calculus&quot;&gt;π-calculus&lt;/a&gt;，虽然看起来吓人，其实看透了之后你发现它里面并没有很多东西。π-calculus对并发进行“建模”，却不能解决并发所带来的各种问题，比如竞争（race condition）。实际上普通的语言也能对并发进行简单的建模，所以π-calculus其实只停留于纸面上，不可能应用到现实中去。跟π-calculus类似的一个概念&lt;a href=&quot;https://en.wikipedia.org/wiki/Communicating_sequential_processes&quot;&gt;CSP&lt;/a&gt;也有类似的问题，属于“白象理论”。很多语言（比如Go）扯着CSP的旗号，引起很多人无厘头的膜拜，可见白象的威力有多大 :)&lt;/p&gt;

&lt;p&gt;我在学校研究PL的时候就是这样，每天都发现天外有天，每天都发现曾经的偶像其实很多时候是错觉。最后我发现，PL领域其实最后就剩下那么一点点实质的内容，其它的都是人们造出来的浮云。所以每当有人问我推荐PL书籍，我都比较无语，因为我的PL知识只有非常少数是看书得来的。自己动手琢磨出来的知识，才是最管用的。&lt;/p&gt;

&lt;h4&gt;没人知道你是谁&lt;/h4&gt;

&lt;p&gt;PL的学生还有一个问题，那就是毕业后工作不好找。只有极少数公司（像微软，Intel，Oracle）里的少数团队，可以发挥PL专家的特殊才能。绝大部分其它公司根本不知道PL是什么，PL专家是干什么的。你跟他们说你的专业是“程序语言”，他们还以为你只是学会了“编程”而已，还问你想做“前端”还是“后端” :) 诚然，PL学生一般都有很好的编程能力，然而公司往往只关心自己的实际需求。PL学生毕业之后，很容易被普通公司作为没有任何专长的人对待。&lt;/p&gt;

&lt;p&gt;另外，PL的圈子相当的小，而且门派宗教观念严重，所以就算你从名师手下毕业，想进入另一个老师的门徒掌权的公司，很可能因为两个门派的敌视而无法被接纳，就算进去了也经常会因为对于PL的理念不同而发生冲突。所以，学习PL最精髓的理论是有好处的，然而进入PhD投身PL的研究，我觉得应该三思。&lt;/p&gt;

&lt;h3&gt;公司里的PL人：过度工程&lt;/h3&gt;

&lt;p&gt;PL人在学校里跟着教授炒冷饭，毕业进入了公司之后，他们的行为方式还是非常类似。他们喜欢在公司里做的一件事情，叫做“过度工程”。本来很直接，很容易解决的一个问题，非要给你扯到各种炫酷的PL名词，然后用无比复杂的方案来解决。&lt;/p&gt;

&lt;p&gt;有一些PL人喜欢推广他们认为高大上的语言，比如Haskell，OCaml，Scala等。这些语言在PL学术界很受尊重，所以他们以为这些语言能够奇迹般的解决实际的问题，然而事实却不是这样的。事实是，这些学术界出来的语言，其实缺乏处理现实问题的机制。为了能够在学术上证明程序的所谓“正确性”，而且由于类型系统本身的局限性，这些语言往往被设计得过于简单，具有过度的约束性，以至于表达能力欠缺。&lt;/p&gt;

&lt;p&gt;最后，你发现用这些语言来写代码，总是这也不能做，那也不能做，因为你要是那么做了，编译器就无法发现“类型错误”。到最后你发现，这些语言的约束，其实是无需有的。如果放宽这些约束，其实可以更优雅，更简单的对问题进行建模。对正确性的过分关注，其实导致了PL人选择蹩脚的语言，写出绕着弯子，难以理解的代码。&lt;/p&gt;

&lt;p&gt;还有一类PL人，喜欢设计不必要存在的语言。因为他们认为设计语言是PL人的特异功能，所以随时随地都想把问题往“语言设计”的方向上靠。这样的趋势是非常危险的，因为有原则的PL人，其实都明白一条重要的道理：不到万不得已的时候，千万不要制造语言。&lt;/p&gt;

&lt;p&gt;很多PL人在公司里盲目的制造新的语言，导致的问题是，到最后谁也无法理解这种新语言写出来的代码。这一方面是新语言必然导致的结果，另一方面是由于，并不是每一个PL人都有全面的知识和很好的“品味”。每个PL学生毕业，往往只深入研究了PL的某个子领域，而对其它方面只是浮光掠影，所以他们有可能在那上面犯错。有些PL人喜欢照猫画虎，所以可能盲目的模仿Go语言，Haskell或者Python的特性，设计出非常蹊跷难用的语法。这些新的语言，其实让其他人苦不堪言。最后你发现，他们声称新语言能解决的问题，其实用像Java一样的老语言，照样可以很容易的解决。&lt;/p&gt;

&lt;p&gt;喜欢钻牛角尖，把问题搞复杂，就是很多公司里的PL人的共同点。制造语言是PL人应该尽量避免的事情，这恰恰跟PL人的专长是矛盾的。所以有原则的PL人，生活怎么可能不苦 :)&lt;/p&gt;

&lt;h3&gt;PL人的天才病&lt;/h3&gt;

&lt;p&gt;很多研究PL的人喜欢看低其它程序员，认为自己能设计实现程序语言，就是天之骄子。我之所以从Dan Friedman那里学到了好东西，却没有成为他的PhD学生，一方面就是因为看不惯围绕在他身边那些自认为是“天才”的人。&lt;/p&gt;

&lt;p&gt;总是有那么一群本科生，自认为掌握了Friedman所讲授的精髓，所以高人一等。其实呢，他们的水平比起我这样的，其实差的天远。于是我就经常无奈的看着他们，吵吵闹闹的宣讲他们解决的“新问题”，貌似什么了不起的发明一样，受到Friedman的肯定就受宠若惊的样子。而其实呢，那些都是我几年前就已经试过并且抛弃的方案……&lt;/p&gt;

&lt;p&gt;其它的PL人，包括PhD学生，也有一样的毛病。不管在三流大学，还是在Harvard，Princeton，MIT这样的“牛校”出来的，只要是PL人，几乎必然有这种天才作风。另外你可能不知道的是，牛校往往并不产出优秀的PL人才。像Stanford，Berkeley，MIT这样的传统CS牛校，其实在PL方面是相当差的。&lt;/p&gt;

&lt;p&gt;这种天才病的危害在于，它蒙蔽了这些人的眼睛。他们不再能设计出让“普通人”可以容易使用的产品。如果你不会用，他们就会嘲笑你笨，而其实呢，是因为他们的设计不好。他们喜欢用含混晦涩的方式（所谓“函数式”）的写法来构造代码，让其它人阅读和修改都极其困难，……&lt;/p&gt;

&lt;p&gt;这些所谓天才，看不到简单直观的解决方案，为了显示自己的聪明而采用繁复的抽象，其实是一种愚蠢。真正的天才，必须能够让事情变得简单。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/03/31/no-longer-pl</guid>
<pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
