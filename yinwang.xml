<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>当然我在扯淡</title>
<link>http://www.yinwang.org/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Mon, 11 Jan 2016 13:08:46 +0800</lastBuildDate>
<item>
<title>Tesla Autopilot的事故责任问题</title>
<link>http://yinwang.org/blog-cn/2016/01/10/tesla-autopilot</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;Tesla Autopilot的事故责任问题&lt;/h2&gt;&lt;p&gt;(这是《&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/12/12/tesla-model-s/&quot;&gt;Tesla Model S的设计失误&lt;/a&gt;》一文中加入的新小节。由于写作时间相距太远，现在提出来独立成文。)&lt;/p&gt;&lt;p&gt;Tesla在不久前通过“软件更新”，使Model S具有了初级的“自动驾驶”（autopilot）功能。这个功能可以让Model S自动地，沿着有明确边界线的车道行驶，根据前后车辆的速度相应的加速和减速。驾驶员在这种情况下可以放开方向盘，让车子的电脑系统自己驾驶。&lt;/p&gt;&lt;p&gt;这貌似一个很新很酷的功能，然而在推出不久之后，YouTube上就出现了一些视频，比如&lt;a href=&quot;https://www.youtube.com/watch?v=Lx3-epk_ztQ&quot;&gt;这个&lt;/a&gt;。它们显示，autopilot在高速公路出口弯道这类地方，有可能进行错误的，猛烈的转弯，险些酿成车祸。让我感到悲哀的是，这视屏下有很多评论，大部分都在谩骂车主是傻逼：“这是车主自己的责任！” “Autopilot只能在车道上有明确的边界线的时候使用！”……&lt;/p&gt;&lt;p&gt;Elon Musk也在一次&lt;a href=&quot;https://www.youtube.com/watch?v=60-b09XsyqU&quot;&gt;采访&lt;/a&gt;中明确的告诉记者：“如果用户因为使用autopilot而导致了车祸，是用户自己的责任！”他反复地声明：“autopilot还处于beta版本……”&lt;/p&gt;&lt;p&gt;我对他的这些说法持不同的观点：&lt;/p&gt;&lt;p&gt;首先，Tesla根本就不应该把一个处于&quot;beta状态&quot;的功能，自动推送到所有车主的系统里面。实际上，像autopilot这种关系到人的生命安全的功能，根本是不允许有所谓&quot;beta版本&quot;或者“测试版本”的。难道有人愿意拿自己的生命给Tesla做实验吗？Tesla把这样不成熟的系统，强制推送给用户，然后又说如果出了事故，用户负所有责任，是一种不负责任的做法。&lt;/p&gt;&lt;p&gt;另外，就算是用户没有仔细阅读autopilot的使用说明，在“不该”用它的地方（比如高速公路出口弯道）使用了autopilot，如果出了车祸，Tesla也应该负全责。理由如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;作为用户，他们没有义务阅读并且深刻的理解autopilot的局限性。在软件行业，存在一种习惯性的“责备用户”的伎俩。如果软件设计有问题，用户没记住这软件的毛病，以至于出了问题，一般被认为是用户的错。Tesla想把软件行业的这种不正之风引入到汽车行业，那显然是行不通的。&lt;/p&gt;

&lt;p&gt;Telsa的autopilot局限实在太多：天气不好的时候不行，路面上的边界线不清晰也不行，…… 作为一个用户，他们不可能，也不应该记住所有这些能使用autopilot的条件。他们也许没有足够的能力来判断这些条件是否成立：路上的线还在，但是被磨损得很浅了，到底autopilot能不能用呢？我不知道！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户也许没有足够的时间来响应条件的改变。由于autopilot自动驾驶，汽车有可能开头行驶在它可以应付的条件下（天气好，路面线条清晰），然而随着行驶，路面和天气条件有可能会变化。比如路面线条也许不再清晰，也许下起雨来使得autopilot不再看得清路面。这种条件的变化也许是突如其来，驾驶员没有料到的。等他们反应过来，想关闭autopilot的时候，车祸也许就已经发生了。在这种情况下，如果上诉到法庭，我想稍微明理一点的法官，都应该判Tesla败诉。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于意识到这个问题，Tesla最近又通过强制的软件更新，对autopilot的功能进行了&lt;a href=&quot;http://www.reuters.com/article/us-tesla-autopilot-idUSKCN0UO0NM20160110&quot;&gt;限制&lt;/a&gt;，说是为了防止用户用autopilot做一些“疯狂”的事情。在我看来，这不是用户疯狂，而是Tesla很疯狂 :)&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">tesla-autopilot</guid>
<pubDate>Sun, 10 Jan 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>给Las Vegas的差评</title>
<link>http://yinwang.org/blog-cn/2016/01/04/las-vegas</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;给Las Vegas的差评&lt;/h2&gt;&lt;p&gt;新年的旅行，大部分是浪漫而快乐的，然而也有不如人意的一两天。这一两天的不如意，来自于一个错误的，类似“朝圣”的理念：要去赌城Las Vegas看看，人生才算完整。其实本来没什么兴趣的，但因为一路开车观光，欣赏风景和美食，走得比较近了，就想顺路去Vegas看看也无妨，不看也许会后悔。哪知道这一失足，差点毁了整个旅行的心情。旅程完成之后，我只有一个遗憾——我希望自己没去过Vegas这鬼地方。&lt;/p&gt;&lt;p&gt;不知道为什么，Vegas仿佛是很多中国人在美国旅游，必去的一个“胜地”。对于在国内从没见过赌场的人，它充满了神秘。对于在美国的各种小村子里面（比如大学啊，硅谷啊）待久了，无聊了，想去“城里逛逛”的中国人，它充满了魅力。电视上总是看到这里灯红酒绿，街上熙熙攘攘的人群，club里激情洋溢的艳影，疯狂的party，各种“有名”的show，遍地散发漂亮小姐的广告，甚至还可以去赌场里感受一下……&lt;/p&gt;&lt;p&gt;然而真的到了Vegas，却发现那些朦胧的幻想，被扫得一干二净。如果你来Vegas的目的不是赌钱，那么你多半会失望的。如果你来了却没失望，那你的脑子恐怕患了某种神奇的疾病 :)&lt;/p&gt;&lt;p&gt;下面我就把自己对Vegas的感受简要说一下。&lt;/p&gt;&lt;h3&gt;自然环境恶劣&lt;/h3&gt;&lt;p&gt;Vegas真的是在沙漠里。去Vegas的路，从沙漠中间穿过。风呼呼的吹呀，如果不好好扶稳方向盘，恐怕车子就会被风吹到路边去。Vegas的冬天又冷又干，本来鲜活的一个人，到了Vegas，整个人都不好了。夜里相对湿度低于20%，到的当天晚上就舌头干，喉咙干，鼻子干，咳嗽不止，嘴唇干裂疼痛，各种不爽……&lt;/p&gt;&lt;p&gt;然而再恶劣的自然条件，都不能跟恶劣的人心相比。Vegas最让人厌恶的，其实是这里的人。&lt;/p&gt;&lt;h3&gt;服务人员素质低下&lt;/h3&gt;&lt;p&gt;我评价一个地方的生活质量，最重要的指标，在于它的服务业人员是否对所有人发自心底的友好，而不只是对有钱人点头哈腰。在我看来，Vegas是一个虚伪势利，对人极其不友好的城市。它就像一只哈巴狗，只对又有钱又傻的人摇尾巴。当然它摇尾巴的目的，不过是想从这些傻人身上榨取最大的利润。&lt;/p&gt;&lt;p&gt;酒店里西装革履的招待员，对你貌似彬彬有礼，可是眼神对视的时候，你却能感觉到他们高冷的气势。那笑容不是发自心底的，你看得到他们内心的傲慢，居高临下的态度，甚至歧视。这些服务人员，仿佛随时在上下打量你是什么人种，穿的衣服是否名牌，口袋里是否有钱可以拿出来。当你来的时候，你感觉她的眼睛不是在说“欢迎你来到Vegas！”，而是在说：“OK，我们开恩让你住这里了，好自为之吧！”当你走的时候，他的眼睛打量一下你，仿佛在说：“就这样？没赌钱就走人了？”&lt;/p&gt;&lt;p&gt;态度生硬的酒店服务员还算是好点的了，商店和饭店里，服务人员态度恶劣露骨的，实在多的去了。那态度，仿佛你花了高价，反倒是来跟他们要饭的一样。在Vegas，我算是开了眼界了，这是我一生中见过服务态度最差的地方。我可以说，Vegas 60%以上的服务人员，素质低下，态度恶劣和虚假，对人冷眼相对，非常没有礼貌。这里面感觉到的委屈和歧视，真是不忍回首，一天要被各种各样的服务人员坏好几次心情。&lt;/p&gt;&lt;h3&gt;吃的东西很难找，排长队&lt;/h3&gt;&lt;p&gt;Vegas的餐厅非常少，质量非常低。在街上走老半天也看不到什么吃的东西。每次走进看似商场的地方，清一色的奢侈品：LV，GUCCI，…… 然后就进到赌场了。恁是看不到吃的东西！&lt;/p&gt;&lt;p&gt;好不容易看到点吃的，大家排着长队，服务态度还非常差。跟纽约，三藩，洛杉矶不一样，Vegas似乎没有任何本地人开的，受好评的餐厅。可以吃的东西，基本上都是在别的地方都有的连锁店快餐。&lt;/p&gt;&lt;p&gt;去吃排名Top 10的“Vegas自助餐”，付了不菲的价钱，排了两个小时，拐了5道弯的长队。店员像学校食堂大妈一样满脸的鄙夷，吆喝着叫你进去，像是赏给你吃的。最后吃到的东西还不如公司的免费午餐，进餐环境还不如嘲杂拥挤的广东dimsum店。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/buffet.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;这现象恐怕只有在Vegas才能遇到。按照普通的标准，排队一小时的餐厅，必然非常好。排队两个小时的餐厅，一定要超级好才行。洛杉矶最好的韩国烧烤，才有可能在过年的时候排两小时的队。在Vegas，这套标准行不通了！而且这些buffet被设计来，在排队的时候，你没法看到里面的食物。等你等了几个小时排到了，进去才发现是那样的质量，后悔已经来不及了。&lt;/p&gt;&lt;p&gt;所有价格合理一点的地方，全都排长队，这包括各种有名的“Vegas自助餐”，Outback Steakhouse, Cheesecake Factory一类的连锁店。Vegas的自助餐名气大，质量差。不要以为排长队，价钱高就是好东西，因为大家到处找不到吃的，只好排长队吃自助了，吃的竟是一些残羹冷炙，连新鲜水果都没有，还不如别的地方的China Buffet。&lt;/p&gt;&lt;p&gt;当然，如果你肯花大价钱去吃某轮胎公司给评了级的餐厅，巨大的盘子里放一勺子东西那种，就另当别论了。反正我是不会给这种谋暴利的人送钱去的，又不想排长队，所以最后发现只有Panda Express和Chipotle之类的快餐可以吃了。如果这些地方都关门了，那就只有到Walgreens里面买块三明治了。如果怕冷不想去Walgreens，那就在房间里吃泡面吧。哦对了，我告诉过你，Vegas的酒店房间里是没有咖啡机的吧？所以也没有开水给你泡面了。&lt;/p&gt;&lt;p&gt;吃的东西质量是如此的差，队是如此的长，以至于M&amp;amp;M&#39;s和Hershey&#39;s这些摆在超市里都没人买的巧克力品牌，居然都可以在大街上开店。各个Starbucks和Walgreens也经常排长队，因为游客找不到吃的，所以跑到这些地方来买三明治和面包当晚餐了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/m-and-m.jpg&quot; width=&quot;40%&quot;&gt;&lt;/p&gt;&lt;p&gt;在Vegas，我第一次遇到Starbucks的店员，为了15美元之小的买卖，要求我出示身份ID，还“指导”我在收据上签字，显示出一副“你会用信用卡吗？”的神色。由于我的信用记录和可靠性极好，从来没丢过信用卡，在其它城市的类似Starbucks的大店，我刷卡是根本不需要签字的，更不要说出示ID了。刷了卡收据也不要，就去等咖啡了，利索得很。一般说来，贫穷地区的小店里使用信用卡，店员要求出示身份ID的几率要大一些，因为如果是被盗的信用卡，他们赔不起。现在这居然发生在了Vegas大街上的Starbucks。这绚丽的霓虹灯之下，到底是什么穷地方，破地方啊，我真的很无语。&lt;/p&gt;&lt;p&gt;Sigh，来到Vegas就意味着营养不良，外带各种心酸……&lt;/p&gt;&lt;h3&gt;想钱想疯了&lt;/h3&gt;&lt;p&gt;到了Vegas，你不是被当成一个人，而是被当成了用来宰割的牛羊。你感觉各种服务设施，不仅是在骗钱，而且是在抢钱。天然条件恶劣的地方，人们一般都特别友好和温暖，乐于助人，然而Vegas是一个例外。它不但是自然界的沙漠，而且是人性的沙漠。你自己要到这沙漠里来，那么所有东西我们都要卖高价，因为你不得不买！&lt;/p&gt;&lt;p&gt;从酒店，商场，到外面的饭店，交通工具，各种show，人们都想给垃圾标上大价钱，不是让虚荣心驱使你去买，就是让“求生”的欲望逼你去买。我是一个不吝惜钱的人，我用的东西都是高质量的。我愿意出大价钱买东西，然而我要求它必须值那个钱，我要求的是优质的产品和服务。Vegas的几乎所有东西都很贵，然而花了钱，你却买不到相应质量的产品和服务。&lt;/p&gt;&lt;p&gt;看似高档的四星级酒店，房间里连咖啡机这么基本的设施都没有。我走遍美国这么多的地方：纽约，波士顿，奥兰多，迈阿密，旧金山，西雅图，夏威夷…… 高中低档的酒店都住过，这是唯一一个没有咖啡机的酒店。连最便宜的Motel，全都有咖啡机。夏威夷海边的高档resort，有咖啡机。唯独Vegas的四星级酒店没有。咖啡机是一个重要的东西，不是因为它可以做咖啡，而是因为它可以用来烧热水。Vegas的自来水，喝起来味道很不好，貌似水质很硬。晚上又冷又干，却只能去售货机买$3一瓶的冷冻瓶装水，喝得直打哆嗦。因为气候实在太干，不一会儿又渴了……&lt;/p&gt;&lt;p&gt;收了每天$30的所谓“Resort Fee”，几乎跟夏威夷设施完善的resort一个价，却没见到酒店为此提供了什么服务。去游泳池泡泡居然还要按天收费，每人每天$17。房间里缺少本来该有的设施，是为了逼迫你到外面去花钱。饿了出去找不到吃的，点个汉堡到房间，20美元！起床稍微晚了一点，回到酒店，发现房间都没有打扫，毛巾都没有换！&lt;/p&gt;&lt;p&gt;路上堵得一塌糊涂，开车还不如走路快。没有通畅的公交工具，只有一个叫“monorail”的架空单轨电车，可以载你经过少于2英里的路程。这个monorail的车子，也不知是哪个城市淘汰的产品，开起来摇摇晃晃，嘎吱的响，仿佛要从半空中掉下去似的。短短不到2英里的路程，单程票价是$5。比较一下，其它城市好几十英里的地铁，也只收$2。&lt;/p&gt;&lt;p&gt;本来这种架空电车应该是用来观光的，然而如此的高价之下，车身窗户上还遮上障眼的纱网，印上巨幅的广告，导致车内光线暗淡，没法畅快的看到外面的风景，像是在坐囚车。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/vegas-monorail.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;&lt;p&gt;作为这个交通工具的消费者，付了高价却不受尊重，被剥夺了一览窗外景物的基本权利。现在世界上的东西，一般是免费的靠广告赚钱，收费的就不会在上面打广告。可是Vegas的monorail既要收高额票价，又要里外打上广告，妨碍视线，真是什么钱都赚。谁叫你没有别的交通工具可以用呢？&lt;/p&gt;&lt;h3&gt;赌场，赌场，还是赌场&lt;/h3&gt;&lt;p&gt;本来对赌场没有什么反感的，觉得小赌娱乐一下也无妨。到了Vegas，却真的对赌场产生了严重的反感。&lt;/p&gt;&lt;p&gt;在Vegas，你被完全剥夺了回避赌场的权利，你无法不经过赌场而到达任何地方。不管多么高大上的酒店，要进到房间，必须走过狭长的赌场过道。要去坐monorail？必须穿过赌场。要买吃的，喝的，穿的？必须穿过赌场。要买show的票？必须穿过赌场。&lt;/p&gt;&lt;p&gt;赌场里空气很不好，充满了烟味，二氧化碳严重超标，氧气不足，所以一进去就觉得胸闷，呼吸不畅，嗓子发痒，甚至头晕目眩。想想吧，你支付着高昂的酒店费用，却被剥夺了直接进入自己房间，而不呼吸污浊空气的基本权利。在这种情况下，本来想小赌一把的我，就打消了这个念头。&lt;/p&gt;&lt;p&gt;到了房间，整装出门逛街。回到酒店，却又不知道客房电梯在哪个旮旯里了。看路牌说“Guest Elevator走这边”，走到一半，发现还是没看见电梯，却没了路牌。不得不找赌场工作人员问（当然，他们态度也不怎么好），才找到回房间的电梯。每一次进酒店，都要经过这么一番摸索折腾，累不累，烦不烦呀。&lt;/p&gt;&lt;p&gt;有些酒店里有看show的剧场，你找到了剧场，却发现剧场旁边找不到售票处（box office）。你需要穿过赌场，跑到另外一边，才能找到box office。如果你用了ticket master之类的服务，还会发现ticket master的取票机不在剧场旁边，也不在box office旁边，而是在赌场的不知道哪个旮旯里……&lt;/p&gt;&lt;p&gt;这其实是赌场老板故意针对人的心理设计的。Vegas的酒店，几个重要设计原则就是：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计一定要没有组织，没有逻辑，让人摸不着头脑，容易迷路。这可以最大限度的迫使人接收到赌场的诱惑。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;迫使你必须经过赌场的诱惑，才能回到自己的房间。途中还会听到一些人歇斯底里的叫声：“哇！赢钱啦！”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;赌场里换气设施故意不做好。这样空气里氧气含量低，二氧化碳和烟味重，可以使人在赌钱的时候头脑不清醒，不能有效地控制自己的行为，以至于输了钱还不赶快撤退。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样的设计，使得你不得不经受很大的诱惑，或许有些人本来不赌钱的，就开始赌，最后输得精光。说真的，你把空气弄好一点，也许我还真的上钩了，可惜就是空气太差，再大的赚钱诱惑对我来说也是白搭。遇到我这么珍惜自己的生命和健康的人，算你们倒霉 :P&lt;/p&gt;&lt;h3&gt;丑陋的Vegas人&lt;/h3&gt;&lt;p&gt;Vegas路上走着的人，除了少数游客，大多穿着老气过时，粗人酒鬼模样。很少看到打扮有格调，有教养的人。不然就是怒目相向，不然就是鬼鬼祟祟的神情。&lt;/p&gt;&lt;p&gt;Vegas是妓女合法化的地方，在这里找小姐是“规范”的，合法的。所以你就可以在大街上看到一些车，打着穿着暴露的美女照片和电话号码，招摇过市。路边也站着很多散发美女小卡片的丑陋男人。&lt;/p&gt;&lt;p&gt;不要被那些靓丽性感的照片迷惑了。请看看大街上的妹纸们，有看得过去的吗？土爆了！如果大街上都没有好看点的妹纸，你觉得花了大价钱就会有漂亮妹纸陪你睡觉吗？你做梦吧。&lt;/p&gt;&lt;p&gt;早就有人报道过说，在Vegas找小姐，是按“项目”收费的。给你一个类似涮涮锅点菜的单子，打几个勾，加起来随便就两三千美元。结果到时候看人，各种穷形尽相的大妈，倒贴钱都没人要的。&lt;/p&gt;&lt;p&gt;所以Vegas的小姐跟其他东西一样，垃圾卖大价钱。所以欲求不满的中国同学们，还是把钱省着回咋们东莞用吧 :P&lt;/p&gt;&lt;p&gt;……还好，我自带了可人的美女来，发小广告的小混混们看到，就自惭形秽的躲开了 :)&lt;/p&gt;&lt;h3&gt;退休明星的舞台&lt;/h3&gt;&lt;p&gt;Vegas最著名的另一个地方，就是它的各种show。Topless的Jubilee show，太阳马戏团的O show和其它，大卫科波菲尔魔术，Elton John演唱会，最近Britney Spears也开始在这里演出。这貌似一个文化丰富的地方？&lt;/p&gt;&lt;p&gt;可是你有没有发现，这些常驻Vegas演show的，其实都不再是当红的明星？你有多少年没看过马戏表演了？你有十几年没见过大卫科波菲尔，Elton John，Britney Spears这些人了吧？能亲眼见到这些儿时崇拜的明星，是不是很激动呢？可惜，他们已经不再是当年的，英俊美丽的，身材不变形，唱歌不走调的他们了。&lt;/p&gt;&lt;p&gt;花了上百的票价，看到的竟是一些人老珠黄。特别是Britney Spears，大街上放着她的广告，各种SM的场景，感觉跟Vegas跳脱衣舞的大妈们差不多了。有一个理论是，当一个明星开始在Vegas常驻现场演出，而不是在电视里面出现的时候，你就知道他已经没落了。&lt;/p&gt;&lt;p&gt;在Vegas，你还会惊讶的发现，多年没在电视上见过的“吉尼斯世界纪录”之类的无聊东西，在街上开店卖票…… 不过呢说真的，那个topless的Jubilee show还真是不错的，属于Vegas比较有特色，有质量的一个show。虽然是topless两点暴露，却一点不感觉色情。还是有点舞台效果和艺术价值的。&lt;/p&gt;&lt;h3&gt;人造风景名胜&lt;/h3&gt;&lt;p&gt;越是文化匮乏的地方越是喜欢附庸风雅。Vegas的酒店，喜欢人造一些“迷你版”的欧洲名胜。比如有个叫Paris的酒店门口，造了一个小型的埃菲尔铁塔…… 等等。这些所谓的名胜，让Vegas成为了一个类似国内“世界乐园”的地方。这些东西材料也不怎么好，所以看上去各种cheap。Caesar Palace门口那雕像，石料肯定不好，不然不会看起来那么脏那么旧。&lt;/p&gt;&lt;p&gt;很多人在这些假的名胜旁边合影留念，让人哭笑不得，仿佛他们从来没见过好的风景。这些人完全不明白旅行的意义是什么，他们照相的目的在于表示自己“到此一游”。在某个酒店里的大厅，我看到大群的人们，对着一些假花和三流水准的圣诞装饰物照相，真是让人匪夷所思。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/photographing.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;&lt;h3&gt;休闲设施匮乏&lt;/h3&gt;&lt;p&gt;Vegas的大街上，Mall里面，很少看到有椅子可以坐。少数人坐在喷水池边上，很冷，其它人都在走路或者站着。你感觉在Vegas最深刻的记忆，就是在不停地走路。这种休闲设施的缺乏，使得Vegas不适合作为休闲旅游的去处。&lt;/p&gt;&lt;p&gt;唯一不缺座位，不需要排队的地方，就是赌场。&lt;/p&gt;&lt;h3&gt;总结&lt;/h3&gt;&lt;p&gt;我怀着一个“朝圣”的心，结果自己颠覆了Vegas，这座很多中国人心目中的“旅游胜地”。如果你是为了赌钱来到Vegas，你也许会喜欢它，然而它绝对不是一个休闲度假的好去处。如果你希望见到热情好客的人民，温馨周到的服务，你一定是会失望的。&lt;/p&gt;&lt;p&gt;如果说去Vegas旅行有它的价值的话，那就是它给了我一个反面的教材，一场心灵的洗礼。我亲眼看见并且经历了人类文明最没落地方。我清楚地知道，我不希望我的国家，我的人民变成那个样子。我不再对赌场之类的“成人游戏”有好奇心，我更加珍惜自己身边美好的人和事物。这是我第一次，也是最后一次，来Las Vegas旅行。我想它还是值得的。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">las-vegas</guid>
<pubDate>Mon, 04 Jan 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>写书计划</title>
<link>http://yinwang.org/blog-cn/2015/12/19/book-plan</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;写书计划&lt;/h2&gt;&lt;p&gt;好些人问过我写书的事情。我确实该写本书了。计算机科学，其实根本不是科学，它缺乏基本的科学精神。计算机“科学”里面的少量真知灼见，已经被大量的商业动机和“天才语录”给淹没。这个领域的所谓“知识”，其实90%以上都是扯淡，或者是死板的教条和本本主义。剩下不到10%，却是非常好的东西。&lt;/p&gt;&lt;p&gt;这种瞎蒙混骗的风气，从&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/10/18/turing&quot;&gt;图灵&lt;/a&gt;那一辈就开始了，以至于好的东西和不好的东西，永远的混在了一起，没法区分开来。你可以提出一个完全没用的理论，却仍然有人相信它是伟大的发明，并且拿到图灵奖。很多经典的书籍，其实让人知其然而不知其所以然，很多甚至把简单的问题复杂化。因为它们的目的，其实在于掩盖真相，传播谬论，让人恐惧和糊涂，以至于人们以为计算机科学博大精深，有无穷无尽的东西要学。&lt;/p&gt;&lt;p&gt;我希望能够改变这个格局。上次写的《&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy/&quot;&gt;编程的智慧&lt;/a&gt;》，其实就是这样一本书的开端。这其中的内容，真不是拿一个名校的CS PhD，当个教授或者Principle Engineer，甚至Chief Architect就能搞清楚的。之所以叫做“开端”，是因为它还没有达到我希望的组织和清晰程度。这样的内容以blog的形式出现，已经显示出它的弊端了。Blog组织内容的方式是按时间，blog的单元是文章。由于我希望写出的内容，有效性是接近“永恒”，而且由于内容比较多，需要多层的目录，逻辑组织上blog也无法应付。所以我必须用书的形式写出来。&lt;/p&gt;&lt;p&gt;写这样一本书，不是什么大不了的事情，然而它对于混沌不堪的计算机科学界，恐怕具有转折性的意义，所以我必须使用一种世界上大部分人都能看懂的语言。那种语言在现在看来就是英语。我会把这本书的初稿放在网络上，供人们免费下载阅读，这样他们可以给我有益的反馈，提醒我谬误和不清晰之处。这本书会覆盖计算机科学的方方面面，从程序语言，操作系统，到数据库，网络系统，……&lt;/p&gt;&lt;p&gt;有人可能以为这是一个可望而不可即的，包罗万象的宏伟目标，那只是因为他们没有看穿CS里面的迷雾。如果要面面俱到，照本宣科，把每个子领域的死知识都一股脑写进去，包括每种操作系统命令，每种语言的用法，每个数据库的API，各种乱七八糟的WEB技术，…… 那当然是一辈子也写不完的。然而如果你看透了这层迷雾，就会发现CS里面的精髓部分其实没有很多，它们完全是可以在短时间里掌握的。&lt;/p&gt;&lt;p&gt;所以这本书的定位，在于精髓和创造，而不是细节和死记硬背。我希望把它们共同的精髓提取出来，而去掉其中肤浅的死知识部分。如果你希望它教会你所有的东西，包括某最新语言新加入的特性，或者某最新big data工具的API，那显然是不可能的。有太多的书籍可以教会你那些东西，所以不用我来费工夫。然而我所介绍的精髓概念，应该可以帮助你设计和创造出这样的语言特性和大数据工具，而不只是成为一个被动的使用者。&lt;/p&gt;&lt;p&gt;在初期的时候，我会把书的内容放在网上，供大家免费阅读，提出宝贵意见。等到这本书达到我满意的程度之时，我也愿意让高水平的出版社，印成纸张出版。不过出版社的位置，应该处于“转载”的位置。免费下载的PDF，会一直得到更新和补充。只有这样不断地改进，这本书才能达到我满意的地步。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">book-plan</guid>
<pubDate>Sat, 19 Dec 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>Tesla Model S的设计失误</title>
<link>http://yinwang.org/blog-cn/2015/12/12/tesla-model-s</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;Tesla Model S的设计失误&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-interior.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;这幅美丽的图片，就是红极一时的Tesla电动车Model S的内景。然而你有没有发现，其中有一些不大对劲的地方？虽然我看好电动汽车，它们环保，安静，运动敏捷，然而我发现Tesla的这款Model S，其实有一些严重的设计失误。&lt;/p&gt;&lt;h3&gt;缺少硬件开关，过度依赖软件和触摸屏&lt;/h3&gt;&lt;p&gt;纵观Model S的内景，你会发现这车里面怎么光溜溜的，就没看到几个按钮。确实如此，Model S内部设施的控制，基本上完全靠中间那个很大的触摸屏。&lt;/p&gt;&lt;p&gt;顶棚上有一个天窗，却没看见天窗的开关。通常说来，当人们看见门或者窗户，他们期望有一个开关，设在旁边顺手的地方。然而你在Model S里面一抬头，却看不见任何可以按下或者掰动的开关。顶棚上面几乎是光溜溜的一片：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-sunroof.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;有些人可能觉得这样的设计，比其它车子更加美观，简洁。然而你可能没想到，这种“美观”其实是有代价的。一个很简单的问题是：你怎么打开天窗？答案：你必须使用触摸屏！&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-screen.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;你要在触摸屏上找到一个叫“Controls”的页面，然后从左边的控制栏选择“Sunroof”，然后在右边会出现一个车子的图片，和一个滚动条。你把滚动条往下拉，天窗就打开了……&lt;/p&gt;&lt;h3&gt;把简单的问题复杂化&lt;/h3&gt;&lt;p&gt;然而这种依赖于触摸屏的设计，其实是让简单的问题变复杂，变麻烦了。其它车的天窗开关都是很明显，不需要“找”的，而Tesla的天窗开关，你要找一会儿，甚至找到了还要琢磨一下，才会知道该怎么用。我现在把导致这种结果的原因，详细分析如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;天窗控制器不在天窗旁边。触摸屏跟天窗，处于风马不及的位置。这违反了一条基本的设计原理：控制器应该很容易找到，最好在它所控制的东西上面或者旁边。如果用户想打开天窗，他应该能够在天窗旁边，找到一个明显是用来打开它的开关。几乎所有其它车子，天窗开关都在顶棚上，不知Model S的设计者，为何要抛弃这种久经考验的设计。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;触摸屏上干扰信息太多，不容易找到正确的按钮。触摸屏太大，上面显示着所有控制器的信息。这些控制器的位置，本来可以分布在车的各个部位，现在却集中到了一个仅十几寸的屏幕上面。这当然显示不下，只有放到好几个菜单里面去。&lt;/p&gt;

&lt;p&gt;这些“软件控件”的位置，也不是很符合逻辑。例如，为什么有些控件（比如天窗）在tab里面藏着，而另外有些（比如门锁）直接露在外面？以至于你一眼看去，会不知所措。&lt;/p&gt;

&lt;p&gt;相比之下，大部分其它车的硬件天窗控制器，附近没有很多干扰信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/mercedes-sunroof-control.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个控制器在顶棚上，而且处于控制板的中央位置。旁边只有几个顶灯的开关。这些开关，对应着灯在顶棚上的位置。后面的灯，控制器在后面；前面的灯，控制器在前面；左边的灯，控制器在左边；右边的灯，控制器在右边……&lt;/p&gt;

&lt;p&gt;这种排列方式，在设计学上叫做“自然映射”（natural mapping）。你不需要多次的摸索和记忆，甚至不需要看开关上的标记。只根据开关的相对位置，你就知道哪一个开关控制哪一盏灯。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查找天窗控制器的“逻辑路径”太深。从最开头的触摸屏界面，直到找到打开天窗的控件，你需要进入至少两层菜单。如果菜单之前停留在另外的状态，你还需要点击某个按钮，回到“主界面”，然后还要从上往下进入两级菜单。这种设计所需要的“逻辑路径”，长度&amp;gt;=3。&lt;/p&gt;

&lt;p&gt;这种多层的“间接访问”，很容易把人搞糊涂。对年纪大点的人，几乎是不可用的。就算是年轻人，恐怕也需要摸索一阵子。如果在紧急情况下，或者事先没熟悉过这车的情况下，需要找到控制器（比如通过天窗逃生），恐怕会不知所措。&lt;/p&gt;

&lt;p&gt;比较一下其它车子的设计吧。其它牌子车的顶棚上，一般有一个比较大的，明显是用来打开天窗的开关。不管车子当时处于什么状态，直接伸手就可以摸到这个开关。这种设计所需要的“逻辑路径”，长度=1，也就是说是直接的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;触屏的界面并不直观。仔细观察触屏上的控件，它们的操作方式并不是那么直观的。看到那个滚动条一样的东西，我该是点击呢，还是拖动呢？“VENT”，“OPEN”那几个字的位置，到底表示什么呢？我如何让天窗向上倾斜通风（tilt）？真是有点莫名其妙的感觉，恐怕要看说明书，摸索一会儿才能知道这到底怎么用。&lt;/p&gt;

&lt;p&gt;相比之下，其它牌子汽车的硬件开关的设计，其实非常的直观。开关向后一拉，天窗就打开。向前一推，天窗就关闭。有些车子的天窗可以向上倾斜一定的角度（tilt），所以你可以把这按钮向上一推，天窗就进入倾斜通风的状态。&lt;/p&gt;

&lt;p&gt;这种硬件开关的设计，符合了“自然映射”的原理。天窗的开关，成为了天窗的一个“模型”（model）。开关的位置，正好跟天窗平行。开关的运动方式，跟天窗的运动方式，产生一种“自然”的对应关系。开关向后，天窗也向后。开关向前，天窗也向前。开关被向上推，天窗也向上倾斜。这是非常好的设计。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;触感，力反馈和行车安全&lt;/h3&gt;&lt;p&gt;触摸屏缺乏触感和“力反馈”，无法进行“盲操作”。由于触摸屏是平的，所以它无法提供触觉和力反馈。你无法光靠手就摸到按钮的位置，而必须用眼睛看屏幕。当你找到并且拖动屏幕上的滚动条，你的手指不能得到任何力和振动的反馈。你不能立即感觉到，是否已经真的触发了“开天窗”这个操作。只有当天窗开始移动，你才知道刚才的操作是否成功。&lt;/p&gt;&lt;p&gt;相比之下，硬件天窗开关具有很大的优势。有些车子的天窗开关，设计得符合人体工学，正好符合你的手指的形状。摸起来容易，掰起来舒服，有感觉。手往上一摸，就能找到天窗控制器，之后不用眼睛就能操作。&lt;/p&gt;&lt;p&gt;像天窗开关这种“盲操作”，在开车的时候特别重要，因为开车时你的眼睛应该随时注视前方的道路。如果眼睛开小差去看屏幕了，就可能出车祸。这就跟开车时用手机发短信一样危险。触摸屏看起来很酷，而其实是降低了汽车的安全性。&lt;/p&gt;&lt;h3&gt;系统可靠性：触摸屏是“中央薄弱环节”&lt;/h3&gt;&lt;p&gt;仔细观察一下Model S，你会发现它的内部几乎没有硬件的开关。几乎所有的设施：天窗，空调气孔，窗户，门，后备箱，充电盖，…… 全都是用这个触摸屏来控制。&lt;/p&gt;&lt;p&gt;从系统设计的角度来看，这个触摸屏就是一个“中央薄弱环节”（single point of failure）。只要触摸屏一出问题，你就会失去对几乎所有设施的控制。根据这篇&lt;a href=&quot;http://www.autonews.com/article/20140811/OEM06/140819992/tesla-model-s-has-more-than-its-share-of-problems-consumer-reports&quot;&gt;文章&lt;/a&gt;，有的Tesla用户报告说，他的Model S在12000英里的时候，触摸屏突然坏掉，以至于门把都没法用了！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Just before the car went in for its annual service, at a little over 12,000 miles, the center screen went blank, eliminating access to just about every function of the car…&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;相比之下，其它汽车的硬件开关位置是分散的，它们的电路逻辑是相对独立的。一个开关坏掉了，另外一个还可以用。其它车子的屏幕，一般只用来显示倒车摄像信息，以及音乐娱乐等无关紧要的东西。Tesla用这个屏幕来控制所有的配件，真的是发挥过度了。&lt;/p&gt;&lt;h3&gt;门把的设计问题&lt;/h3&gt;&lt;p&gt;Model S的门把设计也有问题。它的门把是电动的，而其它车的门把，都是机械的。在停止的状态，Model S的门把会自动缩回去，不露一点缝隙：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-door-handle-down.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;当你接近车子的时候，内部的电机会让门把伸出来，这样你就能拉开车门：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-door-handle-up.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;按照Tesla设计师的&lt;a href=&quot;http://www.carbodydesign.com/2013/11/tesla-chief-designer-creating-a-car-from-the-ground-up&quot;&gt;思路&lt;/a&gt;：“第一次接近这部车的时候，你首先接触到的是门把：这应该是一个印象深刻的经历。在你走近的同时，门把也伸出来——就好像是这车子想起了你……”&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;As you approach the car for the first time, the first contact you have with the vehicle is through the door handle: it needs to be a memorable experience […] The idea of this door handles that protrudes from the car as you approach it – [it’s like] the car is already thinking for you.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;多么诗情画意的场景，一部会想起你的车，一个朋友！可惜这美好的第一印象，是经不起现实考验的。等你买下这车，实际用起来的时候，问题就来了。首先，这个门把被人手抓握的部分，是扁平的形状。这种形状非常的不符合人体工学，捏起来会很不舒服，使不上劲。如果车门被冰冻住，或者门被撞变形了，或者有紧急情况需要很快的开门，这门把就会带来很大的麻烦，甚至可能是很危险的。&lt;/p&gt;&lt;p&gt;另外，在寒冷的地区，车停在外面，缩进去的门把会被冰冻住。等你要开门的时候，才发现门把被冻住了，出不来。如果软件出了故障，也可能导致门把出不来。一旦出了这些事情，你就完全失去了打开车门的能力。如果门把是机械的，就算上面有一点冰，一拉把手，冰就碎掉，门就开了。如果实在冻得严重了，你把冰稍微凿一下，一拉就开。Tesla的设计者，貌似完全没考虑过这些“意外”的情况。&lt;/p&gt;&lt;p&gt;没有任何其它牌子的汽车采用像这样的门把设计。从丰田一直到&lt;a href=&quot;http://www.bugatti.com&quot;&gt;Bugatti&lt;/a&gt;，它们的门把全都是机械的，粗壮的，直接就可以拉的。没人在这上面耍花样。你想这应该有原因的吧？由于人的生命安全，在事故的时候依赖于快速地打开车门，门把的设计需要是坚固而可靠的。&lt;/p&gt;&lt;p&gt;只有Tesla别出心裁，搞得门把完全缩进去，跟车门平齐，连个可以用力的地方都没有。门把和车门之间的缝隙很小，所以冻在里面的冰没法凿开。很多人发现这是个讨厌的问题。看看这篇&lt;a href=&quot;https://my.teslamotors.com/it_IT/forum/forums/those-door-handles&quot;&gt;讨论&lt;/a&gt;，你就会发现人们为了这个门把，费了多少脑筋，想出五花八门的解决方案：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;提前远程启动车子，让内部温度起来，化掉把手上的冰&lt;/li&gt;
&lt;li&gt;往门把上泼热水&lt;/li&gt;
&lt;li&gt;放热水袋放在门把上&lt;/li&gt;
&lt;li&gt;停车的时候在门把上贴一块透明胶，发现冻上了就把胶布撕掉&lt;/li&gt;
&lt;li&gt;用电吹风吹&lt;/li&gt;
&lt;li&gt;... ...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管这些方式可不可行，有没有效果，你都可以看到，这门把的设计，其实带来了不必要的麻烦。这样的设计，除了看起来很“未来”几乎没有任何实用价值。买了辆酷车，活得可真累。&lt;/p&gt;&lt;h3&gt;人体工学和舒适性问题&lt;/h3&gt;&lt;p&gt;另外，我发现Model S的触摸屏，其实在一个很不舒服的位置。如果我靠在司机的座位上，我的手是无法顺利地碰到屏幕右边的。我必须启用我的腹肌，稍微坐起来一点，努力伸出右手，才能够得着那个位置。&lt;/p&gt;&lt;p&gt;如果触摸屏的位置稍微往下放一点，倾斜度降低一些，就会方便很多。另外，这个触摸屏真的不需要做那么大。&lt;/p&gt;&lt;p&gt;另外一个奇葩的地方是，触摸屏下方，座位之间，有一片很低的，光溜溜的平面，像个微型的保龄球球道……&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-console.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;这貌似是用来放随身物品的。然而这个空间，由于位置和形状的问题，恐怕不会得到有效的利用。由于平台位置太低，几乎到了地板上，如果往里面放置物品，拿起来会非常的不顺手，甚至需要弯腰下去，而且恐怕会被不小心踢翻。因为整个平面是光滑的，中间也没有挡板，车子加减速时，东西可能会到处乱跑。从美学角度看，这个区域的边界，跟触摸屏线条错位，感觉不流畅，不美观。&lt;/p&gt;&lt;p&gt;另外有用户&lt;a href=&quot;https://my.teslamotors.com/it_CH/forum/forums/cup-holders-and-spilled-coffee&quot;&gt;反映&lt;/a&gt;，Model S的咖啡杯座，被设置在一个很容易被手肘碰翻的位置。某些Tesla的“专家用户”对此的建议是，去买“防溅”的咖啡杯。有些聪明人甚至自己设计，并且用3D打印机山寨了一个架子来放咖啡：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-3d-printed-cup-holder.png&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;我对此举动非常的无语。本来Tesla的设计师应该做好的东西，居然需要自己动手。很不可思议的是，这样不舒服的车，被叫做“豪华车”，价钱是其它牌子的两三倍……&lt;/p&gt;&lt;h3&gt;可靠性问题&lt;/h3&gt;&lt;p&gt;虽然这篇文章里面，我只想指出Model S的设计问题，它其实也有很多可靠性的问题。&lt;/p&gt;&lt;p&gt;最近的一些&lt;a href=&quot;http://jalopnik.com/report-two-thirds-of-early-tesla-model-s-drivetrains-m-1747222846&quot;&gt;报道&lt;/a&gt;指出，由于动力系统的问题，2/3以上的早期Model S，动力系统的寿命都不会超过6万英里。Consumer Reports也&lt;a href=&quot;http://www.consumerreports.org/cars/tesla-reliability-doesnt-match-its-high-performance&quot;&gt;报道&lt;/a&gt;，Model S的可靠性“低于平均水平”。报告指出，Model S存在各种质量问题：触摸屏崩溃，门把失灵，发动机故障，天窗漏水，各种部件嘎吱作响，等等。另外一篇Consumer Report的&lt;a href=&quot;http://www.roadandtrack.com/new-cars/car-technology/news/a27094/consumer-reports-tesla-model-s-not-recommended-on-reliability&quot;&gt;文章&lt;/a&gt;，对各种电动车的可靠性进行了排名，Model S名列倒数第一。&lt;/p&gt;&lt;h3&gt;安全性问题&lt;/h3&gt;&lt;p&gt;2016年1月1号，在挪威的一个Tesla充电站，有一台Model S在充电的时候，莫名其妙起火燃烧（见&lt;a href=&quot;http://www.extremetech.com/extreme/220237-tesla-model-s-catches-fire-at-supercharger-station-in-norway&quot;&gt;新闻&lt;/a&gt;和&lt;a href=&quot;https://www.youtube.com/watch?v=CWXN7ni4FTc&quot;&gt;视频&lt;/a&gt;）。由于着火的材料是锂金属，消防队无法用水控制火势，只能用泡沫覆盖隔离，等待锂材料燃烧完毕。最后这台车被完全烧毁，幸好没有人员伤亡。事故起因正在调查之中。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-burn.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;Elon Musk对此事故的反应比较让人失望，他说：“美国每年有上万辆汽车起火事故，没有人报道。为什么Tesla的车一起火，媒体就争相报道？” 不好好调查和检讨起火的原因，反倒笑别人“一百步”，这种态度是不可取的。&lt;/p&gt;&lt;p&gt;其实媒体报道Tesla车起火，是有他们的原因的。汽油车着火，一般都是因为有人犯了严重的错误，导致严重的车祸，油箱破裂，又遇上火源或者重击。而电动车起火，不需要有人犯错误，不需要有严重的车祸，莫名其妙就着火了。你有见过崭新的汽油车，在加油站加油，忽然自己着火吗？&lt;/p&gt;&lt;p&gt;这不是第一辆起火的Model S。世界上只有3万多辆Model S，却已经出现过3起这样的&lt;a href=&quot;https://www.youtube.com/watch?v=q0kjI08n4fg&quot;&gt;起火事件&lt;/a&gt;。之前的一个Model S，半路上底部被硬物撞击。屏幕提示说，电池出了问题，请停车并且撤离。幸好车主按照电脑的指示做了，结果撤离不久之后，车就开始燃烧。如果车主没有停车撤离，后果是相当可怕的。这种对生命危险缺乏明确警示信号，其实也是一种严重的设计问题。&lt;/p&gt;&lt;p&gt;汽车底部被硬物刮伤是常有的，从来没听说过这样挂一下就起火的。我觉得Model S的电池，平铺于车身底部，目标太大，是这种事故的起因之一。下图显示了Model S车内电池的位置：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-battery.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;&lt;p&gt;你可以看到，车的底盘几乎全部被电池覆盖。如果车底被硬物撞击，电池部分受冲击的概率会比较大。&lt;/p&gt;&lt;p&gt;Tesla在不久前通过“软件更新”，使Model S具有了初级的“自动驾驶”（autopilot）功能。这个功能可以让Model S自动地，沿着有明确边界线的车道行驶，根据前后车辆的速度相应的加速和减速。驾驶员在这种情况下可以放开方向盘，让车子的电脑系统自己驾驶。&lt;/p&gt;&lt;p&gt;这貌似一个很新很酷的功能，然而在推出不久之后，YouTube上就出现了一些视频，比如&lt;a href=&quot;https://www.youtube.com/watch?v=Lx3-epk_ztQ&quot;&gt;这个&lt;/a&gt;。它们显示，autopilot在高速公路出口弯道这类地方，有可能进行错误的，猛烈的转弯，险些酿成车祸。让我感到悲哀的是，这视屏下有很多评论，大部分都在谩骂车主是傻逼：“这是车主自己的责任！” “Autopilot只能在车道上有明确的边界线的时候使用！”……&lt;/p&gt;&lt;p&gt;Elon Musk也在一次&lt;a href=&quot;https://www.youtube.com/watch?v=60-b09XsyqU&quot;&gt;采访&lt;/a&gt;中明确的告诉记者：“如果用户因为使用autopilot而导致了车祸，是用户自己的责任！”他反复地声明：“autopilot还处于beta版本……”&lt;/p&gt;&lt;p&gt;我对他的这些说法持不同的观点：&lt;/p&gt;&lt;p&gt;首先，Tesla根本就不应该把一个处于&quot;beta状态&quot;的功能，自动推送到所有车主的系统里面。实际上，像autopilot这种关系到人的生命安全的功能，根本是不允许有所谓&quot;beta版本&quot;或者“测试版本”的。难道有人愿意拿自己的生命给Tesla做实验吗？Tesla把这样不成熟的系统，强制推送给用户，然后又说如果出了事故，用户负所有责任，是一种不负责任的做法。&lt;/p&gt;&lt;p&gt;另外，就算是用户没有仔细阅读autopilot的使用说明，在“不该”用它的地方（比如高速公路出口弯道）使用了autopilot，如果出了车祸，Tesla也应该负全责。理由如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;作为用户，他们没有义务阅读并且深刻的理解autopilot的局限性。在软件行业，存在一种习惯性的“责备用户”的伎俩。如果软件设计有问题，用户没记住这软件的毛病，以至于出了问题，一般被认为是用户的错。Tesla想把软件行业的这种不正之风引入到汽车行业，那显然是行不通的。&lt;/p&gt;

&lt;p&gt;Telsa的autopilot局限实在太多：天气不好的时候不行，路面上的边界线不清晰也不行，…… 作为一个用户，他们不可能，也不应该记住所有这些能使用autopilot的条件。他们也许没有足够的能力来判断这些条件是否成立：路上的线还在，但是被磨损得很浅了，到底autopilot能不能用呢？我不知道！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户也许没有足够的时间来响应条件的改变。由于autopilot自动驾驶，汽车有可能开头行驶在它可以应付的条件下（天气好，路面线条清晰），然而随着行驶，路面和天气条件有可能会变化。比如路面线条也许不再清晰，也许下起雨来使得autopilot不再看得清路面。这种条件的变化也许是突如其来，驾驶员没有料到的。等他们反应过来，想关闭autopilot的时候，车祸也许就已经发生了。在这种情况下，如果上诉到法庭，我想稍微明理一点的法官，都应该判Tesla败诉。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于意识到这个问题，Tesla最近又通过强制的软件更新，对autopilot的功能进行了&lt;a href=&quot;http://www.reuters.com/article/us-tesla-autopilot-idUSKCN0UO0NM20160110&quot;&gt;限制&lt;/a&gt;，说是为了防止用户用autopilot做一些“疯狂”的事情。在我看来，这不是用户疯狂，而是Tesla很疯狂 :)&lt;/p&gt;&lt;h3&gt;关于Model X&lt;/h3&gt;&lt;p&gt;Tesla即将推出的SUV（Model X），不但继承了以上提到的Model S的各种问题（触摸屏，门把，……），而且还制造了新的问题。Model X具有一个别出心裁的车门设计，这车子看起来像一只展翅的鸟：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-x-door.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;这样开的车门貌似更省空间，方便在狭窄的地方开门，而且看起来更酷，有点像McLaren或者Lamborghini。然而这样的设计，在我看来有以下几个问题：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开门的时候，车的后部暴露太多。在下雨或者下雪的时候，雨雪会乘着车门张开的时候飘到车里。门虽然貌似盖住了空隙，然而由于升起来的位置太高，所以其实留下很大的空挡。当有一点风，雨雪有一定角度的时候，就会大量飘进车里。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于门上的缝隙太长，这种设计更加容易出现由于密封圈老化而漏水的问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当车门升起来的时候，夹在门缝里的灰尘和渣滓会掉进车里。车顶上如果有积雪，也会掉进车里。设想一下吧，下雪天开了一会车，打开后门，然后车顶上的雪都掉进去了，是什么感觉……:P&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下大雪的时候，后面的车门可能被大雪压住打不开，或者导致电动机超负荷损坏。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在顶棚很低的车库里可能会碰到天花板。这是一个很现实的问题，因为很多车库旁边的空间很多，顶棚却很低。比如，这次我到洛杉矶和拉斯维加斯旅游，经常遇到这样的车库：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/garage-low-roof.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顶棚不再能安装货架。不知道滑雪板和kayak该绑在哪里。这降低了Model X作为一个SUV的使用价值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总的说来，在非常狭窄的地方开门，其实并不是什么很需要解决的事情。有钱买Model X的人，难道会经常把车停在狭窄的夹缝里吗？为了这种不常见的应用，用得着花这么大功夫设计个车门吗？就算你能开门，人出去之后挤不挤得出去，是另外一回事。如果地方实在太窄，你完全可以让后面的人先下车，然后再进车位。另外，滑动式的车门同样可以解决这个问题，根本用不着花大成本来实现升起来的车门。&lt;/p&gt;&lt;p&gt;如果你知道，Model X的车身宽度为81.6英寸，比Hummer H2, Cadillac Escalade和Ford F-150这样的庞然大物还要宽，你就会发现真正的问题不在于空间不够，而是在于这车实在太宽了。有多少人愿意开这么宽的车，是一个问题。&lt;/p&gt;&lt;h3&gt;对待设计的态度问题&lt;/h3&gt;&lt;p&gt;我发现Tesla的设计团队，在态度上有一些严重的问题。Tesla的总设计师Franz von Holzhausen，在一个&lt;a href=&quot;http://gigaom.com/2013/11/06/how-tesla-overcame-the-challenges-of-electric-car-design-from-the-ground-up&quot;&gt;采访&lt;/a&gt;中谈到，Tesla是如何在“完全没有汽车设计经验”的背景之下，“从零开始”（from ground up）设计出了Model S，好像是非常了不起的成就似的。这位设计师提到：“Tesla是从一张白纸（clean slate）开始，没有已有的思想可以借鉴……”&lt;/p&gt;&lt;p&gt;这其实是而夸大其词。世界上没有任何成功的设计，真的可以从所谓“白纸”开始的，你总是有前人的经验可以学习。不管是前人的成功还是失败，都有借鉴的意义。电动车比起汽油车，其实并不是一个全新的领域，它只不过是动力系统不一样而已。像门，窗，内饰，轮子，减震器，方向盘之类，里面的设计原理，其实都是一样的。&lt;/p&gt;&lt;p&gt;仅仅因为动力不一样，就对前人的经验视而不见，甚至盲目的藐视。这样的态度给用户带来的，是潜在的麻烦甚至危险。有些人喜欢把一个领域说成是全新的，往往是因为他们想“圈地”。所以Tesla的设计师其实是在说，电动车这个领域跟其它汽车公司的都不一样，所以你们都不用跟我竞争啦。同时这也可以让用户以为，只有Tesla才能做出电动车。&lt;/p&gt;&lt;p&gt;另外，我觉得人们对Elon Musk的个人崇拜，导致了很多人对Telsa的问题视而不见，盲目的以为Tesla是好车，豪华车，是最先进的技术。很多人盲目的相信Elon Musk，以为他是天才，他说的，他做的都是对的，而其实并不是这样。有传言说，Model S最早的设计，很多是Elon Musk自作聪明提出来的。后来其中特别不堪的一些，被设计师给去掉了。然而这种盲目“创新”的传统，却在Tesla遗留下来，并且利用媒体向全世界辐射，给大家洗脑。&lt;/p&gt;&lt;p&gt;Tesla标榜自己重视“设计”，其实却歪曲了“设计”这个词的含义。喜欢谈论所谓“用户体验”（User Experience），然而他们所谓的用户体验，只是浮于表面。真正的用户体验，应该是在实质上方便，可靠，舒服，易用。而Tesla所谓的用户体验，强调的是一些肤浅的，没有实质意义的方面，比如让门把自动伸出来，让你感觉它是你的朋友。&lt;/p&gt;&lt;p&gt;Elon Musk甚至在一次&lt;a href=&quot;http://www.cc.com/video-clips/o26y1r/the-colbert-report-elon-musk-pt--1&quot;&gt;采访&lt;/a&gt;中提到，你应该能够给你的车子起个名字，它应该就像你的宠物一样。由此可见，他关心的是什么 :) 说实话，真的有人在乎一个车的门把吗？我怎么觉得他的vision或者价值观有问题。花费很大工夫，试图让你在买车之前产生良好的第一印象，以至于不惜重金。结果买下来之后的日子里，你就发现它的各种毛病——连最便宜的车都没有的毛病。&lt;/p&gt;&lt;p&gt;汽车的设计，很多方面关系到人的生命安全。车上的各种设备，为什么是那个形状，为什么在那个位置，很多都是有理由的。不是你想它是个什么样子，就可以是什么样子的。很多这些经验甚至可能是用生命换来的，经历了战火和各种恶劣环境的考验。这真的不是一个新的公司短短几年就可以摸索清楚的。&lt;/p&gt;&lt;p&gt;有些设计貌似很新，很酷，很未来，像科幻电影里面的一样。直到你开始用它，才发现是有问题的。很多人把Elon Musk比作&lt;a href=&quot;http://www.imdb.com/title/tt0371746&quot;&gt;钢铁侠&lt;/a&gt;，然而他们没有意识到，科幻和现实是有很大区别的。Elon Musk的背景，也许可以做出高性能的电动机，然而一辆汽车除了发动机，还有很多关键的方面。忘记历史就等于毁灭未来，标新立异，不吸取前人的经验教训，把好的东西学过来，这样做设计是很难成功的。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">tesla-model-s</guid>
<pubDate>Sat, 12 Dec 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程的智慧</title>
<link>http://yinwang.org/blog-cn/2015/11/21/programming-philosophy</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;编程的智慧&lt;/h2&gt;&lt;p&gt;编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而由于软件行业喜欢标新立异，喜欢把简单的事情搞复杂，我希望这些文字能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。&lt;/p&gt;&lt;h3&gt;反复推敲代码&lt;/h3&gt;&lt;p&gt;既然“天才是百分之一的灵感，百分之九十九的汗水”，那我先来谈谈这汗水的部分吧。有人问我，提高编程水平最有效的办法是什么？我想了很久，终于发现最有效的办法，其实是反反复复地修改和推敲代码。&lt;/p&gt;&lt;p&gt;在IU的时候，由于Dan Friedman的严格教导，我们以写出冗长复杂的代码为耻。如果你代码多写了几行，这老顽童就会大笑，说：“当年我解决这个问题，只写了5行代码，你回去再想想吧……” 当然，有时候他只是夸张一下，故意刺激你的，其实没有人能只用5行代码完成。然而这种提炼代码，减少冗余的习惯，却由此深入了我的骨髓。&lt;/p&gt;&lt;p&gt;有些人喜欢炫耀自己写了多少多少万行的代码，仿佛代码的数量是衡量编程水平的标准。然而，如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。你会制造出越来越多平庸甚至糟糕的代码。在这种意义上，很多人所谓的“工作经验”，跟他代码的质量，其实不一定成正比。如果有几十年的工作经验，却从来不回头去提炼和反思自己的代码，那么他也许还不如一个只有一两年经验，却喜欢反复推敲，仔细领悟的人。&lt;/p&gt;&lt;p&gt;有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。&lt;/p&gt;&lt;p&gt;就像文学作品一样，代码是不可能一蹴而就的。灵感似乎总是零零星星，陆陆续续到来的。任何人都不可能一笔呵成，就算再厉害的程序员，也需要经过一段时间，才能发现最简单优雅的写法。有时候你反复提炼一段代码，觉得到了顶峰，没法再改进了，可是过了几个月再回头来看，又发现好多可以改进和简化的地方。这跟写文章一模一样，回头看几个月或者几年前写的东西，你总能发现一些改进。&lt;/p&gt;&lt;p&gt;所以如果反复提炼代码已经不再有进展，那么你可以暂时把它放下。过几个星期或者几个月再回头来看，也许就有焕然一新的灵感。这样反反复复很多次之后，你就积累起了灵感和智慧，从而能够在遇到新问题的时候直接朝正确，或者接近正确的方向前进。&lt;/p&gt;&lt;h3&gt;写优雅的代码&lt;/h3&gt;&lt;p&gt;人们都讨厌“面条代码”（spaghetti code），因为它就像面条一样绕来绕去，没法理清头绪。那么优雅的代码一般是什么形状的呢？经过多年的观察，我发现优雅的代码，在形状上有一些明显的特征。&lt;/p&gt;&lt;p&gt;如果我们忽略具体的内容，从大体结构上来看，优雅的代码看起来就像是一些整整齐齐，套在一起的盒子。如果跟整理房间做一个类比，就很容易理解。如果你把所有物品都丢在一个很大的抽屉里，那么它们就会全都混在一起。你就很难整理，很难迅速的找到需要的东西。但是如果你在抽屉里再放几个小盒子，把物品分门别类放进去，那么它们就不会到处乱跑，你就可以比较容易的找到和管理它们。&lt;/p&gt;&lt;p&gt;优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。这是因为程序所做的几乎一切事情，都是信息的传递和分支。你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的if语句，它看起来就会像这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (...) {
  if (...) {
    ...
  } else {
    ...
  }
} else if (...) {
  ...
} else {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意到了吗？在我的代码里面，if语句几乎总是有两个分支。它们有可能嵌套，有多层的缩进，而且else分支里面有可能出现少量重复的代码。然而这样的结构，逻辑却非常严密和清晰。在后面我会告诉你为什么if语句最好有两个分支。&lt;/p&gt;&lt;h3&gt;写模块化的代码&lt;/h3&gt;&lt;p&gt;有些人吵着闹着要让程序“模块化”，结果他们的做法是把代码分部到多个文件和目录里面，然后把这些目录或者文件叫做“module”。他们甚至把这些目录分放在不同的VCS repo里面。结果这样的作法并没有带来合作的流畅，而是带来了许多的麻烦。这是因为他们其实并不理解什么叫做“模块”，肤浅的把代码切割开来，分放在不同的位置，其实非但不能达到模块化的目的，而且制造了不必要的麻烦。&lt;/p&gt;&lt;p&gt;真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。&lt;/p&gt;&lt;p&gt;想要达到很好的模块化，你需要做到以下几点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免写太长的函数。如果发现函数太大了，就应该把它拆分成几个更小的。通常我写的函数长度都不超过40行。对比一下，一般笔记本电脑屏幕所能容纳的代码行数是50行。我可以一目了然的看见一个40行的函数，而不需要滚屏。只有40行而不是50行的原因是，我的眼球不转的话，最大的视角只看得到40行代码。&lt;/p&gt;

&lt;p&gt;如果我看代码不转眼球的话，我就能把整片代码完整的映射到我的视觉神经里，这样就算忽然闭上眼睛，我也能看得见这段代码。我发现闭上眼睛的时候，大脑能够更加有效地处理代码，你能想象这段代码可以变成什么其它的形状。40行并不是一个很大的限制，因为函数里面比较复杂的部分，往往早就被我提取出去，做成了更小的函数，然后从原来的函数里面调用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;制造小的工具函数。如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。有些帮助函数也许就只有两行，然而它们却能大大简化主要函数里面的逻辑。&lt;/p&gt;

&lt;p&gt;有些人不喜欢使用小的函数，因为他们想避免函数调用的开销，结果他们写出几百行之大的函数。这是一种过时的观念。现代的编译器都能自动的把小的函数内联（inline）到调用它的地方，所以根本不产生函数调用，也就不会产生任何多余的开销。&lt;/p&gt;

&lt;p&gt;同样的一些人，也爱使用宏（macro）来代替小函数，这也是一种过时的观念。在早期的C语言编译器里，只有宏是静态“内联”的，所以他们使用宏，其实是为了达到内联的目的。然而能否内联，其实并不是宏与函数的根本区别。宏与函数有着巨大的区别（这个我以后再讲），应该尽量避免使用宏。为了内联而使用宏，其实是滥用了宏，这会引起各种各样的麻烦，比如使程序难以理解，难以调试，容易出错等等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个函数只做一件简单的事情。有些人喜欢制造一些“通用”的函数，既可以做这个又可以做那个，它的内部依据某些变量和条件，来“选择”这个函数所要做的事情。比如，你也许写出这样的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  if (getOS().equals(&quot;MacOS&quot;)) {
    a();
  } else {
    b();
  }
  c();
  if (getOS().equals(&quot;MacOS&quot;)) {
    d();
  } else {
    e();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写这个函数的人，根据系统是否为“MacOS”来做不同的事情。你可以看出这个函数里，其实只有&lt;code&gt;c()&lt;/code&gt;是两种系统共有的，而其它的&lt;code&gt;a()&lt;/code&gt;, &lt;code&gt;b()&lt;/code&gt;, &lt;code&gt;d()&lt;/code&gt;, &lt;code&gt;e()&lt;/code&gt;都属于不同的分支。&lt;/p&gt;

&lt;p&gt;这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooMacOS() {
  a();
  c();
  d();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooOther() {
  b();
  c();
  e();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  a();
  b()
  c();
  if (getOS().equals(&quot;MacOS&quot;)) {
    d();
  } else {
    e();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;a()&lt;/code&gt;，&lt;code&gt;b()&lt;/code&gt;，&lt;code&gt;c()&lt;/code&gt;都是一样的，只有&lt;code&gt;d()&lt;/code&gt;和&lt;code&gt;e()&lt;/code&gt;根据系统有所不同。那么你可以把&lt;code&gt;a()&lt;/code&gt;，&lt;code&gt;b()&lt;/code&gt;，&lt;code&gt;c()&lt;/code&gt;提取出去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void preFoo() {
  a();
  b()
  c();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后制造两个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooMacOS() {
  preFoo();
  d();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooOther() {
  preFoo();
  e();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，我们既共享了代码，又做到了每个函数只做一件简单的事情。这样的代码，逻辑就更加清晰。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。有些人写代码，经常用类成员来传递信息，就像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`&quot;&gt; class A {
   String x;

   void findX() {
      ...
      x = ...;
   }

   void foo() {
     findX();
     ...
     print(x);
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 首先，他使用&lt;code&gt;findX()&lt;/code&gt;，把一个值写入成员&lt;code&gt;x&lt;/code&gt;。然后，使用&lt;code&gt;x&lt;/code&gt;的值。这样，&lt;code&gt;x&lt;/code&gt;就变成了&lt;code&gt;findX&lt;/code&gt;和&lt;code&gt;print&lt;/code&gt;之间的数据通道。由于&lt;code&gt;x&lt;/code&gt;属于&lt;code&gt;class A&lt;/code&gt;，这样程序就失去了模块化的结构。由于这两个函数依赖于成员x，它们不再有明确的输入和输出，而是依赖全局的数据。&lt;code&gt;findX&lt;/code&gt;和&lt;code&gt;foo&lt;/code&gt;不再能够离开&lt;code&gt;class A&lt;/code&gt;而存在，而且由于类成员还有可能被其他代码改变，代码变得难以理解，难以确保正确性。&lt;/p&gt;

&lt;p&gt; 如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个class，而且更加容易理解，不易出错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`&quot;&gt; String findX() {
    ...
    x = ...;
    return x;
 }
 void foo() {
   int x = findX();
   print(x);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;写可读的代码&lt;/h3&gt;&lt;p&gt;有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。&lt;/p&gt;&lt;p&gt;实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。&lt;/p&gt;&lt;p&gt;有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。这样的情况应该少出现，否则这意味着整个代码的设计都有问题。&lt;/p&gt;&lt;p&gt;如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// put elephant1 into fridge2
put(elephant1, fridge2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我的函数名&lt;code&gt;put&lt;/code&gt;，加上两个有意义的变量名&lt;code&gt;elephant1&lt;/code&gt;和&lt;code&gt;fridge2&lt;/code&gt;，已经说明了这是在干什么（把大象放进冰箱），所以上面那句注释完全没有必要。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部变量应该尽量接近使用它的地方。有些人喜欢在函数最开头定义很多局部变量，然后在下面很远的地方使用它，就像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  int index = ...;
  ...
  ...
  bar(index);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于这中间都没有使用过&lt;code&gt;index&lt;/code&gt;，也没有改变过它所依赖的数据，所以这个变量定义，其实可以挪到接近使用它的地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  ...
  ...
  int index = ...;
  bar(index);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样读者看到&lt;code&gt;bar(index)&lt;/code&gt;，不需要向上看很远就能发现&lt;code&gt;index&lt;/code&gt;是如何算出来的。而且这种短距离，可以加强读者对于这里的“计算顺序”的理解。否则如果index在顶上，读者可能会怀疑，它其实保存了某种会变化的数据，或者它后来又被修改过。如果index放在下面，读者就清楚的知道，index并不是保存了什么可变的值，而且它算出来之后就没变过。&lt;/p&gt;

&lt;p&gt;如果你看透了局部变量的本质——它们就是电路里的导线，那你就能更好的理解近距离的好处。变量定义离用的地方越近，导线的长度就越短。你不需要摸着一根导线，绕来绕去找很远，就能发现接收它的端口，这样的电路就更容易理解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部变量名字应该简短。这貌似跟第一点相冲突，简短的变量名怎么可能有意义呢？注意我这里说的是局部变量，因为它们处于局部，再加上第2点已经把它放到离使用位置尽量近的地方，所以根据上下文你就会容易知道它的意思：&lt;/p&gt;

&lt;p&gt;比如，你有一个局部变量，表示一个操作是否成功：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boolean successInDeleteFile = deleteFile(&quot;foo.txt&quot;);
if (successInDeleteFile) {
  ...
} else {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个局部变量&lt;code&gt;successInDeleteFile&lt;/code&gt;大可不必这么啰嗦。因为它只用过一次，而且用它的地方就在下面一行，所以读者可以轻松发现它是&lt;code&gt;deleteFile&lt;/code&gt;返回的结果。如果你把它改名为&lt;code&gt;success&lt;/code&gt;，其实读者根据一点上下文，也知道它表示&quot;success in deleteFile&quot;。所以你可以把它改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boolean success = deleteFile(&quot;foo.txt&quot;);
if (success) {
  ...
} else {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的写法不但没漏掉任何有用的语义信息，而且更加易读。&lt;code&gt;successInDeleteFile&lt;/code&gt;这种&quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/CamelCase&quot;&gt;camelCase&lt;/a&gt;&quot;，如果超过了三个单词连在一起，其实是很碍眼的东西，所以如果你能用一个单词表示同样的意义，那当然更好。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要重用局部变量。很多人写代码不喜欢定义新的局部变量，而喜欢“重用”同一个局部变量，通过反复对它们进行赋值，来表示完全不同意思。比如这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String msg;
if (...) {
  msg = &quot;succeed&quot;;
  log.info(msg);
} else {
  msg = &quot;failed&quot;;
  log.info(msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然这样在逻辑上是没有问题的，然而却不易理解，容易混淆。变量&lt;code&gt;msg&lt;/code&gt;两次被赋值，表示完全不同的两个值。它们立即被&lt;code&gt;log.info&lt;/code&gt;使用，没有传递到其它地方去。这种赋值的做法，把局部变量的作用域不必要的增大，让人以为它可能在将来改变，也许会在其它地方被使用。更好的做法，其实是定义两个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (...) {
  String msg = &quot;succeed&quot;;
  log.info(msg);
} else {
  String msg = &quot;failed&quot;;
  log.info(msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于这两个&lt;code&gt;msg&lt;/code&gt;变量的作用域仅限于它们所处的if语句分支，你可以很清楚的看到这两个&lt;code&gt;msg&lt;/code&gt;被使用的范围，而且知道它们之间没有任何关系。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把复杂的逻辑提取出去，做成“帮助函数”。有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，这样你就可以使用有意义的函数名来代替注释。举一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
// put elephant1 into fridge2
openDoor(fridge2);
if (elephant1.alive()) {
  ...
} else {
   ...
}
closeDoor(fridge2);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你把这片代码提出去定义成一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void put(Elephant elephant, Fridge fridge) {
  openDoor(fridge);
  if (elephant.alive()) {
    ...
  } else {
     ...
  }
  closeDoor(fridge);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样原来的代码就可以改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
put(elephant1, fridge2);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更加清晰，而且注释也没必要了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把复杂的表达式提取出去，做成中间变量。有些人听说“函数式编程”是个好东西，也不理解它的真正含义，就在代码里使用大量嵌套的函数。像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pizza pizza = makePizza(crust(salt(), butter()),
   topping(onion(), tomato(), sausage()));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码一行太长，而且嵌套太多，不容易看清楚。其实训练有素的函数式程序员，都知道中间变量的好处，不会盲目的使用嵌套的函数。他们会把这代码变成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Crust crust = crust(salt(), butter());
Topping topping = topping(onion(), tomato(), sausage());
Pizza pizza = makePizza(crust, topping);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写，不但有效地控制了单行代码的长度，而且由于引入的中间变量具有“意义”，步骤清晰，变得很容易理解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在合理的地方换行。对于绝大部分的程序语言，代码的逻辑是和空白字符无关的，所以你可以在几乎任何地方换行，你也可以不换行。这样的语言设计，是一个好东西，因为它给了程序员自由控制自己代码格式的能力。然而，它也引起了一些问题，因为很多人不知道如何合理的换行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  有些人喜欢利用IDE的自动换行机制，编辑之后用一个热键把整个代码重新格式化一遍，IDE就会把超过行宽限制的代码自动折行。可是这种自动这行，往往没有根据代码的逻辑来进行，不能帮助理解代码。自动换行之后可能产生这样的代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   if (someLongCondition1() &amp;amp;&amp;amp; someLongCondition2() &amp;amp;&amp;amp; someLongCondition3() &amp;amp;&amp;amp; 
     someLongCondition4()) {
     ...
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   由于&lt;code&gt;someLongCondition4()&lt;/code&gt;超过了行宽限制，被编辑器自动换到了下面一行。虽然满足了行宽限制，换行的位置却是相当任意的，它并不能帮助人理解这代码的逻辑。这几个boolean表达式，全都用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;连接，所以它们其实处于平等的地位。为了表达这一点，当需要折行的时候，你应该把每一个表达式都放到新的一行，就像这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   if (someLongCondition1() &amp;amp;&amp;amp; 
       someLongCondition2() &amp;amp;&amp;amp; 
       someLongCondition3() &amp;amp;&amp;amp; 
       someLongCondition4()) {
     ...
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   这样每一个条件都对齐，里面的逻辑就很清楚了。再举个例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   log.info(&quot;failed to find file {} for command {}, with exception {}&quot;, file, command,
     exception);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   这行因为太长，被自动折行成这个样子。&lt;code&gt;file&lt;/code&gt;，&lt;code&gt;command&lt;/code&gt;和&lt;code&gt;exception&lt;/code&gt;本来是同一类东西，却有两个留在了第一行，最后一个被折到第二行。它就不如手动换行成这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   log.info(&quot;failed to find file {} for command {}, with exception {}&quot;,
     file, command, exception);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   把格式字符串单独放在一行，而把它的参数一并放在另外一行，这样逻辑就更加清晰。&lt;/p&gt;&lt;p&gt;   为了避免IDE把这些手动调整好的换行弄乱，很多IDE（比如IntelliJ）的自动格式化设定里都有“保留原来的换行符”的设定。如果你发现IDE的换行不符合逻辑，你可以修改这些设定，然后在某些地方保留你自己的手动换行。&lt;/p&gt;&lt;p&gt;说到这里，我必须警告你，这里所说的“不需注释，让代码自己解释自己”，并不是说要让代码看起来像某种自然语言。有个叫Chai的JavaScript测试工具，可以让你这样写代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;expect(foo).to.be.a(&#39;string&#39;);
expect(foo).to.equal(&#39;bar&#39;);
expect(foo).to.have.length(3);
expect(tea).to.have.property(&#39;flavors&#39;).with.length(3);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种做法是极其错误的。程序语言本来就比自然语言简单清晰，这种写法让它看起来像自然语言的样子，反而变得复杂难懂了。&lt;/p&gt;&lt;h3&gt;写简单的代码&lt;/h3&gt;&lt;p&gt;程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。&lt;/p&gt;&lt;p&gt;并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，“新”的特性，我基本都只用经过千锤百炼，我觉得值得信奈的那一套。&lt;/p&gt;&lt;p&gt;现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免使用自增减表达式（i++，++i，i--，--i）。这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。&lt;/p&gt;

&lt;p&gt;其实这两个表达式完全可以分解成两步，把读和写分开：一步更新i的值，另外一步使用i的值。比如，如果你想写&lt;code&gt;foo(i++)&lt;/code&gt;，你完全可以把它拆成&lt;code&gt;int t = i; i += 1; foo(t);&lt;/code&gt;。如果你想写&lt;code&gt;foo(++i)&lt;/code&gt;，可以拆成&lt;code&gt;i += 1; foo(i);&lt;/code&gt; 拆开之后的代码，含义完全一致，却清晰很多。到底更新是在取值之前还是之后，一目了然。&lt;/p&gt;

&lt;p&gt;有人也许以为i++或者++i的效率比拆开之后要高，这只是一种错觉。这些代码经过基本的编译器优化之后，生成的机器代码是完全没有区别的。自增减表达式只有在两种情况下才可以安全的使用。一种是在for循环的update部分，比如&lt;code&gt;for(int i = 0; i &amp;lt; 5; i++)&lt;/code&gt;。另一种情况是写成单独的一行，比如&lt;code&gt;i++;&lt;/code&gt;。这两种情况是完全没有歧义的。你需要避免其它的情况，比如用在复杂的表达式里面，比如&lt;code&gt;foo(i++)&lt;/code&gt;，&lt;code&gt;foo(++i) + foo(i)&lt;/code&gt;，…… 没有人应该知道，或者去追究这些是什么意思。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;永远不要省略花括号。很多语言允许你在某种情况下省略掉花括号，比如C，Java都允许你在if语句里面只有一句话的时候省略掉花括号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (...) 
  action1();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;咋一看少打了两个字，多好。可是这其实经常引起奇怪的问题。比如，你后来想要加一句话&lt;code&gt;action2()&lt;/code&gt;到这个if里面，于是你就把代码改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (...) 
  action1();
  action2();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了美观，你很小心的使用了&lt;code&gt;action1()&lt;/code&gt;的缩进。咋一看它们是在一起的，所以你下意识里以为它们只会在if的条件为真的时候执行，然而&lt;code&gt;action2()&lt;/code&gt;却其实在if外面，它会被无条件的执行。我把这种现象叫做“光学幻觉”（optical illusion），理论上每个程序员都应该发现这个错误，然而实际上却容易被忽视。&lt;/p&gt;

&lt;p&gt;那么你问，谁会这么傻，我在加入&lt;code&gt;action2()&lt;/code&gt;的时候加上花括号不就行了？可是从设计的角度来看，这样其实并不是合理的作法。首先，也许你以后又想把&lt;code&gt;action2()&lt;/code&gt;去掉，这样你为了样式一致，又得把花括号拿掉，烦不烦啊？其次，这使得代码样式不一致，有的if有花括号，有的又没有。况且，你为什么需要记住这个规则？如果你不问三七二十一，只要是if-else语句，把花括号全都打上，就可以想都不用想了，就当C和Java没提供给你这个特殊写法。这样就可以保持完全的一致性，减少不必要的思考。&lt;/p&gt;

&lt;p&gt;有人可能会说，全都打上花括号，只有一句话也打上，多碍眼啊？然而经过实行这种编码规范几年之后，我并没有发现这种写法更加碍眼，反而由于花括号的存在，使得代码界限明确，让我的眼睛负担更小了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合理使用括号，不要盲目依赖操作符优先级。利用操作符的优先级来减少括号，对于&lt;code&gt;1 + 2 * 3&lt;/code&gt;这样常见的算数表达式，是没问题的。然而有些人如此的仇恨括号，以至于他们会写出&lt;code&gt;2 &amp;lt;&amp;lt; 7 - 2 * 3&lt;/code&gt;这样的表达式，而完全不用括号。&lt;/p&gt;

&lt;p&gt;这里的问题，在于移位操作&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的优先级，是很多人不熟悉，而且是违反常理的。由于&lt;code&gt;x &amp;lt;&amp;lt; 1&lt;/code&gt;相当于把&lt;code&gt;x&lt;/code&gt;乘以2，很多人误以为这个表达式相当于&lt;code&gt;(2 &amp;lt;&amp;lt; 7) - (2 * 3)&lt;/code&gt;，所以等于250。然而实际上&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的优先级比加法&lt;code&gt;+&lt;/code&gt;还要低，所以这表达式其实相当于&lt;code&gt;2 &amp;lt;&amp;lt; (7 - 2 * 3)&lt;/code&gt;，所以等于4！&lt;/p&gt;

&lt;p&gt;解决这个问题的办法，不是要每个人去把操作符优先级表给硬背下来，而是合理的加入括号。比如上面的例子，最好直接加上括号写成&lt;code&gt;2 &amp;lt;&amp;lt; (7 - 2 * 3)&lt;/code&gt;。虽然没有括号也表示同样的意思，但是加上括号就更加清晰，读者不再需要死记&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的优先级就能理解代码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免使用continue和break。循环语句（for，while）里面出现return是没问题的，然而如果你使用了continue或者break，就会让循环的逻辑和终止条件变得复杂，难以确保正确。&lt;/p&gt;

&lt;p&gt;出现continue或者break的原因，往往是对循环的逻辑没有想清楚。如果你考虑周全了，应该是几乎不需要continue或者break的。如果你的循环里出现了continue或者break，你就应该考虑改写这个循环。改写循环的办法有多种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。&lt;/li&gt;
&lt;li&gt;如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。&lt;/li&gt;
&lt;li&gt;有时候你可以把break替换成return，从而去掉break。&lt;/li&gt;
&lt;li&gt;如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;下面我对这些情况举一些例子。&lt;/p&gt;

&lt;p&gt;情况1：下面这段代码里面有一个continue：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; goodNames = new ArrayList&amp;lt;&amp;gt;();
for (String name: names) {
  if (name.contains(&quot;bad&quot;)) {
    continue;
  }
  goodNames.add(name);
  ...
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它说：“如果name含有&#39;bad&#39;这个词，跳过后面的循环代码……” 注意，这是一种“负面”的描述，它不是在告诉你什么时候“做”一件事，而是在告诉你什么时候“不做”一件事。为了知道它到底在干什么，你必须搞清楚continue会导致哪些语句被跳过了，然后脑子里把逻辑反个向，你才能知道它到底想做什么。这就是为什么含有continue和break的循环不容易理解，它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。&lt;/p&gt;

&lt;p&gt;其实，我们只需要把continue的条件反向，这段代码就可以很容易的被转换成等价的，不含continue的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; goodNames = new ArrayList&amp;lt;&amp;gt;();
for (String name: names) {
  if (!name.contains(&quot;bad&quot;)) {
    goodNames.add(name);
    ...
  }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;goodNames.add(name);&lt;/code&gt;和它之后的代码全部被放到了if里面，多了一层缩进，然而continue却没有了。你再读这段代码，就会发现更加清晰。因为它是一种更加“正面”地描述。它说：“在name不含有&#39;bad&#39;这个词的时候，把它加到goodNames的链表里面……”&lt;/p&gt;

&lt;p&gt;情况2：for和while头部都有一个循环的“终止条件”，那本来应该是这个循环唯一的退出条件。如果你在循环中间有break，它其实给这个循环增加了一个退出条件。你往往只需要把这个条件合并到循环头部，就可以去掉break。&lt;/p&gt;

&lt;p&gt;比如下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (condition1) {
  ...
  if (condition2) {
    break;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当condition成立的时候，break会退出循环。其实你只需要把condition2反转之后，放到while头部的终止条件，就可以去掉这种break语句。改写后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (condition1 &amp;amp;&amp;amp; !condition2) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情况表面上貌似只适用于break出现在循环开头或者末尾的时候，然而其实大部分时候，break都可以通过某种方式，移动到循环的开头或者末尾。具体的例子我暂时没有，等出现的时候再加进来。&lt;/p&gt;

&lt;p&gt;情况3：很多break退出循环之后，其实接下来就是一个return。这种break往往可以直接换成return。比如下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean hasBadName(List&amp;lt;String&amp;gt; names) {
    boolean result = false;

    for (String name: names) {
        if (name.contains(&quot;bad&quot;)) {
            result = true;
            break;
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数检查names链表里是否存在一个名字，包含“bad”这个词。它的循环里包含一个break语句。这个函数可以被改写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean hasBadName(List&amp;lt;String&amp;gt; names) {
    for (String name: names) {
        if (name.contains(&quot;bad&quot;)) {
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改进后的代码，在name里面含有“bad”的时候，直接用&lt;code&gt;return true&lt;/code&gt;返回，而不是对result变量赋值，break出去，最后才返回。如果循环结束了还没有return，那就返回false，表示没有找到这样的名字。使用return来代替break，这样break语句和result这个变量，都一并被消除掉了。&lt;/p&gt;

&lt;p&gt;我曾经见过很多其他使用continue和break的例子，几乎无一例外的可以被消除掉，变换后的代码变得清晰很多。我的经验是，99%的break和continue，都可以通过替换成return语句，或者翻转if条件的方式来消除掉。剩下的1%含有复杂的逻辑，但也可以通过提取一个帮助函数来消除掉。修改之后的代码变得容易理解，容易确保正确。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;写直观的代码&lt;/h3&gt;&lt;p&gt;我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。比如，Unix命令行有一种“巧妙”的写法是这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;command1 &amp;amp;&amp;amp; command2 &amp;amp;&amp;amp; command3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于Shell语言的逻辑操作&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;具有“短路”的特性，如果&lt;code&gt;a&lt;/code&gt;等于false，那么&lt;code&gt;b&lt;/code&gt;就没必要执行了。这就是为什么当command1成功，才会执行command2，当command2成功，才会执行command3。同样，&lt;/p&gt;&lt;pre&gt;&lt;code&gt;command1 || command2 || command3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;操作符&lt;code&gt;||&lt;/code&gt;也有类似的特性。上面这个命令行，如果command1成功，那么command2和command3都不会被执行。如果command1失败，command2成功，那么command3就不会被执行。&lt;/p&gt;&lt;p&gt;这比起用if语句来判断失败，似乎更加巧妙和简洁，所以有人就借鉴了这种方式，在程序的代码里也使用这种方式。比如他们可能会写这样的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (action1() || action2() &amp;amp;&amp;amp; action3()) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你看得出来这代码是想干什么吗？action2和action3什么条件下执行，什么条件下不执行？也许稍微想一下，你知道它在干什么：“如果action1失败了，执行action2，如果action2成功了，执行action3”。然而那种语义，并不是直接的“映射”在这代码上面的。比如“失败”这个词，对应了代码里的哪一个字呢？你找不出来，因为它包含在了&lt;code&gt;||&lt;/code&gt;的语义里面，你需要知道&lt;code&gt;||&lt;/code&gt;的短路特性，以及逻辑或的语义才能知道这里面在说“如果action1失败……”。每一次看到这行代码，你都需要思考一下，这样积累起来的负荷，就会让人很累。&lt;/p&gt;&lt;p&gt;其实，这种写法是滥用了逻辑操作&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;和&lt;code&gt;||&lt;/code&gt;的短路特性。这两个操作符可能不执行右边的表达式，原因是为了机器的执行效率，而不是为了给人提供这种“巧妙”的用法。这两个操作符的本意，只是作为逻辑操作，它们并不是拿来给你代替if语句的。也就是说，它们只是碰巧可以达到某些if语句的效果，但你不应该因此就用它来代替if语句。如果你这样做了，就会让代码晦涩难懂。&lt;/p&gt;&lt;p&gt;上面的代码写成笨一点的办法，就会清晰很多：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (!action1()) {
  if (action2()) {
    action3();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我很明显的看出这代码在说什么，想都不用想：如果action1()失败了，那么执行action2()，如果action2()成功了，执行action3()。你发现这里面的一一对应关系吗？&lt;code&gt;if&lt;/code&gt;=如果，&lt;code&gt;!&lt;/code&gt;=失败，…… 你不需要利用逻辑学知识，就知道它在说什么。&lt;/p&gt;&lt;h3&gt;写无懈可击的代码&lt;/h3&gt;&lt;p&gt;在之前一节里，我提到了自己写的代码里面很少出现只有一个分支的if语句。我写出的if语句，大部分都有两个分支，所以我的代码很多看起来是这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (...) {
  if (...) {
    ...
    return false;
  } else {
    return true;
  }
} else if (...) {
  ...
  return false;
} else {
  return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。&lt;/p&gt;&lt;p&gt;很多人写if语句喜欢省略else的分支，因为他们觉得有些else分支的代码重复了。比如我的代码里，两个else分支都是&lt;code&gt;return true&lt;/code&gt;。为了避免重复，他们省略掉那两个else分支，只在最后使用一个&lt;code&gt;return true&lt;/code&gt;。这样，缺了else分支的if语句，控制流自动“掉下去”，到达最后的&lt;code&gt;return true&lt;/code&gt;。他们的代码看起来像这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (...) {
  if (...) {
    ...
    return false;
  } 
} else if (...) {
  ...
  return false;
} 
return true;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种写法看似更加简洁，避免了重复，然而却很容易出现疏忽和漏洞。嵌套的if语句省略了一些else，依靠语句的“控制流”来处理else的情况，是很难正确的分析和推理的。如果你的if条件里使用了&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;和&lt;code&gt;||&lt;/code&gt;之类的逻辑运算，就更难看出是否涵盖了所有的情况。&lt;/p&gt;&lt;p&gt;由于疏忽而漏掉的分支，全都会自动“掉下去”，最后返回意想不到的结果。即使你看一遍之后确信是正确的，每次读这段代码，你都不能确信它照顾了所有的情况，又得重新推理一遍。这简洁的写法，带来的是反复的，沉重的头脑开销。这就是所谓“面条代码”，因为程序的逻辑分支，不是像一棵枝叶分明的树，而是像面条一样绕来绕去。&lt;/p&gt;&lt;p&gt;另外一种省略else分支的情况是这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String s = &quot;&quot;;
if (x &amp;lt; 5) {
  s = &quot;ok&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写这段代码的人，脑子里喜欢使用一种“缺省值”的做法。&lt;code&gt;s&lt;/code&gt;缺省为null，如果x&amp;lt;5，那么把它改变（mutate）成“ok”。这种写法的缺点是，当&lt;code&gt;x&amp;lt;5&lt;/code&gt;不成立的时候，你需要往上面看，才能知道s的值是什么。这还是你运气好的时候，因为s就在上面不远。很多人写这种代码的时候，s的初始值离判断语句有一定的距离，中间还有可能插入一些其它的逻辑和赋值操作。这样的代码，把变量改来改去的，看得人眼花，就容易出错。&lt;/p&gt;&lt;p&gt;现在比较一下我的写法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String s;
if (x &amp;lt; 5) {
  s = &quot;ok&quot;;
} else {
  s = &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种写法貌似多打了一两个字，然而它却更加清晰。这是因为我们明确的指出了&lt;code&gt;x&amp;lt;5&lt;/code&gt;不成立的时候，s的值是什么。它就摆在那里，它是&lt;code&gt;&quot;&quot;&lt;/code&gt;（空字符串）。注意，虽然我也使用了赋值操作，然而我并没有“改变”s的值。s一开始的时候没有值，被赋值之后就再也没有变过。我的这种写法，通常被叫做更加“函数式”，因为我只赋值一次。&lt;/p&gt;&lt;p&gt;如果我漏写了else分支，Java编译器是不会放过我的。它会抱怨：“在某个分支，s没有被初始化。”这就强迫我清清楚楚的设定各种条件下s的值，不漏掉任何一种情况。&lt;/p&gt;&lt;p&gt;当然，由于这个情况比较简单，你还可以把它写成这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String s = x &amp;lt; 5 ? &quot;ok&quot; : &quot;&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于更加复杂的情况，我建议还是写成if语句为好。&lt;/p&gt;&lt;h3&gt;正确处理错误&lt;/h3&gt;&lt;p&gt;使用有两个分支的if语句，只是我的代码可以达到无懈可击的其中一个原因。这样写if语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。&lt;/p&gt;&lt;p&gt;程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。&lt;/p&gt;&lt;p&gt;错误处理是一个古老的问题，可是经过了几十年，还是很多人没搞明白。Unix的系统API手册，一般都会告诉你可能出现的返回值和错误信息。比如，Linux的&lt;a href=&quot;http://man7.org/linux/man-pages/man2/read.2.html&quot;&gt;read&lt;/a&gt;系统调用手册里面有如下内容：&lt;/p&gt;&lt;pre&gt;
RETURN VALUE 
On success, the number of bytes read is returned... 

On error, -1 is returned, and errno is set appropriately.
&lt;p&gt;
ERRORS

EAGAIN, EBADF, EFAULT, EINTR, EINVAL, ...
&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;很多初学者，都会忘记检查&lt;code&gt;read&lt;/code&gt;的返回值是否为-1，觉得每次调用&lt;code&gt;read&lt;/code&gt;都得检查返回值真繁琐，不检查貌似也相安无事。这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就必须要对这个-1作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。&lt;/p&gt;&lt;p&gt;对于Java来说，这相对方便一些。Java的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union类型”。比如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String foo() throws MyException {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里MyException是一个错误返回。你可以认为这个函数返回一个union类型：&lt;code&gt;{String, MyException}&lt;/code&gt;。任何调用&lt;code&gt;foo&lt;/code&gt;的代码，必须对MyException作出合理的处理，才有可能确保程序的正确运行。Union类型是一种相当先进的类型，目前只有极少数语言（比如Typed Racket）具有这种类型，我在这里提到它，只是为了方便解释概念。掌握了概念之后，你其实可以在头脑里实现一个union类型系统，这样使用普通的语言也能写出可靠的代码。&lt;/p&gt;&lt;p&gt;由于Java的类型系统强制要求函数在类型里面声明可能出现的异常，而且强制调用者处理可能出现的异常，所以基本上不可能出现由于疏忽而漏掉的情况。但有些Java程序员有一种恶习，使得这种安全机制几乎完全失效。每当编译器报错，说“你没有catch这个foo函数可能出现的异常”时，有些人想都不想，直接把代码改成这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;try {
  foo();
} catch (Exception e) {}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者最多在里面放个log，或者干脆把自己的函数类型上加上&lt;code&gt;throws Exception&lt;/code&gt;，这样编译器就不再抱怨。这些做法貌似很省事，然而都是错误的，你终究会为此付出代价。&lt;/p&gt;&lt;p&gt;如果你把异常catch了，忽略掉，那么你就不知道foo其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。这当然迟早会出问题，因为你根本不知道自己在干什么。&lt;/p&gt;&lt;p&gt;catch异常的时候，你不应该使用Exception这么宽泛的类型。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，因为它会不经意的catch住另外的异常（比如B）。你的代码逻辑是基于判断A是否出现，可你却catch所有的异常（Exception类），所以当其它的异常B出现的时候，你的代码就会出现莫名其妙的问题，因为你以为A出现了，而其实它没有。这种bug，有时候甚至使用debugger都难以发现。&lt;/p&gt;&lt;p&gt;如果你在自己函数的类型加上&lt;code&gt;throws Exception&lt;/code&gt;，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着&lt;code&gt;throws Exception&lt;/code&gt;，这毛病就传得更远。我的经验是，尽量在异常出现的当时就作出处理。否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。&lt;/p&gt;&lt;p&gt;另外，try { ... } catch里面，应该包含尽量少的代码。比如，如果&lt;code&gt;foo&lt;/code&gt;和&lt;code&gt;bar&lt;/code&gt;都可能产生异常A，你的代码应该尽可能写成：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;try {
  foo();
} catch (A e) {...}

try {
  bar();
} catch (A e) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不是&lt;/p&gt;&lt;pre&gt;&lt;code&gt;try {
  foo();
  bar();
} catch (A e) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一种写法能明确的分辨是哪一个函数出了问题，而第二种写法全都混在一起。明确的分辨是哪一个函数出了问题，有很多的好处。比如，如果你的catch代码里面包含log，它可以提供给你更加精确的错误信息，这样会大大地加速你的调试过程。&lt;/p&gt;&lt;h3&gt;正确处理null指针&lt;/h3&gt;&lt;p&gt;穷举的思想是如此的有用，依据这个原理，我们可以推出一些基本原则，它们可以让你无懈可击的处理null指针。&lt;/p&gt;&lt;p&gt;首先你应该知道，许多语言（C，C++，Java，C#，……）的类型系统对于null的处理，其实是完全错误的。这个错误源自于&lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;Tony Hoare&lt;/a&gt;最早的设计，Hoare把这个错误称为自己的“&lt;a href=&quot;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&quot;&gt;billion dollar mistake&lt;/a&gt;”，因为由于它所产生的财产和人力损失，远远超过十亿美元。&lt;/p&gt;&lt;p&gt;这些语言的类型系统允许null出现在任何对象（指针）类型可以出现的地方，然而null其实根本不是一个合法的对象。它不是一个String，不是一个Integer，也不是一个自定义的类。null的类型本来应该是NULL，也就是null自己。根据这个基本观点，我们推导出以下原则：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制。虽然写法上有点别扭，然而Java的异常，和函数的返回值合并在一起，基本上可以当成union类型来用。比如，如果你有一个函数find，可以帮你找到一个String，也有可能什么也找不到，你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String find() throws NotFoundException {
  if (...) {
    return ...;
  } else {
    throw new NotFoundException();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java的类型系统会强制你catch这个NotFoundException，所以你不可能像漏掉检查null一样，漏掉这种情况。Java的异常也是一个比较容易滥用的东西，不过我已经在上一节告诉你如何正确的使用异常。&lt;/p&gt;

&lt;p&gt;Java的try...catch语法相当的繁琐和蹩脚，所以如果你足够小心的话，像&lt;code&gt;find&lt;/code&gt;这类函数，也可以返回null来表示“没找到”。这样稍微好看一些，因为你调用的时候不必用try...catch。很多人写的函数，返回null来表示“出错了”，这其实是对null的误用。“出错了”和“没有”，其实完全是两码事。“没有”是一种很常见，正常的情况，比如查哈希表没找到，很正常。“出错了”则表示罕见的情况，本来正常情况下都应该存在有意义的值，偶然出了问题。如果你的函数要表示“出错了”，应该使用异常，而不是null。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要把null放进“容器数据结构”里面。所谓容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。&lt;/p&gt;

&lt;p&gt;解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。&lt;/p&gt;

&lt;p&gt;需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A {
  String name = null;
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之所以可以这样，是因为null只可能在A对象的name成员里出现，你不用怀疑其它的成员因此成为null。所以你每次访问name成员时，检查它是否是null就可以了，不需要对其他成员也做同样的检查。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播。null很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”。有时候它表示“出错了”，“失败了”。有时候它甚至可以表示“成功了”，…… 这其中有很多误用之处，不过无论如何，你必须理解每一个null的意义，不能给混淆起来。&lt;/p&gt;

&lt;p&gt;如果你调用的函数有可能返回null，那么你应该在第一时间对null做出“有意义”的处理。比如，上述的函数&lt;code&gt;find&lt;/code&gt;，返回null表示“没找到”，那么调用&lt;code&gt;find&lt;/code&gt;的代码就应该在它返回的第一时间，检查返回值是否是null，并且对“没找到”这种情况，作出有意义的处理。&lt;/p&gt;

&lt;p&gt;“有意义”是什么意思呢？我的意思是，使用这函数的人，应该明确的知道在拿到null的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。如果你违反了这一点，就有可能采用一种不负责任，危险的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String foo() {
  String found = find();
  if (found == null) {
    return null;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当看到find()返回了null，foo自己也返回null。这样null就从一个地方，游走到了另一个地方，而且它表示另外一个意思。如果你不假思索就写出这样的代码，最后的结果就是代码里面随时随地都可能出现null。到后来为了保护自己，你的每个函数都会写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void foo(A a, B b, C c) {
  if (a == null) { ... }
  if (b == null) { ... }
  if (c == null) { ... }
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数作者：明确声明不接受null参数，当参数是null时立即崩溃。不要试图对null进行“容错”，不要让程序继续往下执行。如果调用者使用了null作为参数，那么调用者（而不是函数作者）应该对程序的崩溃负全责。&lt;/p&gt;

&lt;p&gt;上面的例子之所以成为问题，就在于人们对于null的“容忍态度”。这种“保护式”的写法，试图“容错”，试图“优雅的处理null”，其结果是让调用者更加肆无忌惮的传递null给你的函数。到后来，你的代码里出现一堆堆nonsense的情况，null可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了null是什么意思，该做什么，所有人都把null踢给其他人。最后这null像瘟疫一样蔓延开来，到处都是，成为一场噩梦。&lt;/p&gt;

&lt;p&gt;正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是null，如果你给我null，程序崩溃了该你自己负责。至于调用者代码里有null怎么办，他自己该知道怎么处理（参考以上几条），不应该由函数作者来操心。&lt;/p&gt;

&lt;p&gt;采用强硬态度一个很简单的做法是使用&lt;code&gt;Objects.requireNonNull()&lt;/code&gt;。它的定义很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; T requireNonNull(T obj) {
  if (obj == null) {
    throw new NullPointerException();
  } else {
    return obj;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以用这个函数来检查不想接受null的每一个参数，只要传进来的参数是null，就会立即触发&lt;code&gt;NullPointerException&lt;/code&gt;崩溃掉，这样你就可以有效地防止null指针不知不觉传递到其它地方去。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用@NotNull和@Nullable标记。IntelliJ提供了@NotNull和@Nullable两种标记，加在类型前面，这样可以比较简洁可靠地防止null指针的出现。IntelliJ本身会对含有这种标记的代码进行静态分析，指出运行时可能出现&lt;code&gt;NullPointerException&lt;/code&gt;的地方。在运行时，会在null指针不该出现的地方产生&lt;code&gt;IllegalArgumentException&lt;/code&gt;，即使那个null指针你从来没有deference。这样你可以在尽量早期发现并且防止null指针的出现。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Optional类型。Java 8和Swift之类的语言，提供了一种叫Optional的类型。正确的使用这种类型，可以在很大程度上避免null的问题。null指针的问题之所以存在，是因为你可以在没有“检查”null的情况下，“访问”对象的成员。&lt;/p&gt;

&lt;p&gt;Optional类型的设计原理，就是把“检查”和“访问”这两个操作合二为一，成为一个“原子操作”。这样你没法只访问，而不进行检查。这种做法其实是ML，Haskell等语言里的模式匹配（pattern matching）的一个特例。模式匹配使得类型判断和访问成员这两种操作合二为一，所以你没法犯错。&lt;/p&gt;

&lt;p&gt;比如，在Swift里面，你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let found = find()
if let content = found {
  print(&quot;found: &quot; + content)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你从&lt;code&gt;find()&lt;/code&gt;函数得到一个Optional类型的值&lt;code&gt;found&lt;/code&gt;。假设它的类型是&lt;code&gt;String?&lt;/code&gt;，那个问号表示它可能包含一个String，也可能是nil。然后你就可以用一种特殊的if语句，同时进行null检查和访问其中的内容。这个if语句跟普通的if语句不一样，它的条件不是一个Bool，而是一个变量绑定&lt;code&gt;let content = found&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我不是很喜欢这语法，不过这整个语句的含义是：如果found是nil，那么整个if语句被略过。如果它不是nil，那么变量content被绑定到found里面的值（unwrap操作），然后执行&lt;code&gt;print(&quot;found: &quot; + content)&lt;/code&gt;。由于这种写法把检查和访问合并在了一起，你没法只进行访问而不检查。&lt;/p&gt;

&lt;p&gt;Java 8的做法比较蹩脚一些。如果你得到一个Optional&lt;string&gt;类型的值found，你必须使用“函数式编程”的方式，来写这之后的代码：&lt;/string&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Optional&amp;lt;String&amp;gt; found = find();
found.ifPresent(content -&amp;gt; System.out.println(&quot;found: &quot; + content));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段Java代码跟上面的Swift代码等价，它包含一个“判断”和一个“取值”操作。ifPresent先判断found是否有值（相当于判断是不是null）。如果有，那么将其内容“绑定”到lambda表达式的content参数（unwrap操作），然后执行lambda里面的内容，否则如果found没有内容，那么ifPresent里面的lambda不执行。&lt;/p&gt;

&lt;p&gt;Java的这种设计有个问题。判断null之后分支里的内容，全都得写在lambda里面。在函数式编程里，这个lambda叫做“&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation&quot;&gt;continuation&lt;/a&gt;”，Java把它叫做
“&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html&quot;&gt;Consumer&lt;/a&gt;”，它表示“如果found不是null，拿到它的值，然后应该做什么”。由于lambda是个函数，你不能在里面写&lt;code&gt;return&lt;/code&gt;语句返回出外层的函数。比如，如果你要改写下面这个函数（含有null）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  String found = find();
  if (found != null) {
    return found;
  } else {
    return &quot;&quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会比较麻烦。因为如果你写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  Optional&amp;lt;String&amp;gt; found = find();
  found.ifPresent(content -&amp;gt; {
    return content;    // can&#39;t return from foo here
  });
  return &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;里面的&lt;code&gt;return a&lt;/code&gt;，并不能从函数&lt;code&gt;foo&lt;/code&gt;返回出去。它只会从lambda返回，而且由于那个lambda（&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#accept-T-&quot;&gt;Consumer.accept&lt;/a&gt;）的返回类型必须是&lt;code&gt;void&lt;/code&gt;，编译器会报错，说你返回了String。由于Java里closure的自由变量是只读的，你没法对lambda外面的变量进行赋值，所以你也不能采用这种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  Optional&amp;lt;String&amp;gt; found = find();
  String result = &quot;&quot;;
  found.ifPresent(content -&amp;gt; {
    result = content;    // can&#39;t assign to result
  });
  return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，虽然你在lambda里面得到了found的内容，如何使用这个值，如何返回一个值，却让人摸不着头脑。你平时的那些Java编程手法，在这里几乎完全废掉了。实际上，判断null之后，你必须使用Java 8提供的一系列古怪的&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html&quot;&gt;函数式编程操作&lt;/a&gt;：&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;orElse&lt;/code&gt;之类，想法把它们组合起来，才能表达出原来代码的意思。比如之前的代码，只能改写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  Optional&amp;lt;String&amp;gt; found = find();
  return found.orElse(&quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这简单的情况还好。复杂一点的代码，我还真不知道怎么表达，我怀疑Java 8的Optional类型的方法，到底有没有提供足够的表达力。那里面少数几个东西表达能力不咋的，论工作原理，却可以扯到functor，continuation，甚至monad等高深的理论…… 仿佛用了Optional之后，这语言就不再是Java了一样。&lt;/p&gt;

&lt;p&gt;所以Java虽然提供了Optional，但我觉得可用性其实比较低，难以被人接受。相比之下，Swift的设计更加简单直观，接近普通的过程式编程。你只需要记住一个特殊的语法&lt;code&gt;if let content = found {...}&lt;/code&gt;，里面的代码写法，跟普通的过程式语言没有任何差别。&lt;/p&gt;

&lt;p&gt;总之你只要记住，使用Optional类型，要点在于“原子操作”，使得null检查与取值合二为一。这要求你必须使用我刚才介绍的特殊写法。如果你违反了这一原则，把检查和取值分成两步做，还是有可能犯错误。比如在Java 8里面，你可以使用&lt;code&gt;found.get()&lt;/code&gt;这样的方式直接访问found里面的内容。在Swift里你也可以使用&lt;code&gt;found!&lt;/code&gt;来直接访问而不进行检查。&lt;/p&gt;

&lt;p&gt;你可以写这样的Java代码来使用Optional类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Option&amp;lt;String&amp;gt; found = find();
if (found.isPresent()) {
  System.out.println(&quot;found: &quot; + found.get());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用这种方式，把检查和取值分成两步做，就可能会出现运行时错误。&lt;code&gt;if (found.isPresent())&lt;/code&gt;本质上跟普通的null检查，其实没什么两样。如果你忘记判断&lt;code&gt;found.isPresent()&lt;/code&gt;，直接进行&lt;code&gt;found.get()&lt;/code&gt;，就会出现&lt;code&gt;NoSuchElementException&lt;/code&gt;。这跟&lt;code&gt;NullPointerException&lt;/code&gt;本质上是一回事。所以这种写法，比起普通的null的用法，其实换汤不换药。如果你要用Optional类型而得到它的益处，请务必遵循我之前介绍的“原子操作”写法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;防止过度工程&lt;/h3&gt;&lt;p&gt;人的脑子真是奇妙的东西。虽然大家都知道过度工程（over-engineering）不好，在实际的工程中却经常不由自主的出现过度工程。我自己也犯过好多次这种错误，所以觉得有必要分析一下，过度工程出现的信号和兆头，这样可以在初期的时候就及时发现并且避免。&lt;/p&gt;&lt;p&gt;过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”……&lt;/p&gt;&lt;p&gt;这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，把手头的问题先搞定了，再谈以后扩展的问题。&lt;/p&gt;&lt;p&gt;另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。为了让代码可以重用，最后被自己搞出来的各种框架捆住手脚，最后连可用的代码就没写好。如果可用的代码都写不好，又何谈重用呢？很多一开头就考虑太多重用的工程，到后来被人完全抛弃，没人用了，因为别人发现这些代码太难懂了，自己从头开始写一个，反而省好多事。&lt;/p&gt;&lt;p&gt;过度地关心“测试”，也会引起过度工程。有些人为了测试，把本来很简单的代码改成“方便测试”的形式，结果引入很多复杂性，以至于本来一下就能写对的代码，最后复杂不堪，出现很多bug。&lt;/p&gt;&lt;p&gt;世界上有两种“没有bug”的代码。一种是“没有明显的bug的代码”，另一种是“明显没有bug的代码”。第一种情况，由于代码复杂不堪，加上很多测试，各种coverage，貌似测试都通过了，所以就认为代码是正确的。第二种情况，由于代码简单直接，就算没写很多测试，你一眼看去就知道它不可能有bug。你喜欢哪一种“没有bug”的代码呢？&lt;/p&gt;&lt;p&gt;根据这些，我总结出来的防止过度工程的原则如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。&lt;/li&gt;
&lt;li&gt;先写出可用的代码，反复推敲，再考虑是否需要重用的问题。&lt;/li&gt;
&lt;li&gt;先写出可用，简单，明显没有bug的代码，再考虑测试的问题。&lt;/li&gt;
&lt;/ol&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">programming-philosophy</guid>
<pubDate>Sat, 21 Nov 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>图灵的光环</title>
<link>http://yinwang.org/blog-cn/2015/10/18/turing</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;图灵的光环&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-5e4e06e891dfddfa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;仿佛全世界的人都知道，&lt;a href=&quot;https://en.wikipedia.org/wiki/Alan_Turing&quot;&gt;图灵&lt;/a&gt;（Alan Turing）是个天才，是他创造了计算机科学，是他破解了德国纳粹的Enigma密码。由于他的杰出贡献，计算机科学的最高荣誉，被叫做“图灵奖”。然而根据自己一直以来对图灵机等计算模型的看法，加上一些历史资料，我发现图灵本人的实际成就，相对于他所受到的崇拜，其实相差甚远。&lt;/p&gt;&lt;p&gt;由于二战以来各国政府对于当时谍报工作的保密措施造成的事实混淆，再加上图灵的不幸生世所引来的同情，图灵这个名字似乎拥有了一种扑朔迷离的光环。人们把很多本来不是图灵作出的贡献归结在他身上，把本来很平常的贡献过分地夸大。图灵的光环，掩盖了许多对这些领域做出过更加重要贡献的人。&lt;/p&gt;&lt;h3&gt;图灵传&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-ae05459a3fdc19cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;2012年，在图灵诞辰&lt;a href=&quot;http://cacm.acm.org/magazines/2013/1/158780-who-begat-computing/fulltext&quot;&gt;一百周年&lt;/a&gt;的时候，人们风风火火的召开各种大会，纪念这位“计算机之父”，很多媒体也添油加醋地宣传他的丰功伟绩。还有个叫Andrew Hodges的人，抓住这个时机推销自己写的一本传记，叫做《&lt;a href=&quot;http://www.amazon.com/Alan-Turing-Enigma-Andrew-Hodges/dp/069115564X&quot;&gt;Alan Turing: The Enigma&lt;/a&gt;》。这本书红极一时，后来还被改编成了电影。&lt;/p&gt;&lt;p&gt;这本传记看似客观，引经据典，字里行间却可以感受到作者对图灵个人的膜拜和偏袒，他在倾心打造一个“天才”。作者片面地使用对图灵有利的证据，对不利的方面只字不提。仿佛图灵做的一切都是有理的，他做的不好的地方都是因为别人的问题，或者风水不好。提到别人做的东西，尽是各种缺陷和局限性，不是缺陷也要说成是缺陷；提到图灵的工作，总是史无前例，开天辟地的发明。别人先做出来的东西，生拉硬拽，硬要说成是受了图灵的“启发”，还怪别人没有引用图灵的论文。这让你感觉仿佛别人都在抄袭图灵伟大的研究成果，都在利用他，欺负他似的。如果你不想花钱买书，可以看看同一作者写的一个&lt;a href=&quot;http://www.turing.org.uk/publications/dnb.html&quot;&gt;图灵简要生平&lt;/a&gt;，足以从中感受到这种倾向。&lt;/p&gt;&lt;p&gt;我写这篇文章的很大一部分原因，就是因为这本传记。作者对图灵贡献的片面夸大，对其他一些学者的变相贬低，让我感到不平。图灵在计算机界的名声，本来就已经被严重的夸大和美化，被很多人盲目的崇拜。现在出了这本传记和电影，又在人们心中加重了这层误解。所以我觉得有必要澄清一些事实，让人们不再被迷惑。&lt;/p&gt;&lt;h3&gt;密码学&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-431f7a82e38fa57b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;很多人提到二战Enigma密码的故事，就会把功劳一股脑地归到图灵头上，只字不提其他人。其实呢，破解Enigma密码是很多人共同努力的结果，图灵只是其中的一员。这些人缺少了任何一个，都可能是灾难性的后果。其中好些人的想法早于图灵，启发过图灵，贡献比图灵的大，设计的东西比图灵的先进，却很少有人听说过他们的名字。论智力和贡献，图灵在其中只是中等水平，最后说起来倒好像是他单枪匹马拯救了大家，这是不公平的。&lt;/p&gt;&lt;p&gt;最初破掉Enigma密码的，其实不是英国人，而是波兰人。波兰人不但截获并且仿造了德国人的Enigma机器，而且发现了其中微妙的漏洞，发明了一种用于解密的机器叫做&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Bomba_(cryptography)&quot;&gt;BOMBA&lt;/a&gt;，以及一种手工破解的方法叫做&lt;a href=&quot;https://en.wikipedia.org/wiki/Zygalski_sheets&quot;&gt;Zygalski sheets&lt;/a&gt;。BOMBA可以在两个小时之内破解掉Enigma密码。波兰人一声不吭地窃听了德国人的通信长达六年半，最后在二战爆发前夕把这技术送给了英法盟友。&lt;/p&gt;&lt;p&gt;BOMBA的工作原理，其实就是模拟好几个Enigma机器，“并发”运转，这样可以加速猜出秘钥。最开头这样还行，但后来德国人改进了Enigma机器，把可选的齿轮从3个增加到了5个。5选3，有60种情况，这样秘钥的空间增大了60倍。理论上BOMBA只要运转60倍多的Enigma机器，就可以破解这增大的解空间，然而那已经超出了波兰的物资和人力。再加上德国人就要打过去，所以波兰只好请英法盟友帮忙。&lt;/p&gt;&lt;p&gt;图灵最重要的贡献，就是改进波兰人的&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Bomba_(cryptography)&quot;&gt;BOMBA&lt;/a&gt;，设计了一个更好的机器叫&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Bombe&quot;&gt;BOMBE&lt;/a&gt;。BOMBE比起BOMBA，其实并没有质的飞跃，只不过BOMBE同时模拟的Enigma机器更多，转的更快。另外它加入了一些“优化”措施，尽早排除不可行的路径，所以速度快很多。图灵最初的设计，要求必须能够事先猜出很长的文本，所以基本不能用。后来&lt;a href=&quot;https://en.wikipedia.org/wiki/Gordon_Welchman&quot;&gt;Gordon Welchman&lt;/a&gt;发明了一种电路，叫做diagonal board，才使Bombe能够投入实用。关于Gordon Welchman的故事，你可以参考这个&lt;a href=&quot;https://www.youtube.com/watch?v=t8gPED2veig&quot;&gt;BBC纪录片&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;在Bombe能够投入使用之前，有一个叫&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Herivel_tip&quot;&gt;John Herivel&lt;/a&gt;的人，发现了一种特殊的技巧，叫做Herivel tip，这种技术在Bombe投入使用之前几个月就已经投入实用，破解掉很多德军的消息，立下汗马功劳。如果Herivel tip没有被发明，盟军可能在1940年5月就已经战败，BOMBE也就根本没机会派上用场。&lt;/p&gt;&lt;p&gt;同时在Bletchley Park，还诞生了一台大型可编程电子计算机&lt;a href=&quot;http://www.cryptomuseum.com/crypto/colossus/index.htm&quot;&gt;Colossus&lt;/a&gt;，它是由一个叫&lt;a href=&quot;https://en.wikipedia.org/wiki/Tommy_Flowers&quot;&gt;Tommy Flowers&lt;/a&gt;的工程师设计的。Colossus不是用来破解Enigma密码的，而是用于破解&lt;a href=&quot;http://www.cryptomuseum.com/crypto/lorenz/sz40/index.htm&quot;&gt;Lorenz SZ-40&lt;/a&gt;。那是一种比Enigma还要先进的密码机器，用于发送希特勒的最高指令。&lt;/p&gt;&lt;p&gt;德国人后来又改进了他们的通信方式，使用了一种具有四个齿轮的Enigma机器。这大大的增加了破解的难度，普通的Bombe机器也破不了它了。后来是&lt;a href=&quot;https://en.wikipedia.org/wiki/Harold_Keen&quot;&gt;Harold Keen&lt;/a&gt;设计了一个叫做Mammoth的机器，后来加上美国海军的帮助，制造了更快的Bombe，才得以破解。&lt;/p&gt;&lt;p&gt;所以你看到了，所有这些人的工作加起来，才改善了二战的局面。波兰人的BOMBA，已经包含了最重要的思想。图灵的工作其实更多是量的改进，而不是质的飞跃。现在很多人喜欢跟风，片面的夸大图灵在其中的作用，这是不对的。如果你对Enigma机器的技术细节感兴趣，可以参考这两个视频：[&lt;a href=&quot;https://www.youtube.com/watch?v=G2_Q9FoD-oQ&quot;&gt;视频1&lt;/a&gt;][&lt;a href=&quot;https://www.youtube.com/watch?v=V4V2bpZlqx8&quot;&gt;视频2&lt;/a&gt;]。&lt;/p&gt;&lt;h3&gt;理论计算机科学&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://abstrusegoose.com/206&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-c0c3a9d622234896.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;图灵被称为“计算机之父”，计算机科学界的最高荣誉，被叫做“图灵奖”（Turing Award）。然而如果你深入的理解了计算理论和程序语言理论就会发现，图灵对于理论计算机科学，其实并没产生长远而有益的影响。在某种程度上说，他其实帮了一个倒忙。图灵的理论复杂不堪，给人们造成很大的误导，阻碍了计算机科学的发展。而且他对于发表论文，对待研究的态度让我怀疑，我觉得图灵本人其实就是当今计算机学术界的一些不正之风的鼻祖。&lt;/p&gt;&lt;h4&gt;图灵机和lambda演算&lt;/h4&gt;&lt;p&gt;绝大部分计算机专业的人提到图灵，就会想起图灵机（Turing Machine）。稍微有点研究的人，可能知道图灵机与lambda演算在计算能力上的等价性。然而在“计算能力”上等价，并不等于说它们具有同样的价值，随便用哪个都无所谓。科学研究有一条通用的原则：如果多个理论可以解释同样的现象，取最简单的一个。虽然lambda演算和图灵机能表达同样的理论，却比图灵机简单，优雅，实用很多。&lt;/p&gt;&lt;p&gt;计算理论（Theory of Computation）这个领域，其实是被图灵机给复杂化了。图灵机的设计是丑陋，复杂，缺乏原则的。它的读写头，纸带，状态，操作，把本来很简单的语义搞得异常复杂。图灵机的读写两种操作同时发生，这恰好是编程上最忌讳的一种错误，类似于C语言的&lt;code&gt;i++&lt;/code&gt;。图灵机是如此的复杂和混淆，以至于你很难看出它到底要干什么，也很难用它清晰地表达自己的意思。这就是为什么每个人上“计算理论”课程，都会因为图灵机而头痛。如果你挖掘一点历史，也许会发现图灵机的原型，其实是图灵母亲使用的打字机。用一台打字机来建模所有的计算，这当然是可行的，然而却复杂不堪。&lt;/p&gt;&lt;p&gt;相比之下，lambda演算更加简单，优雅，实用。它是一个非常有原则的设计。Lambda演算不但能清晰地显示出你想要表达的意思，而且有直接的“物理实现”。你可以自然的把一个lambda演算表达式，看成是一个电子线路模块。对于现实的编程语言设计，系统设计，lambda演算有着巨大的指导和启发意义。以至于很多&lt;a href=&quot;https://existentialtype.wordpress.com/2011/03/16/languages-and-machines&quot;&gt;理解lambda演算的人&lt;/a&gt;都搞不明白，图灵机除了让一些理论显得高深莫测，还有什么存在的意义。&lt;/p&gt;&lt;h4&gt;历史的倒退&lt;/h4&gt;&lt;p&gt;图灵机比起lambda演算来说，其实是一个&lt;a href=&quot;http://www.users.waitrose.com/~hindley/SomePapers_PDFs/2006CarHin,HistlamRp.pdf&quot;&gt;历史&lt;/a&gt;的倒退。1928年，Alonzo Church发明了lambda演算（当时他25岁）。Lambda演算被设计为一个通用的计算模型，并不是为了解决某个特定的问题而诞生的。1929年，Church成为普林斯顿大学教授。1932年，Church在Annals of Mathematics发表了一篇&lt;a href=&quot;https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/church.pdf&quot;&gt;论文&lt;/a&gt;，纠正逻辑领域里几个常见的问题，他的论述中用了lambda演算。1935年，Church发表&lt;a href=&quot;http://www.jstor.org/stable/2371045&quot;&gt;论文&lt;/a&gt;，使用lambda演算证明基本数论中存在不可解决的问题。1936年4月，Church发表了一篇两页纸的“&lt;a href=&quot;https://users.fit.cvut.cz/~staryja2/MIVYC/church-a-note-on-the-entscheidungsproblem.pdf&quot;&gt;note&lt;/a&gt;”，指出自己1935年那篇论文可以推论得出，著名的Hilbert“&lt;a href=&quot;https://en.wikipedia.org/wiki/Entscheidungsproblem&quot;&gt;可判定性问题&lt;/a&gt;”是不可解决的。&lt;/p&gt;&lt;p&gt;1936年5月，当时还在剑桥读硕士的图灵，也写了一篇论文，使用自己设计的一种“计算机器”（后来被叫做图灵机）来证明同一个问题。图灵的论文投稿，比Church最早的结论发表，晚了整整一年。编辑从来没见过图灵机这样的东西，而且它纷繁复杂，远没有lambda演算来得优雅。就像所有人对图灵机的第一印象一样，编辑很难相信这打字机一样的操作方式，能够容纳“所有的计算”。他无法确定图灵的论述是否正确，只好找人帮忙。Church恐怕是当时世界上唯一能够验证图灵的论文正确性的人。所以一番好心之下，编辑写了封信给Church，说：“这个叫图灵的年轻人很聪明，他写了一篇论文，使用一种机器来证明跟你一样的结果。他会把论文寄给你。如果你发现他的结果是正确的而且有用，希望你帮助他拿到奖学金，进入Princeton跟你学习。”&lt;/p&gt;&lt;p&gt;图灵就是这样成为了Church的学生，然而图灵心高气傲，恐怕从来没把Church当成过老师，反倒总觉得Church抢先一步，破坏了自己名垂青史的机会。跟Church的其它学生不一样，图灵没能理解lambda演算的精髓，却认为自己的机器才是最伟大的发明。进入Princeton之后，图灵不虚心请教，只是一心想发表自己的论文，想让大家对自己的“机器”产生兴趣，结果遭到很大的挫折。当然了，一个名不见经传的人，做了个怪模怪样的机器，说它可以囊括宇宙里所有的计算，你不被当成民科才怪呢！&lt;/p&gt;&lt;p&gt;1937年，在Church的帮助下，图灵的那篇&lt;a href=&quot;http://plms.oxfordjournals.org/content/s2-42/1/230.full.pdf+html&quot;&gt;论文&lt;/a&gt;（起名为《Computable Numbers》）终于发表了。Church还是很器重图灵的，他把图灵的机器叫做“图灵机”。不幸的是，论文发表之后，学术界对此几乎没有任何反响，只有两人向图灵索取这篇论文。图灵当然不爽了，于是后来就到处推销自己的图灵机，想让大家承认那是伟大的发明。有了一个锤子，看什么都是钉子。后来每到一个地方，每做一个项目（见下一节），他都想把问题往自己那篇论文和图灵机上靠，东拉西扯的想证明它的价值，甚至称别人发明的东西全都是受到了图灵机的启发…… 经过人们很长的时间的以讹传讹之后，他终于成功了。&lt;/p&gt;&lt;p&gt;图灵当年的作法，其实跟当今计算机学术界的普遍现象差不多。我想发表自己的想法A，结果别人已经发表了B，解决了A要解决的问题，而且还比A简单和清晰。怎么办呢？首先，我声明自己从没看过B的论文，这样就可以被称为“独立的发现”。然后，我证明A和B在“本质”上是等价的。最后，我东拉西扯，挖掘一下B的局限性，A相对于B在某些边沿领域的优势…… 这样反复折腾，寻找A的优势，总有一天会成功发表的。一旦发表成功，就会有人给我唱高调，没用的东西也要说成是有用的。他们会在A的基础上发展他们自己的东西，最后把我推崇为大师。那发表更早，更简单优美的B，也就无人问津了。胜利！&lt;/p&gt;&lt;p&gt;现在不得不说一下《图灵传》对此的歪曲。Church的论文发表，比图灵的论文投稿还早一年，而且Church使用了比图灵机更简单优雅的计算模型。Church的成果本来天经地义应该受到更多的尊重，到头来作者却说：“...and Turing was &lt;em&gt;robbed&lt;/em&gt; of the full reward for his originality”（见第3节“&lt;a href=&quot;http://www.turing.org.uk/publications/dnb.html&quot;&gt;The Turing machine&lt;/a&gt;”）。让人感觉貌似是Church用不正当的手段“抢走”了图灵的“原创性”一样。你本来没有什么原创性，还丑陋复杂，所以何谈抢走呢？我怎么觉得恰恰相反，其实是图灵抢走了Church的原创性？现在提起Hilbert可判定性问题，可计算性理论，人们都想起图灵，有谁还想得起Church，有谁知道他是第一个解决了这问题的人，有谁知道他用了更优美的办法？&lt;/p&gt;&lt;h4&gt;Lambda演算与计算理论&lt;/h4&gt;&lt;p&gt;由于图灵到处推销自己的理论，把不好的东西说成是好的，把别人发明的机器硬往自己的理论上面靠，说他们受到了图灵机的“启发”，以至于很多人被蛊惑，以为它比起lambda演算确实有优势。再加上很多人为了自己的利益而以讹传讹，充当传教士，这就是为什么图灵机现在被人们普遍接受作为计算模型。然而这并不能改变它丑陋和混淆的本质。图灵机的设计，其实是专门为了证明Hilbert的可判定性问题不可解决，它并不是一个用途广泛的计算模型。图灵机之所以被人接受，很大部分原因在于人的无知和愚蠢。很多人（包括很多所谓“理论计算机科学家”）根本没好好理解过lambda演算，他们望文生义，以为图灵机是“物理的”，实际可用的“机器”，而lambda演算只是一个理论模型。&lt;/p&gt;&lt;p&gt;事实恰恰相反：lambda演算其实非常的实用，它的本质跟电子线路没什么两样。几乎所有现实可用的程序语言，其中的语义全都可以用lambda演算来解释。而图灵机却没有很多现实的意义，用起来非常蹩脚，所以只能在计算理论中作为模型。另外一个更加鲜为人知的事实是：lambda演算其实在计算理论方面也可以完全取代图灵机，它不但可以表达所有图灵机能表达的理论，而且能够更加简洁和精确地表达它们。&lt;/p&gt;&lt;p&gt;很多理论计算机科学家喜欢用图灵机，仿佛是因为用它作为模型，能让自己的理论显得高深莫测，晦涩难懂。普通的计算理论课本，往往用图灵机作为它的计算模型，使用苦逼的办法推导各种可计算性（computability）和复杂性（complexity）理论。特别是像Michael Sipser那本经典的&lt;a href=&quot;http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X&quot;&gt;计算理论教材&lt;/a&gt;，晦涩难懂，混淆不堪，有时候让我都怀疑作者自己有没有搞懂那些东西。&lt;/p&gt;&lt;p&gt;后来我发现，其实图灵机所能表达的理论，全都可以用更加简单的lambda演算（或者任何一种现在流行的程序语言）来表示。图灵机的每一个状态，不过对应了lambda演算（或者某种程序语言）里面的一个“AST节点”，然而用lambda演算来表示那些计算理论，却可以比图灵机清晰和容易很多。在Indiana大学做计算理论课程助教的时候，我把这种思维方式悄悄地讲述给了上课的学生们，他们普遍表示我的这种思维方式更易理解，而且更加贴近实际的编程。&lt;/p&gt;&lt;p&gt;举一个很简单的例子。我可以用一行lambda演算表达式，来显示Hilbert的“可判定性问题”是无解的：&lt;/p&gt;&lt;p&gt;&lt;code&gt;Halting(λm.not(Halting(m,m)), λm.not(Halting(m,m)))&lt;/code&gt;&lt;/p&gt;&lt;p&gt;完整的证明不到一页纸，请看我的另外一篇&lt;a href=&quot;https://yinwang0.wordpress.com/2012/10/25/halting&quot;&gt;文章&lt;/a&gt;（英文）。这也就是图灵在他的&lt;a href=&quot;http://plms.oxfordjournals.org/content/s2-42/1/230.full.pdf+html&quot;&gt;论文&lt;/a&gt;里，折腾了十多页纸证明的东西。&lt;/p&gt;&lt;p&gt;我曾经以为自己是唯一知道这个秘密的人，直到有一天我把这个秘密告诉了我的博士导师，Amr Sabry。他对我说：“哈哈！其实我早就知道这个，你可以参考一下Neil Jones写的一本书，叫做《Computability and Complexity: From a Programming Perspective》。这本书现在已经可以&lt;a href=&quot;http://www.diku.dk/~neil/comp2book2007/book-whole.pdf&quot;&gt;免费下载&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;此书作者用一种很简单的程序语言，阐述了一般人用图灵机来描述的那些理论（可计算性理论，复杂性理论）。他发现用程序语言来描述计算理论，不但简单直接，清晰明了，而且在某些方面可以更加精确地描述图灵机无法描述的定理。得到这本书，让我觉得如获至宝，原来世界上有跟我看法如此相似，对事物洞察力如此之高的人！&lt;/p&gt;&lt;p&gt;在一次会议上，我有幸地遇到了Neil Jones，跟他切磋思想。当提到这本书的模型与图灵理论的关系，老教授谦虚地说：“图灵的模型还是有它的价值的……” 然而到最后，他其实也没能说清楚这价值何在。我心里很清楚，他只是为了避免引起宗教冲突，或者避免显得狂妄自大，而委婉其词。眼前的这位教授，虽然从来没有得过图灵奖，很少有人听说过他的名字，然而他对于计算本质的理解，却比图灵本人还要高出很多。&lt;/p&gt;&lt;p&gt;总的说来，图灵机也许不是一文不值，然而由于lambda演算可以更加清晰地解释图灵机能表示的所有理论，图灵机的价值相对来说几乎为零。Church在1937年给图灵论文写的&lt;a href=&quot;http://www.jstor.org/stable/2268810&quot;&gt;Review&lt;/a&gt;指出，图灵机的优势，在于它可以让不懂很多数学，不理解lambda演算之类理论的人也可以看得懂。我怎么觉得图灵机对于不懂很多数学的人，理解起来其实更加痛苦呢？而且就算它真的对“外行”或者“笨人”的理解有好处，这价值貌似也不大吧？:P&lt;/p&gt;&lt;h3&gt;电子计算机&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-994f2434c9330f8b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;很多“理论计算机科学家”喜欢说，大家现在用的计算机，只不过是一个“Universal Turing Machine”。就算你根本不知道图灵是谁，自己辛苦设计出一个机器或者语言，他们总喜欢说：“是图灵启发了你，因为你那东西是跟图灵机等价的，是图灵完备的……”&lt;/p&gt;&lt;p&gt;那么现在让我们来看看，图灵本人和他的理论，真正对电子计算机的发展起过多大的作用吧。如果一个人对一个行业起过重大的作用，那我们可以说“没有他不行”。然而事实却是，即使没有图灵，计算机技术会照样像今天一样发展，丝毫不会受到影响。看一看历史，你也许会惊讶的发现，图灵的理论不但没能启发任何计算机的设计，而且图灵亲自设计的唯一一个计算机（ACE），最后也以悲惨的失败告终。&lt;/p&gt;&lt;h4&gt;什么是Universal Turing Machine（UTM）&lt;/h4&gt;&lt;p&gt;ACE失败的一个重要原因，是因为图灵过度的看重他自己发明的Universal Turing Machine（UTM）。所以我想首先来解密一下，这个被很多人吹得神乎其神的，似乎什么都可以往上面扯的UTM，到底是什么东西。&lt;/p&gt;&lt;p&gt;说白了，UTM就是一个&lt;a href=&quot;http://www.yinwang.org/blog-cn/2012/08/01/interpreter&quot;&gt;解释器&lt;/a&gt;，就像Python或者JavaScript的解释器一样。计算机的处理器（CPU）也是一个解释器，它是用来解释机器指令的。那这样说来，任何可编程，具有指令集的机器都是UTM了，所以图灵的理论启发了所有这些机器？你尽管跟我扯吧 :)&lt;/p&gt;&lt;p&gt;你应该知道，在图灵的UTM出现以前，Church的lambda演算里面早就有&lt;a href=&quot;https://github.com/yinwang0/lightsabers/blob/master/meta-interp.ss&quot;&gt;解释器&lt;/a&gt;的概念了，所以UTM根本不是什么新东西，而且它比起lambda演算的解释器，真是丑陋又复杂。而Church其实也不是第一个提出解释器这概念的人，像这类通用的概念，已经很难追溯是谁“发明”的了。也许并不是某一个人发明了它，而是历史上的很多人。&lt;/p&gt;&lt;p&gt;解释器这个概念的涵义实在是包罗万象，几乎无处不在。只要是“可编程”的机器，它本质上必然包含一个解释器。一个工程师在不知道解释器这概念的情况下，照样很有可能“不小心”设计出一个可编程的机器，所以如果你把这些全都归结成图灵或者Church的功劳，就太牵强了。&lt;/p&gt;&lt;h4&gt;图灵与ACE的故事&lt;/h4&gt;&lt;p&gt;事实上，最早的电子计算机，并不是图灵设计的，而是电子工程师跟其他一些数学家合作的结果。根据老一辈工程师的&lt;a href=&quot;http://www.bbc.com/news/technology-18327261&quot;&gt;叙述&lt;/a&gt;，图灵的工作和理论，对于现实的电子计算机设计，几乎没有任何的正面作用。很多工程师其实根本不知道图灵是谁，图灵机是什么。他们只是根据实际的需求，设计和制造了那些电路。这就是为什么我们今天看到的电子计算机，跟图灵机或者图灵的其他理论几乎完全不搭边。&lt;/p&gt;&lt;p&gt;世界上最早的两台电子计算机，ENIAC和EDVAC，都是美国人设计制造的。其中EDVAC的设计报告，是冯诺依曼（von Neumann）参与并签署的。提到EDVAC的设计，《图灵传》有一段有趣的介绍，它基本是这样说的：“冯诺依曼在Princeton的时候，很了解图灵开天辟地的发明—UTM。UTM只有一根纸带，而EDVAC把指令和数据放在同一个存储空间，所以EDVAC的设计肯定是受了UTM的启发。然而EDVAC的设计报告，却只字不提图灵和UTM的名字，更没有引用图灵划时代的论文《Computable Numbers》……”&lt;/p&gt;&lt;p&gt;这其实是在含沙射影的说，冯诺依曼和EDVAC团队抄袭了图灵的研究成果。照这种歪理，我洗衣服的时候，袜子和内裤放在同一个桶里洗，也是受了图灵的启发了，就因为UTM只有一条纸带？这世界上的事物，还有啥不是受了UTM启发的？这让我想起某些全靠打专利官司赚钱的公司（&lt;a href=&quot;https://en.wikipedia.org/wiki/Patent_troll&quot;&gt;patent troll&lt;/a&gt;）…… 冯诺依曼作为一代数学大师，比UTM重大的研究成果多得是了，他会在乎抄袭图灵的东西吗？其实人家恐怕是根本没把图灵和他的论文当回事。而且其他人（比如Church）早就有跟UTM等价的想法，而且还更好，更简单。之前抢了Church的风头，现在居然欺到冯诺依曼头上来了。哎，真受不了这种一辈子只想出过一个点子的人……&lt;/p&gt;&lt;p&gt;所以听说美国人造出了EDVAC，图灵开始各种羡慕嫉妒恨，感叹自己英才无用武之地。终于有一天，他的机会来了。在EDVAC诞生几个月之后，英国国家物理实验室（NPL）联系了图灵。他们想赶上美国的计算机技术发展，所以想招募图灵，让他帮忙山寨一个EDVAC的“英国特色版本”。图灵设计的机器叫做&lt;a href=&quot;https://en.wikipedia.org/wiki/Automatic_Computing_Engine&quot;&gt;ACE&lt;/a&gt;（Automatic Computing Engine）。最初，图灵给NPL一个很宏伟的蓝图：ACE可以如此的强大，以至于整个英国只需要这样一台计算机就够了，我们可以把它叫做“英国国家计算机”…… 然而再大的口号，也难逃脱现实的检验，ACE项目最终以失败告终。&lt;/p&gt;&lt;p&gt;《图灵传》把ACE失败的责任，推托到NPL和其它人的“近视”和“官僚”，然而ACE失败的主要责任，其实在于图灵自己：他完全没有设计一台现实的计算机的基本技能，却总是自以为是，设立高大空的目标。图灵的设计跟当时（包括现在的）所有实用的计算机都有巨大的差别。不出你所料，他最初的设计思路，是根据自己之前的论文《Computable Numbers》里提到的“Universal Turing Machine”，不过从中去掉了一些不实际的设计，比如用一根纸带来存储数据。这一点改进貌似做对了，可是呢，他又加入了一些让工程师们无语的设计，美其名曰“极简设计”（minimalism）。比如，ACE的硬件只提供AND, OR, NOT之类的逻辑运算作为“基本操作”，其它的算数操作，包括加减乘除，全部用代码来实现。图灵大师啊，你知不知道有一种重要的指标，叫做“效率”？&lt;/p&gt;&lt;p&gt;这还不算…… 后来他更加异想天开，终于扯上了“思考机器”（thinking machines）—他想让ACE成为可以像人一样思考的机器，还想让这机器能够自己写自己的代码。按照图灵的原话：“在ACE的工作中，我对人脑建模的兴趣，比实际的计算应用更感兴趣。” 他显然已经把ACE当成了自己一个人的玩具，而不再是解决人们实际需求的工具。只要有人反对这想法，他就会嘲笑说，你是怕我的机器太聪明了，抢了你的饭碗吧？其实图灵对于实际的人脑工作原理所知甚少，基本处于初中生理卫生课本水平，然而他总喜欢对人说，人脑不过就是一个UTM。看吧，它有输入，输出，状态转换，就跟UTM一样…… 所谓“图灵测试”（Turing Test），就是那时候提出来的。当然了，因为他扯到了“thinking machine”，就有后人把他称为人工智能（AI）的鼻祖。其实呢，图灵测试根本就不能说明一个机器具有了人的智能，它只是在测试一些肤浅的表象。后来，“&lt;a href=&quot;https://en.wikipedia.org/wiki/Thinking_Machines_Corporation&quot;&gt;thinking machines&lt;/a&gt;”成为了一种通用的幌子，用于筹集大笔科研经费，最后全都血本无归。&lt;/p&gt;&lt;p&gt;图灵设计了这机器，NPL当时却没有能力制造它。于是他们求助于另外两位实现过计算机的工程师：&lt;a href=&quot;https://en.wikipedia.org/wiki/Frederic_Calland_Williams&quot;&gt;F. C. Williams&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Maurice_Wilkes&quot;&gt;Maurice Wilkes&lt;/a&gt;（后来EDSAC计算机的设计者），请他们帮忙实现图灵的设计。可想而知，Williams和Wilkes都表示不喜欢ACE的设计，而且指出图灵的性格与自己的研究风格不匹配，不愿跟他合作，所以双双拒绝了NPL的邀请。最后，NPL新成立了一个电子部门，ACE的工程终于可以开始。然而，根据资深工程师们的讨论，觉得图灵提出的制造一个“电子人脑”和“智能机器”，并不是实际可行，或者在短期之内能派上用场的项目，所以决定做一些实际点的事情。图灵对此非常恼火，各种抱怨，说别人官僚啊，近视啊，没想象力啊之类的，然后开始公开的抵制NPL的决定。&lt;/p&gt;&lt;p&gt;最后工程师们和管理层都受不了他了，鉴于他名声在外，又不好意思开掉他，只好提出一个破天荒的提议：由NPL资助，让图灵回到剑桥大学去度年假（sabbatical），做一些纯数学的研究。于是ACE在图灵不在的情况下，终于开工了⋯⋯1950年，ACE运行了它的第一个程序。然而工程师们实现的ACE，完全偏离了图灵的设计，以至于实际的机器和图灵的设计之间，几乎没有任何相似性。一年之后，图灵还想回到NPL，继续影响ACE的设计，然而NPL的领导们却建议他继续留在大学里做纯理论的研究，并且让曼彻斯特大学给他一个职位。最后图灵接受了这个建议，这下大家伙儿都松了一口气…… :P&lt;/p&gt;&lt;p&gt;图灵设计的唯一一个计算机ACE，终究以图灵完全退出整个项目而告终。今天回头看来，如果当时图灵留下来了，NPL真的按照图灵的意思来做，ACE恐怕直到今天都造不出来。由于图灵不切实际的设计和高傲的性格，NPL失去了最优秀的人的帮助。1949年，Maurice Wilkes按照EDVAC的思路，成功制造了&lt;a href=&quot;https://en.wikipedia.org/wiki/Electronic_Delay_Storage_Automatic_Calculator&quot;&gt;EDSAC&lt;/a&gt;，速度是ACE的两倍以上，而且更加实用。所以你看到了，图灵并不是一个实干家，他的双脚飘在半空中。他的理论，他设计的机器，他的代码，全都停留在纸上。他并没有帮助造出任何一台实际可用的计算机，他对计算机的工程实现几乎没有任何有益的影响。可惜的是，有些人喜欢把实干家们千辛万苦造出来，真正可以用的东西，牵强附会地归功于某些高谈阔论的理论家，仿佛那是理论家的功劳似的。这也许就是为什么图灵被他们称为“计算机之父”吧。&lt;/p&gt;&lt;p&gt;如果对ACE和其它早期计算机感兴趣，你可以参考一下更详细的&lt;a href=&quot;http://ed-thelen.org/comp-hist/EarlyBritish-05-12.html#Ch-05&quot;&gt;资料&lt;/a&gt;。你也可以看一看《图灵传》，虽然它观点荒唐，对图灵各种偏袒，然而图灵和其他人的通信，基本的史实，他应该不好意思篡改。&lt;/p&gt;&lt;h3&gt;总结&lt;/h3&gt;&lt;p&gt;我说这些是为了什么呢？我当然不是想否认图灵所做出的贡献。像许多的计算机工作者一样，他的某些工作当然是有意义的。然而那种意义并不像很多人所吹嘘的那么伟大，它们甚至不包含很多的创新。&lt;/p&gt;&lt;p&gt;我觉得很多后人给图灵带上的光环，掩盖了太多其它值得我们学习和尊敬的人，给人们对于计算机科学的概念造成了误导。计算机科学不是图灵一个人造出来的，图灵并不是计算机科学的鼻祖，他甚至不是在破解Enigma密码和电子计算机诞生过程中起最重要作用的人。&lt;/p&gt;&lt;p&gt;许许多多的计算机科学家和电子工程师们，是他们造就了今天的计算科学。他们的聪明才智和贡献，不应该被图灵的光环所掩盖，他们应该受到像跟图灵一样的尊敬。希望大家不要再神化图灵，不要再神化任何人。不要因为膜拜某些人，而失去向另一些人学习的机会。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">turing</guid>
<pubDate>Sun, 18 Oct 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>谈谈Parser</title>
<link>http://yinwang.org/blog-cn/2015/09/19/parser</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;谈谈Parser&lt;/h2&gt;&lt;p&gt;一直很了解人们对于parser的误解，可是一直都提不起兴趣来阐述对它的观点。然而我觉得是有必要解释一下这个问题的时候了。我感觉得到大部分人对于parser的误解之深，再不澄清一下，恐怕这些谬误就要写进歪曲的历史教科书，到时候就没有人知道真相了。&lt;/p&gt;&lt;h3&gt;什么是Parser&lt;/h3&gt;&lt;p&gt;首先来科普一下。所谓parser，一般是指把某种格式的文本（字符串）转换成某种数据结构的过程。最常见的parser，是把程序文本转换成编译器内部的一种叫做“抽象语法树”（AST）的数据结构。也有简单一些的parser，用于处理CSV，JSON，XML之类的格式。&lt;/p&gt;&lt;p&gt;举个例子，一个处理算数表达式的parser，可以把“1+2”这样的，含有&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;+&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt;三个字符的字符串，转换成一个对象（object）。这个对象就像&lt;code&gt;new BinaryExpression(ADD, new Number(1), new Number(2))&lt;/code&gt;这样的Java构造函数调用生成出来的那样。&lt;/p&gt;&lt;p&gt;之所以需要做这种从字符串到数据结构的转换，是因为编译器是无法直接操作“1+2”这样的字符串的。实际上，代码的本质根本就不是字符串，它本来就是一个具有复杂拓扑的数据结构，就像电路一样。“1+2”这个字符串只是对这种数据结构的一种“编码”，就像ZIP或者JPEG只是对它们压缩的数据的编码一样。&lt;/p&gt;&lt;p&gt;这种编码可以方便你把代码存到磁盘上，方便你用文本编辑器来修改它们，然而你必须知道，文本并不是代码本身。所以从磁盘读取了文本之后，你必须先“解码”，才能方便地操作代码的数据结构。比如，如果上面的Java代码生成的AST节点叫&lt;code&gt;node&lt;/code&gt;，你就可以用&lt;code&gt;node.operator&lt;/code&gt;来访问&lt;code&gt;ADD&lt;/code&gt;，用&lt;code&gt;node.left&lt;/code&gt;来访问&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;node.right&lt;/code&gt;来访问&lt;code&gt;2&lt;/code&gt;。这是很方便的。&lt;/p&gt;&lt;p&gt;对于程序语言，这种解码的动作就叫做parsing，用于解码的那段代码就叫做parser。&lt;/p&gt;&lt;h3&gt;Parser在编译器中的地位&lt;/h3&gt;&lt;p&gt;那么貌似这样说来，parser是编译器里面很关键的一个部分了？显然，parser是必不可少的，然而它并不像很多人想象的那么重要。Parser的重要性和技术难度，被很多人严重的夸大了。一些人提到“编译器”，就跟你提LEX，YACC，ANTLR等用于构造parser的工具，仿佛编译器跟parser是等价的似的。还有些人，只要听说别人写了个parser，就觉得这人编程水平很高，开始膜拜了。这些其实都显示出人的肤浅。&lt;/p&gt;&lt;p&gt;我喜欢把parser称为“万里长征的第0步”，因为等你parse完毕得到了AST，真正精华的编译技术才算开始。一个先进的编译器包含许多的步骤：语义分析，类型检查/推导，代码优化，机器代码生成，…… 这每个步骤都是在对某种中间数据结构（比如AST）进行分析或者转化，它们完全不需要知道代码的字符串形式。也就是说，一旦代码通过了parser，在后面的编译过程里，你就可以完全忘记parser的存在。所以parser对于编译器的地位，其实就像ZIP之于JVM，就像JPEG之于PhotoShop。Parser虽然必不可少，然而它比起编译器里面最重要的过程，是处于一种辅助性，工具性，次要的地位。&lt;/p&gt;&lt;p&gt;鉴于这个原因，好一点的大学里的程序语言（PL）课程，都完全没有关于parser的内容。学生们往往直接用Scheme这样代码数据同形的语言，或者直接使用AST数据结构来构造程序。在Kent Dybvig这样编译器大师的课程上，学生直接跳过parser的构造，开始学习最精华的语义转换和优化技术。实际上，Kent Dybvig根本不认为parser算是编译器的一部分。因为AST数据结构其实才是程序本身，而程序的文本只是这种数据结构的一种编码形式。&lt;/p&gt;&lt;h3&gt;Parser技术发展的误区&lt;/h3&gt;&lt;p&gt;既然parser在编译器中处于次要的地位，可是为什么还有人花那么大功夫研究各种炫酷的parser技术呢。LL，LR，GLR，LEX, YACC，Bison，parser combinator，ANTLR，PEG，…… 制造parser的工具似乎层出不穷，每出现一个新的工具都号称可以处理更加复杂的语法。&lt;/p&gt;&lt;p&gt;很多人盲目地设计复杂的语法，然后用越来越复杂的parser技术去parse它们，这就是parser技术仍然在发展的原因。其实，向往复杂的语法，是程序语言领域流传非常广，危害非常大的错误倾向。在人类历史的长河中，留下了许多难以磨灭的历史性糟粕，它们固化了人类对于语言设计的理念。很多人设计语言似乎不是为了拿来好用的，而是为了让用它的人迷惑或者害怕。&lt;/p&gt;&lt;p&gt;有些人假定了数学是美好的语言，所以他们盲目的希望程序语言看起来更加像数学。于是他们模仿数学，制造了各种奇怪的操作符，制定它们的优先级，这样你就可以写出&lt;code&gt;2 &amp;lt;&amp;lt; 7 - 2 * 3&lt;/code&gt;这样的代码，而不需要给子表达式加上括号。还有很多人喜欢让语法变得“简练”，就为了少打几个括号，分号，花括号，…… 可是由此带来的结果是复杂，不一致，有多义性，难扩展的语法，以及障眼难读，模棱两可的代码。&lt;/p&gt;&lt;p&gt;更有甚者，对数学的愚蠢做法执迷不悟的人，设计了像Haskell和Coq那样的语言。在Haskell里面，你可以在代码里定义新的操作符，指定它的“结合律”（associativity）和“优先级”（precedence）。这样的语法设计，要求parser必须能够在parse过程中途读入并且加入新的parse规则。Coq试图更加“强大”一些，它让你可以定义“mixfix操作符”，也就是说你的操作符可以连接超过两个表达式。这样你就可以定义像&lt;code&gt;if...then...else...&lt;/code&gt;这样的“操作符”。&lt;/p&gt;&lt;p&gt;制造这样复杂难懂的语法，其实没有什么真正的好处。不但给程序员的学习造成了不必要的困难，让代码难以理解，而且也给parser的作者带来了严重的挑战。可是有些人就是喜欢制造问题，就像一句玩笑话说的：有困难要上，没有困难，制造困难也要上！&lt;/p&gt;&lt;p&gt;如果你的语言语法很简单（像Scheme那样），你是不需要任何高深的parser理论的。说白了，你只需要知道如何parse匹配的括号。最多一个小时，几百行Java代码，我就能写出一个Scheme的parser。&lt;/p&gt;&lt;p&gt;可是很多人总是嫌问题不够有难度，于是他们不停地制造更加复杂的语法，甚至会故意让自己的语言看起来跟其它的不一样，以示“创新”。当然了，这样的语言就得用更加复杂的parser技术，这正好让那些喜欢折腾复杂parser技术的人洋洋得意。&lt;/p&gt;&lt;h3&gt;编译原理课程的误导&lt;/h3&gt;&lt;p&gt;程序员们对于parser的误解，很大程度上来自于大学编译原理课程照本宣科的教育。很多老师自己都不理解编译器的精髓，所以就只有按部就班的讲一些“死知识”，灌输“业界做法”。一般大学里上编译原理课，都是捧着一本大部头的“&lt;a href=&quot;http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools&quot;&gt;龙书&lt;/a&gt;”或者“&lt;a href=&quot;https://www.cs.princeton.edu/~appel/modern&quot;&gt;虎书&lt;/a&gt;”，花掉一个学期1/3甚至2/3的时间来学写parser。由于parser占据了大量时间，以至于很多真正精华的内容都被一笔带过：语义分析，代码优化，类型推导，静态检查，机器代码生成，…… 以至于很多人上完了编译原理课程，记忆中只留下写parser的痛苦回忆。&lt;/p&gt;&lt;p&gt;“龙书”之类的教材在很多人心目中地位是如此之高，被誉为“经典”，然而其实除了开头很大篇幅来讲parser理论，这本书其它部分的水准其实相当低。大部分学生的反应其实是“看不懂”，然而由于一直以来没有更好的选择，它经典的地位真是难以动摇。“龙书”后来的新版我浏览过一下，新加入了类型检查/推导的部分，可是我看得出来，其实作者们自己对于类型理论都是一知半解，所以也就没法写清楚，让人可以看懂了。&lt;/p&gt;&lt;p&gt;龙书作者的水平，跟Dan Friedman，Kent Dybvig这样真正的大师比起来，其实差的老远。如果你想真的深入理解编译理论，最好是从PL课程的读物，比如&lt;a href=&quot;http://www.eopl3.com&quot;&gt;EOPL&lt;/a&gt;开始。我可以说PL这个领域，真的是高于编译器领域的。请不要指望编译器的作者能够轻易设计出好的语言，因为他们可能根本不理解很多语言设计的东西，他们只是会按部就班地实现某些别人设计的语言。可是反过来，理解了PL的理论，编译器的东西只不过是把一种语言转换成另外一种语言（机器语言）而已。工程的细枝末节很麻烦，可是当你掌握了精髓的原理，那些都容易摸索出来。&lt;/p&gt;&lt;h3&gt;我写parser的心得和秘诀&lt;/h3&gt;&lt;p&gt;虽然我已经告诉你，给过度复杂的语言写parser其实是很苦逼，没有意思的工作，然而有些历史性的错误已经造成了深远的影响，所以很多时候虽然心知肚明，你也不得不妥协一下。由于像C++，Java，JavaScript，Python之类语言的流行，有时候你是被迫要给它们写parser。在这一节，我告诉你一些秘诀，也许可以帮助你更加容易的写出这些语言的parser。&lt;/p&gt;&lt;p&gt;很多人都觉得写parser很难，一方面是由于语言设计的错误思想导致了复杂的语法，另外一方面是由于人们对于parser构造过程的思维误区。很多人不理解parser的本质和真正的用途，所以他们总是试图让parser干一些它们本来不应该干的事情，或者对parser有一些不切实际的标准。当然，他们就会觉得parser非常难写，非常容易出错。&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尽量拿别人写的parser来用。维护一个parser是相当繁琐耗时，回报很低的事情。一旦语言有所改动，你的parser就得跟着改。所以如果你能找到免费的parser，那就最好不要自己写。现在的趋势是越来越多的语言在标准库里提供可以parse它自己的parser，比如Python和Ruby。这样你就可以用那语言写一小段代码调用标准的parser，然后把它转换成一种常用的数据交换格式，比如JSON。然后你就可以用通用的JSON parser解析出你想要的数据结构了。&lt;/p&gt;

&lt;p&gt;如果你直接使用别人的parser，最好不要使用它原来的数据结构。因为一旦parser的作者在新版本改变了他的数据结构，你所有的代码都会需要修改。我的秘诀是做一个“AST转换器”，先把别人的AST结构转换成自己的AST结构，然后在自己的AST结构之上写其它的代码，这样如果别人的parser修改了，你可以只改动AST转换器，其它的代码基本不需要修改。&lt;/p&gt;

&lt;p&gt;用别人的parser也会有一些小麻烦。比如Python之类语言自带的parser，丢掉了很多我需要的信息，比如函数名的位置，等等。我需要进行一些hack，找回我需要的数据。相对来说，这样小的修补还是比从头写一个parser要划得来。但是如果你实在找不到一个好的parser，那就只好自己写一个。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;很多人写parser，很在乎所谓的“one-pass parser”。他们试图扫描一遍代码文本就构造出最终的AST结构。可是其实如果你放松这个条件，允许用多pass的parser，就会容易很多。你可以在第一遍用很容易的办法构造一个粗略的树结构，然后再写一个递归树遍历过程，把某些在第一遍的时候没法确定的结构进行小规模的转换，最后得到正确的AST。&lt;/p&gt;

&lt;p&gt;想要一遍就parse出最终的AST，可以说是一种过早优化（premature optimization）。有些人盲目地认为只扫描一遍代码，会比扫描两遍要快一些。然而由于你必须在这一遍扫描里进行多度复杂的操作，最终的性能也许还不如很快的扫完第一遍，然后再很快的遍历转换由此生成的树结构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外一些人试图在parse的过程中做一些本来不属于它做的事情，比如进行一些基本的语义检查。有些人会让parser检查“使用未定义的变量”等语义错误，一旦发现就在当时报错，终止。这种做法其实混淆了parser的作用，造成了不必要的复杂性。&lt;/p&gt;

&lt;p&gt;就像我说的，parser其实只是一个解码器。parser要做的事情，应该是从无结构的字符串里面，解码产生有结构的数据结构。而像“使用未定义的变量”这样的语义检查，应该是在生成了AST之后，使用单独的树遍历来进行的。人们常常混淆“解码”，“语法”和“语义”三者的不同，导致他们写出过度复杂，效率低下，难以维护的parser。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另一种常见的误区是盲目的相信YACC，ANTLR之类所谓“parser generator”。实际上parser generator的概念看起来虽然美好，可是实际用起来几乎全都是噩梦。事实上最好的parser，比如EDG C++ parser，几乎全都是直接用普通的程序语言手写而成的，而不是自动生成的。&lt;/p&gt;

&lt;p&gt;这是因为parser generator都要求你使用某种特殊的描述语言来表示出语法，然后自动把它们转换成parser的程序代码。在这个转换过程中，这种特殊的描述语言和生成的parser代码之间，并没有很强的语义连接关系。如果生成的parser有bug，你很难从生成的parser代码回溯到语法描述，找到错误的位置和原因。你没法对语法描述进行debug，因为它只是一个文本文件，根本不能运行。&lt;/p&gt;

&lt;p&gt;所以如果你真的要写parser，我建议你直接用某种程序语言手写代码，使用普通的递归下降（recursive descent）写法，或者parser combinator的写法。只有手写的parser才可以方便的debug，而且可以输出清晰，人类可理解的出错信息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有些人喜欢死扣BNF范式，盲目的相信“LL”，“LR”等语法的区别，所以他们经常落入误区，说“哎呀，这个语法不是LL的”，于是采用一些像YACC那样的LR parser generator，结果落入非常大的麻烦。其实，虽然有些语法看起来不是LL的，它们的parser却仍然可以用普通的recursive descent的方式来写。&lt;/p&gt;

&lt;p&gt;这里的秘诀在于，语言规范里给出的BNF范式，其实并不是唯一的可以写出parser的做法。BNF只是一个基本的参照物，它让你可以对语法有个清晰的概念，可是实际的parser却不一定非得按照BNF的格式来写。有时候你可以把语法的格式稍微改一改，变通一下，却照样可以正确地parse原来的语言。其实由于很多语言的语法都类似于C，所以很多时候你写parser只需要看一些样例程序，然后根据自己的经验来写，而不需要依据BNF。&lt;/p&gt;

&lt;p&gt;Recursive descent和parser combinator写出来的parser其实可以非常强大，甚至可以超越所谓“上下文无关文法”，因为在递归函数里面你可以做几乎任意的事情，所以你甚至可以把上下文传递到递归函数里，然后根据上下文来决定对当前的节点做什么事情。而且由于代码可以得到很多的上下文信息，如果输入的代码有语法错误，你可以根据这些信息生成非常人性化的出错信息。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;总结&lt;/h3&gt;&lt;p&gt;所以你看到了，parser并不是编译器，它甚至不属于编译里很重要的东西。程序语言和编译器里面有比parser重要很多，有趣很多的东西。Parser的研究，其实是在解决一些根本不存在，或者人为制造的问题。复杂的语法导致了复杂的parser技术，它们仍然在给计算机世界带来不必要的困扰和麻烦。对parser写法的很多误解，过度工程和过早优化，造成了很多人错误的高估写parser的难度。&lt;/p&gt;&lt;p&gt;能写parser并不是什么了不起的事情，其实它是非常苦逼，真正的程序语言和编译器专家根本不屑于做的事情。所以如果你会写parser，请不要以为是什么了不起的事情，如果你看到有人写了某种语言的parser，也不要表现出让人哭笑不得的膜拜之情。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">parser</guid>
<pubDate>Sat, 19 Sep 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>数学和编程</title>
<link>http://yinwang.org/blog-cn/2015/07/04/math</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;数学和编程&lt;/h2&gt;&lt;p&gt;好些人来信问我，要成为一个好的程序员，数学基础要达到什么样的程度？十八年前，当我成为大学计算机系新生的时候，也为同样的问题所困扰。面对学数学，物理等学科的同学，我感到自卑。经常有人说那些专业的知识更加精华一些，难度更高一些，那些专业的人毕业之后如果做编程工作，水平其实比计算机系毕业的还要高。直到几年前深入研究程序语言之后，对这个问题我才得到了答案和解脱。由于好多编程新手遇到同样的困扰，所以我想在这里把这个问题详细的阐述一下。&lt;/p&gt;&lt;h3&gt;数学并不是计算机科学的基础&lt;/h3&gt;&lt;p&gt;很多人都盲目的认为，计算机科学是数学的一个分支，数学是计算机科学的基础，数学是更加博大精深的科学。这些人以为只要学会了数学，编程的事情全都不在话下，然而事实却并非如此。&lt;/p&gt;&lt;p&gt;事实其实是这样的：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;计算机科学其实根本不是数学，它只不过借用了非常少，非常基础的数学，比高中数学还要容易一点。所谓“高等数学”，在计算机科学里面基本用不上。&lt;/li&gt;
&lt;li&gt;计算机是比数学更加基础的工具，就像纸和笔一样。计算机可以用来解决数学的问题，也可以用来解决不是数学的问题，比如工程的问题，艺术的问题，经济的问题，社会的问题等等。&lt;/li&gt;
&lt;li&gt;计算机科学是完全独立的学科。学习了数学和物理，并不能代替对计算机科学的学习。你必须针对计算机科学进行学习，才有可能成为好的程序员。&lt;/li&gt;
&lt;li&gt;数学家所用的语言，比起常见的程序语言（比如C++，Java）来说，其实是非常落后而糟糕的设计。所谓“数学的美感”，其实大部分是夜郎自大。&lt;/li&gt;
&lt;li&gt;99%的数学家都写不出像样的代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;数学是异常糟糕的语言&lt;/h3&gt;&lt;p&gt;这并不是危言耸听。如果你深入研究过程序语言的理论，就会发现其实数学家们使用的那些符号，只不过是一种非常糟糕的程序语言。数学的理论很多是有用的，然而数学家门用于描述这些理论所用的语言，却是纷繁复杂，缺乏一致性，可组合性（composability），简单性，可用性。这也就是为什么大部分人看到数学就头痛。这不是他们不够聪明，而是数学语言的“&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/03/17/design&quot;&gt;设计&lt;/a&gt;”有问题。人们学习数学的时候，其实只有少部分时间在思考它的精髓，而大部分时间是在折腾它的语法。&lt;/p&gt;&lt;p&gt;举一个非常简单的例子。如果你说cos&lt;sup&gt;2&lt;/sup&gt;θ表示(cos θ)&lt;sup&gt;2&lt;/sup&gt;，那么理所当然，cos&lt;sup&gt;-1&lt;/sup&gt;θ就应该表示1/(cos θ)了？可它偏偏不是！别被数学老师们的教条和借口欺骗啦，他们总是告诉你：“你应该记住这些！” 可是你想过吗：“凭什么？” cos&lt;sup&gt;2&lt;/sup&gt;θ表示(cos θ)&lt;sup&gt;2&lt;/sup&gt;，而cos&lt;sup&gt;-1&lt;/sup&gt;θ，明明是一模一样的形式，表示的却是arccos θ。一个是求幂，一个是调用反函数，风马不及，却写成一个样子。这样的语言设计混淆不堪，却喜欢以“约定俗成”作为借口。&lt;/p&gt;&lt;p&gt;如果你再多看一些数学书，就会发现这只是数学语言几百年累积下来的糟粕的冰山一角。数学书里尽是各种上标下标，带括号的上标下标，x，y，z，a，b，c，f，g，h，各种扭来扭去的希腊字母，希伯来字母…… 斜体，黑体，花体，双影体，……用不同的字体来表示不同的“类型”。很多符号的含义，在不同的子领域里面都不一样。有些人上一门数学课，到最后还没明白那些符号是什么意思。&lt;/p&gt;&lt;p&gt;直到今天，数学家们写书仍然非常不严谨。他们常犯的一个错误是把x&lt;sup&gt;2&lt;/sup&gt;这样的东西叫做“函数”（function）。其实x&lt;sup&gt;2&lt;/sup&gt;根本不是一个函数，它只是一个表达式。你必须同时指明“x是参数”，加上x&lt;sup&gt;2&lt;/sup&gt;，才会成为一个函数。所以正确的函数写法其实看起来像这样：f(x) = x&lt;sup&gt;2&lt;/sup&gt;。或者如果你不想给它一个名字，可以借用lambda calculus的写法，写成：λx.x&lt;sup&gt;2&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;可是数学家们灰常的喜欢“约定俗成”。他们定了一些不成文的规矩是这样：凡是叫“x”的，都是函数的参数，凡是叫“y”的，都可能是一个函数…… 所以你写x&lt;sup&gt;2&lt;/sup&gt;就可以表示λx.x&lt;sup&gt;2&lt;/sup&gt;，而不需要显式的写出“λx”。殊不知这些约定俗成，看起来貌似可以让你少写几个字，却造成了许许多多的混淆和麻烦。比如，你在Mathematica里面可以对 &lt;a href=&quot;http://www.wolframalpha.com/input/?i=D%5Bx%5E2%2By%2Cx%5D&quot;&gt;x&lt;sup&gt;2&lt;/sup&gt;+y&lt;/a&gt; 求关于&lt;code&gt;x&lt;/code&gt;的导数，而且会得到 &lt;code&gt;y&#39;(x) + 2x&lt;/code&gt; 这样蹊跷的结果，因为它认为&lt;code&gt;y&lt;/code&gt;可能是一个函数。更奇怪的是，如果你在后面多加一个&lt;code&gt;a&lt;/code&gt;，也就是对&lt;a href=&quot;http://www.wolframalpha.com/input/?i=D%5Bx%5E2%2By%2Ba%2Cx%5D&quot;&gt;x&lt;sup&gt;2&lt;/sup&gt;+y+a&lt;/a&gt;求导，你会得到 &lt;code&gt;2x&lt;/code&gt;！那么 &lt;code&gt;y&#39;(x)&lt;/code&gt; 到哪里去了？莫名其妙……&lt;/p&gt;&lt;p&gt;相对而言，程序语言就严谨很多，所有的程序语言都要求你必须指出函数的参数叫什么名字。像x&lt;sup&gt;2&lt;/sup&gt;这样的东西，在程序语言里面不是一个函数（function），而只是一个表达式（expression）。即使 JavaScript 这样毛病众多的语言都是这样。比如，你必须写：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function (x) { return x * x }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那个括号里的&lt;code&gt;(x)&lt;/code&gt;，显式的声明了变量的名字，避免了可能出现的混淆。我不是第一个指出这些问题的人。其实现代逻辑学的鼻祖Gottlob Frege在一百多年以前就在他的论文“&lt;a href=&quot;http://www.olimon.org/uan/frege-writings.pdf&quot;&gt;Function and Concept&lt;/a&gt;”里批评了数学家们的这种做法。可是数学界的表达方式直到今天还是一样的混乱。&lt;/p&gt;&lt;p&gt;很多人学习微积分都觉得困难，其实问题不在他们，而在于莱布尼兹（Leibniz）。莱布尼兹设计来描述微积分的语言（∫，dx, dy, ...），从现代语言设计的角度来看，其实非常之糟糕，可以说是一塌糊涂。我不能怪莱布尼兹，他毕竟是几百年前的人了，他不知道我们现在知道的很多东西。然而古人的设计，现在还不考虑改进，反而当成教条灌输给学生，那就是不思进取了。&lt;/p&gt;&lt;p&gt;数学的语言不像程序语言，它的历史太久，没有经过系统的，考虑周全的，统一的设计。各种数学符号的出现，往往是历史上某个数学家有天在黑板上随手画出一些古怪的符号，说这代表什么，那代表什么，…… 然后就定下来了。很多数学家只关心自己那块狭窄的子领域，为自己的理论随便设计出一套符号，完全不管这些是否跟其它子领域的符号相冲突。这就是为什么不同的数学子领域里写出同样的符号，却可以表示完全不同的涵义。在这种意义上，数学的语言跟Perl（一种非常糟糕的程序语言）有些类似。Perl把各种人需要的各种功能，不加选择地加进了语言里面，造成语言繁复不堪，甚至连Perl的创造者自己都不能理解它所有的功能。&lt;/p&gt;&lt;p&gt;数学的证明，使用的其实也是极其不严格的语言——古怪的符号，加上含糊不清，容易误解的人类语言。如果你知道什么是&lt;a href=&quot;https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence&quot;&gt;Curry-Howard Correspondence&lt;/a&gt;就会明白，其实每一个数学证明都不过是一段代码。同样的定理，可以有许多不同版本的证明（代码）。这些证明有的简短优雅，有的却冗长繁复，像面条一样绕来绕去，没法看懂。你经常在数学证明里面看到“未定义的变量”，证明的逻辑也包含着各种隐含知识，思维跳跃，非常难以理解。很多数学证明，从程序的观点来看，连编译都不会通过，就别提运行了。&lt;/p&gt;&lt;p&gt;数学家们往往不在乎证明的优雅性。他们认为只要能证明出定理，你管我的证明简不简单，容不容易看懂呢。你越是看不懂，就越是觉得我高深莫测，越是感觉你自己笨！这种思潮到了编程的时候就显出弊端了。数学家写代码，往往忽视代码的优雅性，简单性，模块化，可读性，性能，数据结构等重要因素，认为代码只要能算出结果就行。他们把代码当成跟证明一样，一次性的东西，所以他们的代码往往不能满足实际工程的严格要求。&lt;/p&gt;&lt;p&gt;数学里最在乎语言设计的分支，莫过于逻辑学了。很多人（包括很多程序语言专家）都盲目的崇拜逻辑学家，盲目的相信数理逻辑是优雅美好的语言。在程序语言界，数理逻辑已经成为一种灾害，明明很容易就能解释清楚的语义，非得写成一堆稀奇古怪，含义混淆的逻辑公式。殊不知其实数理逻辑也是有很大的历史遗留问题和误区的。研究逻辑学的人经常遇到各种“不可判定”（undecidable）问题和所谓“悖论”（paradox），研究几十年也没搞清楚，而其实那些问题都是他们自己造出来的。你只需要把语言改一下，去掉一些不必要的功能，问题就没了。但逻辑学家们总喜欢跟你说，那是某天才老祖宗想出来的，多么多么的了不起啊，不能改！&lt;/p&gt;&lt;p&gt;用一阶逻辑（first-order logic）这样的东西，你可以写出一些毫无意义的语句。逻辑老师们会告诉你，记住啦，这些是没有意义的，如果写出来这些东西，是你的问题！他们没有意识到，如果一个人可以用一个语言写出毫无意义的东西，那么这问题在于这个语言，而不在于这个人。一阶逻辑号称可以“表达所有数学”，结果事实却是，没有几个数学家真的可以用它表达很有用的知识。到后来，稍微明智一点的逻辑学家们开始研究这些老古董语言到底出了什么毛病，于是他们创造了Model Theory这样的理论。写出一些长篇大部头，用于“验证”这些逻辑语言的合理性。这些问题在我看来都是显而易见的，因为很多逻辑的语言根本就不是很好很有用的东西。去研究它们“为什么有毛病”，其实是白费力气。自己另外设计一个更好语言就完事了。&lt;/p&gt;&lt;p&gt;在我看来，除了现代逻辑学的鼻祖&lt;a href=&quot;https://en.wikipedia.org/wiki/Gottlob_Frege&quot;&gt;Gottlob Frege&lt;/a&gt;理解了逻辑的精髓，其它逻辑学家基本都是照本宣科，一知半解。他们喜欢把简单的问题搞复杂，制造一些新名词，说得玄乎其玄灵丹妙药似的。如果你想了解逻辑学的精华，建议你看看&lt;a href=&quot;http://www.olimon.org/uan/frege-writings.pdf&quot;&gt;Frege的文集&lt;/a&gt;。看了之后你也许会发现，Frege思想的精华，其实已经融入在几乎所有的程序语言里了。&lt;/p&gt;&lt;h3&gt;编程是一门艺术&lt;/h3&gt;&lt;p&gt;从上面你也许已经明白了，普通程序员使用的编程语言，就算是C++这样毛病众多的语言，其实也已经比数学家使用的语言好很多。用数学的语言可以写出含糊复杂的证明，在期刊或者学术会议上蒙混过关，用程序语言写出来的代码却无法混过计算机这道严格的关卡。因为计算机不是人，它不会迷迷糊糊的点点头让你混过去，或者因为你是大师就不懂装懂。代码是需要经过现实的检验的。如果你的代码有问题，它迟早会导致出问题。&lt;/p&gt;&lt;p&gt;计算机科学并不是数学的一个分支，它在很大程度上是优于数学，高于数学的。有些数学的基本理论可以被计算机科学所用，然而计算机科学并不是数学的一部分。数学在语言方面带有太多的历史遗留糟粕，它其实是泥菩萨过河，自身难保，它根本解决不了编程中遇到的实际问题。&lt;/p&gt;&lt;p&gt;编程真的是一门艺术，因为它符合艺术的各种特征。艺术可以利用科学提供的工具，然而它却不是科学的一部分，它的地位也并不低于科学。和所有的艺术一样，编程能解决科学没法解决的问题，满足人们新的需求，开拓新的世界。所以亲爱的程序员们，别再为自己不懂很多数学而烦恼了。数学并不能帮助你写出好的程序，然而能写出好程序的人，却能更好的理解数学。我建议你们先学编程，再去看数学。&lt;/p&gt;&lt;p&gt;如果你想了解更多关于数学语言的弊病以及程序语言对它们的改进，我建议你看看这个Gerald Susman的&lt;a href=&quot;http://www.infoq.com/presentations/Expression-of-Ideas&quot;&gt;讲座&lt;/a&gt;。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">math</guid>
<pubDate>Sat, 04 Jul 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>谈程序的正确性</title>
<link>http://yinwang.org/blog-cn/2015/07/02/program-correctness</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;谈程序的正确性&lt;/h2&gt;&lt;p&gt;不管在学术圈还是在工业界，总有很多人过度的关心所谓“程序的正确性”，有些甚至到了战战兢兢，舍本逐末的地步。下面举几个例子：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很多人把测试（test）看得过于重要。代码八字还没一撇呢，就吵着要怎么怎么严格的测试，防止“将来”有人把代码改错了。这些人到后来往往被测试捆住了手脚，寸步难行。不但代码bug百出，连测试里面也很多bug。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有些人对于“使用什么语言”这个问题过度的在乎，仿佛只有用最新最酷，功能最多的语言，他们才能完成一些很基本的任务。这种人一次又一次的视一些新语言为“灵丹妙药”，然后一次又一次的幻灭，最后他们什么有用的代码也没写出来。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有些人过度的重视所谓“类型安全”（type safety），经常抱怨手头的语言缺少一些炫酷的类型系统功能，甚至因此说没法写代码了！他们没有看到，即使缺少一些由编译器静态保障的类型安全，代码其实一点问题都没有，而且也许更加简单。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有些人走上极端，认为所有的代码都必须使用所谓“形式化方法”（formal methods），用机器定理证明的方式来确保它100%的没有错误。这种人对于证明玩具大小的代码乐此不疲，结果一辈子也没写出过能解决实际问题的代码。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;100%可靠的代码，这是多么完美的理想！可是到最后你发现，天天念叨着要“正确性”，“可靠性”的人，几乎总是眼高手低，说的比做的多。自己没写出什么解决实际问题的代码，倒是很喜欢对别人的“代码质量”评头论足。这些人自己的代码往往复杂不堪，喜欢使用各种看似高深的奇技淫巧，用以保证所谓“正确”。他们的代码被很多所谓“测试工具”和“类型系统”捆住手脚，却仍然bug百出。到后来你逐渐发现，对“正确性”的战战兢兢，其实是这些人不解决手头问题的借口。&lt;/p&gt;&lt;h3&gt;衡量程序最重要的标准&lt;/h3&gt;&lt;p&gt;这些人其实不明白一个重要的道理：你得先写出程序，才能开始谈它的正确性。看一个程序好不好，最重要的标准，是看它能否有效地解决问题，而不是它是否正确。如果你的程序没有解决问题，或者解决了错误的问题，或者虽然解决问题但却非常难用，那么这程序再怎么正确，再怎么可靠，都不是好的程序。&lt;/p&gt;&lt;p&gt;正确不等于简单，不等于优雅，不等于高效。一个不简单，不优雅，效率低的程序，就算你费尽周折证明了它的正确，它仍然不会很好的工作。这就像你得先有了房子，才能开始要求房子是安全的。想想吧，如果一个没有房子的流浪汉，路过一座没有人住的房子，他会因为这房子“不是100%安全”，而继续在野外风餐露宿吗？写出代码就像有了房子，而代码的正确性，就像房子的安全性。写出可以解决问题的程序，永远是第一位的。而这个程序的正确性，不管它如何的重要，永远是第二位的。对程序的正确性的强调，永远不应该高于写出程序本身。&lt;/p&gt;&lt;p&gt;每当谈起这个问题，我就喜欢打一个比方：如果“黎曼猜想”被王垠证明出来了，它会改名叫“王垠定理”吗？当然不会。它会被叫做“黎曼定理”！这是因为，无论一个人多么聪明多么厉害，就算他能够证明出黎曼猜想，但这个猜想并不是他最先想出来的。如果黎曼没有提出这个猜想，你根本不会想到它，又何谈证明呢？所以我喜欢说，一流的数学家提出猜想，二流的数学家证明别人的猜想。同样的道理，写出解决问题的代码的人，比起那些去证明（测试）他的代码正确性的人，永远是更重要的。因为如果他没写出这段代码，你连要证明（测试）什么都不知道！&lt;/p&gt;&lt;h3&gt;如何提高程序的正确性&lt;/h3&gt;&lt;p&gt;话说回来，虽然程序的正确性相对于解决问题，处于相对次要的地位，然而它确实是不可忽视的。但这并不等于天天鼓吹要“测试”，要“形式化证明”，就可以提高程序的正确性。&lt;/p&gt;&lt;p&gt;如果你深入研究过程序的逻辑推导就会知道，测试和形式化证明的能力都是非常有限的。测试只能测试到最常用的情况，而无法覆盖所有的情况。别被所谓“测试覆盖”（test coverage）给欺骗了。一行代码被测试覆盖而没有出错，并不等于在那里不会出错。一行代码是否出错，取决于在它运行之前所经过的所有条件。这些条件的数量是组合爆炸关系，基本上没有测试能够覆盖所有这些前提条件。&lt;/p&gt;&lt;p&gt;形式化方法对于非常简单直接的程序是有效的，然而一旦程序稍微大点，形式化方法就寸步难行。你也许没有想到，你可以用非常少的代码，写出&lt;a href=&quot;https://en.wikipedia.org/wiki/Collatz_conjecture&quot;&gt;Collatz Conjecture&lt;/a&gt;这样至今没人证明出来的数学猜想。实际使用中的代码，比这种数学猜想要复杂不知道多少倍。你要用形式化方法去证明所有的代码，基本上等于你永远也没法完成项目。&lt;/p&gt;&lt;p&gt;那么提高程序正确性最有效的方法是什么呢？在我看来，最有效的方法莫过于对代码反复琢磨推敲，让它变得简单，直观，直到你一眼就可以看得出它不可能有问题。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">program-correctness</guid>
<pubDate>Thu, 02 Jul 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>DRY原则的误区</title>
<link>http://yinwang.org/blog-cn/2015/06/14/dry-principle</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;DRY原则的误区&lt;/h2&gt;&lt;p&gt;很多编程的人，喜欢鼓吹各种各样的“原则”，比如KISS原则，DRY原则…… 总有人把这些所谓原则奉为教条或者秘方，以为兢兢业业地遵循这些，空喊几个口号，就可以写出好的代码。同时，他们对违反这些原则的人嗤之以鼻——你不知道，不遵循或者藐视这些原则，那么你就是菜鸟。所谓“&lt;a href=&quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY原则&lt;/a&gt;”（Don&#39;t Repeat Yourself，不要重复你自己）就是这些教条其中之一。盲目的迷信DRY原则，在实际的工程中带来了各种各样的问题，却经常被忽视。&lt;/p&gt;&lt;p&gt;简言之，DRY原则鼓励对代码进行抽象，但是鼓励得过了头。DRY原则说，如果你发现重复的代码，就把它们提取出去做成一个“模板”或者“框架”。对于抽象我非常的在行，实际上程序语言专家做的许多研究，就是如何设计更好的抽象。然而我并不奉行所谓DRY原则，并不是尽一切可能避免“重复”。“避免重复”并不等于“抽象”。有时候适当的重复代码是有好处的，所以我有时候会故意的进行重复。&lt;/p&gt;&lt;h3&gt;抽象与可读性的矛盾&lt;/h3&gt;&lt;p&gt;代码的“抽象”和它的“可读性”（直观性），其实是一对矛盾的关系。适度的抽象和避免重复是有好处的，它甚至可以提高代码的可读性，然而如果你尽“一切可能”从代码里提取模板，甚至把一些微不足道的“共同点”也提出来进行“共享”，它就开始有害了。这是因为，模板并不直接显示在“调用”它们的位置。提取出模板，往往会使得阅读代码时不能一目了然。如果由此带来的直观性损失超过了模板所带来的好处时，你就应该考虑避免抽象了。要知道，代码读的次数要比写的次数多很多。很多人为了一时的“写的快感”，过早的提取出不必要的模板，其实损失了读代码时的直观性。如果自己的代码连自己都不能一目了然，你就不能写出优雅的代码。&lt;/p&gt;&lt;p&gt;举一个实际的例子。奉行DRY原则的人，往往喜欢提取类里面的“共同field”，把它们放进一个父类，然后让原来的类继承这个父类。比如，本来的代码可能是：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;class A {
  int a;
  int x;
  int y;
}

class B {
  int a;
  int u;
  int v;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;奉行DRY原则的人喜欢把它改成这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;class C {
  int a;
}

class A extends C {
  int x;
  int y;
}

class B extends C {
  int u;
  int v;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后面这段代码有什么害处呢？它的问题是，当你看到&lt;code&gt;class A&lt;/code&gt;和&lt;code&gt;class B&lt;/code&gt;的定义时，你不再能一目了然的看到&lt;code&gt;int a&lt;/code&gt;这个field。“可见性”，对于程序员能够产生直觉，是非常重要的。这种无关紧要的field，其实大部分时候都没必要提出去，造出一个新的父类。很多时候，不同类里面虽然有同样的&lt;code&gt;int a&lt;/code&gt;这样的field，然而它们的含义却是完全不同的。有些人不管三七二十一就来个“DRY”，结果不但没带来好处，反而让程序难以理解。&lt;/p&gt;&lt;h3&gt;抽象的时机问题&lt;/h3&gt;&lt;p&gt;奉行DRY原则的人还有一个问题，就是他们随时都在试图发现“将来可能重用”的代码，而不是等到真的出现重复的时候再去做抽象。很多时候他们提取出一个貌似“经典模板”，结果最后过了几个月发现，这个模板在所有代码里其实只用过一次。这就是因为他们过早的进行了抽象。&lt;/p&gt;&lt;p&gt;抽象的思想，关键在于“发现两个东西是一样的”。然而很多时候，你开头觉得两个东西是一回事，结果最后发现，它们其实只是肤浅的相似，而本质完全不同。同一个&lt;code&gt;int a&lt;/code&gt;，其实可以表示很多种风马牛不及的性质。你看到都是&lt;code&gt;int a&lt;/code&gt;就提出来做个父类，其实反而让程序的概念变得混乱。还有的时候，有些东西开头貌似同类，后来你增添了新的逻辑之后，发现它们的用途开始特殊化，后来就分道扬镳了。过早的提取模板，反而捆住了你的手脚，使得你为了所谓“一致性”而重复一些没用的东西。这样的一致性，其实还不如针对每种情况分别做特殊处理。&lt;/p&gt;&lt;p&gt;防止过早抽象的方法其实很简单，它的名字叫做“等待”。其实就算你不重用代码，真的不会死人的。时间能够告诉你一切。如果你发现自己仿佛正在重复以前写过代码，请先不要停下来，请坚持把这段重复的代码写完。如果你不把它写出来，你是不可能准确的发现重复的代码的，因为它们很有可能到最后其实是不一样的。&lt;/p&gt;&lt;p&gt;你还应该避免没有实际效果的抽象。如果代码才重复了两次，你就开始提取模板，也许到最后你会发现，这个模板总共也就只用了两次！只重复了两次的代码，大部分时候是不值得为它提取模板的。因为模板本身也是代码，而且抽象思考本身是需要一定代价的。所以最后总的开销，也许还不如就让那两段重复的代码待在里面。&lt;/p&gt;&lt;p&gt;这就是为什么我喜欢一种懒懒的，笨笨的感觉。因为我懒，所以我不会过早的思考代码的重用。我会等到事实证明重用一定会带来好处的时候，才会开始提取模板，进行抽象。经验告诉我，每一次积极地寻找抽象，最后的结果都是制造一些不必要的模板，搞得自己的代码自己都看不懂。很多人过度强调DRY，强调代码的“重用”，随时随地想着抽象，结果被这些抽象搅混了头脑，bug百出，寸步难行。如果你不能写出“可用”（usable）的代码，又何谈“可重用”（reusable）的代码呢？&lt;/p&gt;&lt;h3&gt;谨慎的对待所谓原则&lt;/h3&gt;&lt;p&gt;说了这么多，我是在支持DRY，还是反对DRY呢？其实不管是支持还是反对它，都会表示我在乎它，而其实呢，我完全不在乎这类原则，因为它们非常的肤浅。这就像你告诉我说你有一个重大的发现，那就是“1+1=2”，我该支持你还是反对你呢？我才懒得跟你说话。人们写程序，本来自然而然就会在合适的时候进行抽象，避免重复，怎么过了几十年后，某个菜鸟给我们的做法起了个名字叫DRY，反而他成了“大师”一样的人物，我倒要用“DRY”这个词来描述我一直在干的事情呢？所以我根本不愿意提起“DRY”这个名字。&lt;/p&gt;&lt;p&gt;所以我觉得这个DRY原则根本就不应该存在，它是一个根本没有资格提出“原则”的人提出来的。看看他鼓吹的其它低劣东西（比如Agile，Ruby），你就会发现，他是一个兜售减肥药的“软件工程专家”。世界上有太多这样的肤浅的所谓原则，我不想对它们一一进行评价，这是在浪费我的时间。世界上有比这些喜欢提出“原则”的软件工程专家深邃很多的人，他们懂得真正根本的原理。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">dry-principle</guid>
<pubDate>Sun, 14 Jun 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>所谓软件工程</title>
<link>http://yinwang.org/blog-cn/2015/06/07/software-engineering</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;所谓软件工程&lt;/h2&gt;&lt;p&gt;很多编程的人包括我，头衔叫做“软件工程师”（software engineer），然而我却不喜欢这个名字。我喜欢把自己叫做“程序员”（programmer）或者“计算机科学家”（computer scientist）。这是为什么呢？这需要从“软件工程”（software engineering）在现实中的涵义谈起。&lt;/p&gt;&lt;p&gt;有人把软件工程这个领域的本质总结为：“How to program if you cannot？”（如果你不会编程，那么你如何编程？）我觉得这句话说得很好，因为我发现软件工程这整个领域，基本就是吹牛扯淡卖“减肥药”的。软件行业的大部分莫名其妙的愚昧行为，很多是由所谓“软件工程专家”发明的。总有人提出一套套的所谓“方法论”或者“原则”，比如Extreme Programming，Design Patterns，Agile，Pair Programming，Test Driven Development（TDD），DRY principle，…… 他们把这些所谓方法论兜售给各个软件公司，鼓吹它们的各种好处，说使用这些方法，就可以用一些平庸的“软件工程师”，制造出高质量低成本的软件。这就跟减肥药的广告一样：不用运动，不用节食，一个星期瘦20斤。你开头还不以为然，觉得这些肤浅的说法能造成什么影响。结果久而久之，这些所谓“方法论”和“原则”成为了整个行业的教条，造成了文化大革命一样的风气。违反这些教条的人，必然被当成菜鸟一样的鄙视，当成小学生一样的教育，当成“反革命”一样的批斗。就算你技术比这些教条的提出者还高明不知道多少倍也一样。&lt;/p&gt;&lt;p&gt;打破这些软件工程专家们制造的幻觉的一个办法，就是实地去看看这些所谓专家们自己用这些方法论做出了什么好东西。你会惊奇的发现，这些提出各种玄乎其玄的新名词的所谓“专家”，几乎都是从不知道什么旮旯里冒出来的民科，没有一个做出过什么有技术含量的东西，他们根本没有资格对别人编程的方式做出指导。这些人做出来少数有点用的东西（比如JUnit），其实非常容易，以至于每个初学编程的人都应该做得出来。可世界上就是有这样划算的职业，你虽然写不出好的代码，你对计算原理的理解非常肤浅，却可以通过一些手段，得到评价别人的“代码质量”的权力，占据软件公司的管理层位置。久而久之，别人还以为你是什么泰斗。你仔细看过提出Java Design Pattern的四个人（GoF），到底做出过什么厉害的东西吗？没有。提出“DRY Principle”的作者，做出过什么好东西吗？没有。再看看Agile，Pair Programming，TDD……的提出者？全都是一群饭桶。他们其实根本就不懂很多编程的东西，写出文章和书来也是极其肤浅，一知半解。&lt;/p&gt;&lt;p&gt;所谓“软件工程”，并不像土木工程，机械工程，电机工程，是建立在实际的，科学的基础上的。跟这些“硬工程”不一样，软件弄得不好不会出人命，也不会跟做芯片的公司那样，出一个bug立即导致上亿的损失，身败名裂。所以研究软件工程，似乎特别容易钻空子，失败了之后容易找借口和替罪羊。如果你说我的方法不好，你有什么证据吗？口说无凭，我浪费了你多少时间呢？你的具体执行是不是完全照我说的来的呢？你肯定有什么细节没按我说的做，所以才会失败。总之，如果你用了我的办法不管用，那是你自己的问题！&lt;/p&gt;&lt;p&gt;想起这些借口我就想起一个笑话：两夫妻睡觉发现床上有跳蚤，身上被咬了好多大包。去买了号称“杀伤率100%”的跳蚤药，撒了好多在床上。第二天早上起来，发现又被咬了好多新的大包。妻子责怪丈夫，说他没看说明书就乱撒。结果丈夫打开说明书一看，内容如下：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本跳蚤药使用方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;抓住跳蚤&lt;/li&gt;
&lt;li&gt;掰开跳蚤的嘴&lt;/li&gt;
&lt;li&gt;把药塞进跳蚤嘴里&lt;/li&gt;
&lt;li&gt;合上跳蚤的嘴&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;p&gt;我发现很多软件工程的所谓方法论失败之后的借口，跟这跳蚤药的说明书很像 :)&lt;/p&gt;&lt;p&gt;人都想省钱，雇用高质量的程序员不容易呀，所以很多公司还是上钩了。他们请这些“软件工程专家”来到公司，推行各种各样的软件方法论，可是发现最后都失败了。这是为什么呢？因为再高明的方法论，也无法代替真正的，精华的计算机科学教育。直到今天还有很多公司推行所谓的Agile，煞有介事的搞一些stand-up meeting, scrum之类的形式主义东西，以为这些过家家似的做法就能提高开发质量和效率。很多开发人员也很把一些软件工程的工具当回事，喜欢折腾Git，Maven等工具一些偏僻的“新功能”。他们很在乎所谓的版本控制，测试等东西，以为熟练的掌握这些就能开发出高质量，可靠的代码。可是你最后发现，无论你如何高效的使用这些工具，它们都只能起到辅助的，次要的作用。编程工具永远不是程序本身，对编程工具的熟练掌握，永远也无法代替真正的对程序和计算的理解。过分强调这些工具的使用，是本末倒置的，让工程走上失败道路的作法。&lt;/p&gt;&lt;p&gt;编程真的是一门艺术，它完全符合艺术的各种特征，编程界也充满了艺术界的独有特征。有些初学艺术的人（比如10年前的我），总是挑剔手上的工具，非要用最新最炫的工具，用它们最偏僻最难用的“特性”，才觉得自己能够做出优秀的作品。很多人照不出好的照片，就怪相机不好。买了几万块钱的笨重高档相机，照出来的照片还不如别人用手机照的。这些人不明白，好的摄影师和不好的摄影师，区别在于眼睛，而不是相机。一个真正的艺术家，可以用任何在手上的工具创造出色的作品。有些甚至可以用一些废品垃圾，拙劣的工具，做出杰出的，别具风味的艺术品。因为艺术存在于人的心里，而不在他们使用的工具里面。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">software-engineering</guid>
<pubDate>Sun, 07 Jun 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程的宗派</title>
<link>http://yinwang.org/blog-cn/2015/04/03/paradigms</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;编程的宗派&lt;/h2&gt;&lt;p&gt;总是有人喜欢争论这类问题，到底是“函数式编程”（FP）好，还是“面向对象编程”（OOP）好。既然出了两个帮派，就有人积极地做它们的帮众，互相唾骂和鄙视。然后呢又出了一个“好好先生帮”，这个帮的人喜欢说，管它什么范式呢，能解决问题的工具就是好工具！我个人其实不属于这三帮人中的任何一个。&lt;/p&gt;&lt;h3&gt;面向对象编程（Object-Oriented Programming）&lt;/h3&gt;&lt;p&gt;如果你看透了表面现象就会发现，其实“面向对象编程”本身没有引入很多新东西。所谓“面向对象语言”，其实就是经典的“过程式语言”（比如Pascal），加上一点抽象能力。所谓“类”和“对象”，基本是过程式语言里面的记录（record，或者叫结构，structure），它本质其实是一个从名字到数据的“映射表”（map）。你可以用名字从这个表里面提取相应的数据。比如&lt;code&gt;point.x&lt;/code&gt;，就是用名字&lt;code&gt;x&lt;/code&gt;从记录&lt;code&gt;point&lt;/code&gt;里面提取相应的数据。这比起数组来是一件很方便的事情，因为你不需要记住存放数据的下标。即使你插入了新的数据成员，仍然可以用原来的名字来访问已有的数据，而不用担心下标错位的问题。&lt;/p&gt;&lt;p&gt;所谓“对象思想”（区别于“面向对象”），实际上就是对这种数据访问方式的进一步抽象。一个经典的例子就是平面点的数据结构。如果你把一个点存储为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct Point {
  double x;
  double y;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么你用&lt;code&gt;point.x&lt;/code&gt;和&lt;code&gt;point.y&lt;/code&gt;可以直接访问它的X和Y坐标。但你也可以把它存储为“极坐标”方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct Point {
  double r;
  double angle;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样你可以用&lt;code&gt;point.r&lt;/code&gt;和&lt;code&gt;point.angle&lt;/code&gt;访问它的模和角度。可是现在问题来了，如果你的代码开头把Point定义为第一种XY的方式，使用&lt;code&gt;point.x&lt;/code&gt;, &lt;code&gt;point.y&lt;/code&gt;访问X和Y坐标，可是后来你决定改变Point的存储方式，用极坐标，你却不想修改已有的含有&lt;code&gt;point.x&lt;/code&gt;和&lt;code&gt;point.y&lt;/code&gt;的代码，怎么办呢？&lt;/p&gt;&lt;p&gt;这就是“对象思想”的价值，它让你可以通过“间接”（indirection，或者叫做“抽象”）来改变&lt;code&gt;point.x&lt;/code&gt;和&lt;code&gt;point.y&lt;/code&gt;的语义，从而让使用者的代码完全不用修改。虽然你的实际数据结构里面根本没有&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;这两个成员，但由于&lt;code&gt;.x&lt;/code&gt;和&lt;code&gt;.y&lt;/code&gt;可以被重新定义，所以你可以通过改变&lt;code&gt;.x&lt;/code&gt;和&lt;code&gt;.y&lt;/code&gt;的定义来“模拟”它们。在你使用&lt;code&gt;point.x&lt;/code&gt;和&lt;code&gt;point.y&lt;/code&gt;的时候，系统内部其实在运行两片代码，它们的作用是从&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;angle&lt;/code&gt;计算出&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;的值。这样你的代码就感觉&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;是实际存在的成员一样，而其实它们是被临时算出来的。在Python之类的语言里面，你可以通过定义“&lt;a href=&quot;https://docs.python.org/2/library/functions.html#property&quot;&gt;property&lt;/a&gt;”来直接改变&lt;code&gt;point.x&lt;/code&gt;和&lt;code&gt;point.y&lt;/code&gt;的语义。在Java里稍微麻烦一些，你需要使用&lt;code&gt;point.getX()&lt;/code&gt;和&lt;code&gt;point.getY()&lt;/code&gt;这样的写法。然而它们最后的目的其实都是一样的——它们为数据访问提供了一层“间接”（抽象）。&lt;/p&gt;&lt;p&gt;这种抽象有时候是个好主意，它甚至可以跟量子力学的所谓“不可观测性”扯上关系。你觉得这个原子里面有10个电子？也许它们只是像&lt;code&gt;point.x&lt;/code&gt;给你的幻觉一样，也许宇宙里根本就没有电子这种东西，也许你每次看到所谓的电子，它都是临时生成出来逗你玩的呢？然而，对象思想的价值也就到此为止了。你见过的所谓“面向对象思想”，几乎无一例外可以从这个想法推广出来。面向对象语言的绝大部分特性，其实是过程式语言早就提供的。因此我觉得，其实没有语言可以叫做“面向对象语言”。就像一个人为一个公司贡献了一点点代码，并不足以让公司以他的名字命名一样。&lt;/p&gt;&lt;p&gt;“对象思想”作为数据访问的方式，是有一定好处的。然而“面向对象”（多了“面向”两个字），就是把这种本来良好的思想东拉西扯，牵强附会，发挥过了头。很多面向对象语言号称“所有东西都是对象”（Everything is an Object），把所有函数都放进所谓对象里面，叫做“方法”（method），把普通的函数叫做“静态方法”（static method）。实际上呢，就像我之前的例子，只有极少需要抽象的时候，你需要使用内嵌于对象之内，跟数据紧密结合的“方法”。其他的时候，你其实只是想表达数据之间的变换操作，这些完全可以用普通的函数表达，而且这样做更加简单和直接。这种把所有函数放进方法的做法是本末倒置的，因为函数其实并不属于对象。绝大部分函数是独立于对象的，它们不能被叫做“方法”。强制把所有函数放进它们本来不属于的对象里面，把它们全都作为“方法”，导致了面向对象代码逻辑过度复杂。很简单的想法，非得绕好多道弯子才能表达清楚。很多时候这就像把自己的头塞进屁股里面。&lt;/p&gt;&lt;p&gt;这就是为什么我喜欢开玩笑说，面向对象编程就像“&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E8%AA%AA&quot;&gt;地平说&lt;/a&gt;”（Flat Earth Theory）。当然你可以说地球是一个平面。对于局部的，小规模的现象，它没有问题。然而对于通用的，大规模的情况，它却不是自然，简单和直接的。直到&lt;a href=&quot;http://www.theflatearthsociety.org/cms&quot;&gt;今天&lt;/a&gt;，你仍然可以无止境的寻找证据，扭曲各种物理定律，自圆其说地平说的幻觉，然而这会让你的理论非常复杂，经常需要缝缝补补还难以理解。&lt;/p&gt;&lt;p&gt;面向对象语言不仅有自身的根本性错误，而且由于面向对象语言的设计者们常常是半路出家，没有受到过严格的语言理论和设计训练却又自命不凡，所以经常搞出另外一些奇葩的东西。比如在JavaScript里面，每个函数同时又可以作为构造函数（constructor），所以每个函数里面都隐含了一个this变量，你嵌套多层对象和函数的时候就发现没法访问外层的this，非得bind一下。Python的变量定义和赋值不分，所以你需要访问全局变量的时候得用global关键字，后来又发现如果要访问“中间层”的变量，没有办法了，所以又加了个nonlocal关键字。Ruby先后出现过四种类似lambda的东西，每个都有自己的怪癖…… 有些人问我为什么有些语言设计成那个样子，我只能说，很多语言设计者其实根本不知道自己在干什么！&lt;/p&gt;&lt;p&gt;软件领域就是喜欢制造宗派。“面向对象”当年就是乘火打劫，扯着各种幌子，成为了一种宗派，给很多人洗了脑。到底什么样的语言才算是“面向对象语言”？这样基本的问题至今没有确切的答案，足以说明所谓面向对象，基本都是扯淡。每当你指出某个OO语言X的弊端，就会有人跟你说，其实X不是“地道的”OO语言，你应该去看看另外一个OO语言Y。等你发现Y也有问题，有人又会让你去看Z…… 直到最后，他们告诉你，只有Smalltalk才是地道的OO语言。这不是很搞笑吗，说一个根本没人用的语言才是地道的OO语言，这就像在说只有死人的话才是对的。这就像是一群政客在踢皮球，推卸责任。等你真正看看Smalltalk才发现，其实面向对象语言的根本毛病就是由它而来的，Smalltalk并不是很好的语言。很多人至今不知道自己所用的“面向对象语言”里面的很多优点，都是从过程式语言继承来的。每当发生函数式与面向对象式语言的口水战，都会有面向对象的帮众拿出这些过程式语言早就有的优点来进行反驳：“你说面向对象不好，看它能做这个……” 拿别人的优点撑起自己的门面，却看不到事物实质的优点，这样的辩论纯粹是鸡同鸭讲。&lt;/p&gt;&lt;h3&gt;函数式编程（Functional Programming）&lt;/h3&gt;&lt;p&gt;函数式语言一直以来比较低调，直到最近由于并发计算编程瓶颈的出现，以及Haskell，Scala之类语言社区的大力鼓吹，它忽然变成了一种宗派。有人盲目的相信函数式编程能够奇迹般的解决并发计算的难题，而看不到实质存在的，独立于语言的问题。被函数式语言洗脑的帮众，喜欢否定其它语言的一切，看低其它程序员。特别是有些初学编程的人，俨然把函数式编程当成了一天瘦二十斤的减肥神药，以为自己从函数式语言入手，就可以对经验超过他十年以上的老程序员说三道四，仿佛别人不用函数式语言就什么都不懂一样。&lt;/p&gt;&lt;h4&gt;函数式编程的优点&lt;/h4&gt;&lt;p&gt;函数式编程当然提供了它自己的价值。函数式编程相对于面向对象最大的价值，莫过于对于函数的正确理解。在函数式语言里面，函数是“一类公民”（first-class）。它们可以像1, 2, &quot;hello&quot;，true，对象…… 之类的“值”一样，在任意位置诞生，通过变量，参数和数据结构传递到其它地方，可以在任何位置被调用。这些是很多过程式语言和面向对象语言做不到的事情。很多所谓“面向对象设计模式”（design pattern），都是因为面向对象语言没有first-class function，所以导致了每个函数必须被包在一个对象里面才能传递到其它地方。&lt;/p&gt;&lt;p&gt;函数式编程的另一个贡献，是它们的类型系统。函数式语言对于类型的思维，往往非常的严密。函数式语言的类型系统，往往比面向对象语言来得严密和简单很多，它们可以帮助你对程序进行严密的逻辑推理。然而类型系统一是把双刃剑，如果你对它看得太重，它反而会带来不必要的复杂性和过度工程。这个我在下面讲讲。&lt;/p&gt;&lt;h4&gt;各种“白象”（white elephant）&lt;/h4&gt;&lt;p&gt;所谓白象，“white elephant”，是指被人奉为神圣，价格昂贵，却没有实际用处的东西。函数式语言里面有很好的东西，然而它们里面有很多多余的特性，这些特性跟白象的性质类似。&lt;/p&gt;&lt;p&gt;函数式语言的“拥护者”们，往往认为这个世界本来应该是“纯”（pure）的，不应该有任何“副作用”。他们把一切的“赋值操作”看成低级弱智的作法。他们很在乎所谓尾递归，类型推导，fold，currying，maybe type等等。他们以自己能写出使用这些特性的代码为豪。可是殊不知，那些东西其实除了能自我安慰，制造高人一等的幻觉，并不一定能带来真正优秀可靠的代码。&lt;/p&gt;&lt;h5&gt;纯函数&lt;/h5&gt;&lt;p&gt;半壶水都喜欢响叮当。很多喜欢自吹为“函数式程序员”的人，往往并不真的理解函数式语言的本质。他们一旦看到过程式语言的写法就嗤之以鼻。比如以下这个C函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int f(int x) {
    int y = 0;
    int z = 0;
    y = 2 * x;
    z = y + 1;
    return z / 3;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很多函数式程序员可能看到那几个赋值操作就皱起眉头，然而他们看不到的是，这是一个真正意义上的“纯函数”，它在本质上跟Haskell之类语言的函数是一样的，也许还更加优雅一些。&lt;/p&gt;&lt;p&gt;盲目鄙视赋值操作的人，也不理解“数据流”的概念。其实不管是对局部变量赋值还是把它们作为参数传递，其实本质上都像是把一个东西放进一个管道，或者把一个电信号放在一根导线上，只不过这个管道或者导线，在不同的语言范式里放置的方向和样式有一点不同而已！&lt;/p&gt;&lt;h5&gt;对数据结构的忽视&lt;/h5&gt;&lt;p&gt;函数式语言的帮众没有看清楚的另一个重要的，致命的东西，是数据结构的根本性和重要性。数据结构的有些问题是“物理”和“本质”地存在的，不是换个语言或者换个风格就可以奇迹般消失掉的。函数式语言的拥护者们喜欢盲目的相信和使用列表（list），而没有看清楚它的本质以及它所带来的时间复杂度。列表带来的问题，不仅仅是编程的复杂性。不管你怎么聪明的使用它，很多性能问题是根本没法解决的，因为列表的拓扑结构根本就不适合用来干有些事情！&lt;/p&gt;&lt;p&gt;从数据结构的角度看，Lisp所谓的list就是一个单向链表。你必须从上一个节点才能访问下一个，而这每一次“间接寻址”，都是需要时间的。在这种数据结构下，很简单的像length或者append之类函数，时间复杂度都是O(n)！为了绕过这数据结构的不足，所谓的“Lisp风格”告诉你，不要反复append，因为那样复杂度是O(n&lt;sup&gt;2&lt;/sup&gt;)。如果需要反复把元素加到列表末尾，那么应该先反复cons，然后再reverse一下。很可惜的是，当你同时有递归调用，就会发现cons+reverse的做法颠来倒去的，非常容易出错。有时候列表是正的，有时候是反的，有时候一部分是反的…… 这种方式用一次还可以，多几层递归之后，自己都把自己搞糊涂了。好不容易做对了，下次修改可能又会出错。然而就是有人喜欢显示自己聪明，喜欢自虐，迎着这类人为制造的“困难”勇往直前 :)&lt;/p&gt;&lt;p&gt;富有讽刺意味的是，半壶水的Lisp程序员都喜欢用list，真正深邃的Lisp大师级人物，却知道什么时候应该使用记录（结构）或者数组。在Indiana大学，我曾经上过一门Scheme（一种现代Lisp方言）编译器的课程，授课的老师是R. Kent Dybvig，他是世界上最先进的Scheme编译器Chez Scheme的作者。我们的课程编译器的数据结构（包括AST）都是用list表示的。期末的时候，Kent对我们说：“你们的编译器已经可以生成跟我的Chez Scheme媲美的代码，然而Chez Scheme不止生成高效的目标代码，它的编译速度是你们的700倍以上。它可以在5秒钟之内编译它自己！” 然后他透露了一点Chez Scheme速度之快的原因。其中一个原因，就是因为Chez Scheme的内部数据结构根本不是list。在编译一开头的时候，Chez Scheme就已经把输入的代码转换成了数组一样的，固定长度的结构。后来在工业界的经验教训也告诉了我，数组比起链表，确实在某些时候有大幅度的性能提升。在什么时候该用链表，什么时候该用数组，是一门艺术。&lt;/p&gt;&lt;h5&gt;副作用的根本价值&lt;/h5&gt;&lt;p&gt;对数据结构的忽视，跟纯函数式语言盲目排斥副作用的“教义”有很大关系。过度的使用副作用当然是有害的，然而副作用这种东西，其实是根本的，有用的。对于这一点，我喜欢跟人这样讲：在计算机和电子线路最开头发明的时候，所有的线路都是“纯”的，因为逻辑门和导线没有任何记忆数据的能力。后来有人发明了触发器（flip-flop），才有了所谓“副作用”。是副作用让我们可以存储中间数据，从而不需要把所有数据都通过不同的导线传输到需要的地方。没有副作用的语言，就像一个没有无线电，没有光的世界，所有的数据都必须通过实在的导线传递，这许多纷繁的电缆，必须被正确的连接和组织，才能达到需要的效果。我们为什么喜欢WiFi，4G网，Bluetooth，这也就是为什么一个语言不应该是“纯”的。&lt;/p&gt;&lt;p&gt;副作用也是某些重要的数据结构的重要组成元素。其中一个例子是哈希表。纯函数语言的拥护者喜欢盲目的排斥哈希表的价值，说自己可以用纯的树结构来达到一样的效果。然而事实却是，这些纯的数据结构是不可能达到有副作用的数据结构的性能的。所谓纯函数数据结构，因为在每一次“修改”时都需要保留旧的结构，所以往往需要大量的拷贝数据，然后依赖垃圾回收（GC）去消灭这些旧的数据。要知道，内存的分配和释放都是需要时间和能量的。盲目的依赖GC，导致了纯函数数据结构内存分配和释放过于频繁，无法达到有副作用数据结构的性能。要知道，副作用是电子线路和物理支持的高级功能。盲目的相信和使用纯函数写法，其实是在浪费已有的物理支持的操作。&lt;/p&gt;&lt;h5&gt;fold以及其他&lt;/h5&gt;&lt;p&gt;大量使用fold和&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/02/currying&quot;&gt;currying&lt;/a&gt;的代码，写起来貌似很酷，读起来却不必要的痛苦。很多人根本不明白fold的本质，却老喜欢用它，因为他们觉得那是函数式编程的“精华”，可以显示自己的聪明。然而他们没有看到的是，其实fold包含的，只不过是在列表（list）上做递归的“通用模板”，这个模板需要你填进去三个参数，就可以生成一个新的递归函数调用。所以每一个fold的调用，本质上都包含了一个在列表上的递归函数定义。fold的问题在于，它定义了一个递归函数，却没有给它一个一目了然的名字。使用fold的结果是，每次看到一个fold调用，你都需要重新读懂它的定义，琢磨它到底是干什么的。而且fold调用只显示了递归模板需要的部分，而把递归的主体隐藏在了fold本身的“框架”里。比起直接写出整个递归定义，这种遮遮掩掩的做法，其实是更难理解的。比如，当你看到这句Haskell代码：&lt;/p&gt;&lt;pre&gt;foldr (+) 0 [1,2,3]&lt;/pre&gt;&lt;p&gt;你知道它是做什么的吗？也许你一秒钟之后就凭经验琢磨出，它是在对&lt;code&gt;[1,2,3]&lt;/code&gt;里的数字进行求和，本质上相当于&lt;code&gt;sum [1,2,3]&lt;/code&gt;。虽然只花了一秒钟，可你仍然需要琢磨。如果fold里面带有更复杂的函数，而不是&lt;code&gt;+&lt;/code&gt;，那么你可能一分钟都琢磨不透。写起来倒没有费很大力气，可为什么我每次读这段代码，都需要看到&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt;这两个跟自己的意图毫无关系的东西？万一有人不小心写错了，那里其实不是&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt;怎么办？为什么我需要搞清楚&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;[1,2,3]&lt;/code&gt;的相对位置以及它们的含义？这样的写法其实还不如老老实实写一个递归函数，给它一个有意义名字（比如&lt;code&gt;sum&lt;/code&gt;），这样以后看到这个名字被调用，比如&lt;code&gt;sum [1,2,3]&lt;/code&gt;，你想都不用想就知道它要干什么。定义&lt;code&gt;sum&lt;/code&gt;这样的名字虽然稍微增加了写代码时的工作，却给读代码的时候带来了方便。为了写的时候简洁或者很酷而用fold，其实增加了读代码时的脑力开销。要知道代码被读的次数，要比被写的次数多很多，所以使用fold往往是得不偿失的。然而，被函数式编程洗脑的人，却看不到这一点。他们太在乎显示给别人看，我也会用fold！&lt;/p&gt;&lt;p&gt;与fold类似的白象，还有&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/02/currying&quot;&gt;currying&lt;/a&gt;，Hindley-Milner类型推导等特性。看似很酷，但等你仔细推敲才发现，它们带来的麻烦，比它们解决的问题其实还要多。有些特性声称解决的问题，其实根本就不存在。现在我把一些函数式语言的特性，以及它们包含的陷阱简要列举一下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;fold。fold等“递归模板”，相当于把递归函数定义插入到调用的敌方，而不给它们名字。这样导致每次读代码都需要理解几乎整个递归函数的定义。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/02/currying&quot;&gt;currying&lt;/a&gt;。貌似很酷，可是被部分调用的参数只能从左到右，依次进行。如何安排参数的顺序成了问题。大部分时候还不如直接制造一个新的lambda，在内部调用旧的函数，这样可以任意的安排参数顺序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hindley-Milner类型推导。为了避免写参数和返回值的类型，结果给程序员写代码增加了很多的限制。为了让类型推导引擎开心，导致了很多完全合法合理优雅的代码无法写出来。其实还不如直接要程序员写出参数和返回值的类型，这工作量真的不多，而且可以准确的帮助阅读者理解参数的范围。HM类型推导的根本问题其实在于它使用unification算法。Unification其实只能表示数学里的“等价关系”（equivalence relation），而程序语言最重要的关系，subtyping，并不是一个等价关系，因为它不具有对称性（symmetry）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代数数据类型（algebraic data type）。所谓“代数数据类型”，其实并不如普通的类型系统（比如Java的）通用。很多代数数据类型系统具有所谓sum type，这种类型其实带来过多的类型嵌套，不如通用的union type。盲目崇拜代数数据类型的人，往往是因为盲目的相信“数学是优美的语言”。而其实事实是，数学是一种历史遗留的，毛病很多的语言。数学的语言根本没有经过系统的，全球协作的设计。往往是数学家在黑板上随便写个符号，说这个表示XX概念，然后就定下来了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tuple。有代数数据类型的的语言里面经常有一种构造叫做Tuple，比如Haskell里面可以写&lt;code&gt;(1, &quot;hello&quot;)&lt;/code&gt;，表示一个类型为&lt;code&gt;(Int, String)&lt;/code&gt;的结构。这种构造经常被人看得过于高尚，以至于用在超越它能力的地方。其实Tuple就是一个没有名字的结构（类似C的structure），而且结构里面的域也没有名字。临时使用Tuple貌似很方便，因为不需要定义一个结构类型。然而因为Tuple没有名字，而且里面的域没法用名字访问，一旦里面的数据多一点就发现很麻烦了。Tuple往往只能通过模式匹配来获得里面的域，一旦你增加了新的域进去，所有含有这个Tuple的模式匹配代码都需要改。所以Tuple一般只能用在大小不超过3的情况下，而且必须确信以后不会增加新的域进去。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/01/lazy-evaluation&quot;&gt;惰性求值&lt;/a&gt;（lazy evaluation）。貌似数学上很优雅，但其实有严重的逻辑漏洞。因为bottom（死循环）成为了任何类型的一个元素，所以取每一个值，都可能导致死循环。同时导致代码性能难以预测，因为求值太懒，所以可能临时抱佛脚做太多工作，而平时浪费CPU的时间。由于到需要的时候才求值，所以在有多个处理器的时候无法有效地利用它们的计算能力。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尾递归。大部分尾递归都相当于循环语句，然而却不像循环语句一样具有一目了然的意图。你需要仔细看代码的各个分支的返回条件，判断是否有分支是尾递归，然后才能判断这代码是个循环。而循环语句从关键字（for，while）就知道是一个循环。所以等价于循环的尾递归，其实最好还是写成特殊的循环语句。当然，尾递归在另一些情况下是有用的，这些情况不等价于循环。在这种情况下使用循环，经常需要复杂的break或者continue条件，导致循环不易理解。所以循环和尾递归，其实都是有必要的。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;好好先生&lt;/h3&gt;&lt;p&gt;很多人避免“函数式vs面向对象”的辩论，于是他们成为了“好好先生”。这种人没有原则的认为，任何能够解决当前问题的工具就是好工具。也就是这种人，喜欢使用shell script，喜欢折腾各种Unix工具，因为显然，它们能解决他“手头的问题”。&lt;/p&gt;&lt;p&gt;然而这种思潮是极其有害的，它的害处其实更胜于投靠函数式或者面向对象。没有原则的好好先生们忙着“解决问题”，却不能清晰地看到这些问题为什么存在。他们所谓的问题，往往是由于现有工具的设计失误。由于他们的“随和”，他们从来不去思考，如何从根源上消灭这些问题。他们在一堆历史遗留的垃圾上缝缝补补，妄图使用设计恶劣的工具建造可靠地软件系统。当然，这代价是非常大的。不但劳神费力，而且也许根本不能解决问题。&lt;/p&gt;&lt;p&gt;所以每当有人让我谈谈“函数式vs面向对象”，我都避免说“各有各的好处”，因为那样的话我会很容易被当成这种毫无原则的好好先生。&lt;/p&gt;&lt;h3&gt;符号必须简单的对世界建模&lt;/h3&gt;&lt;p&gt;从上面你已经看出，我既不是一个铁杆“函数式程序员”，也不是一个铁杆“面向对象程序员”，我也不是一个爱说“各有各的好处”的好好先生。我是一个有原则的批判性思维者。我不但看透了各种语言的本质，而且看透了它们之间的统一关系。我编程的时候看到的不是表面的语言和程序，而是一个类似电路的东西。我看到数据的流动和交换，我看到效率的瓶颈，而这些都是跟具体的语言和范式无关的。&lt;/p&gt;&lt;p&gt;在我的心目中其实只有一个概念，它叫做“编程”（programming），它不带有任何附加的限定词（比如“函数式”或者“面向对象”）。我的老师Dan Friedman喜欢把自己的领域称为“Programming Languages”，也是一样的原因。因为我们研究的内容，不局限于某一个语言，也不局限于某一类语言，而是所有的语言。在我们的眼里，所有的语言都不过是各个特性的组合。在我们的眼里，最近出现的所谓“新语言”，其实不大可能再有什么真正意义上的创新。我们不喜欢说“发明一个程序语言”，不喜欢使用“发明”这个词，因为不管你怎么设计一个语言，所有的特性几乎都早已存在于现有的语言里面了。我更喜欢使用“设计”这个词，因为虽然一个语言没有任何新的特性，它却有可能在细节上更加优雅。&lt;/p&gt;&lt;p&gt;编程最重要的事情，其实是让写出来的符号，能够简单地对实际或者想象出来的“世界”进行建模。一个程序员最重要的能力，是直觉地看见符号和现实物体之间的对应关系。不管看起来多么酷的语言或者范式，如果必须绕着弯子才能表达程序员心目中的模型，那么它就不是一个很好的语言或者范式。有些东西本来就是有随时间变化的“状态”的，如果你偏要用“纯函数式”语言去描述它，当然你就进入了那些monad之类的死胡同。最后你不但没能高效的表达这种副作用，而且让代码变得比过程式语言还要难以理解。如果你进入另一个极端，一定要用对象来表达本来很纯的数学函数，那么你一样会把简单的问题搞复杂。Java的所谓design pattern，很多就是制造这种问题的，而没有解决任何问题。&lt;/p&gt;&lt;p&gt;关于建模的另外一个问题是，你心里想的模型，并不一定是最好的，也不一定非得设计成那个样子。有些人心里没有一个清晰简单的模型，觉得某些语言“好用”，就因为它们能够对他那种扭曲纷繁的模型进行建模。所以你就跟这种人说不清楚，为什么这个语言不好，因为显然这个语言对他是有用的！如何简化模型，已经超越了语言的范畴，在这里我就不细讲了。&lt;/p&gt;&lt;p&gt;我设计Yin语言的宗旨，就是让人们可以用最简单，最直接的方式来对世界进行建模，并且帮助他们优化和改进模型本身。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">paradigms</guid>
<pubDate>Fri, 03 Apr 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>智商的圈套</title>
<link>http://yinwang.org/blog-cn/2015/03/20/trap-of-intelligence</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;智商的圈套&lt;/h2&gt;&lt;p&gt;上次买了个&lt;a href=&quot;http://www.jianshu.com/p/b501a1675f4d&quot;&gt;任天堂3DS&lt;/a&gt;游戏机，觉得里面的游戏很无聊，所以第二天就把游戏机连同游戏一起，转手倒卖给了别人。从那天之后，我开始琢磨一个问题——到底是什么让我觉得一个游戏好玩或者不好玩。我似乎对事物有一种很特别的品味，很多别人说“好玩”，“有趣”的游戏或者电影，我一看就觉得很无趣，或者很自虐。我一生中玩过最好玩的游戏，其实没有几个，可能掰着手指头都数得出来：&lt;a href=&quot;http://braid-game.com&quot;&gt;Braid&lt;/a&gt;，&lt;a href=&quot;http://en.wikipedia.org/wiki/Limbo_%28video_game%29&quot;&gt;Limbo&lt;/a&gt;，&lt;a href=&quot;http://en.wikipedia.org/wiki/Klonoa:_Door_to_Phantomile&quot;&gt;Klonoa&lt;/a&gt;（風のクロノア door to phantomile），《&lt;a href=&quot;https://itunes.apple.com/cn/app/ji-nian-bei-gu/id728293409&quot;&gt;纪念碑谷&lt;/a&gt;》，&lt;a href=&quot;http://en.wikipedia.org/wiki/Metal_Gear_Solid&quot;&gt;Metal Gear Solid&lt;/a&gt;，……&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/Klonoa.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;如果你觉得我智商太高，所以才觉得很多游戏没有挑战性，不好玩，那么你其实并不了解我。我并不是一个“智商达人”，我不追求挑战性。我觉得很多游戏缺乏的不是挑战性和“难度”，而是设计的巧妙。很多游戏我根本没法玩过关，却只是觉得呆板，繁琐，老套，公式化。我并不会因为游戏玩不过关，作业做不出来，或者书看不懂而沮丧。恰恰相反，我认为我的智力根本就不应该是用来干这些事情的。如果有事情让我觉得沮丧，我一般都认为是这个事情有问题，而不是我有问题。如果说我也有错的话，那么我的错误就在于选择了参与这项活动，我根本不应该做这件事情。这就是为什么我大部分时候都比一般人开心。&lt;/p&gt;&lt;p&gt;我觉得很多人有一种奇怪的倾向，他们喜欢挑战或者彰显自己的智商。每当我向人推荐类似Braid的游戏，他们就会认为我喜欢“解谜题”，于是他们给我推荐类似&lt;a href=&quot;http://www.zelda.com&quot;&gt;Zelda&lt;/a&gt;或者&lt;a href=&quot;http://www.antichamber-game.com&quot;&gt;Antichamber&lt;/a&gt;之类的游戏，告诉我它们很考智力。可是这样的游戏，我一般玩不到几分钟就开始觉得无聊。这说明我并不是喜欢“解谜题”，而是因为另外一些特征而喜欢某些游戏。喜欢玩Zelda，Antichamber，或者《生化危机》一类游戏的人，往往有一种自虐倾向。这种人似乎很在乎自己的智商，所以游戏玩了不久之后，就会被“套牢”。他们会认为能够把某个游戏打通关，是对自己智商的认可。如果你跟他说这游戏太难太麻烦，他就会开始鄙视你的智力，吹嘘自己只花了多么短的时间就玩通关了。&lt;/p&gt;&lt;p&gt;然而如果你退后一步，就会发现这些游戏，其实都存在某种“&lt;a href=&quot;http://www.jianshu.com/p/b501a1675f4d&quot;&gt;设计公式&lt;/a&gt;”。一旦掌握了这些公式，你就可以轻而易举地制造出这样的游戏。然后你就会发现，热衷于这些游戏的人，其实并不聪明，因为他们被游戏的设计者玩弄于鼓掌之中，而没能发现其中的设计公式。这些人为了得到别人的认可，检验或者训练所谓的“智力”，甚至为了“合群”，选择了这类只能叫做“自虐型”的游戏。&lt;/p&gt;&lt;p&gt;这种游戏玩到后来，你就会发现这不是在娱乐，而是在完成任务，不是你在玩游戏，而是游戏在玩你。你盼望它早点结束，但却无法立即罢手，因为你对自己说：“如果现在半途而废，我就是一个懦夫，一个笨蛋，就不再是一个天才……” 你在虚拟的空间中来回的游走，摸索和寻找那些能打开机关的“钥匙”，而它们被游戏的设计者故意放在一些让人恼火的地方。你感觉到的不是快乐，而是繁琐，沮丧和空虚。&lt;/p&gt;&lt;p&gt;我发现容易落入这种圈套的人，他们在日常生活和工作中也容易出现类似的倾向。总的说来，这种人正如卓别林的《大独裁者》最后的&lt;a href=&quot;http://tinyurl.com/bbqfs6s&quot;&gt;演讲&lt;/a&gt;所描述的，“想得太多，感觉太少”（think too much, feel too little）。这种人如果沿着这条道路发展下去，就会变成像机器一样思考的人。正是这种人，给世界带来了灾难。希特勒就是这样一种人的典型代表，他太在乎自己是否优秀和聪明，却感觉不到人间的爱和痛苦，所以他对自己认为是劣等民族的人进行残酷的屠杀。&lt;/p&gt;&lt;p&gt;所以，我其实并不是因为智力上的挑战性而喜欢Braid，Limbo，Klonoa等游戏。我喜欢它们，是因为它们充满了创意和想象力，却又不让人觉得繁琐和累赘。在这样的游戏里，你能做一些你从前根本没想到过的事情，它们的设计可以用“妙不可言”来形容。这种游戏的逻辑很连贯流畅，你不需要到处瞎撞，来回跑动，而是一气呵成，行云流水，却又不乏波澜起伏和机智巧妙之处。这就像自己在演出一场出神入化的电影。你感觉到的不是沮丧，迷茫，不是对自己智力的考验和评价，而是真正的愉悦和解脱。&lt;/p&gt;&lt;p&gt;当我推荐Klonoa给一个朋友的时候，我说：“玩这个游戏就感觉是在梦里……” 结果他对我说：“你知道另外一个叫什么什么的游戏里面，也有个四维空间吗？……” 其实我根本不是在跟他讨论“梦是什么”这种学术问题，而是在说“梦幻的感觉”。这位朋友就属于我前面提到的，“想得太多”的类型。我说像是在梦里，说的是一种感觉，只有心才看得见；而他所理解的“梦”，是一种很理论的东西，就像数学里的多维空间，需要用脑才分析得出来。由于过度理性，他总是忙于分析一些“深层次”的理论，而看不见我能轻松感觉到的乐趣。我对他的建议是：少想一点，少分析一点，多用心感觉。只有用心去体会，你才会理解，Klonoa这样的游戏的价值，其实不在于智力和难度，而在于它让你感觉到的梦幻，创意，自由，想象力，和艺术。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">trap-of-intelligence</guid>
<pubDate>Fri, 20 Mar 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>我为什么不再公开开发Yin语言</title>
<link>http://yinwang.org/blog-cn/2015/03/18/yin-lang-secret</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;我为什么不再公开开发Yin语言&lt;/h2&gt;&lt;p&gt;有些人可能知道我在设计一个程序语言，叫做Yin语言。最开头宣布要做这个语言的时候，很多人热血沸腾，可是过了不久，我发现自己很不喜欢这样的气氛，越来越厌倦跟人讨论，所以后来悄悄地丢掉这些人，淡出了。我现在想告诉你我是怎么想的。&lt;/p&gt;&lt;p&gt;我从来没有想让Yin语言流行起来。我对程序语言的认识，其实超乎所有人的想象。我默默地看着各种新语言扯着各种幌子进行推广，可是它们的设计没有吸取历史教训，所以继续犯一些古老的错误，或者犯一些我根本不会犯的新错误，或者解决一些根本不需要解决的问题。其实程序语言已经不缺很多新的功能了，这些语言缺少的不是功能，而是简单和优雅。要达到简单和优雅，必须要有品位，而品位就像一个艺术家的心，是非常难得到的。没有经过Indiana式教育的人，是几乎不可能达到这种品位的。就算Friedman培养出来的那么多学生，也极少有人可以达到我这种地步。&lt;/p&gt;&lt;p&gt;我清楚的知道，其它语言设计者是完全没法达到我的一些精华思想的。我其实很懒，我希望有其他人做出我设想的语言，这样我就不需要亲自动手了，然而至今没有发现任何人可以做到，甚至根本没有想到。这些想法，早在多年前就已经被我在多个原型中实现过，所以具体做起来不会是问题。在我的心目中，Yin语言就像原子弹的技术。我不想搞核扩散，我并不想让所有人都得到它。我曾经觉得应该把它与全世界分享，后来我发现，你越是愿意分享，别人越是不拿你的东西当回事。我觉得这个世界不配拥有这样的语言，因为人类是那么的愚蠢。最可怕的是，很多人根本不知道自己其实很愚蠢。在资本主义这种奖励贪婪人的制度下，Yin语言被所有人掌握，很可能不是在造福世界，而是一种灾难。所以即使我把Yin语言做出来了，它也只会属于少数人，我不想让这样的技术落到贪婪或者愚蠢的人手里。&lt;/p&gt;&lt;p&gt;我很不喜欢人们对于一个新语言的反应。我不会因为人们对我设计的东西显示出盲目的热血沸腾而受到鼓舞，因为越是盲目热情的人，越可能脑子有问题，越可能在将来浪费我的口水，有理也说不清。我宣布开发Yin语言的第一天，就有人想把其他语言的“社区”的概念放到它身上。就像很多语言都搞得像宗教一样，一下子出现了好些想做“Yin语言传教士”的人。有些人太积极了，未经我同意就建立了IRC聊天室之类的东西，还有人立即买了个域名给Yin语言（然后控制权还没有给我）。他们其实没有想到，那些都不是我想要的。我很不喜欢其他语言的宗教性质，社区意识，阵营意识。我感觉有很多人其实只是想抢占“第一把交椅”，就像很多其他语言的狂热分子一样。他们让我感觉，从一开头我就已经失去了对这个语言的控制，仿佛它不再是我的设计。Yin语言跟其它语言不一样，它不应该有一个社区，不应该成为一个宗教，因为我是一个科学家，我的设计完全出于理性的思考。&lt;/p&gt;&lt;p&gt;我也不喜欢很多人对Yin语言肤浅的赞美或者质疑。有些人激动地对我说：“美国人，日本人，都有可以设计语言的人了，我们中国终于也有了！” 有的人甚至建议让它看起来像中文，符合中国人的思维方式。这些说法显示出人们对语言设计的无知和品位的低下。日本人做出了什么语言呢？我只知道一个日本人造的语言，它是一个彻底的垃圾 :P 美国人也没几个真正设计好点的语言。而且一个程序语言本来就跟人类语言扯不上任何关系，只不过有些关键字是人类语言的单词而已。也没有所谓“符合中国人的思维方式”一说，因为人脑其实根本就不是用人类语言在思考。人脑的思维方式更像是一种程序语言，一种电路，而不是人类语言。只有需要跟另一个人交流的时候，人脑才会把内部的“数据结构”转换成人类语言，就像Java的toString()方法一样。这就是我现在正在做的事，我很清楚我现在给你们打的这些字，不可能完全符合我的思维，也就是言不达意。所以无论把一个语言设计得像中文或者像英语，最后都是一个错误，因为普通的程序语言（比如C）早就在很多方面超越了人类语言，没有人类语言特有的那些历史遗留问题。SQL和COBOL之类的语言试图设计得像英语，结果惹出更多的麻烦事，得不偿失。想要一个程序语言有“中国特色”，其实显示出国人的自卑心理，也是在贬低我的价值。“中国第一”对我来说毫无意义，这让我感觉他们其实认为Yin语言跟“国产Linux”是一类的。要知道，我是世界上最强的语言设计者之一（很可能没有之一），我的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/01/29/human-value&quot;&gt;价值&lt;/a&gt;是不限定于任何国家的，它不需要任何人的肯定。&lt;/p&gt;&lt;p&gt;还有的人开始发送各种github issue，请求他们在其他语言（比如Ruby）里用过，认为重要的“特性”。有人要求我给这个语言“定性”，一本正经的要我说明这是什么“范式”的语言。有人义正言辞的索取1.0版本的specification。有人开始质疑我的一些设计，甚至自作聪明的做了改动。有人质疑我为什么不用正则表达式来做lexer，跟我说Java的lexer多么的严谨，因为它用了正则表达式…… 这一切都让我觉得越来越傻，越来越无语，越来越浪费时间和口水。他们不知道，他们头脑里的很多概念几乎全都不存在于我的脑子里。我不喜欢有人自作聪明，觉得好像自己懂很多似的，好像还可以评价甚至教育我。每一次不耻下问都发现似乎有人真以为我不懂，以为自己是专家了。Yin语言也许根本不符合任何一种“语言范式”，然而它也不会像Scala一样弄成个大杂烩。它应该是天衣无缝的设计，就像一句&lt;a href=&quot;http://www.brainyquote.com/quotes/quotes/a/antoinedes121910.html&quot;&gt;名言&lt;/a&gt;说的：“一个设计师知道他达到了完美，并不是当他不能再加进任何东西，而是当没有任何东西可以被去掉。”&lt;/p&gt;&lt;p&gt;另外，很多人认为重要的特性，很有可能是有问题的。他们不明白，现有程序语言的问题，不是没有实现某些特性，而是实现了多余的特性，有问题的特性。如果错误的特性被加了进去，一旦有人开始用这个语言，就再也没法去掉了。所以作为一个优秀的语言设计者，我的一项重要任务是防止多余或者有问题的特性进入语言里。我也很不喜欢有人拿我的语言，我的开发实力跟其它语言作对比，因为比较本身就是一种不尊重的行为。比如有些人质疑Yin语言有没有&lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/04/18/golang&quot;&gt;Go语言&lt;/a&gt;好，其实是在贬低我，因为我的水平跟Go语言的设计者根本不是一个档次的。Go语言的设计者其实基础知识都没搞清楚还自以为了不起，所以当我的学生都不合格。&lt;/p&gt;&lt;p&gt;所以，Yin语言的设计开发其实仍然在缓慢地进行中，然而已经不再公开，不再开源。我觉得所谓“开源精神”纯属扯淡，很多人开源不过是为了提高自己代码扩散的速度，提高知名度，这样可以带来利益，其实没有人真的是想做什么“贡献”的。这样的虚伪行为带来了开源社区的代码质量普遍低下，各种浮夸之风盛行，有人却看不出来。我不是Paul Graham，我不会吹牛，扬言要做个叫Arc的Lisp方言，结果最后做出来的东西连退步都不是（not even a step backwards）。我是有真正的实力，受过系统的精深的教育的，然而我真的有自己的困难和自己的生活。太多不合格的程序语言设计者占据了重要的语言设计岗位，很多公司已经完全不明白谁才是真正的专家。由于没有经济支持，我的大部分时间得用来做其他工作。设计语言是一个吃力不讨好的活，我想找到其它事情，甚至进入另一个领域，利用我的特殊品味来创造更大的价值。我不是工作狂，我也需要休闲和娱乐。我已经为技术耗费了太多的生命，我觉得我的人生是不完整的。为自己工作其实仍然算是工作，工作和生活需要平衡。我需要享受生活，需要陪我的猫咪，需要跟朋友玩，所以显然是不会浪费周末明媚的阳光，蹲在家里写代码的。所以Yin语言的开发虽然在进行，进度是不会很快的。即使我完成了，可能也不会给很多人用的。所以你们还是继续忍受现有语言和系统的扯淡和煎熬吧 :)&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">yin-lang-secret</guid>
<pubDate>Wed, 18 Mar 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>设计的重要性</title>
<link>http://yinwang.org/blog-cn/2015/03/17/design</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;设计的重要性&lt;/h2&gt;&lt;p&gt;我曾经在一篇&lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/07/17/rest&quot;&gt;文章&lt;/a&gt;里谈过关于设计的问题，然而那篇文章由于标题不够醒目，可能很多人没有注意看。我觉得现在有必要把里面的内容专门提出来讲一下，因为设计在我的心目中具有至关重要的地位，却被很多计算机科学家和程序员所轻视。&lt;/p&gt;&lt;p&gt;我觉得自己不但是一个计算机科学家和程序员，在很大程度上我还是一个设计师。我不但是一个程序语言的设计师，而且是其它很多东西的设计师。我设计的东西不但常常比别人的简洁好用，而且我经常直接看出其他人的设计里面的问题。我写的代码不仅自己容易看懂，而且别人也容易理解。我有时候受命修补前人的BUG，结果没法看懂他们的代码。在这种情况下，我的解决方案是推翻重写。经我重写之后的代码，不仅没有BUG，而且简洁很多。&lt;/p&gt;&lt;p&gt;很多人自己的设计有问题，太复杂不易用，到头来却把责任推在用户身上，使用类似“皇帝的新装”的技巧，让用户有口难言。之前一篇&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/02/24/human-errors&quot;&gt;文章&lt;/a&gt;提到的严重交通事故，就是一个设计问题，却被很多人归结为“人为错误”。这种出人命的事情都这么难引起人们对设计的关注，就更不要说软件行业那些无关性命的恼人之处了。有些人写的代码过度复杂，BUG众多，却仿佛觉得自己可以评估其他人的智商，打心眼里觉得自己是专家，看不懂他代码的人都是笨蛋。&lt;/p&gt;&lt;p&gt;很多程序员有意把“用户”和自己区别开来，好像程序员应该高人一等，不能以用户的标准。所以他们觉得程序员就是应该会用各种难用的工具，难用的操作系统，程序语言，编辑器，…… 他们觉得只要你追求这些东西的“易用性”或者“直观性”，就说明你智商有问题。只要你说某个东西太复杂，另一个东西好用些，他们就会跟你说：“专家才用这个，你那个是菜鸟用的。” 这些人不明白，程序员其实也是用户，而且他们是自己的代码的用户，每一次调用自己写的函数，自己都是自己的用户。可是这种鄙视用户的风气之胜行，带来了整个行业不但设计过度复杂，而且以复杂为豪的局面。&lt;/p&gt;&lt;p&gt;经常有人自豪的声称自己的项目有多少万行代码，仿佛代码的行数是衡量一个软件质量的标准，行数越多质量越好，然而事实却恰恰相反。你可能需要经历过Indiana式的教育才能真正的理解这一点。如果你拿一些引以为豪的代码给Dan Friedman看，他可能瞟一眼就说：“太长了。当年这个东西我两行代码就写出来了……” 你摸着脑袋怀疑他是不是在吹牛，怎么可能！然后过了几个星期，你把代码重写了好多遍之后，真的发现只需要两行！这时候他才会微笑着点点头，一副龟仙人的味道。就是这样的教育，让我能够在短短几个星期之内，完成Google一个小组的人花几年也没法完成的项目。看过我写的代码，你也许会理解这句&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%AE%89%E6%89%98%E4%B8%87%C2%B7%E5%BE%B7%E5%9C%A3%E5%9F%83%E5%85%8B%E7%B5%AE%E4%BD%A9%E9%87%8C&quot;&gt;《小王子》作者&lt;/a&gt;的&lt;a href=&quot;http://www.brainyquote.com/quotes/quotes/a/antoinedes121910.html&quot;&gt;名言&lt;/a&gt;：“一个设计师知道他达到了完美，并不是当他不能再加进任何东西，而是当没有任何东西可以被去掉。”&lt;/p&gt;&lt;p&gt;如果你跟我一样关心设计，却发现身边的人喜欢显示自己能搞懂复杂的东西，跟你说容易的东西都是菜鸟用的，那么你需要一个朋友。书籍是人类最好的朋友，因为它的作者可以跨越时间和空间的限制，给你最需要的支持和鼓励。这就是当我阅读这本1988年出版的《&lt;a href=&quot;http://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C&quot;&gt;The Design of Everyday Things&lt;/a&gt;》（简称DOET）时的感觉。我觉得，终于有人懂我了！有趣的是，它的作者 Don Norman 曾经是 Apple Fellow，也是《&lt;a href=&quot;http://web.mit.edu/~simsong/www/ugh.pdf&quot;&gt;The Unix-Haters Handbook&lt;/a&gt;》一书序言的作者。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/doet.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;DOET 不但包含并且支持了我的博文《&lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/04/11/hacker-culture&quot;&gt;黑客文化的精髓&lt;/a&gt;》以及《&lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/01/25/pl-and&quot;&gt;程序语言与……&lt;/a&gt;》里的基本观点，而且提出了比《&lt;a href=&quot;http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness&quot;&gt;什么是“对用户友好”&lt;/a&gt;》更精辟可行的解决方案。&lt;/p&gt;&lt;p&gt;我觉得这应该是每个程序员必读的书籍。为什么每个程序员必读呢？因为虽然这本书是设计类专业的必读书籍，而计算机及其编程语言和工具，其实才是作者指出的缺乏设计思想的“重灾区”。看了它，你会发现很多所谓的“人为错误”，其实是工具的设计不合理造成的。一个设计良好的工具，应该只需要很少量的文档甚至不需要文档。这本书将提供给你改进一切事物的原则和灵感。你会恢复你的人性。&lt;/p&gt;&lt;p&gt;值得一提的是，虽然 Don Norman 曾经是 Apple Fellow，但我觉得 Apple 产品设计的人性化程度与 Norman 大叔的思维高度还是有一定的差距的。因为我看了这书之后，立马发现了iPhone的一些设计问题。&lt;/p&gt;&lt;p&gt;如果你跟我一样不想用眼睛看书，可以到 Audible 买本&lt;a href=&quot;http://www.audible.com/pd/Science-Technology/The-Design-of-Everyday-Things-Audiobook/B005I5MDGQ&quot;&gt;有声书&lt;/a&gt;来听。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">design</guid>
<pubDate>Tue, 17 Mar 2015 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
