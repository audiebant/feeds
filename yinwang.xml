<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>当然我在扯淡</title>
<link>http://www.yinwang.org/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Mon, 01 May 2017 15:55:11 +0800</lastBuildDate>
<item>
<title>我为什么不在乎人工智能</title>
<link>http://yinwang.org/blog-cn/2017/04/23/ai</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;我为什么不在乎人工智能&lt;/h2&gt;
                            &lt;p&gt;有人听说我想创业，给我提出了一些“忽悠”的办法。他们说，既然你是程序语言专家，而现在人工智能（AI）又非常热，那你其实可以搞一个“自动编程系统”，号称可以自动生成程序，取代程序员的工作，节省许许多多的人力支出，这样就可以趁着“AI 热”拉到投资。&lt;/p&gt;

&lt;p&gt;有人甚至把名字都给我想好了，叫“深度程序员”（DeepCoder = Deep Learning + Coder）。口号是：“有了 DeepCoder，不用 Top Coder！” 还有人给我指出了这方向最新的，吹得神乎其神的研究，比如微软的 &lt;a href=&quot;http://www.jiqizhixin.com/article/2691&quot;&gt;Robust Fill&lt;/a&gt;……&lt;/p&gt;

&lt;p&gt;我谢谢这些人的关心，然而其实我并不在乎，也不看好人工智能。现在我简单的讲一下我的看法。&lt;/p&gt;

&lt;h3&gt;机器一样的心&lt;/h3&gt;

&lt;p&gt;很多人喜欢鼓吹人工智能，&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/02/12/self-driving-car&quot;&gt;自动车&lt;/a&gt;，机器人等技术，然而如果你仔细观察，就会发现这些人不但不理解人类智能是什么，不理解人工智能有什么局限性，而且这些“AI 狂人”们的心，已经严重的机械化了。他们或多或少的失去了人性，仿佛忘记了自己是一个人，忘记了人最需要的是什么，忘记了人的价值。这些人就像卓别林在『&lt;a href=&quot;https://www.youtube.com/watch?v=w8HdOHrc3OQ&quot;&gt;大独裁者&lt;/a&gt;』最后的演讲里指出的：“机器一样的人，机器一样的心。”&lt;/p&gt;

&lt;p&gt;每当提到 AI，这些人必然野心勃勃地号称要“取代人类的工作”，“节省劳动力开销”。暂且不讨论这些目标能否实现，它们与我的价值观，从一开头就是完全矛盾的。一个伟大的公司，应该为社会创造实在的，新的价值，而不是想方设法“节省”什么劳动力开销，让人失业！想一下都觉得可怕，我创造一个公司，它最大的贡献就是让成千上万的人失业，为贪得无厌的人节省“劳动力开销”，让贫富分化加剧，让权力集中到极少数人手里，最后导致民不聊生，导致社会的荒芜甚至崩溃……&lt;/p&gt;

&lt;p&gt;我不可想象生活在那样一个世界，就算那将使我成为世界上最有钱的人，也没有了意义。世界上有太多钱买不来的东西。如果走在大街上，我看不到人们幸福的笑容，悠闲的步伐，没有亲切的问候，关爱和幽默感，看不见甜蜜浪漫的爱情，反而看见遍地痛不欲生的无家可归者，鼻孔里钻进来他们留下的冲人的尿骚味，走到哪里都怕有人抢劫，因为人们实在活不下去了，除了偷和抢，没有别的办法活……&lt;/p&gt;

&lt;p&gt;如果人工智能成功的话，这也许就是最后的结果。幸运的是，有充足的证据显示，人工智能是永远不会成功的。&lt;/p&gt;

&lt;h3&gt;我的人工智能梦&lt;/h3&gt;

&lt;p&gt;很多人可能不知道，我也曾经是一个“AI 狂热者”。我也曾经为人工智能疯狂，把它作为自己的“伟大理想”。我也曾经张口闭口拿“人类”说事，仿佛机器是可以跟人类相提并论，甚至高于人类的。当深蓝电脑战胜卡斯帕罗夫，我也曾经感叹：“啊，我们人类完蛋了！” 我也曾经以为，有了“逻辑”和“学习”这两个法（kou）宝（hao），机器总有一天会超越人类的智能。可是我没有想清楚这具体要怎么实现，也没有想清楚实现了它到底有什么意义。&lt;/p&gt;

&lt;p&gt;故事要从十多年前讲起，那时候人工智能正处于它的冬天。在清华大学的图书馆，我偶然地发现了一本尘封已久的 『&lt;a href=&quot;http://norvig.com/paip.html&quot;&gt;Paradigms of Artificial Intelligence Programming&lt;/a&gt;』（PAIP），作者是 Peter Norvig。像个考古学家一样，我开始逐一地琢磨和实现其中的各种经典 AI 算法。PAIP 的算法侧重于逻辑和推理，因为在它的年代，很多 AI 研究者都以为人类的智能，归根结底就是逻辑推理。他们天真地以为，有了谓词逻辑，一阶逻辑这些东西，可以表达“因为所以不但而且存在所有”，机器就可以拥有智能。于是他们设计了各种基于逻辑的算法，专家系统（expert system），甚至设计了基于逻辑的程序语言 Prolog，把它叫做“第五代程序语言”。最后，他们遇到了无法逾越的障碍，众多的 AI 公司无法实现他们夸口的目标，各种基于“神经元”的机器无法解决实际的问题，巨额的政府和民间投资化为泡影，人工智能进入了冬天。&lt;/p&gt;

&lt;p&gt;我就是在那样一个冬天遇到了 PAIP。它虽然没能让我投身于人工智能领域，却让我迷上了 Lisp 和程序语言。也是因为这本书，我第一次轻松而有章法的实现了 A* 等算法。我第一次理解到了程序的“模块化”是什么，在代码例子的引导下，我开始在自己的程序里使用小的“工具函数”，而不再忧心忡忡于“函数调用开销”。PAIP 和 SICP 这两本书，最后导致了我投身于更加“基础”的程序语言领域，而不是人工智能。&lt;/p&gt;

&lt;p&gt;在 PAIP 之后，我又迷了一阵子机器学习（machine learning），因为有人告诉我，机器学习是人工智能的新篇章。然而我逐渐意识到，所谓的人工智能和机器学习，跟真正的人类智能，关系其实不大。相对于实际的问题，PAIP 里面的经典算法要么相当幼稚，要么复杂度很高，不能解决实际的问题。最重要的问题是，我看不出 PAIP 里面的算法跟“智能”有什么关系。而“机器学习”这个名字，基本是一个幌子。很多人都看出来了，机器学习说白了就是统计学里面的“拟合函数”，换了一个具有迷惑性的名字而已。&lt;/p&gt;

&lt;p&gt;人工智能的研究者们总是喜欢抬出“神经元”一类的名词来吓人，跟你说他们的算法是受了人脑神经元工作原理的启发。注意了，“&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/12/inspiration&quot;&gt;启发&lt;/a&gt;”是一个非常模棱两可的词，由一个东西启发得来的结果，可以跟这个东西毫不相干。比如我也可以说，Yin 语言的设计是受了九 yin 真经的启发 :P&lt;/p&gt;

&lt;p&gt;世界上这么多 AI 研究者，有几个真的研究过人脑，解刨过人脑，拿它做过实验，或者读过脑科学的研究成果？最后你发现，几乎没有 AI 研究者真正做过人脑或者认知科学的研究。著名的认知科学家 Douglas Hofstadter 早就在接受采访时指出，这帮所谓“AI 专家”，对人脑和意识（mind）是怎么工作的，其实完全不感兴趣，也从来没有深入研究过，却号称要实现“通用人工智能”（Artificial General Intelligence, AGI），这就是为什么 AI 直到今天都只是一个虚无的梦想。&lt;/p&gt;

&lt;h3&gt;识别系统和语言理解&lt;/h3&gt;

&lt;p&gt;纵观历史上机器学习能够做到的事情，都是一些字符识别（OCR），语音识别，人脸识别一类的，我把这些统称为“识别系统”。当然，识别系统是很有价值的，OCR 是非常有用的，我经常用手机上的语音输入法，人脸识别对于警察和间谍机关，显然意义重大。然而很多人因此夸口,说我们可以用同样的方法（机器学习，深度学习），实现“人类级别的智能”，取代很多人的工作，这就是神话了。&lt;/p&gt;

&lt;p&gt;识别系统跟真正理解语言的“人类智能”，其实相去非常远。说白了，这些识别系统，也就是统计学的拟合函数能做的事情：输出一堆像素或者音频，输出一个个的单词文本。很多人分不清“文字识别”和“语言理解”的区别。OCR 和语音识别系统，虽然能依靠统计的方法，“识别”出你说的是哪些字，它却不能真正“理解”你在说什么。&lt;/p&gt;

&lt;p&gt;聊一点深入的话题，看不懂的人可以跳过这一段。“识别”和“理解”的差别，就像程序语言里面“语法”和“语义”的差别。程序语言的文本，首先要经过词法分析器（lexer），语法分析器（parser），才能送进&lt;a href=&quot;http://www.yinwang.org/blog-cn/2012/08/01/interpreter&quot;&gt;解释器&lt;/a&gt;（interpreter），只有解释器才能实现程序的语义。类比一下，自然语言的语音识别系统，其实只相当于程序语言的词法分析器（lexer）。&lt;/p&gt;

&lt;p&gt;大部分的 AI 系统里面连语法分析器（parser）都没有，所以主谓宾，句子结构都分析不清楚，更不要说理解其中的含义了。IBM 的语音识别专家 &lt;a href=&quot;https://en.wikipedia.org/wiki/Frederick_Jelinek&quot;&gt;Frederick Jelinek&lt;/a&gt; 曾经开玩笑说：“每当我开掉一个语言学家，识别率就上升了。” 其原因就是语音识别仅相当于一个 lexer，而语言学家研究的是 parser 以及 interpreter。当然了，你们干的事情太初级了，所以语言学家帮不了你们，但这并不等于语言学家是没有价值的。&lt;/p&gt;

&lt;p&gt;很多人语音识别专家以为语法分析（parser）是没用的，因为人好像从来没有 parse 过句子，就理解了它的意义。然而他们没有察觉到，人其实必须要不知不觉地 parse 有些句子，才能理解它的含义。比如这样一个句子：“我并不完全反对去游泳这个提议。” 我问你，一个不能正确 parse 句子的机器，它如何知道你到底想去游泳，还是不想去？这个机器很可能看到“完全”，“反对”，“游泳”，…… 然后就根据关键字做出判断，认为你不想去游泳。它有可能会考虑那个“不”字，可是这个“不”字在句子里的位置，决定了它否认的结构。没有语法分析，你就不可能正确的理解它到底在否定什么。&lt;/p&gt;

&lt;p&gt;制造自然语言的 parser 有多难？很多人可能没有试过。没想到吧，我做过这事 :) 在 Indiana 的时候，我为了凑足学分，修了一门 NLP 课程，跟几个同学一起实现了一个英语的 parser。你可能想不到有多困难，你不止需要深刻理解编程语言的 parser 理论，还得依靠大量的例子和数据，才能解开人类语言里面的各种歧义。我的合作伙伴是专门研究 NLP 的，什么 Haskell，类型系统，category theory，什么 GLR parsing 之类…… 都弄得很溜。然而就算如此，我们的英语 parser 也只能处理最简单的句子，还错误百出，最后蒙混过关 :P&lt;/p&gt;

&lt;p&gt;经过了语法分析，得到一棵“语法树”，你才能传给人脑里语言的理解中心（类似程序语言的“解释器”）。解释器“执行”这个句子，为相关的名字找到对应的“值”，进行计算，才能得到句子的含义。至于人脑如何为句子里的词汇赋予“意义”，如何把这些意义组合在一起，形成“思维”，这个问题似乎没有人很明白。至少，这需要大量的实际经验，这些经验是一个人从生下来就开始积累的。我们制造的机器完全不具备这些经验，我们不知道如何才能让他获得经验，也不知道这些经验在人脑里面是什么样的结构，如何组织的。所以机器要真的理解一个句子，真的是登天一样的困难。&lt;/p&gt;

&lt;p&gt;这就是为什么 Hofstadter 说：“一个机器要能理解人说的话，它必须要有腿，能够走路，去观察世界，获得它需要的经验，它必须能够跟人一起生活，体验他们的生活和故事……” 最后你发现，制造这样一个机器，比养个小孩困难太多了，这不是吃饱了没事干是什么。&lt;/p&gt;

&lt;h3&gt;机器对话系统和人类客服&lt;/h3&gt;

&lt;p&gt;各大公司最近叫得最响亮的“AI 技术”，就是 Siri，Cortana，Google Assistant，Amazon Echo 一类含有语音识别功能的工具，叫做“个人助手”。这些东西里面，到底有多少可以叫做“智能”的东西，我想用过的人都应该明白。我每一次试用 Siri 都被它的愚蠢所折服，可以让你着急得砸了水果手机。那另外几个同类，也没有好到哪里去。&lt;/p&gt;

&lt;p&gt;很多人被“微软小冰”忽悠过，咋一看这家伙真能理解你说的话呢！然而聊一会你就发现，小冰不过是一个“网络句子搜索引擎”。它只是按照你句子里的关键字，随机搜出网上已有的句子。大部分这类句子出自问答类网站，比如百度知道，知乎。一个很简单的实验，就是反复发送同一个词给小冰，比如“王垠”，看它返回什么内容，然后拿这个内容到 Google 或者百度搜索，你就会找到那个句子真正的出处。人都喜欢自欺欺人，看到几个句子回答得挺“俏皮”，就以为它有智能，而其实它是随机搜出一个句子，牛头不对马嘴，所以你才感觉“俏皮”。比如，你跟小冰说：“你认识王垠吗？”，她可能回答：“王垠这是要做段子手吗？” 心想多可爱的妹子，不正面回答你的问题，有幽默感！然后你在百度一搜，发现这句话是某论坛里面黑我的人说的。小冰只是随机搜索出这句子，至于幽默感，完全是你自己想象出来的。很多人跟小冰对话，喜欢只把其中“符合逻辑”或者“有趣”的部分截图下来，然后惊呼：“哇，小冰好聪明好有趣！” 他们没有告诉你的是，没贴出来的对话，很多都是鸡同鸭讲。&lt;/p&gt;

&lt;p&gt;IBM 的 Watson 系统在 Jeopardy 游戏中战胜了人，很多人就以为 Watson 能理解人类语言，具有人类级别的智能。这些人甚至都不知道 Jeopardy 是怎么玩的，就盲目做出判断，以为 Jeopardy 是一种需要理解人类语言才可以玩的游戏。等你细看，发现 Jeopardy 就是很简单的“猜谜”游戏，题目是一句话，答案是一个名词。比如：“有个歌手去年得了十项格莱美奖，请问他是谁？” 如果你理解了我之前对“识别系统”的分析，就会发现 Watson 也是一种识别系统，它的输入是一个句子，输出是一个名词。一个可以玩 Jeopardy 的识别系统，可以完全不理解句子的意思，而是依靠句子里出现的关键字，依据分析大量语料得到的拟合函数，输出一个单词。世界上那么多的名词，到哪里去找这样的语料呢？这里我给你一个 Jeopardy 谜题作为提示：“什么样的网站，你给它一个名词，它输出一些段落和句子，给你解释这个东西是什么，并且提供给你各种相关信息？” 很容易猜吧？你只需要把这种网站的内容掉一个头，制造一个神经网络，输入句子，输出名词，就可以制造出可以玩 Jeopardy 的机器来，而且它很容易超越人类玩家（为什么？）。其实为了验证 Watson 是否理解人类语言，我早些时候去 Watson 的网站玩过它的“客服 demo”，结果完全是鸡同鸭讲，大部分时候 Watson 回答：“我不清楚你在说什么。你是想要……” 然后列出一堆选项，1，2，3……&lt;/p&gt;

&lt;p&gt;当然，我并不是说这些产品完全没有价值。我用过 Siri 和 Google Assistant，我发现它们还是有用的，特别是在开车的时候。因为开车时操作手机容易出事，所以我可以利用语音控制。比如我可以对手机说：“导航到最近的加油站。” 然而实现这种语音控制，根本不需要理解语言，你只需要用语音识别输入一个函数调用：导航（加油站）。个人助手在其它时候用处都不大。我不想在家里和公共场所使用它们，原因很简单：我懒得说话，或者不方便说话。点击几下屏幕，我就可以精确地做到我想要的事情，这比说话省力很多，也精确很多。个人助手完全不理解你在说什么，这种局限性本来无可厚非，可以用就行了，然而各大公司最近却拿个人助手这类东西来煽风点火，夸大其中的“智能”成分，闭口不提他们的局限性，让外行们以为人工智能就快实现了，这就是为什么我必须鄙视一下这种做法。&lt;/p&gt;

&lt;p&gt;举个例子，由于有了这些“个人助手”，有人就号称类似的技术可以用来制造“机器客服”，使用机器代替人作为客服。他们没有想清楚的是，客服看似“简单工作”，跟这些语音控制的玩意比起来，难度却是天壤之别。客服必须理解公司的业务，必须能够精确地理解客户在说什么，必须形成真正的对话，要能够为客户解决真正的问题，而不能只抓住一些关键字进行随机回复。另外，客服必须能够从对话信息，引发现实世界的改变，比如呼叫配送中心停止发货，向上级请求满足客户的特殊要求，拿出退货政策跟客户辩论，拒绝他们的退货要求，抓住客户心理，向他们推销新服务等等，各种需要“人类经验”才能处理的事情。所以机器能不但要能够形成真正的对话，理解客户的话，它们还需要现实世界的大量经验，需要改变现实世界的能力，才可能做客服的工作。由于这些个人助手全都是在忽悠，所以我看不到有任何希望，能够利用现有的技术实现机器客服。&lt;/p&gt;

&lt;p&gt;连客服这么按部就班的工作，机器都无法取代，就不用说更加复杂的工作了。很多人看到 AlphaGo 的胜利，以为所谓 Deep Learning 终究有一天能够实现人类级别的智能。在之前的一篇&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/03/09/alpha-go&quot;&gt;文章&lt;/a&gt;里，我已经指出了这是一个误区。很多人以为人觉得困难的事情（比如围棋），就是体现真正人类智能的地方，其实不是那样的。我问你，心算除法（23423451345 / 729）难不难？这对于人是很难的，然而任何一个傻电脑，都可以在 0.1 秒之内把它算出来。围棋，国际象棋之类也是一样的原理。这些机械化的问题，其实不能反应真正的人类智能，它们体现的只是大量的蛮力。&lt;/p&gt;

&lt;p&gt;纵观人工智能领域发明过的吓人术语，从 Artificial Intelligence 到 Artificial General Intelligence，从 Machine Learning 到 Deep Learning，…… 我总结出这样一个规律：人工智能的研究者们似乎很喜欢制造吓人的名词，当人们对一个名词失去信心，他们就会提出一个不大一样的，新的名词，免得人们把对这个名词的失望，转移到新的研究上面。然而这些名词之间，终究是换汤不换药。因为没有人真的知道人的智能是什么，所以也就没有办法实现“人工智能”。&lt;/p&gt;

&lt;p&gt;生活中的每一天，我这个“前 AI 狂热者”都在为“人类智能”显示出来的超凡能力而感到折服。甚至不需要是人，任何高等动物（比如猫）的能力，都让我感到敬畏。我发自内心的尊重人和动物。我不再有资格拿“人类”来说事，因为面对这个词汇，任何机器都是如此的渺小。&lt;/p&gt;

&lt;h3&gt;纪念我的聊天机器人 helloooo&lt;/h3&gt;

&lt;p&gt;乘着这个热门话题，现在我来讲一下，十多年前我自己做聊天机器人的故事……&lt;/p&gt;

&lt;p&gt;如果你看过 PAIP 或者其它的经典人工智能教材，就会发现这些机器对话系统，最初的思想来自一个叫“&lt;a href=&quot;https://en.wikipedia.org/wiki/ELIZA&quot;&gt;ELIZA&lt;/a&gt;”的 AI 程序。Eliza 被设计为一个心理医生，跟你对话排忧解难，而它内部其实就是一个类似小冰的句子搜索引擎，实现方式完全用正则表达式匹配搞定。比如，Eliza 的某个规则可以说，当用户说：“我(.*)”，那么你就回答：“我也$1……” 其中 $1 代替原句子里的一部分，造成一种“理解”的效果。比如用户也许会说：“我好无聊。” Eliza 就可以说：“我也好无聊……” 然后这两个无聊的人就惺惺相惜，有伴了。&lt;/p&gt;

&lt;p&gt;有些清华的老朋友也许还记得，十多年前在清华的时候，我做了一个聊天机器人放在水木清华 BBS，红极一时，所以我也可以算是网络聊天机器人的鼻祖了 :) 我的聊天机器人，水木账号叫 helloooo。helloooo 的性格像蜡笔小新，是一个调皮又好色的小男孩。它内部采用的就是类似 Eliza 的做法，根本不理解句子，甚至连语料库都没有，神经网络也没有，里面就是一堆我事先写好的正则表达式“句型”而已。你输入一个句子，它匹配之后，从几种回复之中随机挑一个，所以你反复说同样的话，helloooo 的回答不会重复，如果你故意反复说同样的话，最后 helloooo 会对你说：“你怎么这么无聊啊？”或者“你有病啊？” 或者转移话题，或者暂时不理你…… 这样对方就不会明显感觉它是一个傻机器。&lt;/p&gt;

&lt;p&gt;就是这么简单个东西。出乎我意料的是，helloooo 一上网就吸引了很多人。一传十十传百，每天都不停地有人发信息跟他聊。由于我给他设置的正则表达式和回复方式考虑到了人的心理，所以 helloooo 显得很“俏皮”，有时候还可能装傻，捣蛋，延迟回复，转移话题，还可能主动找你聊天，使用超过两句的小段子，…… 各种花样都有。最后，这个小色鬼赢得了好多妹子们的喜爱，甚至差点约了几个出去呢！:P 在这点上，helloooo 可比小冰强很多。小冰的技术含量虽然多一些，数据多很多，然而 helloooo 感觉更像一个人，也更受欢迎。这说明，我们其实不需要很高深的技术，不需要理解自然语言，只要你设计巧妙，抓住人的心理，就能做出人们喜爱的聊天机器。&lt;/p&gt;

&lt;p&gt;后来，helloooo 终于引起了清华大学人智组研究生的兴趣，来问我：“你这里面使用的什么语料库做分析啊？” 我：“&amp;amp;%&amp;amp;￥@#@#%……”&lt;/p&gt;

&lt;h3&gt;自动编程是不可能的&lt;/h3&gt;

&lt;p&gt;现在回到有些人最开头的提议，实现自动编程系统。我现在可以很简单的告诉你，那是不可能实现的。微软的 &lt;a href=&quot;http://www.jiqizhixin.com/article/2691&quot;&gt;Robust Fill&lt;/a&gt; 之类，全都是在扯淡。我对微软最近乘着 AI 热，各种煽风点火的做法，表示少许鄙视。不过微软的研究员也许知道这些东西的局限，只是国内小编在夸大它的功效吧。&lt;/p&gt;

&lt;p&gt;你仔细看看他们举出的例子，就知道那是一个玩具问题。人给出少量例子，想要电脑完全正确的猜出他想做什么，那显然是不可能的。很简单的原因，例子不可能包含足够的信息，精确地表达人想要什么。最最简单的变换也许可以，然而只要多出那么一点点例外情况，你就完全没法猜出来他想干什么。就连人看到这些例子，都不知道另一个人想干什么，机器又如何知道？这根本就是想实现“读心术”。甚至人自己都可以是糊涂的，他根本不知道自己想干什么，机器又怎么猜得出来？所以这比读心术还要难！&lt;/p&gt;

&lt;p&gt;对于如此弱智的问题，都不能 100% 正确的解决，遇到稍微有点逻辑的事情，就更没有希望了。论文最后还“高瞻远瞩”一下，提到要把这作法扩展到有“控制流”的情况，完全就是瞎扯。所以 RobustFill 所能做的，也就是让这种极其弱智的玩具问题，达到“接近 92% 的准确率”而已了。另外，这个 92% 是用什么标准算出来的，也很值得怀疑。&lt;/p&gt;

&lt;p&gt;任何一个负责的程序语言专家都会告诉你，自动生成程序是根本不可能的事情。因为“读心术”是不可能实现的，所以要机器做事，人必须至少告诉机器自己“想要什么”，然而表达这个“想要什么”的难度，其实跟编程几乎是一样的。实际上程序员工作的本质，不就是在告诉电脑自己想要它干什么吗？最困难的工作（数据结构，算法，数据库系统）已经被固化到了库代码里面，然而表达“想要干什么”这个任务，是永远无法自动完成的，因为只有程序员自己才知道他想要什么，甚至他自己都要想很久，才知道自己想要什么……&lt;/p&gt;

&lt;p&gt;有句话说得好：编程不过是一门失传的艺术的别名，这门艺术的名字叫做“思考”。没有任何机器可以代替人的思考，所以程序员是一种不可被机器取代的工作。虽然好的编程工具可以让程序员工作更加舒心和高效，任何试图取代程序员工作，节省编程劳力开销，克扣程序员待遇，试图把他们变成“可替换原件”的做法（比如 Agile，TDD），最终都会倒戈，使得雇主收到适得其反的后果。同样的原理也适用于其它的创造性工作：厨师，发型师，画家，……&lt;/p&gt;

&lt;p&gt;所以别妄想自动编程了。节省程序员开销唯一的办法，是邀请优秀的程序员，尊重他们，给他们好的待遇，让他们开心安逸的生活和工作。同时，开掉那些满口“Agile”，“Scrum”，“TDD”，“&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/06/07/software-engineering&quot;&gt;软件工程&lt;/a&gt;”，光说不做的扯淡管理者，他们才是真正浪费公司资源，降低开发效率和软件质量的祸根。&lt;/p&gt;

&lt;h3&gt;傻机器的价值&lt;/h3&gt;

&lt;p&gt;我不反对继续投资研究那些有实用价值的人工智能（比如人脸识别一类的），然而我觉得不应该过度夸大它的用处，把注意力过分集中在它上面，仿佛那是唯一可以做的事情，仿佛那是一个划时代的革命，仿佛它将取代一切人类劳动。&lt;/p&gt;

&lt;p&gt;我的个人兴趣其实不在人工智能上面。那我要怎么创业呢？很简单，我觉得大部分人不需要很“智能”的机器，“傻机器”才是对人最有价值的，我们其实远远没有开发完傻机器的潜力。所以设计新的，可靠的，造福于人的傻机器，应该是我创业的目标。当然我这里所谓的“机器”，包括了硬件和软件，甚至可以包括云计算，大数据等内容。&lt;/p&gt;

&lt;p&gt;只举一个例子，有些 AI 公司想研制“机器佣人”，可以自动打扫卫生做家务。我觉得这问题几乎不可能解决，还不如直接请真正智能的——阿姨来帮忙。我可以做一个阿姨服务平台，方便需要服务的家庭和阿姨进行牵线搭桥。给阿姨配备更好的工具，通信，日程，支付设施，让她工作不累收钱又方便。另外给家庭提供关于阿姨工作的反馈信息，让家庭也省心放心，那岂不是两全其美？哪里需要什么智能机器人，难度又高，又贵又不好用。显然这样的阿姨服务平台，结合真正的人的智能，轻而易举就可以让那些机器佣人公司死在萌芽之中。&lt;/p&gt;

&lt;p&gt;当然我可能不会真去做个阿姨服务平台，只是举个例子，说明许许多多对人有用的傻机器，还在等着我们去发明。这些机器设计起来虽然需要灵机一动，然而实现起来难度却不高，给人带来便利，经济上见效也快。这些东西不对人的工作造成竞争，反而可能制造更多的就业机会。利用人的智慧，加上机器的蛮力，让人们又省力又能挣钱，才是最合理的发展方向。&lt;/p&gt;

&lt;p&gt;（如果你喜欢这篇文章，欢迎&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付款&lt;/a&gt;，数量随意）&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/23/ai</guid>
<pubDate>Sun, 23 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>那些垠黑们</title>
<link>http://yinwang.org/blog-cn/2017/04/19/yinhei</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;那些垠黑们&lt;/h2&gt;
                            &lt;p&gt;我知道有许多人喜欢看我的博客，因为我擦亮了他们的眼睛，给了他们智慧和力量。我也知道有很多人喜欢“黑”我，我曾经在意过这些“垠黑”，甚至亲自跟他们吵。然而逐渐的，我发现了这些垠黑们的一些特征。有些是闲的无聊，有的是心理不正常，有些则是因为我批判的东西，正好伤到了他耐以生存的幌子。所以这些人开始在网上黑我，甚至自己立个靶子，杜撰我从来没有说过的话，然后进行反驳，以此攻击我本人。&lt;/p&gt;

&lt;p&gt;有朋友跟我说，在网上看到这些黑我的人，都帮我骂回去。其实逐一的反击这些垠黑，完全是浪费时间。跟疯狗对骂，不但不起作用，反倒坏了自己的心情。对这些人，最好的办法是忽略他们。不去看他们说什么，不去访问他们聚集的网站（比如知乎）。&lt;/p&gt;

&lt;p&gt;虽然垠黑们都是蚍蜉想撼大树，但是由于他们在网络上的无耻行为引起我的朋友们不必要的烦扰，我觉得还是有必要写一篇文章，统一对他们进行披露和鄙视。&lt;/p&gt;

&lt;h3&gt;现实中的垠黑&lt;/h3&gt;

&lt;p&gt;如果你只看网上的信息，还真能把你急坏了，因为似乎很多人都在黑我，你会以为王垠名声这么差，这下子完蛋了。然而“网民”跟现实的世界，其实是有很大的差别的。现实世界里，我的身边充满了敬佩和支持我的人。之前的公司 20 多个中国人，大部分都直接或者间接看过我的文章，大部分人都喜欢我，支持我。只要我说要回国，有要挽留的，有要帮忙的…… 这里面只有一个人是不尊敬我的。&lt;/p&gt;

&lt;p&gt;这个人让我记忆深刻。他显然没有看过我的文章，我平时也很少跟他说话。有一天他对我说，我听说你有一个很有名的博客，可以给我看看吗？我告诉了他网址，他就当着我的面开始浏览文章列表，用一种嘲讽的口气念叨道：“哦，谈谈这技术，谈谈那技术。哦~ 呵呵呵……” 我的直觉是很灵敏的，我立即意识到，自己根本就不该跟他说话。于是我走开，跟旁边的朋友聊天去了。后来，我发现这个人是从 Google 过来的，平时总会有意无意的提起自己在 Google 的经历，Google 又做了什么“新技术”，显示自己是“Google 人”，后来听说他又回 Google 去了。我真是很佩服 Google 对人的洗脑能力，一朝被 Google 洗脑，永远给 Google 舔屁股。&lt;/p&gt;

&lt;p&gt;现实生活中，我就只遇到过这样一个垠黑。你可以看出他们大概是怎样一种人。没有实力的人，总是喜欢用公司的名气撑起自己的自信，当然他们很不满意我披露和鄙视这些公司。&lt;/p&gt;

&lt;h3&gt;网络上的垠黑&lt;/h3&gt;

&lt;p&gt;网络上的垠黑，貌似还真的挺多，我甚至亲身见过其中一位。前段时间我专门写了一篇博文，反驳某个看似专业的垠黑对 PySonar 的歪曲。可是后来我发现，跟这种人争锋相对，其实不但贬低了我自己的身份，而且还给他提供了信息。在我的文章中，我指出了这人好几处知识缺陷，一知半解，照本宣科的地方，并且点明了好几处精髓的思维要点。&lt;/p&gt;

&lt;p&gt;这样的辩论，我显然取得了压倒性的胜利，因为对方只是一个想鼓吹起自己名声的小人。然而我的文章却泄露了很重要的直觉和技术机密，如果这人有点心机和脑子，应该可以从里面学到一些精髓思想，进而可以拿去忽悠其他人。所以我虽然取得了胜利，却可能在无意中教会了别人一些重要的东西。也许他黑我的目的就在于此吧，使用“激将法”逼我说出一些信息。&lt;/p&gt;

&lt;p&gt;由于这个原因，我删掉了那篇博文。自己的技术机密和这种人的名字，都不应该出现在我的博客上面，他们应该被抹去。&lt;/p&gt;

&lt;h3&gt;所谓“老同学”&lt;/h3&gt;

&lt;p&gt;垠黑的队伍里面，其实也有少数老同学一类的。很多人总是在乎老同学情谊，然而其实每个人的老同学里面，有几个是真正的朋友呢？&lt;/p&gt;

&lt;p&gt;当我离开 Coverity 时，大骂这公司的恶劣行径。这时候一个清华的老同学给我 email，说想跟我聊聊。我以前就跟他说话不大投机，不是一类人。但念在老同学的情面，觉得他现在联系我，可能想口头上支持我一下，也没指望他帮什么忙。于是按约好的时间打电话给他，结果只甩给我一句：“我在给我家老二换尿布忙着呢！” 就挂机了，再也没有打回来。明明是他主动找我聊，打过去却又说他很忙，这老同学真是很有礼貌啊 :P 百思不得其解，不知道他的话是不是在表达这样一个意思：我都生了二胎了，王垠你混的也太差吧！后来他又没头没脑发 email 给我，说：“我正在用 Coverity 的产品呢！” 然后我明白了，原来他因为 Coverity 的产品还不错，就觉得我不该骂 Coverity 对待员工的恶劣作法。然后这人表达能力也有问题，不知道他到底想说什么。&lt;/p&gt;

&lt;p&gt;世界上就是有这样的老同学，本来当年关系就不咋的，一直没联系，现在主动找上门来，居然开口就嘲笑你。这样的老同学心态不正常，不联系也罢。类似的，特地来嘲讽我的老同学还有另外两个，都是当年说话就不投机的，喜欢吹牛扯淡，不择手段追求功名利禄那种，甚至很猥琐。真正的老同学和朋友，联系就没断过，也不会看到别人转载我的文章才来问候。&lt;/p&gt;

&lt;h3&gt;为什么会有垠黑&lt;/h3&gt;

&lt;p&gt;为什么这些人喜欢在网上黑我呢？你也许会问。原因很简单，王垠发布的那些真相，伤害到了他们用来撑起自己名声的东西。&lt;/p&gt;

&lt;p&gt;如果你仔细观察这些垠黑在网上发的东西，就会发现它们都有一个特点。很多垠黑喜欢上知乎，他们上知乎回答问题，目的在于提高自己的知名度，建立自己在网络上的威望，这样有利于自己将来的仕途，也许真有无知的小公司因为知乎上的威望值，请他们去做 VP 也说不定。如果你观察他们的“知乎头衔”，就会发现他们很喜欢把自己所在公司的名字，自己做的“牛逼技术”挂在上面。比如，“Intel 工程师”，“MIT 博士生”，“CoreCLR 开发者”……&lt;/p&gt;

&lt;p&gt;这种人还很喜欢在朋友圈转发一种文章，我把它们叫做“技术马屁”。这种文章的标题一般看起来像这样：“硅谷黑科技：牛逼到爆的你从来没听说过的技术！”，“Twitter 内部大数据系统构架分析” ，“Google Kubernetes 构建大规模集群系统详解”，“为什么自动驾驶车会征服全世界”，“所向无敌的 CFA 静态分析技术”…… 咋一看，你以为他只是对技术很感兴趣，很兴奋，然而久而久之你就发现，这人其实根本不知道他转发了什么东西。他甚至自己都没看过那些文章，他也知道其他人不会仔细看。只是这些文章的标题看起来吓人，再把自己的昵称改成“硅谷XXX”，这样国内没见过世面的小编就会不明觉厉，以为这人是什么业界大牛。然后你还发现这人的交际圈里面，充满了各种互相吹捧，一知半解，招摇撞骗的人。也就是这些人，败坏了整个 IT 行业的风气。&lt;/p&gt;

&lt;p&gt;那么这种人为什么想黑我呢？你想想，有这么一个叫王垠的，他看透了很多东西，他的文章总是揭示各种技术和社会的真相。他告诉你，自动驾驶车是不切实际的幻想，Go 语言和 Kubernetes 其实是非常混乱不成熟设计糟糕的技术，他告诉你 PL 领域的很多研究其实完全无法投入实用的，他讲述自己在 Google，Coverity 等公司的恶劣遭遇…… 每当王垠揭露这样一个事情，这种夸夸其谈的小人就少了一个可以吹嘘，可以作为靠山的东西，反而会因为自己吹嘘过某个东西，引起相反的效果。看他转发那种马屁文章的人，会开始识破他们的真面目。&lt;/p&gt;

&lt;p&gt;这种人显然不希望真相得到传播，因为真相会威胁到他在社会上的立足之地，所以他们会在网上群起攻击王垠。比如有人会说：“王垠吹得那么牛那么神，那怎么在微软的职称才是个 SDE2？” 还有人嘲笑说：“老王啊老王，年纪一大把了还在追求自己的情怀，看我，十年前就开始追求财富……” 各种这样的嘲笑和侮蔑。然而这有意义吗？任何正直有良知的人看了这些，都知道这些人是什么东西。他们的活动圈子，不过也就是那一群互相吹捧的垃圾而已。这些人的话，对于我来说就像是哈巴狗的叫声，完全不能引起我情绪的波动。我写这篇文章的原因，其实主要是我的有些朋友看了那些很不平静，去跟他们对骂。我不想让朋友们的心情受到影响，所以在这里写一篇文章，一巴掌把网上这些苍蝇蚊子全都拍死，省得我朋友去费心 :)&lt;/p&gt;

&lt;h3&gt;网络上没有人知道你是一条狗&lt;/h3&gt;

&lt;p&gt;很多人看到“网上”一片骂声，却没有发现只有心理不正常，太无聊的人才会上那些网站。有真知灼见的人，好些都很少上网，听说了我的故事都直接联系我，不会在网上谈论这些东西。可以说我的圈子是谈笑有鸿儒，往来无白丁。至于那些“网民”们在说些什么，对于我完全无足轻重。因为“网络上没有人知道你是一条狗”，所以我根本不把网民当做人来对待。&lt;/p&gt;

&lt;p&gt;有人认为我在“网上”很活跃，甚至认为我是“网红”，然而我从来就不认为我写文章是在“上网”，我写文章从来就不是为了取悦任何人，所以也跟“网红”扯不上任何关系。正好相反，我是一个完全活在现实世界的人，我跟网民是完全隔绝的。我的文章虽然放在“网上”，依靠网络传播，然而它们就像鲁迅登在报纸上的文章一样，并不属于网络交流。这甚至不属于交流，只能叫做“发表”。在这个过程中，信息的传播是单向的，我从来不看任何人对我文章的评价。不是因为我害怕看人们的评价，而是因为没有人有资格来评价，所以我不在乎。我从来不参与任何网络讨论区的讨论，从来不上 Facebook，知乎，MITBBS 之类的网站。我甚至屏蔽绝大部分微信联系人的朋友圈，我完全不在乎他们在看什么，想什么，做什么。对于我来说，只有面对面的交流才是真实可靠的。&lt;/p&gt;

&lt;p&gt;所以呢，这些垠黑其实对我一点作用都没有。他们想抹黑我，想吓退我，然而他们在我眼里不过是哈巴狗而已。当然了，我不会指出这些垠黑的名字，因为我不想被狗咬。然而看过我文章的人，他们显然会擦亮自己的眼睛，在现实世界中识别出这些夸夸其谈，两面三刀的小人，所以这种人在社会上的势力会越来越小。正直而有真知灼见的人都会支持我，我们将联合在一起，互相支持，逐渐改善 IT 业界和职场的不正之风。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/19/yinhei</guid>
<pubDate>Wed, 19 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>为什么我的代码进入闭源状态</title>
<link>http://yinwang.org/blog-cn/2017/04/18/close-source</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;为什么我的代码进入闭源状态&lt;/h2&gt;
                            &lt;p&gt;我做出了一个可能让很多人遗憾的决定。从今天开始，我曾经开源放在 GitHub 上的代码，除了教育性质的代码，全部进入私有闭源状态。这些代码包括 PySonar2，RubySonar，ydiff 等等，它们已经从 GitHub 上消失。从今以后，除非用于教育目的，我将不再开源任何代码。当然，大家已经下载的那些代码，仍然可以按照开源许可证免费使用，然而最新的改进以及将来的新产品，将全部闭源。做出这个决定的大部分原因，是因为多次对人心的失望。&lt;/p&gt;

&lt;p&gt;PySonar2 一度处于开源状态，使用宽松的 BSD 和 Apache 版权。PySonar 的用户包括了 Google，Sourcegraph，还有其它几个我不能透露名字的，做专业代码管理工具的公司。很多人崇尚 BSD 这样的宽松版权，因为这样可以最大限度的传播代码。他们甚至把这作为了一种信仰，对于 GPL 这类严格限制商业用途的版权嗤之以鼻。甚至遮住眼睛对你说：“你的代码是 GPL 的，我不能看！看了之后写出一样的代码来，你会起诉我！” 然而多年的经历之后，我才发现 BSD 并不是好的开源版权，它其实会让代码的作者失去自由，而 GPL 才是真正保护软件及其作者的自由的。就像 &lt;a href=&quot;https://en.wikipedia.org/wiki/Richard_Stallman&quot;&gt;Stallman&lt;/a&gt; 说的，自由软件（Free Software）这个词里的“free”，是自由的意思，而不是免费的意思。直到今天，我才明白他这句话的真正含义。&lt;/p&gt;

&lt;p&gt;为什么 BSD 版权会让人失去自由？这个故事要从 Sourcegraph 讲起……&lt;/p&gt;

&lt;p&gt;Sourcegraph 是一家做代码管理工具的公司。他们初期的系统，其实只是在 PySonar 之上做了一个简单的 web 包装。把 PySonar 分析出来的信息倒到数据库里面，然后通过 web 方式显示给用户。PySonar 本身早就有一个演示程序，可以生成互动的 HTML，所以其实 Sourcegraph 能做的事情，我很容易就可以做到，只不过多一些杂活而已。Sourcegraph 并没有在 PySonar 之上增添很多的新东西，也无法做出 PySonar 这样的核心技术。他们早期的 UI 混淆不堪，有很多地方都是我给他们改了之后，才好了一点。但是因为我一直不在乎 Python 这语言，也没觉得这种工具有什么市场，所以一直没有动手开发一套完整的服务。不是不能做，而是没有动力去做。&lt;/p&gt;

&lt;p&gt;BSD 的版权使得 Sourcegraph 的两个创始人可以完全免费，无限制的使用 PySonar。这样的结果，使得我无法为 PySonar 收到任何的回报。后来 Sourcegraph 的两个人找到我，想招我进去，帮助他们制造 RubySonar 和改进 PySonar。这样就开始了我们的不平等合作关系。Sourcegraph 使用了 PySonar，按理我不需要另外做什么，就应该有一定的回报。然而现在他们把我招进去作为员工，我必须要做点其它事情，才能得到回报，也就是说我反倒成为了他们的打工仔。几个月之后，我逐渐发现这两个人的肤浅和不尊重。最后，在得到了最重要的技术改进之后，两个创始人翻脸不认人，把我赶出了公司。&lt;/p&gt;

&lt;p&gt;新的 PySonar2 里面已经没有了 Google 的代码。由于对人心的失望，我曾一度把 PySonar2 的版权改为 AGPL。这是 GPL 的增强版，它要求任何使用这些代码的人和公司，在对它做出改进之后，必须把改进的代码能让人下载。就算你在自己的服务器上运行这些代码，不把它作为产品提供给人，也一样需要让人能够下载到改进的代码。这并不是说你不能用这些代码，但如果作为一个公司，你不想让别人得到改进后的代码，那么你完全可以找代码的原作者，付给他一定的报酬，得到闭源使用这些代码的权利。也就是说，AGPL 能够让代码的作者在某些时候得到应有的回报。&lt;/p&gt;

&lt;p&gt;把版权改为 AGPL 之后，出现了一个奇怪的事情。申请美国绿卡的时候，我找以前 Google 的上司要一封“工作经历证明”。这种证明本应是公司无条件提供的，甚至不应该需要通过上司去获取，而是人事部无条件签发。然而收到 email 之后，前上司却对我说：“我可以给你这个证明，然而我想让你给我提供一个好处作为交换。你的 PySonar2 现在改成了 AGPL 版权，我们想用你的代码，却因为这个版权没法用。你能否把版权改为 BSD 一类的，这样很多人都可以用它？” 面对这样的无理要求，我很鄙视，所以干脆没要 Google 的工作经历证明，直接找其它公司开了证明。&lt;/p&gt;

&lt;p&gt;又过了一段时间，我感觉 AGPL 似乎确实限制了 PySonar 的应用，所以又把版权给换成了 BSD，进而换成了 Apache，一种比 BSD 还要宽松的版权。刚换成 BSD，我就发现有一家代码工具公司 fork 了 PySonar，最新的 commit 正好是改为 BSD 版权的时候。这个公司从来没联系过我，从来没感谢我，只是无声无息地用 PySonar 来赚钱。他们 fork 这个时候的 PySonar，应该只是用于法律保护，证明 PySonar 的代码在这时候是 BSD 版权的。&lt;/p&gt;

&lt;p&gt;这样的作法不仅让我一阵心酸。曾经一直在用 PySonar 的另一家公司的创始人 J，当天也发信来跟我说：“正在考虑给你版税呢，结果你就换成 BSD 了。哈哈哈！” 这是什么意思呢？本来都要付钱给你了，结果你把版权换成了 BSD，所以我就可以不给钱了，捡了个大便宜，就是这个意思吧。他最后还是象征性的给了一千美元，然而这相对于 PySonar 为他创造的价值，其实什么都不是。&lt;/p&gt;

&lt;p&gt;我一直把 J 作为朋友。平时如果他报告 PySonar 的 bug，我乐意免费给他改进。我给他介绍投资人，甚至给他介绍妹子…… 我并没有图他什么，并没有要求回报。我只是想积点德，将来总有好的后果吧。然而，前几天当我宣布离开美国的时候，我才发现我的好心其实并没有好报。J 发信息来，说看我想回国，所以想招我进他的公司。给我开了一个价，具体的数字我就不说了，不过这个工资，现在国内是个程序员都能拿到。我当时想，给这点钱，给他当个顾问，关键时刻给点方向，隔几个月改改 PySonar 的代码也就算了，结果他说要求我全职给他工作。笑他太抠门，结果得到的回答是嘲笑：“你嫌钱少，可是你做出过什么真正的产品吗？” 哦，是的，PySonar 不是真正的产品。你在外面做个包装界面，然后功劳都是你的了，我还得给你打工？换成 BSD 版权的时候就捡了一个大便宜，现在我要回国，以为我落难了，趁火打劫想捡个超大便宜。说不定到时候还跟 Sourcegraph 一样跟我翻脸不认人…… 哎，我再也不相信任何免费用我代码的人了。&lt;/p&gt;

&lt;p&gt;这就是我用 BSD 版权发行有价值的代码的辛酸史。有些人免费拿你的高价值代码去赚了钱，到后来却让你给他做廉价劳工。由于这个原因，从今天起，我的代码完全进入闭源状态。没有人再能免费得到 PySonar 最新的改进，没有人再能看见我最新的技术。另外我还留了一手，PySonar 其实一直以来都有一个未开源的分支，里面含有对于静态分析逻辑的重大改进，能够精确地发现很多 Python 程序里的 bug。从今以后，这一切都属于我私有，它们将会让我未来的产品立于不败之地。&lt;/p&gt;

&lt;p&gt;后记：有人可能误以为我要一心拿 PySonar 来做产品。其实 PySonar 支持的那种产品只能用于企业内部提高生产力用，不能产生直接的效益。由于 PySonar 等技术的复杂度和难度之高，收益却不成正比，所以我并不把它作为一个很好的创业手段。我首要的创业目标，应该是创造直接的生产力和效益，而不是提供间接的辅助设施。提供给程序员的产品，程序语言等等，虽然也很重要，然而优先级在我这里其实不是最高的。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/18/close-source</guid>
<pubDate>Tue, 18 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>美国公司管理层的洗脑技巧</title>
<link>http://yinwang.org/blog-cn/2017/04/17/management-tricks</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;美国公司管理层的洗脑技巧&lt;/h2&gt;
                            &lt;p&gt;在美国工作过的人，都对美国公司管理层的心理战术深有感受。很多人都感觉跟上司之间有某种难以言表的问题，总是感觉自己的价值不受尊重，然而由于上司说话客气，所以又不好发作，好几年停留在同样的底层职位不能晋升，却又难以说清楚这到底是怎么回事。其实美国公司的管理者，使用着一些强大的意识控制（mind control）技巧，经常给你念经洗脑，使得你的头脑失去防御能力，最后沦为任他们摆布的奴隶。经历了这么多工作之后，我想把他们常用的技巧总结一下，以便广大员工对此提高警惕，采取相应的对策。&lt;/p&gt;

&lt;p&gt;这篇文章还在继续写作中，这是一个草稿。我这里所指出的技巧，似乎在网上都搜不到。如果你在 Google 搜索，只能找到一些冠冕堂皇的题为『如何管理职工』之类的文章，把管理层说得简直无比善良，尊重人才，体贴又公平。当你真正理解了他们才发现，根本不是那样的。由于这个原因，我鼓励大家为这篇文章付款 3 美元，用以鼓励它的继续写作，付款方式请见主页右上方。&lt;/p&gt;

&lt;h3&gt;建立对比参照物&lt;/h3&gt;

&lt;p&gt;管理层跟你杀价，最重要的手法就是“比较”。这作法跟你妈妈买菜时杀价是一样的原理：选择另外一个人作为你的“参照物”，在需要的时候，把这个人抬出来跟你比，以达到某种目的。这个人一般是上司认为水平比你高，或者职称比你高的某个人。这个人也可以就是上司自己，比如他可以跟你讲述他曾经做出的，你无法核实的“业绩”。为了方便，下文把这个用来跟你比的人称为“小强”。&lt;/p&gt;

&lt;p&gt;管理层首先假设小强比你强，价值比你高。虽然事实也许不是这样，但他们总是会想方设法让他显得比你强，比如夸他以前做过多么了不起的事情，让你在不知不觉中接受这个假定。夸别人的时候总是不心虚的，所以把他吹上天也没有自大狂的嫌疑。他到底做没做那些事情，你也无从对证。等你开始点头，他们就可以随时在你面前提起他的名字，借此来达到某种目的。&lt;/p&gt;

&lt;p&gt;举个例子，上司可以让你去做一些高手不愿意做的杂活，比如为团队的代码配置一个测试工具。作为一个编程高手，刚进公司代码都还没碰呢，就被叫去干这种杂活，所以你对此一点不感兴趣。而且这工具由于设计很差，问题很多，耗费你很多时间，却收效不多，非常没有成就感，显然这不是一个聪明人愿意做的。你心想，公司里那么多大学刚毕业的，干嘛不让他们去折腾这些，却让我做这个事情。&lt;/p&gt;

&lt;p&gt;当你对此提出异议的时候，上司就会苦口婆心对你说：“这种杂活是我们每个人都应该会做的。你看看小强，人家编程水平可以说是超一流了，然而当年我们的连续集成（CI）系统，那么无聊的东西，都是他设置的。” 这样你就没话可说了。然而上司没告诉你的事情是，小强当年是自己对那 CI 系统感兴趣，所以他就去做了，那并不是管理层强制分配给他的任务。而对于你，这是强加给你的任务，你不感兴趣也得做。而且小强设置的 CI 系统，比你现在折腾的这个东西容易配置，没那么多毛病，而且对于团队意义挺大。你的情况跟小强的其实没有可比之处，然而这种突如其来的“对比心理压制”，让你措手不及，只好默认接受。&lt;/p&gt;

&lt;p&gt;这里我要指出很多人的一种误区，他们认为杂事必须得有人做，你不做我不做，难道让老板做？所以老板让任何人做任何事都是可以的。这种想法是不对的。公司里自然有不同水平的人，杂事一般都应该交给水平比较低的，或者刚毕业的新手去捣鼓，或者正好有人感兴趣，那当然最好。当然对于新手我们也应该尊重，如果他折腾了一段时间，跟你反映这个东西问题太多不好用，你就应该考虑放弃这个东西，也许有其它更好的选择。水平高的人请进来，真的不是你叫他做什么都可以的。他完全应该拒绝给你端茶倒水，给你跑腿买机票，对不对？所以他也可以拒绝做他觉得不符合自己身份和职责的事情。我见过有些老板，自以为有钱能使鬼推磨，不尊重人才，所以到最后没人愿意给他做事。&lt;/p&gt;

&lt;p&gt;另外一个例子。评职称的时候，你做了一个很好的成果，然而上司可以对你这样说：“我觉得你的成果还没有到让你升职成为 principal 的资格。当年小强做了那个什么什么，比你这难度还要大，人家当时才升了一级而已……” 小强那东西的价值和难度，其实谁也不清楚，但这样跟你一比，就让你沉默接受了他给你的评定。&lt;/p&gt;

&lt;p&gt;把人拿来互相比，是一种不尊重人的作法。管理层就是通过这种比较的方式，来压低人的价值。在 A 面前说 B 更强，在 B 面前说 A 更强。因为 A 和 B 信息不通，结果 A 和 B 的价钱就都给压下去了。这就跟你买菜的时候，跟 A 家的菜农说：“B 家这个菜才卖 2 毛钱一斤。你怎么卖 3 毛 5，也太贵了！” 而其实 B 家的价钱是 5 毛，或者 B 家的菜不新鲜…… 菜农都知道这种技巧，所以他们会对你说：“一分钱一分货。你嫌贵就去 B 家买好了！”&lt;/p&gt;

&lt;p&gt;我觉得广大受过高等教育的人才，也应该有这种一口价的霸气。只有这样，我们程序员才能维护自己这个行业的权益，不受刻薄的买菜大妈们的欺负。&lt;/p&gt;

&lt;h3&gt;激将法&lt;/h3&gt;

&lt;p&gt;上司可以用参照物来实现“激将法”，使得你更加卖命的工作。常用的做法就是，把小强做的东西吹得神乎其神，拿来跟你做的东西比。做技术的人很多都争强好胜，你想要做出胜过小强的东西，所以你就更加拼命地工作。等你做出来，就让公司赚了。最后你仔细一看小强做的东西，其实做得很水……&lt;/p&gt;

&lt;p&gt;我在 Google 做 PySonar 的时候，上司就经常使用这种激将法。他经常会对我说：“你看这个某某 PL 人，多牛啊，做了一个 DSL，要是请到我们这里来该多好！” 或者说：“你看这个 Facebook 的开源项目静态分析工具，貌似也可以做 Python 的静态分析呢，还能支持好多其他语言！” 如果你不仔细看看，也许就会更加拼命的工作，想在这群人里面立于不败之地。然而你仔细看看，就发现那 DSL 其实是完全没必要的东西，反而让问题变复杂了。而 Facebook 那东西，完全就是一个玩具，根本不可能进行深入的静态分析，不过是一个像 lint 一样的 style checker 而已。说支持这么多种语言，其实大部分语言的目录里全都是空的，只有 PHP 的目录里有点东西！&lt;/p&gt;

&lt;p&gt;我看透了上司的激将法，这就是为什么在 PySonar 的第一版里面，我留了一手。Google 使用的版本，其实比 PySonar2 要弱很多。最强的版本，我只留给自己。&lt;/p&gt;

&lt;h3&gt;树立虚假威信&lt;/h3&gt;

&lt;p&gt;很多管理层的人，从跟你面试时开始，就已经开始树立自己的高大形象和威信了。只要你对公司表达一点点的欣赏，他们就会想办法在心理上压倒你。比如，当你表达对某公司的尊敬时，他就会开始说：“对的，这是一个成熟的公司。我在这已经工作了 14 年了，这表示我喜欢这个公司。当年，我是 A 系统的构架师，我还是 B 系统的构架师，我跟某某牛人一起工作……”&lt;/p&gt;

&lt;p&gt;等你进了这公司，从人事部（HR）管理系统里面一查，才发现这人的履历里面根本没有什么 A 系统和 B 系统构架师的经历。后来从同事那里听说，他只不过是参与制作了 A 和 B 里面的一小部分，根本不是什么构架师，而且他参与的那部分代码，直到许多年后的今天还有 bug。&lt;/p&gt;

&lt;p&gt;还有一种虚假威信不依赖于公司，而是在公司外面的“社区”里形成的。比如在 JavaScript 的社区里，这种现象极为严重。有些人写了一块很小的代码，GitHub 上的星比较多，然后就被无知的 JavaScript 程序员们捧上了天。参加各种肤浅的会议，把大学一年级就该学到的东西（closure 一类的）当成宝贝一样宣讲。还有些人开始写书，当然这书完全没有价值，Amazon 上全是一两颗星的差评。然而这种人总能以“书作者”的身份自居，在某些肤浅的公司占据管理位置。&lt;/p&gt;

&lt;p&gt;然后呢，为了维护自己的虚假威信和地位，为了建立“业绩”，他们会在公司里疯狂的瞎指挥。总是要提出一些跟其他公司都不一样的“新作法”，显得自己有创造力，结果每次都帮倒忙。为了有人支持自己，他必须招收更多的同类进入公司。最后导致整个部门都被这种人占领，各种假大空一拥而入，光拿钱不做事，或者帮倒忙。真正有本事的人受不了这些人的排挤，陆续离去，形成“反向淘汰”。这样的公司不走向失败才怪。&lt;/p&gt;

&lt;p&gt;虽然你心知肚明，但为了自我保护，不能告诉上司你已经看透了他。所以他也假设你不知道，于是在以后的日子里，他就可以利用这些虚假的资历，占据对话的有利地位，对你指手画脚。&lt;/p&gt;

&lt;h3&gt;虚构奋斗经历&lt;/h3&gt;

&lt;p&gt;管理层想给你一个比以前公司还低的职称（title），你对此提出异议，他们有一种忽悠技巧可以让你接受它。上司可以这样说：“你知道吗，小公司的职称都是乱来的，不算数的。我当年在小公司，那可是 VP engineering。进这大公司时，人家只给了我个 manager 的职位。可是因为公司尊重人才，再加上我的出色表现，很快就升到了现在的职位。所以关于这个职称你不用担心……”&lt;/p&gt;

&lt;p&gt;等你进了这公司一查 HR 系统，发现他进公司时的职位哪里是 manager 啊，一进来就是 director of XYZ，领导几百个人。 上司为自己制造这种虚假的“卑微”和“奋斗”经历，目的是让你接受不公平的待遇，让你拼命工作而已。&lt;/p&gt;

&lt;h3&gt;夸大职称职责&lt;/h3&gt;

&lt;p&gt;为了压低你的职称和薪水，管理层可以故意夸大高级职称所需要担当的职责。比如你想升职的时候，他可以对你滔滔不绝的念经：“你想要 senior 职称？我们这可是大公司，我们的 senior 级别可不比小公司的。我们的 senior 需要完全从头设计和实现高难度的新功能，要能指导和教育低级别的员工，要能按时保质保量的完成艰巨的任务。如果你想要升到 principal，那你就需要超强的系统编程能力。你看小强，他在六个月之内实现了从编译器，操作系统，一直到数据库的所有东西！你还需要能够从公司利益的角度出发，想法把一个几亿美元的产品，做大到几十亿美元的年利润。我们的 senior 和 principal 级别，可不是像小公司一样闹着玩的！”&lt;/p&gt;

&lt;p&gt;你还真能被他们说得无语，可是回头一想就发现不对劲。后来你发现，这公司的 senior 职工，根本就没有任何他们所宣传的能动性，一般都是打打小补丁而已，朝九晚五的干活，你不叫他做事就完全不管，测试失败了还在继续提交代码，各种耽误你时间。而小强六个月做出来的什么编译器，操作系统，数据库，都是玩具级别的，或者其实根本就是上大学时做的期末大作业。六个月我能把工业级的编译器，操作系统，数据库全都做出来，我还能把几亿美元的产品变成几十亿美元的，那我干嘛要来你们公司工作？我自己开个公司，每年赚个一亿就够了！&lt;/p&gt;

&lt;p&gt;管理层的这种作法，就像在地摊上买顶 20 块钱的帽子。挑了半天，终于决定买了，却只掏出 10 块钱，跟你讨价还价：“你知道我以前 20 块钱能买什么样的帽子吗？那可是金丝貂皮镶边，顶上还嵌了钻石，蓝宝石…… 而且还是买一送 50% 折扣券……” 所以你就只有跟他说，我不做你这种人的生意！&lt;/p&gt;

&lt;h3&gt;制造领域壁垒&lt;/h3&gt;

&lt;p&gt;公司为了压低你的价钱，还可以故意制造和强调“领域壁垒”。本来程序已经写得出神入化了，各种语言，编译器，高级的算法，数据结构，网络协议，WEB，…… 都会。你从来没有觉得一个程序员应该局限于某一个子领域，不管什么技术，拿起来就应该会。然而当你面试之后，也许就会收到这样一封 offer 信：&lt;/p&gt;

&lt;p&gt;“亲爱的 XX，我们很高兴的 offer 你软件工程师的职位。虽然你的背景显示你缺乏并发系统编程的经验，我们觉得你是一个很有潜力的人选。我们决定给你 NNN 的工资，……”&lt;/p&gt;

&lt;p&gt;“并发系统编程”是什么玩意？之前的工作里，线程什么的也不是没用过。你从来没有想到，这样一个不值一提的“技能”，有资格列举在你的简历上。可是现在管理层因此说你缺乏这方面的经验！&lt;/p&gt;

&lt;p&gt;当然，NNN 是一个有点寒掺的工资。如果你不满意，管理层就会对你说教：“你知道吗，并发系统不是你想象的那么容易。我们的工程师在这个领域都有 30 年以上的经验，才能到 senior 级别……”&lt;/p&gt;

&lt;p&gt;等你进去，一眼就发现那些所谓 “30 年并发系统编程经验”的 senior 程序员，在很明显的“竞争条件”（race condition）的地方少放了几个锁，系统会在小概率的情况下出现灾难性的后果。他们不放锁的原因是因为一种误区，认为使用锁一定会降低程序的速度。而且由于过度使用并发，造成了很难察觉的性能瓶颈，本来想用多线程提高性能，结果适得其反。&lt;/p&gt;

&lt;p&gt;其实 IT 界哪有这么多“领域”，每一个领域需要的知识，不过都是计算机科学：数据结构，算法，语言，再加一点工程经验。只能写某一个领域程序的人，根本不配叫做“程序员”。其实管理层早就知道你能胜任这个工作，故意的制造和强调领域壁垒，不过是压低你职称和工资的手段而已。&lt;/p&gt;

&lt;h3&gt;贡献至上论&lt;/h3&gt;

&lt;p&gt;很多公司和人，都流行一种“贡献至上论”。你发现跟自己水平相当甚至比你低的人，职称和工资却比你高，跟管理层理论的时候，他们就会抬出“贡献至上论”。总之就是说，人的薪水是按他为公司做出的贡献来算的，而不是以能力或者水平。你才进公司一年，虽然已经显示出超人的能力，但是公司还没有得到你的贡献，所以现在的薪水是合理的。咋一看貌似一个合理的标准，有多大贡献拿多少钱，然而其实这里面有好几个陷阱。&lt;/p&gt;

&lt;p&gt;首先我们从物理单位的角度来说明，为什么工资应该对应能力，而不是贡献。所谓“工资”都是时间工资，而不是总收入。比如，你的时间工资是“100万/年”，这并不是说你一进公司就拿到 100 万，而是说你工作一年的时间，累积能拿到 100 万。所以“工资”对应的物理单位是“功率”，而不是“能量”。按照这个道理，工资对应的东西，应该是人的功率。人的功率就是他的“能力”，而不是他的“贡献”。粗略的公式是：贡献 = 能力 x 时间。比如 A 一个星期能完成 100 个单元的工作量，B 一个星期只能完成 10 个单元的工作，那么按理 A 的工资就应该是 B 工资的 10 倍。这跟 A 和 B 待在公司的时间，他们已经对公司做出的贡献大小，关系其实不大。B 也许在公司的时间比 A 长很多，已经做的贡献也更多，然而 B 已经拿到的那些收入，已经偿还了他所做出的贡献，所以 A 的工资并不应该因此比 B 的低。&lt;/p&gt;

&lt;p&gt;然后再来想一下，商品的价格是怎么定的？物以稀为贵，对不对？能力高的人是稀少的，如果你不付足够的工资，能力高的人就可以不为你工作，你也许今后再也找不到另一个能力这么高的人。不管他是刚进公司，还是进去一段时间了，都是如此。能力高的人永远不会因为自己刚进公司，没有“贡献”，就接受低于普通人的薪水。如果你知道其他人的职称和薪水，就会发现他们其实一进去就很高，根本不需要已经做出什么贡献。&lt;/p&gt;

&lt;p&gt;另外，“贡献”是一个很主观的东西。打个比方吧，资深外科专家给你做了心脏手术，你不想付钱，于是就说：“虽然你医术很高，然而手术之所以可以成功，主要是因为有家人安慰我，让我得到心灵的抚慰和照顾。所以你的贡献其实很小，不应该付给你那么多的费用！” 明白了吗？公司里有许许多多的人想要晋升到你想要的职位，可是职位却是有限数量的。每个人都做了一点东西，可是最终决定谁做出了更大的贡献，是管理层的少数人决定的。就算你能力高超，做的东西其他人都没法完成，然而你的贡献到了管理层那里，只是几行字而已。这些字是你的上司以及他的上司写出来的，至于他们怎么写，你是无法控制，甚至无法知道的。&lt;/p&gt;

&lt;p&gt;这种贡献至上论导致的结果，是让有能力的人得不到合理的回报，甚至得不到发展才能的机会。由于你刚进公司还没有“贡献”，就算你能力很强，公司可以以此为借口给你很低的工资，然后给你一个完全无法施展才能的任务。你辛苦折腾了一年后发现，管理层说你的贡献没有很多，所以你的职称和薪水就停留在很低的水平。&lt;/p&gt;

&lt;p&gt;所以，能力强的人必须反对这种“贡献至上论”。你的薪资水平，不应该是看你已经做出多少贡献，而应该是看你的能力。如果你是一个能力超强的人，你必须要求高的薪资。因为公司在单位时间内为你付出更多的钱，他们必须想办法利用你的能力，创造大的价值，这样你的才能才有可能得到发挥，你才会变得越来越强。&lt;/p&gt;

&lt;h3&gt;引用公司政策&lt;/h3&gt;

&lt;p&gt;当你不服上司的说法，他们说不过你，就会引用公司的政策文件。比如，如果你对职称不满意，他们就会说：“请你参考公司的职称标准，上面列举了 senior 和 principal 职称需要具备的能力和职责。我觉得你在现阶段还没有满足这些条件。”&lt;/p&gt;

&lt;p&gt;所有这些什么“公司规定”，其实都是借口，是“catch”，它们就像有些信用卡条款下面的小字，你不仔细看就以为小便宜就在眼前，结果根本不是的。那些小字写的是，你必须满足这样那样的条件才可以！&lt;/p&gt;

&lt;p&gt;所有这些诱惑的作用，就是把你变成一头拉磨的驴子。在你的头顶上架个杆子，上面挂着食物。你想吃到这眼前的食物，可是你每走一步这食物就随着你往前挪一步，所以你就总也吃不到，只是不停地给别人拉磨。&lt;/p&gt;

&lt;p&gt;总有人传言说，在这公司升职好快哦，看那谁进来那么低职位，很快就变成 principal 了。轮到你的时候，就发现完全不是那回事。等你去查，发现那个人升职根本就没那么快，好几年了才升了一级。于是你醒悟了，原来这些都是广告吧？&lt;/p&gt;

&lt;p&gt;这些红头文件，貌似很容易拿出来，无可辩驳地压制任何人的意见，然而它们对于有能力的人其实是无效的。很多上司都会在你提出加薪的时候对你说：“我们公司都是每年五月的时候，所有人一起做评估，升职加薪都在那个时候，你就再等等好吗？” 而实际情况却是，公司其实在任何时候都可以给人加薪。只要你对薪水不满意要走人，公司立马可以给你加薪。&lt;/p&gt;

&lt;h3&gt;“这是我们的决定”&lt;/h3&gt;

&lt;p&gt;你的团队遇到一个技术问题，有两种不同的解决方案。有个叫小强的 principal engineer 说应该采用 A 方案，而你觉得应该采用 B 方案。经过好几天，几十封 email 的全组讨论，你用深刻的技术分析和大量的证据，说服团队里的绝大部分人，应该采用 B 方案。A 方案不但不解决问题，而且导致系统过度复杂，容易出错，而且工作量巨大，延缓工期。然而结果却出人意料，你的上司最后发了这样一封 email：&lt;/p&gt;

&lt;p&gt;“经过讨论，我们决定采用 A 方案。这是我们全组人的决定！详情请参考这篇‘XYZ 小组规范文档’（链接）对于此事，不得讨价还价！NON-NEGOTIABLE！”&lt;/p&gt;

&lt;p&gt;你打开链接，发现这文档是上司今天刚写出来的，里面不但缺乏你在 email 讨论里面提出的最重要的观点，而且还有很多理解错误的地方。上司一意孤行，自己做了决定，却号称这是“我们的决定”。自己写了“规范”，完全没有经过队友们同意，却说是“我们小组的规范”。这就是所谓“强奸民意”吧。&lt;/p&gt;

&lt;p&gt;最后你发现，你的上司总是听小强的，不管他说的是对的还是错的。而这个小强，就是团队的系统过度复杂的主要原因。显然你的上司有什么把柄落在了小强的手里…… 同事们也觉得很奇怪，然而大家都面面相觑，除了服从，没有其它办法。&lt;/p&gt;

&lt;h3&gt;待续……&lt;/h3&gt;

&lt;p&gt;当然管理层的招数不止这些，我也还在总结中。如果你有其它的经验，欢迎来信给我指出：shredderyin@gmail.com。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/17/management-tricks</guid>
<pubDate>Mon, 17 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>求带猫回国经验</title>
<link>http://yinwang.org/blog-cn/2017/04/15/monet</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;求带猫回国经验&lt;/h2&gt;
                            &lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/monet.jpg&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;我亲爱的小莫奈要跟我一起回国，我希望给他一个尽量舒适的旅行。目前只搞清楚疫苗和健康证明方面的信息，但是航班方面还不是很清楚。能带宠物进入客舱的航班貌似只有 UA 的，然而这次 UA 的恶劣行径，再加上以前坐 UA 的经历，让我不可能再光顾他们。&lt;/p&gt;

&lt;p&gt;中国的航空公司貌似都只能把宠物放在有氧货舱，但是关于这个有氧舱和旅行用的笼子，我还有挺多疑虑，害怕出问题。也不知道宠物机票等操作的顺序和方法。网上的资料很多啰里八嗦，搞不清楚重点，也不知道有没有过时。所以还请有亲身经验的高手，或者知道相关论坛的人给我指点一下，发信到 shredderyin@gmail.com 即可。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/15/monet</guid>
<pubDate>Sat, 15 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>经验和洞察力</title>
<link>http://yinwang.org/blog-cn/2017/04/14/experience-and-insight</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;经验和洞察力&lt;/h2&gt;
                            &lt;p&gt;过去的事情，就让它已成云烟吧……&lt;/p&gt;

&lt;p&gt;很多人很在乎“经验”，比如号称自己在某领域有 30 年的经验，会用这样那样的技术。我觉得经验是有价值的，我也有经验，各个领域的都有点。然而我并不把经验放在很重要的位置，因为我拥有大部分人都缺乏而且忽视的一种东西：洞察力（insight）。&lt;/p&gt;

&lt;p&gt;每进入一个新的公司，我进入的几乎都是不同的领域。所以最开头的时候，我有可能对那个领域所知甚少。甚至有人觉得我没有经验，所以可以“教育”我。然而每一次他们都没有想到的是，我很快就掌握了他们的经验，并且经过提炼，抛弃其中的垃圾，很快的超越了他们，完成他们根本无法达到的目标。这就是洞察力的威力。&lt;/p&gt;

&lt;p&gt;举个亲身例子，很多人都有用线程的经验，可是有多少人知道线程的本质是什么？有多少人在头脑里有一幅画面，显示出多线程程序的各种动态特征？其实很少有人知道。这就是为什么很多人过度的使用线程并发，结果产生各种同步问题，竞争状态（race condition），死锁等现象。某公司的一片多线程代码，号称是“有非常多并发程序经验”的程序员写的。结果没多久我就发现里面其实含有非常微妙的竞争情况，会在非常小的概率随机发作。发现之后没过几天，已经卖出去用了两年多的产品，由于这个竞争情况，终于引发了严重的后果。有那么多并发编程经验的程序员，两年多都没有察觉这个竞争情况，而很少写多线程程序的我，不但发现了这个竞争，而且很快的想出了修复它的办法，这是为什么呢？靠的就是洞察力。我知道线程的本质，而这是经验不会告诉你的。&lt;/p&gt;

&lt;p&gt;什么是洞察力？洞察力就是透过现象看到本质的能力。有洞察力的人很容易得到经验，然而有经验的人却不一定有洞察力。再愚钝的人，总是可以通过大量的时间获取经验，然而就算你花再多的时间和精力，也难以得到洞察力。所以洞察力是比经验宝贵很多的东西。很难说清楚如何才能有洞察力，也很少有人会告诉你如何去得到它。当然，我也不会告诉你。&lt;/p&gt;

&lt;p&gt;看别人简历，经常会列出各种各样的技术经验，我看一眼就会的东西，也会在上面占个位置。由于这个原因，我把自己 Linkedin 上面曾经列出的“工作经验”全都删掉了。这些东西列在那里，对于我本身的价值，实在是一种贬低。我是一个身上不贴任何标签的，不能被任何头衔所局限的，真正有价值的人。&lt;/p&gt;

&lt;p&gt;经验虽然不是最重要的，然而还是有必要的。很多技术你不能完全不碰它，然而一碰就明白了。但如果没有实际的问题，你又会没有动力去接触那些技术。所以我一直在做的一件事情，就是接触各种技术，然后利用洞察力来获得越来越多的经验。回国之后的初期，我打算着手做自己的产品。同时，我想跟国内的各种公司或者个人做这样的交易。我利用洞察力帮助解决他们最棘手的，已有经验无法解决的难题，从而让我获得经验。当然，我不是作为公司的职工，而只是作为独立的顾问。对公司我会象征性的收取一定的费用，换句话，就是作为“职业杀手”。对于个人，他的问题必须对我也有启发意义。对此感兴趣的公司或者个人，可以跟我联系。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/14/experience-and-insight</guid>
<pubDate>Fri, 14 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>一个人的罢工</title>
<link>http://yinwang.org/blog-cn/2017/04/11/strike</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;一个人的罢工&lt;/h2&gt;
                            &lt;p&gt;世界上有一种罪恶，叫做“不计回报的付出”。我不再是它的作恶者之一。&lt;/p&gt;

&lt;p&gt;看了我上一篇&lt;a href=&quot;http://www.yinwang.org/blog-cn/2017/04/06/update&quot;&gt;文章&lt;/a&gt;之后，可能有人在笑我，既然受到那样不合理的礼遇，干嘛还要再等几个月，等到被微软完全榨干价值才回国？我也是这么想的，所以我已经于昨天开始，无声无息地开始了“一个人的罢工”，我已经停止对微软提供一切工作和服务。罢工会一直进行到微软提供合理的报酬（这样也许我可以给他们提供远程服务），或者裁掉本人为止。&lt;/p&gt;

&lt;p&gt;可以说，微软用极其低廉的价钱，已经从我这里得到了多出许多倍的价值。我写出的代码，其难度和质量，解决的问题，是微软的 principal 级别都难以做到的，然而我却拿着 SDEV2 的职称和 senior 的工资。由于职称工资严重的不符合本人水平，随之带来的是尊严的失去。随着时间的推移，我越来越感觉到这个公司的贪婪和狡诈，感觉自己并没有受到尊重。&lt;/p&gt;

&lt;p&gt;在微软，我没有受到专家的礼遇。事情做的越好越多，越是有人催你做更多的事。我没有感觉到欣赏，感激和尊敬。只感觉到有人在不断地提醒你：工期将近。催你写注释，催你写测试，以为这样你的代码就能被完全据为己有。为了满足事先设定的日程计划，很多时候还必须加班，周末加班，晚上加班，这是极其不合理的。如果你的计划不能在一天 8 小时之内完成，那么它就是霸王计划。&lt;/p&gt;

&lt;p&gt;经济学告诉我们，一分钱一分货。公司付给人固定的工资，他们就应该得到固定数量的服务，而不应该得到更多。设定很紧的工期，导致了很多人超时工作，他们付出了时间，却没有得到补偿。特别像我这样的专家，在短时间内做出太多的价值，却拿跟普通人一样的回报。这就像是外科专家被作为包月家庭医生，太不划算了。&lt;/p&gt;

&lt;p&gt;这种“不计回报的付出”，使得资本家用极少的金钱买到太多的价值。这不仅导致自身的贬值，而且还会导致其他人失业，所以这种行为损人而不利己。由于这个原因，我必须立即停止对微软提供廉价服务。&lt;/p&gt;

&lt;p&gt;外科专家用白菜的价钱给你换了一颗心脏，还没有复诊呢，就显示出各种抠门和不尊重，所以他就不管你了，听天由命吧。我的离去会对项目造成不小的打击，然而这是一个深刻的教训。负责核心技术的 architect 走了，你们没能留住他，丢下无人敢碰的代码。现在好不容易有个人能够一眼看穿这代码在干什么，你们又各种抠门和不尊重，然后他又走了。这样不尊重人才，不失败才怪呢。&lt;/p&gt;

&lt;p&gt;由于这个举动，我可以在两个月之内返回中国。在中国，我将拒绝一切类似这样的不公平交易，以及任何不尊重人的价值的行为。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/11/strike</guid>
<pubDate>Tue, 11 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>更新</title>
<link>http://yinwang.org/blog-cn/2017/04/06/update</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;更新&lt;/h2&gt;
                            &lt;p&gt;几个月没有更新了，有些人来问我为什么，我也没有回他们。显然我不会因为有人来问就写东西，我写东西完全是因为我自己想写，它不受任何人的影响，不管是好心人还是别有用心的。不过现在回答一下，我没写文章是因为我在忙着写很好玩，很有价值的代码。&lt;/p&gt;

&lt;p&gt;我知道这个博客的影响力很大，但我对此所产生的“名气”一点都不在乎。以前公司的同事有时见到我，说：“我听说你在网上很有名啊！介绍几个粉丝来我们公司，我们就走向成功啦！” 我听了苦笑一声。因为对于我来说，“网上有名”其实是一种贬低。想利用我的名气，说明他们不理解我最重要的价值。可能是好心的恭维，然而这种不理解真正价值的恭维，听着很不是滋味。我给公司提供的实实在在的价值，有目共睹，有些人却只能看到名气，这也许说明他们的内心也只有名和利这些东西吧。我王垠没有粉丝，也不需要粉丝。&lt;/p&gt;

&lt;p&gt;虽然我不在乎甚至讨厌“名气”，但我确实在乎“影响力”。我在乎它，是因为很多人能够看到我的文字和想法，这些会对这些人以至于整个社会产生深远的影响。至于这些改变是不是归功到我身上，我根本不在乎。我在乎的是，我的想法真正的改变了很多人的思维，改善了社会风气，最后使我自己也获益。所以也许我最初就不该用自己的真名，而应该使用一个笔名，这样也不至于给我的事业带来影响。但既然这已经发生了，我也只有认命了。我死都不怕，还怕招揽几个恶名吗。实际上名声很难掩盖我真实的能力，就像黄药师的名声，也很难给他造成实际的影响。当然，我的能力是盖世无双的，我可以心平气和的说出这句话，不带半点虚荣。这不需要任何人的认可，因为世界上已经没有任何人有资格来认可我。&lt;/p&gt;

&lt;p&gt;这种奇妙的能力，不但最初在 Google 得到了体现，在 Coverity，Sourcegraph，Shape Security，一次次的巧妙发挥，最近又再一次的在微软得到了发扬光大。我不得不说，微软是少有的踏踏实实，用心做技术的公司，很少有瞎指挥的情况。也只有这样的公司，才可能从最底层开始做独立的技术。在微软，我的团队的产品是一种企业级存储设备，名叫 StorSimple。这东西看似跟我的特长程序语言（PL）关系不大，然而我从来就没有局限于 PL，我的洞察力深入到了计算机科学的各个领域。这是一种艺术，是不局限于领域的才能。任何我接触到的东西，都被揭示出其本质，揭开肤浅复杂的表面现象，被改造得更加简单，更加可靠和精密。&lt;/p&gt;

&lt;p&gt;在微软，我从头构造的基于 B+ 树的核心数据结构，被巧妙地集成到一个复杂的含有大量并发同步问题的系统里面，正在经受企业级数据的千锤百炼，从来没出过差错。存储设备是一个几乎完全不可以出 bug 的领域，因为一旦用户的数据因此丢失或者发生错误，后果将是灾难性的，不可逆转的，不是重启一下机器就可以了结的。用户会离你而去，再也不会回头，这跟飞机因质量问题而坠毁的后果差不多。&lt;/p&gt;

&lt;p&gt;不客气的说，我做的这玩意还真是这产品的核心部件，你可以把它想成是一个“云”里的文件系统（file system）。这是之前走掉的一个 architect 留下来的精(Lan)品(Tanzi)，复杂不堪，还可以用，但它简陋的数据结构无法支持大规模的数据量。把它精确地换成像 B+ 树这么复杂的数据结构，就像做个心脏置换手术，不能出一点差错，不能影响其它组件的运行。这是微软这方向上经验丰富的 principal engineer 们联手也难办到的事情。因为这个原因，再加上它至关重要的核心地位，所以 architect 走后一直没人敢碰这块代码。哎，为什么每次我都接手这样的事情……&lt;/p&gt;

&lt;p&gt;光是写一个没有 bug 的 B+ 树，其实都够让绝大部分的程序员汗颜，更不要说把它集成到 StorSimple 的“异构云”（hybrid cloud）构架里面去。有个写过 B+ 树的 principal engineer 喜欢跟我咋呼要“先写测试”，可我就是直接两天把代码给写出来了，然后再写了一个测试，就已经到了无懈可击的地步。代码优雅而通用化，不带有任何业务逻辑，可以原封不动用到其他地方，比如数据库索引。像 B+ 树这么复杂的数据结构，你还真是很难把它写得简单正确还通用，但我洞察到了精髓，所以稍加思索就办到了。这是我平生第一次写 B+ 树。&lt;/p&gt;

&lt;p&gt;微软有一些厉害的 principal engineer，他们的 B+ 树代码我看过了。实话说吧，虽然可以用，但非常繁复没法看，很难确信它是正确的。每次用到新的地方，你都得改动挺多代码才行，不能作为“库代码”来调用。而且你一改可能就给改错了，难怪跟我说需要很多很多的测试，还说要先写测试再写代码什么的…… 当然我说这些完全没有贬低微软工程师的能力，有个会写 B+ 树的 principal engineer 跟我关系相当好，初期还给了我挺好的参考资料，所以我无意贬低他。不过呢，写代码不能超越王垠，是再正常不过的事了，不是吗？所以当然不是耻辱 :P 相比其它肤浅的公司（Google，Facebook……），微软的好些人显然是有两刷子的，兢兢业业踏踏实实的在做自己的工作，而且在必要的时候给了我一些启发，人也相当好。可是在代码的优雅，简单和可靠性上，世界上还真没有人可以跟王垠抗衡。&lt;/p&gt;

&lt;p&gt;微软工程师确实有很多好人，不过呢公司的官僚系统跟人其实是两码事。我也看到了，我创造的价值已经大大的高于我的薪酬。微软这公司给我的级别（别去查了，是 SDEV2）和薪资，完全就是一个笑话。最初就是忽悠的，我在之前公司就已经是 senior，早就已经对这 title 很不满意了，还给我降一级，说你知道微软要升到 senior 级别需要多少经验吗，你要有微软的经验才行，不是其它地方的经验！说先给你个低点的 title（当然工资比以前高），进来半年以内升职，到现在 9 个月了没有一点动静，却跟你说什么：“Review 的时间还没到，要等到 9 月去了。” 去年 7 月中进来的，年底 bonus 都没有，说：“公司规定不满半年的没有 bonus，自己看看手册吧。” 我管你公司规定如何，我差几天就工作了半年，提供了这么多价值，一点 bonus 都没有，还得等一年？你玩我吧！&lt;/p&gt;

&lt;p&gt;所有这些什么“公司规定”，其实都是借口，是“catch”，它们就像有些信用卡条款下面的小字，你不仔细看就以为小便宜就在眼前，结果根本不是的。那些小字写的是，你必须满足这样那样的条件才可以！所有这些诱惑的作用，就是把你变成一头拉磨的驴子。在你的头顶上架个杆子，上面挂着食物。你想吃到这眼前的食物，可是你每走一步这食物就随着你往前挪一步，所以你就总也吃不到，只是不停地给别人拉磨。总有人传言说，微软升职好快哦，看那谁进来那么低职位，很快就变成 principal 了。轮到你的时候，就发现完全不是那回事。等你去查，发现那个人升职根本就没那么快，好几年了才升了一级。于是你醒悟了，原来这些都是广告吧？&lt;/p&gt;

&lt;p&gt;而且还有人时不时的提醒你一下，好像在说，你不应该得到我应有的回报。比如：“看人家这个（拿L1签证工作的廉价劳动力）印度小妹，也做出了很了不起的成绩，人家才这个级别……” 很是拿 title 当回事，张口闭口“看看人家某 principal……”，“你要是 principal 才可以 remote……” 还喜欢引用某 principal 的话，奉为真理一样。吃饭的时候，跟我关系不错的 remote principal 本来过来跟我坐在一起，然后就被坐在另一桌的大老板叫过去了，说：“过来过来，别跟他们浪费时间。” 这 principal 只好跟我道歉之后走掉了。于是几个 principal 单独一桌，跟大老板一起吃，我和其他人另外一桌。这大老板呢，自以为级别高点（partner），从来不正眼看人，也从来不直接跟我谈话。好像很是高高在上，从几个台阶上面看我的样子。&lt;/p&gt;

&lt;p&gt;虽然口头上的政策是所有级别一视同仁，然而久而久之你就发现一些微妙的区别。有些话，管理层是不敢对 principal 级别的人说的，然而他们却可以对较低级别的人说，而这些话又正好表现出微妙的不尊重。本来自己做不出来的东西，却偏要显得自己能做，以保持自己的权威，显得在指导你似的。有次居然当众对我说，你遇到了困难要告诉大家，我们这么多经验，随便帮你看一下就解决了。哈哈，我倒是想看看王垠都觉得棘手的问题，你们怎么解决！实话说吧，那几个 principal 经常都是在受我指导，走弯路的时候都是我在跟他们争论，及时制止，虽然有些时候不听，继续走弯路。当然，管理层绝对不会忘记的一件事情就是督促写注释，写测试，而且用的是对奴隶说话的口气，说：“你的代码注释太少了，要是你走了就没人能理解了。要是你想能放假，那就要写注释，否则没人能帮你维护代码，你就永远放不了假！” 说这话语气是调侃而温和的，然而听到好几次之后你就发现，这里面的含义是狠毒而贪婪的。如果是个 principal engineer，就没人敢叫他写注释！&lt;/p&gt;

&lt;p&gt;这一切都让我心里很不是滋味。这种情况，不仅我这样顶级专家难以接受，这是任何一个文明人都不应该接受的。我压根就从来没把 title 当回事，我对待 principal engineer 和印度小妹是同样的尊重。张口闭口 principal，那倒是叫你的 principal engineer 写出可以跟我匹敌的代码来啊？实话说吧，门都没有。世界上就只有一个人可以做到这个事情。微软的所有 title，全世界公司和大学的所有 title，还真没有一个是可以衡量本人的。管你什么 principal, partner, distinguished…… 只要跟我一聊，我就知道他脑子里有多少货。资本主义根深蒂固的劣根性就是利用这些标签，肆无忌惮的贬低人的价值，拿白菜的价钱买白粉。你稍微谦虚一点，就有人真把自己当回事了，开始用“老资格”的口气说话。这不是微软一家的问题，然而不管在哪里出现都是值得鄙视的。&lt;/p&gt;

&lt;p&gt;本来进微软的时候我就想，这是我在离开美国之前想看的最后一个公司。所以呢，我的微软之行已经达到了它的目的，也快要到达它的尽头。对于 Google 我只有鄙视，而对于微软，我觉得技术能力还是有那么几刷子的。如果 Google 得分是 D 的话，那微软倒是可以得 B。然而在这里，技术能力确实没法得到公平的回报和尊重。过了这么几个月，我觉得也该是寻求自身价值应有回报的时候了。在美国待了十年，我已经很清楚，美国根本不是一个尊重事实和人才的国度。从来都不是，换了总统也不会是。这个虚伪而邪恶的国家，正在继续走向昏庸和毁灭。这一切，我已经看得很透了。&lt;/p&gt;

&lt;p&gt;我的心，已经飞回到了中国，飞回到了家乡，飞到了北京。我每天都在想象跟老朋友们坐在一起喝茶聊天，感受城市生命的律动。这一切，都是在美国永远得不到的，我命中注定要在中国生活。当然我知道国内的人也很复杂，很多制度不健全，但中国之大，我相信会遇到很多靠谱的人。我不会再给任何公司工作。我会创造一个伟大的公司，它会创造世界上最精致的产品，它会给真正有价值的人相应的回报和尊重。由于一些现实的问题，回国的日子还要等几个月，不过应该在年底之前。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/04/06/update</guid>
<pubDate>Thu, 06 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>精英主义的灭亡</title>
<link>http://yinwang.org/blog-cn/2017/01/02/elitism</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;精英主义的灭亡&lt;/h2&gt;
                            &lt;p&gt;精英主义是一种精神疾病，是一种心理变态。得了这种病的人，有不同的轻重程度。程度轻的人，也许只是张口闭口的“名校”和“牛人”。而程度重的人，最后可能成为反人类的战争罪犯。希特勒就是一个严重的精英主义者，他认为自己是精英，“劣等民族”的人都应该死。&lt;/p&gt;

&lt;p&gt;这些所谓的精英，在智力上，体力上，学识上，人格上，都没有什么值得称道的地方。他们被称为“精英”，往往是通过家族关系，或者舔人屁股，玩弄权术。还有些人，尽其所能包装自己，把自己跟名人或者富豪挂钩，写回忆录，请人给自己写传记，这样别人就以为他是天才，是杰出人物。而他们其实并没有什么特别，也许还不如一般人。&lt;/p&gt;

&lt;p&gt;精英们最在行的事情，其实是拉关系，互相吹捧，唱高调，包装自己。他们在心理上是弱小的，他们必须依赖于名校或者大公司的牌子，依赖于校友的认可，依赖于那些身居高位的人的赞许和提拔。他们很多人不过是某些幕后黑手的木偶人而已。有句话说得好：宠为下，得知若惊，失之若惊。如果你需要身居高位的人的认可，那么你其实是一个卑贱的人。&lt;/p&gt;

&lt;p&gt;精英主义者集结的地方，被中国人叫做“世界一流大学”：哈佛，耶鲁，&lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/01/04/authority&quot;&gt;Cornell&lt;/a&gt;…… 进入这些大学的人，一般都是通过关系或者金钱，却吹捧自己是因为才能出众而进入那些学校。等你亲自进去一看，发现里面的教授很少有真知灼见，上课照本宣科，学生忙着抄笔记，学得一知半解，作业互相抄袭，考试焦头烂额，蒙混过关。&lt;/p&gt;

&lt;p&gt;这些教授倒是对宣传工作相当在行，屁大点研究，总要让纽约时报之类的搞一下政治宣传，然后在院系主页上贴个告示，看哪我们教授的研究被纽约时报报道了！这些人的实际水平，比起很多州立大学里潜心做研究的不知名学者，差不止一个档次。很多中国人都不知道，纽约时报，华盛顿邮报，CNN 之类，其实都是婊子媒体，出钱或者有关系就给你发文拍片。纽约时报的老板就是个毒贩子，黑帮老大。&lt;/p&gt;

&lt;p&gt;实际上，“世界一流大学”这个名词，你只能在中国听到。在美国没有人使用这种词汇，甚至像“著名的”（prestigious）这种词都很少用。如果你进入普通的州立大学，会发现没有人在乎哈佛，耶鲁，Cornell 这些“常春藤联盟”。如果你老是提这些名字，会招致人的反感。因为这些大学的人都知道精英学校是什么东西，根本不屑于提到他们。&lt;/p&gt;

&lt;p&gt;精英大学不但以无能著称，它们比你现象的还要可怕许多。这些学校里面一般都存在一些“秘密组织”，比如 Cornell 的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Quill_and_Dagger&quot;&gt;Quill and Dagger&lt;/a&gt;。这些组织就是精英聚集的场所。为什么要是秘密的呢？因为他们会进行一些见不得人的犯罪活动，导致成员之间互相抓住把柄，从而形成共生死的团伙。甚至有些名校的&lt;a href=&quot;https://www.youtube.com/watch?v=cKy2c-itZEg&amp;amp;feature=youtu.be&amp;amp;t=1255&quot;&gt;整个学院&lt;/a&gt;，都被罪犯花重金包下来，成为培养他们接班人的摇篮。所以美国的名校，其实跟娼妓没什么两样，名气越是大的越是这样。&lt;/p&gt;

&lt;p&gt;很多进入白宫的精英，就是从这种名校秘密组织出来的，比如臭名昭著的克林顿国家安全顾问 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sandy_Berger&quot;&gt;Sandy Berger&lt;/a&gt;，就是 Quill and Dagger 的成员。在 &lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/12/01/september-eleven&quot;&gt;9/11 恐怖袭击&lt;/a&gt;发生之后，Sandy Berger 进入国家档案馆，偷走关于克林顿与 9/11 之间关系的资料原版，并且销毁。这种销毁证据的做法，说明克林顿跟 9/11 肯定有扯不清的关系。&lt;/p&gt;

&lt;p&gt;从这个现象，你也许可以理解为什么很多精英大学容易出现学生自杀的事件。比如上次新闻报道说，一周之内有三个学生从 Cornell 校内同一座桥上跳下去&lt;a href=&quot;http://www.nytimes.com/2010/03/17/education/17cornell.html&quot;&gt;自杀&lt;/a&gt;，结果后来派了警察在桥上日夜巡逻。三个学生几乎在同一时间想不通，在同一地点寻短见，这也未免太巧了点吧。如果你研究过历史就会知道，美国很多所谓的自杀案件其实都是谋杀，只是用自杀来掩盖真相。所以这些学生到底是自杀还是谋杀，谁都说不清楚。想要把孩子送去精英大学读书的人，真的应该考虑一下他们的安全了。&lt;/p&gt;

&lt;p&gt;在精英大学上过研究生的人，大可不必觉得我是在嘲笑你们。精英主义者心目中的所谓“校友”，一般只包括本科阶段的同僚。如果你跟我一样在“二流学校”本科毕业，进入精英学校读研究生或者博士生，他们不会把你当成校友。相反，他们会歧视你，觉得你是去那里打工的，甚至嘲笑你好像什么都不懂，怎么进来的。这是因为本科是塑造人格和价值观的主要阶段，如果你的本科生活是在其它学校度过的，那么你并不具有这种“精英品质”，就算你之后进去读完博士也不会改变这个观念。这就是为什么有些中国人在国内本科都快毕业了，却退学去美国精英大学再读一个本科，因为这些人很想要成为精英，进入“主流社会”。&lt;/p&gt;

&lt;p&gt;然而现在我们已经看清楚了，美国的主流社会和精英们的本质，我们知道了他们在干些什么样的事情。所以如果你不是精英大学官方意义上的校友，反倒没有了这层嫌疑需要洗清。&lt;/p&gt;

&lt;p&gt;美国精英们的“宣传部”，叫做好莱坞。好莱坞通过形象包装，形成偶像崇拜，好莱坞电影就是给人们洗脑的工具。好莱坞明星们给人们灌输错误的标准：审美标准，道德标准。说实话，好莱坞这么多女影星走红地毯，就找不出几个好看的。可是由于他们给人洗脑，以至于很多天生丽质的女生从小耳濡目染，居然觉得好莱坞那些丑女明星比自己美，去模仿她们的化妆和衣着样式，甚至想去做整形手术，这样可以变得更像她们。这些美丽的女孩因为明星崇拜，失去了对自己的尊重和自信，真是可惜。&lt;/p&gt;

&lt;p&gt;说到道德，你可能已经听说了，好莱坞的明星们几乎每一个都吸毒，很多还进行更可怕的犯罪活动。有一种极其变态的犯罪活动，叫做恋童癖（&lt;a href=&quot;https://en.wikipedia.org/wiki/Pedophilia&quot;&gt;pedophilia&lt;/a&gt;），或者直接一点，叫做性虐儿童（child sex abuse）。我们都听说 &lt;a href=&quot;https://youtu.be/iZ0B4jjNdjM?t=2963&quot;&gt;Michael Jackson&lt;/a&gt; 被指控强奸男童的事，后来又莫名其妙死了，这表现出团伙成员之间的内斗现象。有趣的是，好莱坞有很多的明星最后都说是自杀或者吸毒过量死亡。他们到底是自杀还是谋杀，也很值得怀疑。&lt;/p&gt;

&lt;p&gt;恋童活动在好莱坞非常的&lt;a href=&quot;https://www.youtube.com/watch?v=roW238dfUUk&quot;&gt;普遍&lt;/a&gt;，它还经常跟邪教仪式（satanic ritual）结合在一起，这些人会在仪式上当场宰杀儿童用来“祭祀”。这种丧尽天良的可怕罪行，在很多其他国家是要判死刑的，美国政府却几乎完全不管，因为白宫的官员们在干同样的事情。这不是危言耸听，如果你仔细研究，就会发现这就是全世界的精英团伙里面正在进行的：&lt;a href=&quot;https://www.youtube.com/watch?v=ekejhDu-biQ&quot;&gt;美国白宫&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=NUfJXdMIRGw&quot;&gt;英国王室&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=roW238dfUUk&quot;&gt;好莱坞&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Catholic_Church_sexual_abuse_cases&quot;&gt;天主教会&lt;/a&gt;，世界一流大学……&lt;/p&gt;

&lt;p&gt;美国这几年每年有超过 40 万儿童失踪，每年车祸死亡的人数才 3 万多。失踪儿童数量比车祸死亡人数大十倍以上，这是不正常的。这些失踪的儿童到哪里去了？另外，美国有些儿童领养中心和孤儿院，被查出在从事贩卖儿童性奴（child sex trafficking）的生意。这些人还在落后和受灾国家办&lt;a href=&quot;http://www.usapoliticstoday.com/hillary-clinton-kids-wikileaks-nuke-hillary-see-potential-clinton-foundation-sex-trafficking-ring&quot;&gt;孤儿院&lt;/a&gt;，说是人道主义援助，结果被当地警察发现他们带走的小孩都是有父母的…… 你不觉得毛骨悚然吗？&lt;/p&gt;

&lt;p&gt;反正看到这一切的时候，我的世界观都被颠覆了。我真希望这只是一场还没醒来的噩梦，可是无数的证据和证人都说明这就是现实！&lt;/p&gt;

&lt;p&gt;精英们一直以来都依靠媒体来掩盖自己罪恶的真相，给人洗脑，冠冕堂皇的让人崇拜。而这次的美国总统大选，导致了这些主流媒体的轰然倒塌：CNN，华盛顿邮报，纽约时报，时代周刊，BBC，…… 我们现在知道，这些媒体都是被庞大的恶势力网络控制的。&lt;/p&gt;

&lt;p&gt;在互联网发达之后，精英们也利用网络媒体来对公众进行洗脑。他们的帮凶包括 &lt;a href=&quot;https://twitter.com/wikileaks/status/809305627319291906&quot;&gt;Google&lt;/a&gt;，Facebook，Twitter，…… 这些社交媒体不但在政治上帮助这些精英搞宣传，而且帮助他们屏蔽对他们不利的真相，把这些真相都叫做“&lt;a href=&quot;https://www.facebook.com/zuck/posts/10103253901916271&quot;&gt;假新闻&lt;/a&gt;”。而事实是，CNN 之类的主流媒体才是假新闻。如果你仔细研究一下，会发现 Facebook 和华盛顿邮报的幕后支持者，其实是作恶多端的 &lt;a href=&quot;https://www.youtube.com/watch?v=oFH3uLuNL5Y&quot;&gt;CIA&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;真正独立而自由的“另类媒体”，比如 &lt;a href=&quot;http://www.infowars.com/&quot;&gt;InfoWars&lt;/a&gt;，&lt;a href=&quot;http://www.wnd.com/&quot;&gt;Breitbart&lt;/a&gt;，&lt;a href=&quot;http://www.prisonplanet.com&quot;&gt;Prison Planet&lt;/a&gt;，再加上异常强大的 &lt;a href=&quot;https://wikileaks.org/&quot;&gt;WikiLeaks&lt;/a&gt;，通过多方面的证据，揭示了精英们的真相。是这些敢于说真话的人，用他们的&lt;a href=&quot;https://en.wikipedia.org/wiki/Andrew_Breitbart#Death&quot;&gt;生命&lt;/a&gt;和&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/11/22/assange-donation&quot;&gt;自由&lt;/a&gt;，换来了世界局势的转机，同时导致了精英主义走向灭亡。现在听说某人是“精英”，我都得先考虑一下他跟这些龌龊的事情有没有关系，上网搜索调查一下。&lt;/p&gt;

&lt;p&gt;未来的世界属于每一个平凡的人，只是他们还在熟睡，旁边的吸血鬼们正在黑暗中选择他们的猎物…… 当真相的阳光照进来，当人们醒过来的时候，就是精英统治的时代结束的时候。如果你现在还以为有任何人高人一等，你的心里还存在某种偶像，你还以为世界上有&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/10/18/turing&quot;&gt;天才&lt;/a&gt;存在，你还很在乎好莱坞明星，或者 &lt;a href=&quot;https://www.youtube.com/watch?v=oFH3uLuNL5Y&quot;&gt;Zuckerberg&lt;/a&gt; 之类小丑说的话或者做的事，你还在梦想有一天把孩子送到哈佛念书，进入“上流社会”，请仔细再看看这篇文章和相关的视频，你会意识到这些想法有多么的愚蠢。&lt;/p&gt;

&lt;p&gt;你完全没有意识到自己的价值，你没有意识到身边的普通人的价值，你没有发现幸福就在身边。你只是生活在别人为你设计的梦里，追求那些他们让你追求的东西，最终却发现你出卖了灵魂。醒来的过程是痛苦的，但醒来后的未来是美好的。被精英们用欺骗手段收走的力量，就要回到人们的手里！&lt;/p&gt;

&lt;p&gt;（写这样一篇文章挺费神的，说真话是需要一些胆量的，所以如果你觉得开了眼界的话，请考虑付款 $3。谢谢！）&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2017/01/02/elitism</guid>
<pubDate>Mon, 02 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>9-11 袭击的真相</title>
<link>http://yinwang.org/blog-cn/2016/12/01/september-eleven</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;9-11 袭击的真相&lt;/h2&gt;
                            &lt;p&gt;9-11 袭击一直以来都是一个谜。是谁在幕后策划，它为什么会发生？美国政府对此进行的调查都是遮遮掩掩，很多证据藏起来不给人看，借口说是“国家机密”。这种鬼鬼祟祟的行为非常可疑，所以网络上出现了很多的谣言和“阴谋论”，说这是美国政府的人自己干的。然而这些东西很少有确凿的证据，所以久而久之，人们对真相失去了兴趣。每当跟美国人提到“9-11真相”，他们的反应一般都是，我不相信美国政府可能做出这么邪恶的事情！&lt;/p&gt;

&lt;p&gt;然而最近我发现了这部摄制于 2014 年的纪录片『&lt;a href=&quot;https://www.youtube.com/watch?v=8DOnAn_PX6M&quot;&gt;9-11：新的珍珠港&lt;/a&gt;』，它打破了 9-11 的迷雾。跟『华氏9-11』之类的阴谋论不同，『新珍珠港』出自许许多多追求真相的专家：飞行员，土木工程师，结构工程师，爆破专家，甚至世贸大厦的设计者自己…… 它从严谨的证据，数据和科学的角度出发，通过常识和科学理论，指出了美国政府官方报告与实际现象的严重偏差，从而引导人们认识到这背后的可怕真相。再加上一个&lt;a href=&quot;https://www.youtube.com/watch?v=fAawF22QUMs&quot;&gt;前 CIA 特工的证实&lt;/a&gt;，还有一些&lt;a href=&quot;https://www.youtube.com/watch?v=DQbEuBgAKso&quot;&gt;目击证人&lt;/a&gt;的回忆，我发现『新珍珠港』里面的大部分猜想都是正确的。&lt;/p&gt;

&lt;p&gt;大家都没猜错，9-11 确实是美国政府自己策划和执行的。然而具体的细节和操作，其实比我们想象的还要可怕和残忍许多，以至于知道了之后你可能会做噩梦……&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;9-11 是美国政府，军方，CIA 联合策划的，用于发动战争的伪旗行动（false-flag）&lt;/li&gt;
&lt;li&gt;撞击世贸大厦的不是波音客机，而是有两种可能：

&lt;ul&gt;
&lt;li&gt;军方遥控的大型无人机（drone）&lt;/li&gt;
&lt;li&gt;根本没有飞机，而是激光全息成像或者电脑动画&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大楼不是因为飞机撞击和燃烧而垮掉，而是通过可控爆破（controlled demolition）&lt;/li&gt;
&lt;li&gt;可控爆破使用的是美国军方特有的武器：纳米铝热炸弹 （nano thermite bomb）&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;下面我就把这些片子里面最震撼我的部分摘要一下：&lt;/p&gt;

&lt;h3&gt;可控爆破（Controlled Demolition）&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/8DOnAn_PX6M?t=9621&quot;&gt;&lt;img src=&quot;http://www.yinwang.org/images/demolition-evidence.png&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2001 年袭击发生的当天，我看了电视就觉得这很不可思议：飞机撞了楼的上面，下面楼体看起来完好无损，为什么整栋楼后来会从上到下，垂直坍塌下去，一瞬间就消失了？当时媒体给我们的解释是，世贸大厦建造时钢筋用得太少，强度不够，所以被飞机撞伤了结构，再加上飞机燃料的高温，就散架了。你看&lt;a href=&quot;https://www.youtube.com/watch?v=ZD69sP51u-s&quot;&gt;帝国大厦&lt;/a&gt;当年被 B-52 轰炸机撞了都没事，因为它钢筋用得多…… 我当时还真的被忽悠了！&lt;/p&gt;

&lt;p&gt;现在各种证据都显示，世贸大厦的钢架结构其实非常结实稳固，根本不亚于帝国大厦。飞机自身的动能和燃料的温度，都远远不够软化世贸大厦的结构。在 9-11 之前，世界上从来没有一栋钢结构的大厦因为着火而垮塌过。有的大楼着了火，全部烧焦了也都还站在那里。就算你要塌，也不能那么规整地垂直塌下来啊，总要偏一点吧？而且由于材料的阻力，下降速度不可能那么快。你再仔细看它坍塌的视频，就发现这跟拆楼所用的“可控爆破”一模一样，楼体以自由落体的速度，不偏不倚垂直塌下去，就像完全不受阻力一样。这是一架波音飞机撞上去完全不可能达到的效果。唯一能达到这个效果的作法，是使用许许多多的炸弹，在非常精确的时间点引爆，也就是可控爆破的做法。&lt;/p&gt;

&lt;p&gt;『新珍珠港』提供了充足的证据，证明这是经过预谋和精密设计的可控爆破。&lt;/p&gt;

&lt;h3&gt;纳米铝热炸弹（Nano-Thermite Bomb）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/911-molten-steel.png&quot; width=&quot;172&quot;&gt; &lt;img src=&quot;http://www.yinwang.org/images/911-thermite.png&quot; width=&quot;210&quot;&gt; &lt;img src=&quot;http://www.yinwang.org/images/911-bodies.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;据另一些视频（&lt;a href=&quot;https://www.youtube.com/watch?v=rnbMjAN7Bws&quot;&gt;视频1&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=GOb92R34jxo&quot;&gt;视频2&lt;/a&gt;）的介绍，为了更有效的弄垮这三栋楼，他们使用的是铝热炸弹，而不是普通的 TNT 之类的炸药。这符合一位&lt;a href=&quot;https://www.youtube.com/watch?v=DQbEuBgAKso&quot;&gt;目击证人&lt;/a&gt;的口述，在第一个爆炸之后，他看到有橙色的，熔化的钢水从楼的表面流下去。经过 CIA 特工&lt;a href=&quot;https://youtu.be/fAawF22QUMs?t=1498&quot;&gt;证实&lt;/a&gt;，以及化学专家的&lt;a href=&quot;http://www.taliban-norge.no/wp-content/uploads/2013/04/%E4%BB%8E%E4%B8%96%E8%B4%B8%E4%B8%AD%E5%BF%83911%E7%81%BE%E9%9A%BE%E4%B8%AD%E7%9A%84%E5%B0%98%E5%9F%83%E7%89%A9%E9%87%8C%E5%8F%91%E7%8E%B0%E7%83%88%E6%80%A7%E7%82%B8%E8%8D%AF.pdf&quot;&gt;采样研究报告&lt;/a&gt;，这种炸弹是美国军方研制的一种非常先进的武器，成分是纳米铝热材料。这东西在 400 多度的普通温度就可以被激发，进行异常剧烈的铝热反应，产生 3000 多度的高温。这是火山喷发出来的熔岩温度（700-1200 度）的 2-4 倍。难怪有人把它称为“&lt;a href=&quot;http://m.akjunshi.com/article/117609_4.html&quot;&gt;来自地狱的火焰&lt;/a&gt;”，因为自然界很难产生这么高的温度，飞机的燃料也完全不可能到达这种温度。&lt;/p&gt;

&lt;p&gt;也就是这种东西熔化了大量的钢铁和水泥，导致整座大楼垮塌。后来这些熔岩一样的钢材和水泥，滞留在世贸大厦的废墟下面，三个月之后才冷却下去。这就是为什么死了 2800 人，最后只发现不到 300 具完整的尸体，因为大部分人都被炸得粉碎，或者被蒸发掉了！由于铝热炸弹对于人类极其残忍，联合国已经在 1980 年通过『禁止和限制使用，燃烧武器的议定书』，禁止在战争中使用铝热炸弹。然而这次更为超级的“纳米铝热炸弹”，竟然被用在了本国平民身上，其心狠手辣之程度，让人毛骨悚然。&lt;/p&gt;

&lt;h3&gt;无人机（drone）猜想&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/911-boeing-diagram.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;两架飞机撞击大楼的时速大概是 580 mph（英里/小时）。而波音客机在低空的最高时速（VMO）只可能有 400 mph。这两架飞机在低空超过了波音 767 在高空的巡航速度（529 mph）。在低空飞行时，空气阻力会很大。波音 767 的引擎不可能提供这么大的推力。就算你有办法超过 VMO，机身也会被空气阻力给拖散架。很多开了几十年客机，成千上万小时经验的飞行员都说，速度超过 VMO 150 mph 以上，是根本无法控制的。没有人可以这样高速低空飞行，准确的操纵波音客机去撞大楼。&lt;/p&gt;

&lt;p&gt;另外，客机的外壳都是很轻的铝合金材料，强度完全不是世贸大厦外面那层钢架的对手，所以根本不应该可以完全撞进去，至少应该有一部分掉在外面。所以有人猜想，这两架飞机很可能根本不是客机，而是美国军方遥控的，具有加强机身和特殊引擎的军用无人机（drone）。另外经过&lt;a href=&quot;https://www.youtube.com/watch?v=o551CQFAMKI&quot;&gt;视频分析&lt;/a&gt;，也发现在飞机撞上大楼之前，楼体上有闪光出现，说明可能有炸弹同时爆炸，给飞机开路。&lt;/p&gt;

&lt;p&gt;关于这个问题，航空界人士联合起来，进行了一次深入的&lt;a href=&quot;https://www.youtube.com/watch?v=-Laaq44SDgg&quot;&gt;调查&lt;/a&gt;，搜集了许多的雷达，录音数据，发现“客机撞大楼”，确实有很多不符合数据的地方。另外，美国军方之前有一个项目叫 Operation Northwoods，使用无人机跟在客机下面，击毁客机，然后假冒成客机，继续飞行…… 有些专家觉得，这就是 9-11 发生的事情。&lt;/p&gt;

&lt;h3&gt;全息成像和电脑动画猜想&lt;/h3&gt;

&lt;p&gt;另外一些飞行专家指出(&lt;a href=&quot;https://www.youtube.com/watch?v=YQBlv7sZGVE&quot;&gt;视频&lt;/a&gt;)，遥控大型客机高速去撞大楼，也是非常困难而且开销太大。另外，波音客机在如此的低空高速飞行，所有人都应该能听到震耳欲聋的飞机噪音，音量应该超过摇滚音乐会最前排，而现场的新闻报道，&lt;a href=&quot;https://www.youtube.com/watch?v=DQbEuBgAKso&quot;&gt;目击证人&lt;/a&gt;的口述，都没有任何这样的迹象。所以他们怀疑这两架所谓的“飞机”，可能根本就不存在。他们猜想，美国军方可能采用了激光全息成像制造幻觉。&lt;/p&gt;

&lt;p&gt;然而我觉得，激光全息技术发展到今天，也不可能在半空中制造出一个飞机那么大的物体，因为要在半空中制造出不透明的物体，要求你能够改变光线在任意位置的传播方向，那似乎是不可能的。其实有一个更容易的办法可以达到这个效果。你想一想，飞机撞大楼发生在仅仅一秒种之间，为什么有几个人运气就那么好，摄像机正好对准那个方向，拍到了那个镜头？&lt;/p&gt;

&lt;p&gt;所以我觉得这些视频的来源很值得怀疑。也许这些正好拍到飞机的人，全都是这个阴谋的参与者，而他们的视频，全都是事先用电脑动画合成好的，只不过到时候拿出来作为现场录像。这种做法成本很低，然后只需要在大楼里面装上炸弹就可以了。&lt;/p&gt;

&lt;h3&gt;借口：无能&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/personnel-excuse.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;美国政府和军方，喜欢采用“无能”作为借口，来解释他们“故意”的行为。在袭击发生当天，美国空军特别组织了一次训练，把几乎所有的战斗机都调到很远的地方去，只剩下 4 架战机防守东部领空。而且在这之前不久，他们对国防部的人员进行了重大调整，换了几个新手担当重任，结果出事的时候发现只能找到新手，但新手根本不知道该怎么办。另外，还有故意报错方位之类的事情。&lt;/p&gt;

&lt;p&gt;这看似犯了“错误”，然而其实是一种非常狡猾的制造借口的方式。这样飞机撞了楼之后，他们就可以说：“哎呀，不是我们不想拦截他们，只是措手不及……” 美国政府在&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/11/20/hillary-emailgate&quot;&gt;本加西&lt;/a&gt;恐怖袭击发生的时候，也是同样的作法。&lt;/p&gt;

&lt;h3&gt;借口：对民航飞机不设防&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/washington-missle.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;美国政府的另一个借口，是说军方的防空设施只能防御战斗机和导弹之类的东西，而不能防御被劫持的客机。然而事实是，在通常情况下，如果客机偏离规定的航道，并且没有应答的时候，FAA 会立即通知五角大楼，在几分钟之内派出战斗机去拦截民航飞机。另外华盛顿特区附近，有一个“特别空中管制区”，任何飞机要进去必须事先经过许可，不然就会被打下来。附近不但有好几个空军基地，海军基地，还有专门的地对空导弹，随时可以打下飞向五角大楼或者白宫“禁飞区”的可疑飞行物。所以显然，这种理论完全站不住脚。除非美国政府自己有阴谋，这种事情根本不可能发生。&lt;/p&gt;

&lt;p&gt;另外，从这个&lt;a href=&quot;https://www.youtube.com/watch?v=-Laaq44SDgg&quot;&gt;视频&lt;/a&gt;里的雷达和对话记录，你可以发现 FAA 和空军基地在接到劫机报告的时候，在故意放任，踢皮球，比电话客服还漫不经心。这是报告劫机，本来应该是肾上腺素上升的时刻，然而接听人最后一句话居然是慢条斯理的：“…… 好的，我看看我们能做些什么…… 请问还有什么其它事情可以帮助您吗？” 这不是明摆着是怎么回事了吗！&lt;/p&gt;

&lt;h3&gt;各种其他漏洞和疑点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;世贸大厦垮塌之后，还没有进行任何调查，就立即有卡车和挖掘机开始运走它的废墟。这是匆忙销毁证据的做法。&lt;/li&gt;
&lt;li&gt;FBI 和媒体报告说飞机上的人给家人打了电话，而在那个高度和速度，手机是不可能有信号的。&lt;/li&gt;
&lt;li&gt;五角大楼被撞之后的形状，不像是被波音 757 那么大的飞机撞的，完全看不见飞机残骸。附近建筑上的 80 多个摄像头的监控录像都被 FBI 藏起来，无法证实波音 757 真的去了那里。&lt;/li&gt;
&lt;li&gt;五角大楼被撞的那个位置，不久前花了两亿多美元进行了加固，而“飞机”其它可以死更多人的位置不撞，正好撞了那个非常牢固的地方。&lt;/li&gt;
&lt;li&gt;93 号航班坠毁的地点，看不到飞机的残骸和应该有的火焰。&lt;/li&gt;
&lt;li&gt;被指控的那几个恐怖分子，当天根本没在任何机场的监控录像里出现过。&lt;/li&gt;
&lt;li&gt;恐怖分子的飞行教练指出，这人开小飞机都不合格，完全不可能有能力操纵波音客机这种超级复杂的庞然大物。&lt;/li&gt;
&lt;li&gt;坠毁飞机的残骸，从来没有经过重新组装还原的“航空界标准”调查过程。&lt;/li&gt;
&lt;li&gt;五角大楼一名官员作证，显示国防部早就知道有飞机要撞五角大楼，却故意不打下来。然而他作证的录音被 FBI 从网站上去除，在官方报告也没有记录。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;死亡人数仍然在增加&lt;/h3&gt;

&lt;p&gt;9-11 给成千上万的人带来了灾难。由于 9-11 死亡的人数，直到今天都还在增加。由于世贸大厦的建筑材料里面有大量的石棉（asbestos，一种呼吸道致癌物），再加上铝热炸弹里面不知道有什么有毒物质，纳米物质，所以现场附近的人，估计有 40 万人患上了不同程度的呼吸道，食道，肺，肝和肾脏疾病。&lt;/p&gt;

&lt;p&gt;到今天，37000 名当时战斗在一线的救援人员里面，已经有 5000 多人被诊断患了癌症，有 1100 人死亡，医疗开销总数已经超过 3 亿美元。这些人被发现患有 70 多种癌症，其中有很多罕见的癌症，几乎没有办法治疗。然而，这 40 多万受到健康威胁的人里面，只有不到 1 万人收到了政府的“幸存者补助”。 (&lt;a href=&quot;http://www.newsweek.com/2016/09/16/9-11-death-toll-rising-496214.html&quot;&gt;Newsweek 报道&lt;/a&gt;)&lt;/p&gt;

&lt;h3&gt;世界上最阴险的政府&lt;/h3&gt;

&lt;p&gt;所有的证据和现象都表明，这是美国政府自编自导自演的一出戏。他们制造这样惨绝人寰的灾难，是为了有借口可以发动伊拉克战争。另外，世贸大厦的主人也是这次阴谋的参与者之一。他在出事之前买了很多的保险，后来拿到了 40 多亿美元的赔偿，很是赚了一笔。&lt;/p&gt;

&lt;p&gt;成千上万不知情的人在大楼里，被事先准备好的塞满整栋楼的铝热炸弹，炸得粉身碎骨，连完整的尸体都找不到。很多人被完全蒸发掉了，就跟掉进了火山口一样…… 想到这里，我不禁毛骨悚然。这比我们之前想象的飞机撞大楼，还要残忍许多倍，跟日本人的南京大屠杀有得一拼。这要心理多变态的人，才会想出这样的做法！&lt;/p&gt;

&lt;p&gt;美国政府里的某些人为了赚黑心钱，可以随时把本国平民作为炮灰来用。再加上因此发动的伊拉克战争，导致上百万无辜平民死亡，这真是天大的灾难！珍珠港，9-11，&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/11/20/hillary-emailgate&quot;&gt;本加西&lt;/a&gt;，San Bernardino…… 这些袭击都是同样的性质：幌子。天天在叫要打击恐怖分子，结果最可怕的恐怖分子，就坐在白宫里面！小布什是坏人大家都知道。不过大家都还被蒙在鼓里，以为克林顿，希拉里，奥巴马是好人。看看这个片子，醒过来吧。&lt;/p&gt;

&lt;p&gt;另外，看看这个希拉里谈伊朗的&lt;a href=&quot;https://www.youtube.com/watch?v=xvhBoF_pCHo&quot;&gt;视频&lt;/a&gt;。她说：“我希望他们（伊朗）来袭击我们。我们甚至可以去挑起他们来袭击我们。这样我们就有正当的理由向他们开战了！” 明白了吗？其实她就是会制造 9-11 的那种人。难怪揭发 9-11 真相的 CIA 特工 &lt;a href=&quot;https://www.youtube.com/watch?v=_dvxnqe6Eew&quot;&gt;Susan Lindauer 说&lt;/a&gt;：“投票给希拉里，就等于投票给第三次世界大战。就是有那么严重！”&lt;/p&gt;

&lt;p&gt;当今的美国政府里面，窝藏着世界上最阴险的犯罪团伙。犯下这样极端残忍的滔天罪行，居然还可以藏这么深这么久，让人们继续以为他们是道德高尚的好人，也真是无人能比了。人们对 9-11 真相的无知是很危险的。由于他们的无知，这些野心家可以制造任何他们想要的假象，可以诬陷任何好人，继续屠杀本国民众，同时让他们的战争和侵略行为合法化。我希望 Trump 的政府能改变这种情况，让 9-11 的真相大白于天下，把这些十恶不赦的罪犯们早日送上断头台。&lt;/p&gt;

&lt;p&gt;（写这样一篇文章挺费神的，说真话是需要一些胆量的，所以如果你觉得开了眼界的话，请考虑付款 $3。谢谢！）&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/12/01/september-eleven</guid>
<pubDate>Thu, 01 Dec 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>可恶的 C# IDisposable 接口</title>
<link>http://yinwang.org/blog-cn/2016/10/13/c-sharp-disposable</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;可恶的 C# IDisposable 接口&lt;/h2&gt;
                            &lt;p&gt;我们 team 快被 C# 里面的各种 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.idisposable(v=vs.110).aspx&quot;&gt;IDisposable&lt;/a&gt; 对象给折腾疯了…… 故事比较长，先来科普一下。如果你没有用过 C#，IDisposable 是 C# 针对“资源管理”设计的一个接口，它类似于 Java 的 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Closeable.html&quot;&gt;Closeable&lt;/a&gt; 接口。这类接口一般提供一个“方法”（比如叫 Dispose 或者 Close），你的资源（比如文件流）实现这个接口。使用资源的人先“打开资源”，用完之后调用这个方法，表示“关闭资源”。比如，文件打开，读写完了之后，调用 close 关掉，就是这个原理。&lt;/p&gt;

&lt;p&gt;相比于 Java，C# 大部分时候是更好的语言，然而它并没有全面超越 Java。一个显著的不足之处就是 C# 的 IDisposable 接口引起的头痛，要比 Java 的 Closeable 大很多。经过我分析，这一方面是因为 .NET 库代码里面实现了很多没必要的 IDisposable，以至于你经常需要思考如何处理它们。另一方面是由于微软的编码规范和 Roslyn 静态分析引起的误导，使得用户对于 IDisposable 接口的“正确使用”过度在乎，导致代码无端变得复杂，导致 IDisposable 在用户代码里面传染。&lt;/p&gt;

&lt;p&gt;回来说说我们的代码，本来没那么多问题的，结果把 &lt;a href=&quot;https://github.com/dotnet/roslyn-analyzers&quot;&gt;Roslyn 静态分析&lt;/a&gt;一打开，立马给出几百个警告，说“你应该调用 Disposable 成员的 Dispose 方法”（&lt;a href=&quot;(https://msdn.microsoft.com/en-us/library/ms182328.aspx&quot;&gt;CA2213&lt;/a&gt;)），或者说“类型含有 disposable 成员，却没有实现 IDisposable 接口”（&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms182172.aspx&quot;&gt;CA1001&lt;/a&gt;）。奇葩的是，C# 里面有些很小却很常用的对象，包括 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.manualresetevent(v=vs.110).aspx&quot;&gt;ManualResetEvent&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.semaphore(v=vs.110).aspx&quot;&gt;Semaphore&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.readerwriterlockslim(v=vs.110).aspx&quot;&gt;ReaderWriterLockSlim&lt;/a&gt; 都实现了 IDisposable 接口，所以经常搞得你不知所措。按官方的“规矩”，你得显式的调用所有这些对象的 Dispose 方法进行“释放”，而不能依赖 GC 进行回收。所以你的代码经常看起来就像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;void foo()
{
  var event = new ManualResetEvent(false);
  // 使用 _event ...
  event.Dispose();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;貌似没什么困难嘛，我们把每个对象的 Dispose 方法都调用一下，不就得了？然而问题远远不是这么简单。很多时候你根本搞不清楚什么时候该释放一个对象，因为它存在于一个复杂，动态变化的数据结构里面。除非你使用引用计数，否则你没有办法确定调用 Dispose 的时机。如果你过早调用了 Dispose 方法，而其实还有人在用它，就会出现严重的错误。这问题就像 C 语言里面的 free，很多时候你不知道该不该 free 一块内存。如果你过早的 free 了内存，就会出现非常严重而蹊跷的内存错误，比泄漏内存还要严重很多。举一个 C 语言的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void main()
{
    int *a = malloc(sizeof(int));
    *a = 1;

    int *b = malloc(sizeof(int));
    *b = 2;

    free(a);

    int *c = malloc(sizeof(int));
    *c = 3;

    printf(&quot;%d, %d, %d\n&quot;, *a, *b, *c);    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你知道这个程序最后是什么结果吗？自己运行一下看看吧。所以对于复杂的数据结构，比如图节点，你就只好给对象加上引用计数。我当年用 C 语言写计算几何算法的时候就干过这种事情，相信我，这其实挺痛苦。或者如果你的内存够用，也不需要分配释放很多中间结果，那你就干脆把这些对象都放进一个“池子”，到算法结束以后再一并释放它们……&lt;/p&gt;

&lt;p&gt;是的 C# 有垃圾回收（GC），所以你以为不用再考虑这些低级问题了。不幸的是，IDisposable 接口以及对于它兢兢业业的态度，把这麻烦事给带回来了。以前在 Java 里用此类对象，从来没遇到过这么麻烦的事情，最多就是打开文件的时候要记得关掉（关于文件，我之后会细讲一下）。我不记得 Java 的等价物（&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Closeable.html&quot;&gt;Closeable&lt;/a&gt; 接口）引起过这么多的麻烦，Java 的 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html&quot;&gt;Semaphore&lt;/a&gt; 根本就没有实现 Closeable 接口，也不需要在用完之后调用什么 Close 或者 Dispose 之类的方法。作为一个眼睛雪亮的旁观者，我开始怀疑 C# 里的那些像 Semaphore 之类的小东西是否真的需要显式的“释放资源”。&lt;/p&gt;

&lt;p&gt;为了搞明白 C# 库代码里面为什么这么多 IDisposable 对象，我用 JetBrains 出品的反编译器 &lt;a href=&quot;https://www.jetbrains.com/decompiler&quot;&gt;dotPeek&lt;/a&gt; （好东西呀）反编译了 .NET 的库代码。结果发现好些库代码实现了完全没必要的 IDisposable 接口。这说明有些 .NET 库代码的作者其实没有弄明白什么时候该实现 IDisposable ，以及如何有意义地实现它。这些有问题的类，包括常用的 HashAlgorithm（各种 SHA 算法的父类）和 MemoryStream。&lt;/p&gt;

&lt;p&gt;其中 HashAlgorithm 的 Dispose 方法完全没必要，这个类的源代码看起来是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;public abstract class HashAlgorithm : IDisposable, ICryptoTransform {
  ...
  protected internal byte[] HashValue;
  ...
  protected virtual void Dispose(bool disposing)
  {
      if (disposing)
      {
          if (HashValue != null)
              Array.Clear(HashValue, 0, HashValue.Length);
          HashValue = null;
          m_bDisposed = true;
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看明白了吗？它不过是在把内部数组 HashValue 的每个元素清零，然后把指针设为 null。这个库代码作者没有搞明白的是，如果你的 Dispose 方法只是在把一些成员设为 null，那么你根本就不需要实现 IDisposable。为什么呢？因为把引用设为 null 并不等于 C 语言里面的 free，它并不能立即回收那份内存，就算你的对象里面有一个很大的数组也一样。我发现有些 C# 程序员喜欢在使用对象之后把引用赋值为 null，就像这样写代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;void foo()
{
  BigObject x = new BigObject();
  // ...
  // 使用 x 指向的对象 ...
  // ...
  x = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;x = null&lt;/code&gt; 是毫无意义的。写出这样的代码，说明他们不明白 GC 是如何工作的，以为把引用设为 null 就可以释放内存，以为不把引用设为 null，内存就不会被回收！再进一步，如果你仔细看 HashAlgorithm 的源代码，就会发现 HashValue 这个成员数组其实没有必要存在，因为它保存的只是上一次调用 ComputeHash() 的结果而已。这种保存结果的事情，本来应该交给使用者去做，而不是包揽到自己身上。这个数组的存在，还导致你没法重用同一个 HashAlgorithm 对象，因为有共享的成员 HashValue，所以不再是 thread safe 的。&lt;/p&gt;

&lt;p&gt;其实在 C# 里面，你没有办法可以手动回收内存，因为内存是由 GC 统一管理的。就算你实现 Dispose，在里面把成员设置为 null，内存也只有等下次 GC 执行的时候才可能被回收。举一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C#&quot;&gt;class Foo : IDisposable
{
  private byte[] _data = new byte[1000000000];

  public void Dispose()
  {
    _data = null;    // 没用的
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子里面，Foo 类型的 Dispose 只是在把 _data 设为 null，这是毫无意义的。如果你想释放掉这块数组，那么你只需要等不再有人使用 Foo 对象。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;void UseFoo()
{
  Foo foo = new Foo();
  // 使用 f...
  foo.Dispose();  // 没必要
  foo = null;     // 没必要
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;foo.Dispose()&lt;/code&gt; 是完全没必要的。你甚至没必要写 &lt;code&gt;foo = null&lt;/code&gt;，因为 foo 是一个局部变量，它一般很快就会离开作用域的。当函数执行完毕，或者编译器推断 foo 不会再次被使用的时候，GC 会回收整个 Foo 对象，包括里面的巨大数组。&lt;/p&gt;

&lt;p&gt;所以正确的做法应该是完全不要 Dispose，不实现 IDisposable 接口。有些人问，要是 Foo 对象被放进一个全局哈希表之类的数据结构，GC 没法释放它，就需要 Dispose 了吧？这也是一种常见的误解。如果你真要回收全局哈希表里的 Foo 对象，你只需要把 Foo 对象从哈希表里面删掉就可以了。一旦哈希表对 Foo 对象的引用没有了，GC 运行的时候就会发现它成了垃圾，里面的 _data 数组自然也是垃圾，所以一起就回收掉了。&lt;/p&gt;

&lt;p&gt;所以简言之，Dispose 不是用来给你回收内存用的。在 Dispose 方法里把成员设为 null，并不会导致更快的内存释放。有人可能以为 HashAlgorithm 是为了“安全”考虑，所以在 Dispose 方法里对数组清零。然而 IDisposable 是用于释放“资源”的接口，把安全清零这种事情放在这个接口里面，反而会让人误解，造成疏忽。而且从源代码里的注释看来，HashAlgorithm 的这个方法确实是为了释放资源，而不是为了什么安全考虑。这些库代码实现 IDisposable，意味着这个接口会通过这些库代码不必要的传递到用户代码里面去，导致很多不知情用户的代码被迫实现 IDisposable，造成“传染”。&lt;/p&gt;

&lt;p&gt;作为练习，你可以分析一下 MemoryStream 的 Dispose 方法，为什么是没必要的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;protected override void Dispose(bool disposing)
{
    try
    {
        if (disposing)
        {
            _isOpen = false;
            _writable = false;
            _expandable = false;
#if FEATURE_ASYNC_IO
        _lastReadTask = null;
#endif
        }
    }
    finally
    {
        // Call base.Close() to cleanup async IO resources
        base.Dispose(disposing);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我发现 AutoResetEvent，ManualResetEvent，ReaderWriterLockSlim，Semaphore 这些 IDisposable 对象，里面的所谓“资源”，归根结底都是一些很小的 Windows event 对象，而且它们都继承了 SafeHandle。SafeHandle 本身有一个“析构函数”（finalizer），它看起来是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;~SafeHandle()
{
    Dispose(false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 SafeHandle 被 GC 回收的时候，GC 会自动自动调用这个析构函数，进而调用 Dispose。也就是说，你其实并不需要手动调用这些对象（例如 ManualResetEvent, Semaphore 之类）的 Dispose 方法，因为 GC 会调用它们。这些对象占用资源不多，系统里也不会有很多这种对象，所以 GC 完全应该有能力释放它们占用的系统资源。&lt;/p&gt;

&lt;p&gt;很多人谈到这个问题，就会举文件的例子来反驳你，说你不应该依靠 GC 来释放 IDisposable 对象。他们说，你应该及时关闭文件，所以对于其它 IDisposable 资源，你应该做同样的事情，然而他们并没有抓住问题的关键。文件是一种很特殊的资源，你之所以需要在用完之后立即关掉它，而不能等 GC  来做这事，是因为文件是一种“全局资源”。使用文件的时候，你使用文件的名字来读写它。任何知道这个名字的进程，都可以试图访问这个文件。这使得文件成为一种“全局资源”，也就是说，它不是 thread safe 的。一般系统里面，在任何一个时刻，只能有一个进程打开文件进行写操作，然后这个文件就被锁住了，其它进程不能打开。所以如果你不关掉文件，那其它人就没法用它。&lt;/p&gt;

&lt;p&gt;写文件需要给它加锁，当然你必须及时进行解锁，而不能等 GC 这样的过程来帮你解。否则即使你不再引用这个文件，其他人仍然没法及时进入锁定的区域，就造成了不必要的等待。然而有另外一种资源，它不是共享的，而是分配给进程“私人使用”的。系统里面可以有任意多个这样的资源，你用任何一个都可以，它们的使用互不干扰，所以你并不需要非常及时的关闭它们。这种资源的性质，跟内存的性质几乎完全一样。像 ManualResetEvent, Semaphore, ReaderWriterLockSlim 就属于这种非共享的资源，它们的性质跟内存非常相似。就算它们实现了 IDisposable 接口，关闭它们的重要性也跟关闭文件相差非常大。实际上我通过测试发现，就算你把它们完全交给 GC 处理，也不会有任何问题。你掉不调用 Dispose，内存的使用量都一模一样。只不过如果你调用 Dispose，计算花的时间还要多一些。&lt;/p&gt;

&lt;p&gt;微软官方文档和 Roslyn 静态分析说一定要调用 Dispose，其实是把不是问题的问题拿出来让人心惊胆战，结果把代码给搞复杂了，进而引发更严重的问题。很多人把 Roslyn 静态分析的结果很当回事，而其实看了源代码之后，我发现 Roslyn 关于 Dispose 的静态分析实现，是相当幼稚的作法（flow analysis 都没实现），所以结果是非常不准确的，导致很多 false positive。&lt;/p&gt;

&lt;p&gt;另外 Roslyn 分析给出的警告信息，有严重的误导性质。比如编号为&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms182172.aspx&quot;&gt;CA1001&lt;/a&gt;的警告对你说：“Types that own disposable fields should be disposable。” 如果你严格遵循这一“条款”，让所有含有 IDispoable 的成员的类都去实现 IDisposable，那么 IDisposable 接口就会从一些很小的对象（比如常见的 ManualResetEvent），很快扩散到几乎所有的对象里去。每个对象都实现 IDisposable 接口，却没有任何对象真正的调用 Dispose 方法。最终结果跟你什么都不做是一样的，只不过代码变复杂了，还浪费了时间和精力。&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/10/13/c-sharp-disposable</guid>
<pubDate>Thu, 13 Oct 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>C 编译器优化过程中的 Bug</title>
<link>http://yinwang.org/blog-cn/2016/10/12/compiler-bug</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;C 编译器优化过程中的 Bug&lt;/h2&gt;
                            &lt;p&gt;一个朋友向我指出一个最近他们发现的 GCC 编译器优化过程（加上 -O3 选项）里的 bug，导致他们的产品出现非常诡异的行为。这使我想起以前见过的一个 GCC bug。当时很多人死活认为那种做法是正确的，跟他们说不清楚。简言之，这种有问题的优化，喜欢利用 C 语言的“未定义行为”（undefined behavior）进行推断，最后得到奇怪的结果。&lt;/p&gt;

&lt;p&gt;这类优化过程的推理方式都很类似，他们使用一种看似严密而巧妙的推理，例如：“现在有一个整数 &lt;code&gt;x&lt;/code&gt;，我们不知道它是多少。但 &lt;code&gt;x&lt;/code&gt; 出现在一个条件语句里面，如果 &lt;code&gt;x &amp;gt; 1&lt;/code&gt;，那么程序会进入未定义行为，所以我们可以断定 &lt;code&gt;x&lt;/code&gt; 的值必然小于或者等于 1，所以现在我们利用 &lt;code&gt;x ≤ 1&lt;/code&gt; 这个事实来对相关代码进行优化……”&lt;/p&gt;

&lt;p&gt;看似合理，然而它却是不正确的，你能看出来这样的推理错在何处吗？我一时想不起来之前具体的例子了（如果你知道的话告诉我）。上网搜了一下相关话题，发现这篇 Chris Lattner (LLVM 和 &lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/06/swift&quot;&gt;Swift 语言&lt;/a&gt; 的设计者) 写于 2011 年的&lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;文章&lt;/a&gt;。文中指出，编译器利用 C 语言的“未定义行为”进行优化，是合理的，对于性能是很重要的，并且举出这样一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void contains_null_check(int *P) {
  int dead = *P;
  if (P == 0)
    return;
  *P = 4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这例子跟我之前看到的 GCC bug 不大一样，但大致是类似的推理方式：这个函数依次经过这样两个优化步骤（RNCE 和 DCE），之后得出“等价”的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void contains_null_check_after_RNCE(int *P) {
  int dead = *P;
  if (false)  // P 在上一行被访问，所以这里 P 不可能是 null
    return;
  *P = 4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void contains_null_check_after_RNCE_and_DCE(int *P) {
  //int dead = *P;    // 死代码消除
  //if (false)        // 死代码
  //  return;         // 死代码
  *P = 4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他的推理方式是这样：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先，因为在 &lt;code&gt;int dead = *P&lt;/code&gt; 里面，指针 &lt;code&gt;P&lt;/code&gt; 的地址被访问，如果程序顺利通过了这一行而没有出现未定义行为（比如当掉），那么之后 &lt;code&gt;P&lt;/code&gt; 就不可能是 null，所以我们可以把 &lt;code&gt;P == 0&lt;/code&gt; 优化为 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为条件是 &lt;code&gt;false&lt;/code&gt;，所以整个 if 语句都是死代码，被删掉。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dead&lt;/code&gt; 变量赋值之后，没有被任何其它代码使用，所以对 &lt;code&gt;dead&lt;/code&gt; 的赋值是死代码，可以消去。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;最后函数就只剩下一行代码 &lt;code&gt;*P = 4&lt;/code&gt;。然而经我分析，发现这个优化转换是根本错误的做法（unsound 的变换），而不只是像他说的“存在安全隐患”。现在我来考考你，你知道这为什么是错的吗？值得庆幸的是，现在如果你把这代码输入到 Clang，就算加上 -O3 选项，它也不会给你进行这个优化。这也许说明 Lattner 的这个想法后来已经被 LLVM 团队抛弃。&lt;/p&gt;

&lt;p&gt;我写这篇文章的目的其实是想告诉你，不要盲目的相信编译器的作者们做出的变换都是正确的，无论它看起来多么的合理，只要打开优化之后你的程序出现奇葩的行为，你就不能排除编译器进行了错误优化的可能性。Lattner 指出这样的优化完全符合 C 语言的标准，这说明就算你符合国际标准，也有可能其实是错的。有时候，你是得相信自己的直觉……&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/10/12/compiler-bug</guid>
<pubDate>Wed, 12 Oct 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>对 Rust 语言的分析</title>
<link>http://yinwang.org/blog-cn/2016/09/18/rust</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;对 Rust 语言的分析&lt;/h2&gt;
                            &lt;p&gt;Rust 是一门最近比较热的语言，有很多人问过我对 Rust 的看法。由于我本人是一个语言专家，实现过几乎所有的语言特性，所以我不认为任何一种语言是新的。任何“新语言”对我来说，不过是把早已存在的语言特性（或者毛病），挑一些出来放在一起。所以一般情况下我都不会去评论别人设计的语言，甚至懒得看一眼，除非它历史悠久（比如像 C 或者 C++），或者它在工作中惹恼了我（像 Go 和 JavaScript 那样）。这就是为什么这些人问我 Rust 的问题，我一般都没有回复，或者一笔带过。&lt;/p&gt;

&lt;p&gt;不过最近有点闲，我想既然有人这么热衷于这种新语言，那我还是稍微凑下热闹，顺便分享一下我对某些常见的设计思路的看法。所以这篇文章虽然是在评论 Rust 的设计，它却不只是针对 Rust。它是针对某些语言特性，而不只是针对某一种语言。&lt;/p&gt;

&lt;p&gt;由于我这人性格很难闭门造车，所以现在我只是把这篇文章的开头发布出来，边写边更新。所以你要明白，这只是一个开端，我会按自己理解的进度对这篇文章进行更新。你看了之后，可以隔一段时间再回来看新的内容。如果有特别疑惑的问题，也可以发信来问，我会汇总之后把看法发布在这里。&lt;/p&gt;

&lt;h3&gt;变量声明语法&lt;/h3&gt;

&lt;p&gt;Rust 的&lt;a href=&quot;https://doc.rust-lang.org/book/variable-bindings.html&quot;&gt;变量声明&lt;/a&gt;跟 Scala 和 Swift 的很像。你用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的构造来声明一个新的变量。大部分时候 Rust 可以推导出变量的类型，所以你不一定需要写明它的类型。如果你真的要指明变量类型，需要这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x: i32 = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我看来这是丑陋的语法。本来语义是把变量 x 绑定到值 8，可是 x 和 8 之间却隔着一个“i32”，看起来像是把 8 赋值给了 i32……&lt;/p&gt;

&lt;p&gt;变量缺省都是不可变的，也就是不可赋值。你必须用一种特殊的构造&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let mut x = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来声明可变变量。这跟 Swift/Scala 的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;var&lt;/code&gt; 的区别是一样的，只是形式不大一样。&lt;/p&gt;

&lt;h3&gt;变量可以重复绑定&lt;/h3&gt;

&lt;p&gt;Rust 的变量定义有一个比其它语言更奇怪的地方，它可以让你在同一个作用域里面“重复绑定”同一个名字，甚至可以把它绑定到另外一个类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let mut x: i32 = 1;
x = 7;
let x = x; // 这两个 x 是两个不同的变量

let y = 4;
// 30 lines of code ...
let y = &quot;I can also be bound to text!&quot;;
// 30 lines of code ...
println!(&quot;y is {}&quot;, y);      // 定义在第二个 let y 的地方
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Yin 语言最初的设计里面，我也是允许这样的重复绑定的。第一个 y 和 第二个 y 是两个不同的变量，只不过它们碰巧叫同一个名字而已。你甚至可以在同一行出现两个 x，而它们其实是不同的变量！这难道不是一个很酷，很灵活，其他语言都没有的设计吗？后来我发现，虽然这实现起来没什么难度，可是这样做不但没有带来更大的方便性，反而可能引起程序的混淆不清。在同一个作用域里面，给两个不同的变量起同一个名字，这有什么用处呢？自找麻烦而已。&lt;/p&gt;

&lt;p&gt;比如上面的例子，在下面我们看到一个对变量 &lt;code&gt;y&lt;/code&gt; 的引用，它是在哪里定义的呢？你需要在头脑中对程序进行“数据流分析”，才能找到它定义的位置。从上面读起，我们看到 &lt;code&gt;let y = 4&lt;/code&gt;，然而这不一定是正确的定义，因为 &lt;code&gt;y&lt;/code&gt; 可以被重新绑定，所以我们必须继续往下看。30 行代码之后，我们看到了第二个对 &lt;code&gt;y&lt;/code&gt; 的绑定，可是我们仍然不能确定。继续往下扫，30行代码之后我们到了引用 &lt;code&gt;y&lt;/code&gt; 的地方，没有再看到其它对 &lt;code&gt;y&lt;/code&gt; 的绑定，所以我们才能确信第二个 let 是 &lt;code&gt;y&lt;/code&gt; 的定义位置，它是一个字符串。&lt;/p&gt;

&lt;p&gt;这难道不是很费事吗？更糟的是，这种人工扫描不是一次性的工作，每次看到这个变量，你都要疑惑一下它是什么东西，因为它可以被重新绑定，你必须重新确定一下它的定义。如果语言不允许在同一个作用域里面重复绑定同一个名字，你就根本不需要担心这个事情了。你只需要在作用域里面找到唯一的那个 &lt;code&gt;let y = ...&lt;/code&gt;，那就是它的定义。&lt;/p&gt;

&lt;p&gt;也许你会说，只有当有人滥用这个特性的时候，才会导致问题。然而语言设计的问题往往就在于，一旦你允许某种奇葩的用法，就一定会有人自作聪明去用。因为你无法确信别人是否会那样做，所以你随时都得提高警惕，而不能放松下心情来。&lt;/p&gt;

&lt;h3&gt;类型推导&lt;/h3&gt;

&lt;p&gt;另外一个很多人误解的地方是类型推导。在 Rust 和 C# 之类的语言里面，你不需要像 Java 那样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int x = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样显式的指出变量的类型，而是可以让编译器把类型推导出来。比如你写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x = 8;  // x 的类型推导为 i32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器的类型推导就可以知道 &lt;code&gt;x&lt;/code&gt; 的类型是 i32，而不需要你把“i32”写在那里。这似乎是一个很方便的东西。然而看过很多 C# 代码之后你发现，这看似方便，却让程序变得不好读。在看 C# 代码的时候，我经常看到一堆的变量定义，每一个的前面都是 var。我没法一眼就看出它们表示什么，是整数，bool，还是字符串，还是某个用户定义的类？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c#&quot;&gt;var correct = ...;
var id = ...;
var slot = ...;
var user = ...;
var passwd = ...;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我需要把鼠标移到变量上面，让 Visual Studio 显示出它推导出来的类型，可是鼠标移开之后，我可能又忘了它是什么。有时候发现看同一片代码，都需要反复的做这件事，鼠标移来移去的。而且要是没有 Visual Studio，用其它编辑器，或者在 github 上看代码或者 code review 的时候，你就得不到这种信息了。很多 C# 程序员为了避免这个问题，开始用很长的变量名，把类型的名字加在变量名字里面去，这样一来反而更复杂了，却没有想到直接把类型写出来。所以这种形式的类型推导，看似先进或者方便，其实还不如直接在声明处写下变量的类型，就像 Java 那样。&lt;/p&gt;

&lt;p&gt;所以，虽然 Rust 在变量声明上似乎有更灵活的设计，然而我觉得 C 和 Java 之类的语言那样看似死板的方式其实更好。我建议不要使用 Rust 变量的重复绑定，避免使用类型推导，尽量明确的写出类型，以方便读者。如果你真的在乎代码的质量，就会发现大部分时候你的代码的读者是你自己，而不是别人，因为你需要反复的阅读和提炼你的代码。&lt;/p&gt;

&lt;h3&gt;动作的“返回值”&lt;/h3&gt;

&lt;p&gt;Rust 的文档说它是一种“&lt;a href=&quot;https://doc.rust-lang.org/book/functions.html#expressions-vs-statements&quot;&gt;大部分基于表达式&lt;/a&gt;”的语言，并且给出这样一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let mut y = 5;
let x = (y = 6);  // x has the value `()`, not `6`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;奇怪的是，这里变量 &lt;code&gt;x&lt;/code&gt; 会得到一个值，空的 tuple，&lt;code&gt;()&lt;/code&gt;。这种思路不大对，它是从像 OCaml 那样的语言照搬过来的，而 OCaml 本身就有问题。在 OCaml 里面，如果你使用 &lt;code&gt;print_string&lt;/code&gt;，那你会得到如下的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;print_string &quot;hello world!\n&quot;;;

hello world!
- : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，&lt;code&gt;print_string&lt;/code&gt; 是一个“动作”，它对应过程式语言里面的“statement”。就像 C 语言的 &lt;code&gt;printf&lt;/code&gt;。动作通常只产生“副作用”，而不返回值。在 OCaml 里面，为了“理论的优雅”，动作也会返回一个值，这个值叫做 &lt;code&gt;()&lt;/code&gt;。其实 &lt;code&gt;()&lt;/code&gt; 相当于 C 语言的 void。C 语言里面有 void 类型，然而它却不允许你声明一个 void 类型的变量。比如你写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int main()
{
  void x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序是没法编译通过的（试一试？）。让人惊讶的是，古老的 C 的做法其实是正确的，这里有比较深入的原因。如果你把一个类型看成是一个集合（比如 int 是机器整数的集合），那么 void 所表示的集合是个空集，它里面是不含有任何元素的。声明一个 void 类型的变量是没有任何意义的，因为它不可能有一个值。如果一个函数返回 void，你是没法把它赋值给一个变量的。&lt;/p&gt;

&lt;p&gt;可是在 Rust 里面，不但动作（比如 &lt;code&gt;y = 6&lt;/code&gt; ）会返回一个值 &lt;code&gt;()&lt;/code&gt;，你居然可以把这个值赋给一个变量。其实这是错误的作法。原因在于 &lt;code&gt;y = 6&lt;/code&gt; 只是一个“动作”，它只是把 6 放进变量 y 里面，这个动作发生了就发生了，它根本不应该返回一个值，它不应该可以出现在 &lt;code&gt;let x = (y = 6);&lt;/code&gt; 的右边。就算你牵强附会说 &lt;code&gt;y = 6&lt;/code&gt; 的返回值是 &lt;code&gt;()&lt;/code&gt;，这个值是没有任何用处的。更不要说使用空的 tuple 来表示这个值，会引起更大的类型混淆，因为 &lt;code&gt;()&lt;/code&gt; 本身有另外的，更有用的含义。&lt;/p&gt;

&lt;p&gt;你根本就不应该可以写 &lt;code&gt;let x = (y = 6);&lt;/code&gt; 这样的代码。只有当你犯错误或者逻辑不清晰的时候，才有可能把 &lt;code&gt;y = 6&lt;/code&gt; 当成一个值来用。Rust 允许你把这种毫无意义的返回值赋给一个变量，这种错误就没有被及时发现，反而能够通过变量传播到另外一个地方去。有时候这种错误会传播挺远，然后导致问题（运行时错误或者类型检查错误），可是当它出问题的时候，你就不大容易找到错误的起源了。&lt;/p&gt;

&lt;p&gt;这是很多语言的通病，特别是像 JavaScript 或者 PHP 之类的语言。它们把毫无意义或者牵强附会的结果（比如 undefined）到处传播，结果使错误很难被发现和追踪。&lt;/p&gt;

&lt;h3&gt;return 语句&lt;/h3&gt;

&lt;p&gt;Rust 的设计者似乎很推崇“面向表达式”的语言，所以在 Rust 里面你不需要直接写“return”这个语句。比如，这个&lt;a href=&quot;https://doc.rust-lang.org/book/functions.html#early-returns&quot;&gt;例子&lt;/a&gt;里面，你可以直接这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn add_one(x: i32) -&amp;gt; i32 {
    x + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回函数里的最后一个表达式，而不需要写 return 语句，这是函数式语言共有的特征。然而其实我觉得直接写 return 其实是更好的作法，像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn foo(x: i32) -&amp;gt; i32 {
    return x + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编程有一个容易引起问题的作法，叫做“不够明确”，总想让编译器自动去处理一些问题，在这里也是一样的问题。如果你隐性的返回函数里最后一个表达式，那么每一次看见这个函数，你都必须去搞清楚最后一个表达式是什么，这并不是每次都那么明显的。比如下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn main() {
    println!(&quot;{}&quot;, add_one(7));
}

fn add_one(x: i32) -&amp;gt; i32 {
  if (x &amp;lt; 5) {
      if (x &amp;lt; 10) {
        // 做很多事...
        x * 2
      } else {
        // 做很多事...
        x + 1
      }
  } else {
    // 做很多事...
    x / 2
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 if 语句里面有嵌套，每个分支又有好些代码，而且 if 语句又是最后一个语句，所以这个嵌套 if 的三个出口的最后一个表达式都是返回值。如果你写了“return”，那么你可以直接看有几个“return”，或者拿编辑器加亮一下，就知道这个函数有几个出口。然而现在没有了“return”这个关键字，你就必须把最后那个 if 语句自己看清楚了，找到每一个分支的“最后表达式”。很多时候这不是那么明显，你总需要找一下，而且这件事在读代码的时候总是反复做。&lt;/p&gt;

&lt;p&gt;所以对于返回值，我的建议是总是明确的写上“return”，就像第二个例子那样。Rust 的文档说这是“poor style”，那不是真的。有一个例外，那就是当函数体里面只有一条语句的时候，那个时候没有任何歧义哪一个是返回表达式。&lt;/p&gt;

&lt;p&gt;这个问题类似于重复绑定变量和类型推导的问题，属于一种“用户体验设计”问题。无论如何，编译器都很容易实现，然而不同样式的代码，对于人类阅读的工作量，是很不一样的。很多时候最省人力的做法并不是那种看来最聪明，最酷，打字量最少的办法，而是写得最明确，让读者省事的办法。人们常说，代码读的时候比写的时候多得多，所以要想语言好用省事，我们应该更加重视读的时候，而不是写的时候。&lt;/p&gt;

&lt;h3&gt;数组的可变性&lt;/h3&gt;

&lt;p&gt;Rust 的数组可变性标记，跟 Swift 犯了一样的错误。Swift 的问题，我已经在之前的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/06/swift&quot;&gt;文章&lt;/a&gt;有详细叙述，所以这里就不多说了。简言之，同一个标记能表示的可变性，要么针对数组指针，要么针对数组元素，应该只能选择其一。而在 Rust 里面，你只有一个地方可以放“mut”进去，所以要么数组指针和元素全部都可变，要么数组指针和元素都不可变。你没有办法制定一个不可变的数组指针，而它指向的数组的元素却是可变的。&lt;/p&gt;

&lt;p&gt;请对比下面两个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn main() {
    let m = [1, 2, 3];      // 指针和元素都不可变
    m[0] = 10;              // 出错
    m = [4, 5, 6];          // 也出错
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn main() {
    let mut m = [1, 2, 3];  // 指针和元素都可变
    m[0] = 10;              // 不出错
    m = [4, 5, 6];          // 也不出错
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;内存管理&lt;/h3&gt;

&lt;p&gt;Rust 号称实现了非常先进的内存管理机制，不需要垃圾回收（GC）或者引用计数（RC）就可以“静态”的管理内存的分配和释放。然而仔细思考之后你就会发现，这很可能是不切实际的梦想（或者广告）。内存的分配和释放（如果要及时释放的话），本身是一个动态的过程，无法用静态分析来实现。现在你说可以通过一些特殊的构造，特殊的指针和传值方式，静态的决定内存的回收时间，真的有可能吗？&lt;/p&gt;

&lt;p&gt;实际上在 IU 的时候，我有一个类似的梦。我曾经向我的教授们（Friedman，Dybvig）提出过 N 多种不需 GC 和 RC 就能静态管理内存的办法，结果每一次都被他们给我的小例子给打败了，以至于我很难相信有任何人可以想到比 GC 和 RC 更好的方法。&lt;/p&gt;

&lt;p&gt;Rust 那些炫酷的 move semantics, borrowing, lifetime 之类的概念加在一起，不但让语言变得复杂不堪，我感觉并不能从根本上解决内存管理问题。很多人在 blog 里面为这些概念热情洋溢地做宣传，显得自己很懂一样，拿一些玩具代码来演示，可是从没看到任何人说清楚这些东西为什么可以从根本上解决问题，能用到复杂一点的代码里面去。所以我觉得这些东西有“皇帝的新装”之嫌。&lt;/p&gt;

&lt;p&gt;连 Rust 自己的&lt;a href=&quot;https://doc.rust-lang.org/book/ownership.html#meta&quot;&gt;文档&lt;/a&gt;都说，你可能需要“fight with the borrow checker”。为了通过这些检查，你必须用很怪异的方式来写程序，随着问题复杂度的增加，就要求有更怪异的写法。如果用了 lifetime，很简单一个代码看起来就会是这种样子。真够烦的，我感觉我的眼睛都没法 parse 这段代码了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn foo&amp;lt;&#39;a, &#39;b&amp;gt;(x: &amp;amp;&#39;a str, y: &amp;amp;&#39;b str) -&amp;gt; &amp;amp;&#39;a str {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上一次我看 Rust 文档的时候，没发现有 lifetime 这概念。文档对此的介绍非常粗略，仔细看了也不知道他们在说些什么，更不要说相信这办法真的管用了。对不起，我根本不想去理解这些尖括号里的 &lt;code&gt;&#39;a&lt;/code&gt; 和 &lt;code&gt;&#39;b&lt;/code&gt; 是什么，除非你先向我证明这些东西真的能解决内存管理的问题。实际上这个 lifetime 我感觉像是跨过程静态分析时产生的一些标记，要知道静态分析是无法解决内存管理的问题的，我猜想这种 lifetime 在有递归函数的情况下就会遇到麻烦。&lt;/p&gt;

&lt;p&gt;实际上我最开头看 Rust 的时候，它号称只用 move semantics 和好几种不同的指针，就可以解决内存管理的问题。可是一旦有了那几种不同的指针，就已经复杂不堪了，比 C 语言还要麻烦，而且显然不能解决问题。Lifetime 恐怕是后来发现有新的问题解决不了才加进去的，可是我不知道他们这次是不是又少考虑了某些情况。&lt;/p&gt;

&lt;p&gt;Rust 的设计者显然受了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_logic&quot;&gt;Linear Logic&lt;/a&gt; 一类看似很酷的逻辑的启发和熏陶，想用类似的方式奇迹般的解决内存和资源的回收问题。然而研究过一阵子 Linear Logic 之后我发现，这个逻辑自己都没有解决任何问题，只不过给对象的引用方式施加了一些无端的限制，这样使得对象的引用计数是一个固定的值（1）。内存管理当然容易了，可是这样导致有很多程序你没法表达。&lt;/p&gt;

&lt;p&gt;开头让你感觉很有意思，似乎能解决一些小问题。到后来遇到大一点的实际问题的时候，你就发现需要引入越来越复杂的概念，使用越来越奇葩的写法，才能达到目的，而且你总是会在将来某个时候发现它没法解决的问题。因为这个问题很可能从根本上是无法解决的，所以每当遇到有超越现有能力的事情，你就得增加新的“绕过方法”（workaround）。缝缝补补，破败不堪。最后你发现，除了垃圾回收（GC）和引用计数（RC），内存管理还是没有其它更好更简单的办法。&lt;/p&gt;

&lt;p&gt;当然我的意见也许不是完全准确，可我真是没有时间去琢磨这么多乱七八糟，不知道管不管用的概念（特别是 lifetime），更不要说真的用它来构建大型的系统程序了。有用来理解这些概念，把程序改成奇葩样子的时间，我可能已经用 C 语言写出很好的手动内存管理代码了。如果你真的看进去理解了，发现这些东西可以用的话，告诉我一声！不过你必须说明原因，不要只告诉我“皇帝是穿了衣服的” :P&lt;/p&gt;

&lt;h3&gt;完&lt;/h3&gt;

&lt;p&gt;本来想写一个更详细的评价的，可是到了这个地方，我感觉已经失去兴趣了，困就一个字啊…… Rust 比 C 语言复杂太多，我很难想象用这样的语言来构造大型的操作系统。而构造系统程序，是 Rust 设计的初衷。说真的，写操作系统那样的程序，C 语言真的不算讨厌。用户空间的程序，Java，C# 和 Swift 完全可以胜任。所以我觉得 Rust 的市场空间恐怕非常狭小……&lt;/p&gt;

&lt;p&gt;（如果你喜欢这些内容，请付费5美元或者30人民币，谢谢！）&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/09/18/rust</guid>
<pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>支付宝的身份验证问题</title>
<link>http://yinwang.org/blog-cn/2016/09/16/alipay</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;支付宝的身份验证问题&lt;/h2&gt;
                            &lt;p&gt;我看到有人继续在向我之前的支付宝账号付费。其实现在的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费二维码&lt;/a&gt;已经改成了我父亲的账号，原因是因为支付宝的身份验证问题。&lt;/p&gt;

&lt;p&gt;我的支付宝账号是在国内的时候开通的，支付宝收到的博文付费，都是准备转给家人的。开始收费之后，向家人的账号转了一些钱。支付宝似乎有很严格的防盗验证，我开头不熟悉怕出问题，所以做了几个试验，把钱分成好几次转。最后一次的时候，发现支付宝说需要验证我的身份，还打开手机的相机，要做“人脸验证”。让我左边转一点，右边转一点…… 我的身份证是15年前办的了，当然现在不像了！最后验证没有通过，于是支付功能就被锁定了，再也无法向家人转账。解锁的方法只有联系客服，可是客服电话打了老半天，根本没人接……&lt;/p&gt;

&lt;p&gt;由于这个原因，我不能再用我自己的支付宝账号收费。开通新的账号又需要银行卡验证，而我的国内手机和U盾都丢了…… 国内的银行系统就是这么麻烦。&lt;/p&gt;

&lt;p&gt;所以没办法，只好把我父亲的支付宝二维码放了上去。请大家以后不要再向我的账号付费，直接转账给我父亲就可以了。谢谢！&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/09/16/alipay</guid>
<pubDate>Fri, 16 Sep 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>测试的道理</title>
<link>http://yinwang.org/blog-cn/2016/09/14/tests</link>
<description>&lt;div style=&quot;margin: 2% 5% 2% 5%&quot;&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;td width=&quot;60%&quot;&gt;
                        &lt;div style=&quot;padding: 2% 8% 5% 8%; border: 1px solid LightGrey;&quot;&gt;
                            &lt;h2&gt;测试的道理&lt;/h2&gt;
                            &lt;p&gt;在长期的程序语言研究和实际工作中，我摸索出了一些关于测试的道理。然而在我工作过的每一个公司，我发现绝大多数人都不明白这些道理，很多团队集体性的采用错误的做法而不自知。很多人把测试当成一种主义和教条，进行过度的测试，不必要的测试，不可靠的测试，并且把这些错误的做法传授给新手，造成恶性循环。本来目的是提高代码质量，结果不但没能达到目的，反而降低了代码质量，增大了工作量，大幅度延缓工程进度。&lt;/p&gt;

&lt;p&gt;我也写测试，但我的测试方式比“测试教条主义者”们的方式聪明很多。在我心目中，代码本身的地位大大的高于测试。我不忽视测试，但我不会本末倒置，过分强调测试，我并不推崇测试驱动开发（TDD）。我知道该测试什么，不该测试什么，什么时候该写测试，什么时候不该写，什么时候应该推迟测试，什么时候完全不需要测试。因为这个原因，再加上高强的编程能力，我多次完成别人认为在短时间不可能完成的任务，并且制造出质量非常高的代码。&lt;/p&gt;

&lt;h3&gt;测试的道理&lt;/h3&gt;

&lt;p&gt;现在我就把这些自己领悟到的关于测试的道理总结一下，其中有一些是鲜为人知或者被误解的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要以为你处处显示出“重视代码质量”的态度，就能提高代码质量。总有些人，以为自己知道“单元测试”（unit test），“集成测试”（integration test）这样的名词，就很懂编程，就可以教育其他人。可惜，光有态度和口号是不解决问题的，你还必须有实战的技巧，深入的见解和智慧，必须切实地知道应该怎么做。代码的质量不会因为你重视它就得到提升，也不会因为你采取了措施（比如测试，静态分析）就一定会得到改善。你必须知道什么时候该写测试，什么时候不该写测试，需要写测试的时候，要写什么样的测试。其实，提高代码质量唯一可行的手段不是写测试，而是反复的提炼自己的思维，写简单清晰的代码。如果你想真的提高代码质量，我的文章『&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy&quot;&gt;编程的智慧&lt;/a&gt;』是一个不错的出发点。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;真正的编程高手不会被测试捆住手脚。是的，你身边那个你认为“不很在乎测试”的家伙，也许是个比你更好的程序员。我喜欢把编程比喻成开赛车，而测试就是放在路边用来防撞的轮胎护栏……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-a66eb34628e32634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;护栏有时候是很有用，可以救命的，然而一个合格的车手，绝对不会一心想着有护栏保护，测试在编程活动中的地位也应该就是这样。优秀的车手会很快看见优雅而简单的路径，恰到好处地掌握速度和时机，直奔终点而去。护栏只是放在最危险的地段，让你出了意外不要死得太惨。护栏并不能让你成为好的车手，不能让你取得冠军。绝大多数时候，你的安全只有靠自己的技术，而不是护栏，你永远有办法可以撞死自己。测试的作用也是一样，即使有了很多的测试，代码的安全仍然只掌握在你的手里。你永远可以制造出新的 bug，而没有测试可以检测到它……&lt;/p&gt;

&lt;p&gt;通常情况下，一个合格的车手是根本碰不到这些护栏的，他们心里想的是更高的目标：快点到达终点。相比之下，一个不合格的车手，他经常撞到赛道外面去，所以在他的心里，护栏有着至高无上的地位，所以他总是跟别人宣扬护栏的重要性。他开车的时候为了防止犯错，要在他经过的路径两边密密麻麻摆上护栏，甚至把护栏摆到赛道中间，以确保自己的转弯幅度正确。他在护栏之间跌跌撞撞，最后只能算是勉强到达终点。鼓吹测试驱动开发的人，就是这种三流车手，这种人写再多的测试也不可能倒腾出可靠的代码来。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在程序和算法定型之前，不要写测试。TDD 的教条者喜欢跟你说，在写程序之前就应该先写测试。为什么写代码之前要写测试呢？这只是一种教条。这些人其实没有用自己的脑子思考过这个问题，而只是人云亦云，觉得这样“很酷”，符合潮流，或者以为这样做了别人就会认为自己是高手。实际上在程序框架完成，算法定型之前，你都不需要写测试。如果你想知道代码是否正确，用人工方式运行代码，看看结果足以。&lt;/p&gt;

&lt;p&gt;如果你发现编程初期需要保证的性质纷繁复杂，如此之多，不写测试你就没信心的话，那你还是想办法先提高下基本的编程技术吧：多做练习，简化代码，让代码更加模块化，看看我的『编程的智慧』或者『SICP』一类的东西。写测试并不能提高你的水平，正好相反，过早的写测试会捆住你的手脚，让你无法自由的修改代码和算法。如果你不能很快的修改代码，不能用直觉感觉到它的变化和结构，而是因为测试而处处卡顿，你的头脑里就不能产生所谓“&lt;a href=&quot;https://en.wikipedia.org/wiki/Flow_(psychology&quot;&gt;flow&lt;/a&gt;)”，就不能写出优雅的代码来，结果到最后你什么也没学会。只有在程序不再需要大幅度的改动之后，才是逐渐加入测试的时候。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要为了写测试而改变本来清晰的编程方式。很多人为了满足“覆盖”（coverage）的要求，为了可以测试到某些模块，或者为了使用 mock，而把本来简单清晰地代码改成更加复杂而混淆的形式，甚至采用大量 reflection。这样一来其实降低了代码的质量。本来很简单的代码，一眼看去就知道是否正确，可是现在你一眼看过去，到处都是为了方便测试而加进去的各种转接插头，再也无法感觉到代码。这些用来辅助测试的代码，阻碍了你对代码进行直觉思维，而如果你不能把代码的逻辑完全映射在头脑里（进而产生直觉），你是很难写出真正可靠的代码的。&lt;/p&gt;

&lt;p&gt;有些 C# 程序员，为了测试而加入大量的 interface 和 reflection，因为这样可以在测试的时候很方便的把一片代码替换成 mock。结果你就发现这程序里每个类都有一个配套的 interface，还需要写另外一个 mock 类，去实现这个 interface。这样一来，不但代码变得复杂难以理解，而且还损失了 Visual Studio 的协助功能：你不再能按一个键（F12）就直接跳转到方法的定义，而需要先跳到对应的 interface 方法，然后再找到正确的实现。所以你不再能够在代码里面快速的跳转浏览。这种方便性的损失，会大幅度降低头脑产生整体理解的机会。而且为了 mock，每一个构造函数调用都得换成一个含有 reflection 的构造，使得编译器的静态类型检查无法确保类型正确，增加运行时出错的可能性，出错信息还难以理解，得不偿失的后果。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要测试“实现细节”，因为那等同于把代码写两遍。测试应该只描述程序需要满足的“基本性质”（比如 sqrt(4) 应该等于 2），而不是去描述“实现细节”（比如具体的开平方算法的步骤）。有些人的测试过于详细，甚至把代码的每个实现步骤都兢兢业业的进行测试：第一步必须做A，第二步必须做B，第三步必须做C…… 还有些人喜欢给 UI 写测试，他们的测试里经常这样写：如果你浏览到这个页面，那么你应该在标题栏看见这行字……&lt;/p&gt;

&lt;p&gt;仔细想一下就会发现，这种作法本质上不过是把代码（或者UI）写了两遍而已。本来代码里面明白写着：先做A，再做B，再做C。UI 描述文件里面明白写着：标题栏里面是这些内容。你有什么必要在测试里把它们全都再检查一遍呢？这根本没有增加任何可靠性：你在代码里会犯错，你把同样的逻辑换种形式再写一遍，难道就不会错了吗？&lt;/p&gt;

&lt;p&gt;这就像某些脑子秀逗的人，他出门时总是担心门没锁好，关门之后要推推拉拉好几次，确认门是锁上了的。还没走几步，他仍然在怀疑门没锁好，又走回去推推拉拉好几次，却始终不能放心 :P 这种做法非但不能保证代码的正确，反而给修改代码制造了障碍。理所当然，你把同一段代码写了两遍，每当要修改代码，你就得修改两次！这样的测试就像紧箍咒一样，把代码压得密不透风。每一次修改代码，都会导致很多测试失败，以至于这些测试都不得不重写。本质上就是把代码修改了两遍，只不过更加痛苦一些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并不是每修复一个 bug 都需要写测试。很多公司都流传一个常见的教条，就是认为每修复一个 bug，都需要为它写测试，用于确保这个 bug 不再发生。甚至有人要求你这样修复一个 bug：先写一个测试，重现这个 bug，然后修复它，确保测试通过。这种思维其实是一种生搬硬套的教条主义，它会严重的减慢工程的进度，而代码的质量却不会得到提高。写测试之前，你应该仔细的思考一个问题：这个 bug 有多大可能会在同一个地方再次发生？很多低级错误一旦被看出来之后，它就不大可能在同一个地方再次出现。在这种情况下，你只需手工验证一下 bug 消失了就可以。&lt;/p&gt;

&lt;p&gt;为不可能再出现的 bug 大费周折，写 reproducer，构造各种数据结构去验证它，保证它下次不会再出现，其实是多此一举。同样的低级错误就算再出现，也很可能不在同一个地方。写测试不但不能保证它不再发生，而且浪费你很多时间。这测试在每次 build 的时候都会消耗时间，每次编译都因为这些测试多花几分钟，累积起来之后，你就发现工程进度明显减慢。只有当发现已有的测试没有抓住程序必须满足的重要性质时，你才应该写新的测试。你不应该是为这个 bug 而写测试，而是为代码的性质而写测试。这个测试的内容不应该只是防止这个 bug 再次发生，而是要确保 bug 所反映出来的，之前缺失的“性质”得到保证。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免使用 mock，特别是多层的 mock。很多人写测试都喜欢用很多 mock，堆积很多层，以为只有这样才能测试到路径比较深的模块。其实这样不但非常繁琐费事，而且多层的 mock 往往不能产生足够多样化的输入，不能覆盖各种边界情况。如果你发现测试需要进行多层的 mock，那你应该考虑一下，也许你需要的不是 mock，而是改写代码，让它更加模块化。如果你的代码足够模块化，你不应该需要多层的 mock 来测试它。你只需要为每一个模块准备一些输入（包括边界情况），确保它们的输出符合要求。然后你把这些模块像管道一样连接起来，形成一个更大的模块，测试它也符合输入输出要求，以此类推。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要过分重视“测试自动化”，人工测试也是测试。写测试，这个词往往隐含了“自动运行”的含义，也就是假设了要不经人工操作，完全自动的测试。打一个命令，它过一会就会告诉你哪些地方有问题。然而，人们往往忽略了“人工测试”。他们没有意识到，人工去试验，去观察，也是一种测试。所以你就发现这样的情况，由于自动测试在很多时候非常难以构造（比如，如果你要测试一段复杂的交互式GUI代码的响应），很多人花了很多时间，利用各种测试框架和工具，甚至遥控 WEB 浏览器去做一些自动操作，花太多时间却发现各种不可靠，没法测到很多东西。&lt;/p&gt;

&lt;p&gt;其实换一个思路，他们只需要花几分钟的时间，就可以用人工的方式观察到很多深入的问题。过分的重视测试自动化的原因，往往在于一个不切实际的假设，他们假设错误会频繁的再次发生，所以自动化了可以省下人的力气。但是其实，一旦一个 bug 被修好，它反复出现的机会不会很大的。过分的要求测试自动化，不但延缓了工程进度，让程序员恼火，效率低下，而且失去了人工测试的精确性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免写太长，太耗时的测试。很多人写测试，叽里呱啦很长一串，到后来再看的时候，他已经不记得自己当时想测什么了。有些人本来用很小的输入就可以测试到需要的性质，他却总喜欢给一个很大的输入，下意识的以为这样更加靠谱，结果这测试每次都会消耗大量的 build 时间，而其实达到的效果跟很小的输入没有任何区别。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个测试只测试一个方面，避免重复测试。有些人一个测试测很多内容，结果每次那个测试失败，都搞不清楚到底是哪个部件出了问题。有些人为了“放心”，喜欢在多个测试里面“附带”测某些他认为相关的部件，结果每次那个部件出问题，就发现好多个测试失败。如果一个测试只测一个方面，不重复测同一个部件，那么你就可以很快的根据失败的测试，发现出问题的部件和位置。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免通过比较字符串来进行测试。很多人写测试的时候，喜欢通过打印出一些东西，然后使用字符串比较的方式来决定输出是否符合要求。一个常见的做法是把输出打印成格式化的 JSON，然后对比两个文本。甚至有人 JSON 都不用，直接就比较 printf 输出的结果。这种测试是非常脆弱的。因为字符串输出的格式往往会发生微小的变化，比如有人在里面加了一个空格之类的。把这种字符串作为标准输出，进行字符串比较，很容易因为微小的改动而使大量测试失败，导致很多的测试需要做不必要的修改。正确的做法，应该是进行结构化的比较，如果你要把标准结果存成 JSON，那么你应该先 parse 出 JSON 所表示的对象，然后再进行结构化的对比。PySonar2 的测试就是这样的做法，所以相当的稳定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“测试能帮助后来人”的误区。每当指出测试教条主义的错误，就会有人出来说：“测试不是为了你自己，而是为了你走了以后，以后进来的人不犯错误。” 首先，这种人根本没有看清楚我在说什么，因为我从来没有反对过合理的测试。其次，这种“测试能帮助后来人”，其实是没有经过实践检验，站不住脚的说法。如果你的代码写得很乱，就算你测试再多，后来人也无法理解，反倒被莫名其妙的测试失败给弄得更糊涂，不知道是自己错了还是测试错了。我已经说过了，测试不能完全保证代码不被改错，实际上它们防止代码被改错的作用是非常弱的。无论如何，后来人都必须理解原来的代码的逻辑，知道它在做什么，否则他们不可能做出正确的修改，就算你有再严密的测试也一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   举一个亲身的例子。我在 Google 做出 PySonar 之后，最后一个测试都没写。第二次我回到 Google，我的上司 Steve Yegge 对我说：“你走了之后，我改了一些你的代码，真是太清晰，太好把握了，修改你的代码是一种快乐！” 这说明什么问题呢？我并不是说你可以不写测试，但这个例子说明，测试对于后来人的作用，并不是你有些人想象的那么大。创造清晰的代码才是解决这个问题的关键。&lt;/p&gt;

&lt;p&gt;   这种怕人突然走了，代码无法维护的想法，导致了一些人对测试过分的重视，但测试却不能解决这种问题。相反，如果测试太繁琐，做不必要的测试，反而容易让员工不满，容易走人，去加入在这方面更加有见地的公司。有些公司以为有了测试，就可以随便打发人走，这种想法是大错特错的。你需要明白的一个事情是，代码永远是属于写出它的那个人的，就算有测试也一样。如果核心人物真的走了，就算你有再多的测试也没用的，所以解决的方法就是把他们留住！一个有远见的公司总是通过其他的手段解决这个问题，比如优待和尊重员工，创造良好的氛围，使得他们没那么快想走。另外，公司必须注意知识的传承，防止某些代码只有一个人理解。&lt;/p&gt;

&lt;h3&gt;案例分析&lt;/h3&gt;

&lt;p&gt;有人会疑问，我凭什么可以给别人讲这些经验，我自己为此有什么成功的案例呢？所以现在来讲讲我做过的几个东西，以及我亲眼目睹的测试教条主义者们的失败案例。&lt;/p&gt;

&lt;h4&gt;Google&lt;/h4&gt;

&lt;p&gt;很多人可能听说过我在 &lt;a href=&quot;http://www.yinwang.org/blog-%EF%BC%8Ccn/2014/12/31/google-story&quot;&gt;Google&lt;/a&gt; 做的 PySonar。当时 Google 的队友们战战兢兢，说这么高难复杂的东西要从头做起，几乎是不可能的。特别是某位队友，一开头就吵着要我写测试，一直吵到最后，烦死我了。他们为什么这么担心呢？因为对 Python 做类型推导是非常高难度的代码，需要相当复杂的数据结构和算法，需要精通 Python 的语义实现。&lt;/p&gt;

&lt;p&gt;作为一个训练有素的专家，我没有在乎他们的咋呼，没有信他们的教条。我按照自己的方式组织代码，进行精密的思考，设计和推理，最终在三个月之内做出了非常优雅，正确，高性能，而又容易维护的代码。PySonar 到现在仍然是世界上最先进的 Python 类型推导和索引系统，被多家公司采用，用于处理数以百万计的 Python 代码。，&lt;/p&gt;

&lt;p&gt;如果我当时按照 Google 队友的要求，采用已有的开源代码，或者过早的写了测试，别说无法在三个月的实习时间之内完成这个东西，就算折腾好几年也没有可能。&lt;/p&gt;

&lt;h4&gt;Shape Security&lt;/h4&gt;

&lt;p&gt;这种思维方式最近的成功实例，是给 Shape Security 做的一个先进的 JavaScript 混淆器（obfuscator）和对集群（cluster）管理系统的改进。不要小看了这个 JS 混淆器，它的混淆能力要比 uglify 之类的开源工具强很多，也快很多。它不但包含了 uglify 的变量换名等基本功能，而且含有专门针对人类和编译器的复杂化，使得没人能看出一点线索这个程序到底要干什么，让最先进的 JS 编译器也无法把它简化。&lt;/p&gt;

&lt;p&gt;其实这个混淆器也是一种编译器，只不过它把 JavaScript 翻译成不可读的形式。在这个项目中，由于失之毫厘就可以差之千里，我采用了从 Chez Scheme 编译器学过来的，非常严密的测试方法。对每一个编译器的步骤（pass），我都给它设计一些正好可以测到这个步骤的输入代码（比如，具有函数定义的，for循环，try-catch的，等等）。Pass 输出的代码，经过 JavaScript 解释器执行，把结果跟原来程序的执行结果对比。每一个测试程序，经过每一个 pass，输出的中间结果都跟标准结果进行对比，如果错了就表明那个 pass 有问题，出错的小程序会指出大概是哪一个部分出了问题。遵循小巧，不冗余，不重复的原则，我总共只写了40多个非常小的 JavaScript 程序。由于这些测试涵盖了 JavaScript 的所有构造而且几乎不重复，它们能够准确的定位到错误的改动。最后，这个 JS 混淆器能够正确的转换像 AngularJS 那么大的项目，确保语义的正确，让人完全无法读懂，而且能有效地防止被优化器（比如 Closure Compiler）简化掉。&lt;/p&gt;

&lt;p&gt;相比之下，过度鼓吹测试和可靠性的人，并没能制造出这么高质量的混淆器。其实在我进入团队之前，里面的两三位高手已经做了一个混淆器，项目延续了好多个月。这片代码一直没能发布给客户用，因为它的换名部件总是会在某些情况下输出错误的代码，修改了好多次仍然会出错。不是100%的正确，这对于程序语言的转换器来说，是不可接受的。换名只是我的混淆器里的一个步骤，它还包含大概十个类似的步骤，可以把代码进行各种转换。&lt;/p&gt;

&lt;p&gt;在实现换名器的时候，队友们让我直接拿他们以前写的换名代码过来，把 bug 修好就可以。然而看了代码之后，我发现这代码没法修，因为它采用了错误的思路，缝缝补补也不可能达到100%的正确，而且明显效率低下，所以我决定自己重写一个。由于轻车熟路，我只花了一下午的时间，就完成了一个正确的换名器，它完全符合 JavaScript 的语义，各种奇葩的作用域规则，而且结构非常简单。说白了，这个换名器也是一种&lt;a href=&quot;http://www.yinwang.org/blog-cn/2012/08/01/interpreter&quot;&gt;解释器&lt;/a&gt;。对解释器的深刻理解，让我可以很容易的写出任何语言的换名器。&lt;/p&gt;

&lt;p&gt;不幸的是，历史再次重演了 ;) 队友们听说我花一下午重写了一个换名器，非常紧张，咋呼地跟我说：“你知道我们的换名器是花了多少个月的时间做出来的吗？你知道我们写了多少测试来保证它的正确性吗？你现在一下午做出来一个新的，你如何能保证它的正确！” 我不知道他们怎么好意思说出这样的话来，因为事实是，他们花了这么多个月，耗费这么多人力，写了这么多的测试，做出来的换名器却仍然有 bug，没法用。当我把我写的测试和几个大点的 open source 项目（AngularJS, Backbone 等）放进他们的换名器之后，就发现有些地方出问题了，而所有的测试和 open source 项目通过我的换名器，却得到完全正确的代码。另外经过性能测试，我的换名器速度要快四倍的样子。所以就像 &lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/02/18/dijkstra-interview&quot;&gt;Dijkstra&lt;/a&gt; 所说：“最优雅的程序往往也是最高效的。”&lt;/p&gt;

&lt;p&gt;结束这个项目之后，我换了一个团队（cluster团队），这个团队的人要好很多，低调而且幽默。Shape Security 的产品（Shape Shifter）里面包含一个高可靠（HA）集群管理系统，它可以通过网络，选举 leader，构建一个高容错的并行处理集群。这个集群管理系统一直以来都是公司里很复杂，却是可靠性要求最高的一个部件，一旦出问题就可能有灾难性的后果。确实，它当时可靠性非常高，从来没出过问题。但由于历史原因，它的代码过度复杂而缺乏模块化，以至于很难扩展来应付新的客户需求。我进入这个新团队的任务，就是对它进行大规模的简化，模块化和扩展，让它满足新的需求。&lt;/p&gt;

&lt;p&gt;在这个项目中，由于代码的改动幅度很大，在同事和部门领导的理解，信任和支持下，我们决定直接抛弃已有的测试，完全靠严格而及时的 code review，逻辑推理，推敲讨论，手工试验来保证代码的正确。在我修改代码的同时，一位更熟悉已有代码的队友一直通过 git 默默监视着我的每一次改动，根据他自己的经验来判断我的改动是否偏离了原来的语义，及时与我交流和讨论。由于这种灵活而严格的方式，工程不到两个月就完成了。改进后的代码不但更加模块化，更可扩展，适应了新的需求，而且仍然非常可靠。假设部门领导是“测试教条主义者”，不允许抛弃已有的测试，这样的项目是绝对不可能如期完成的。然而在当今世界遇到这样领导的机会，恐怕十个人里面不到一个吧。&lt;/p&gt;

&lt;h4&gt;Coverity&lt;/h4&gt;

&lt;p&gt;最后，我举一个由于测试方式不当而非常失败的案例，那就是 Coverity 的 Java 静态分析产品。我承认 Coverity 的 C 和 C++ 分析器也许是非常好的，然而 Java 的分析器，很难说。当我进入 Coverity 的时候，同事们已经忍受了整整一年的管理层的威逼和高压，超时过劳工作，写出了基本的新产品和很多的测试。可是由于技术债太多，再多的测试也没能保证产品的可靠性。&lt;/p&gt;

&lt;p&gt;我的任务就是利用我深入的 PL 知识，不停的修补前人留下来的各种蹊跷 bug。有些 bug 需要运行20多分钟之后才出现，一次还看不出是怎么回事，所以修起来非常耗时。有时候我只好趴在电脑前面养神，时不时的睁眼看看结果。Coverity 是如此的在乎测试，他们要求每修复一个 bug 你就必须写出新的测试。测试必须能够如实的重现 bug 的现象，修复之后测试必须能够通过。这看似一个很在乎代码质量的做法，然而它不但没能保证产品的稳定可靠，而且大幅度的减慢了工程进度，并且造成员工的疲惫和不满。&lt;/p&gt;

&lt;p&gt;有一次他们分配给我一个 bug：在分析一个中型项目的时候，分析器似乎进入了死循环，好几个小时都不能完成。因为 Coverity 的全局静态分析，其实就是某种图遍历算法。当这个图里面有回路的时候，你就必须小心，如果不问青红皂白就递归进去，就可能进入死循环。避免死循环的办法很简单，你构造一个图节点的集合（Set），然后把它传递到函数里面作为参数。 每当访问一个节点，你先检查这个节点是否已经在这个集合里，如果在你就直接返回，否则你就把这个节点加入到集合里，然后递归处理这个节点的子节点。它的 C++ 代码大概就像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void traverse(Node node, Set&amp;lt;Node&amp;gt; &amp;amp;visited)
{
  if (visited.contains(node)) {
    return;
  } else {
    visited.add(node);
    process_node(node, visited);   // 里面会递归调用 traverse
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看代码之后我发现，代码其实没有进入“死循环”，而是进入了指数复杂度的计算，所以很久都不能完成。这是因为写这函数的人不小心，或者没有理解 C++ 的函数参数缺省是传值（做拷贝）而不是传引用，所以他忘了打那个“&amp;amp;”，所以函数被递归调用的时候不是传递原来的集合，而是做了一个拷贝。每一次递归调用&lt;code&gt;traverse&lt;/code&gt;，visited 都得到一个新的拷贝，所以返回之后，visited 的值就恢复到之前的状态，就像 node 被自动 remove 了一样。所以这个函数仍然会在某种情况下再次访问这个节点。这样的代码不会进入死循环，然而在某种特殊的图结构下，这会造成指数级的时间复杂度（请想一下这是什么样的一种图）。&lt;/p&gt;

&lt;p&gt;本来很明显的一个图论算法问题，加一个“&amp;amp;”就修好了，手工试验也发现问题消失了。然而 Coverity 的测试教条主义者们（包括写出这 bug 的那人自己），吵着闹着，严肃命令我必须写出测试，构造出可以造成这种后果的数据结构，确保这个 bug 不会再重新出现。&lt;/p&gt;

&lt;p&gt;为一个我根本不会犯的错误写测试，而且它不可能再次发生，这不是很搞笑吗？就算你写了测试，也不能保证同样的事情不再发生。如果你不小心漏掉“&amp;amp;”，下次同样的问题还会发生，并且发生在另外的地方，而你却没有给那块代码写测试，所以给这个 bug 写测试，并不能防止同样的问题再次发生。这就像一个技术不过关的赛车手，他在别人不大可能撞车的地方撞了车，然后就要求赛场在那个地方装上轮胎护栏。可是下一次，这个车手又会在另一个其他人都不会撞车地方撞车……&lt;/p&gt;

&lt;p&gt;稍微有点图论常识，熟悉 C++ 基本概念的人，都不会犯这种错误。防止这种问题，只有靠个人的技术和经验，而不能靠测试。防止它再次发生的最好办法，恐怕是开个会把这个问题讲清楚，让大家理解，下次不要再犯。所以给这个 bug 写测试，完全是多此一举。跟队友们讲解了这个原理，他们听了之后，仿佛什么都没有听到一样，仍然强硬的要求：“可是你还是得写这个测试，因为这是我们的规定！你知道要是出了 bug，送一个销售工程师去客户那里，要花多少钱吗……” 无语了。&lt;/p&gt;

&lt;p&gt;Coverity 的 Java 分析，就是经常因为这种测试教条主义，使得项目进展及其痛苦和缓慢，却仍然 bug 百出。Coverity 的其他的问题，还包括我上面指出的，写重复的测试，一个测试测太多东西，使用字符串比较来做测试，等等。你恐怕很难想象，一个制造旨在提高代码质量的产品的公司，自己代码的质量是这样维护的 :P&lt;/p&gt;

&lt;h3&gt;完&lt;/h3&gt;

&lt;p&gt;由于绝大多数人对测试的误解如此之深，测试教条主义的流毒如此之广，导致许许多多优秀的程序员沉沦在繁琐的测试驱动开发中，无法舒展自己的长处。为了大家有一个轻松，顺利又可靠的工作环境，我希望大家多多转发这篇文章，改变这个行业的陋习。我希望大家在工程中理性的对待测试，而不是盲目的写测试，只有这样才能更好更快的完成项目。&lt;/p&gt;

&lt;p&gt;（由于这篇文章包含了我很多年的经验和深入的见解，希望你觉得有收获的话为此付费。建议价格是5美元，或者30人民币。【&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费方式&lt;/a&gt;】）&lt;/p&gt;

                        &lt;/div&gt;

                        &lt;div style=&quot;margin-top: 5px&quot;&gt;
                            &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                            &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;6657867155&quot;&gt;&lt;/ins&gt;
                            &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;

                    &lt;td width=&quot;16%&quot; valign=&quot;top&quot;&gt;
                        &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
                        &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-1331524016319584&quot; data-ad-slot=&quot;2703393155&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                        &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2016/09/14/tests</guid>
<pubDate>Wed, 14 Sep 2016 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
