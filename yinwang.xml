<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>当然我在扯淡</title>
<link>http://www.yinwang.org/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Fri, 08 Apr 2016 12:39:01 +0800</lastBuildDate>
<item>
<title>回应CFA传人对我的攻击</title>
<link>http://yinwang.org/blog-cn/2016/04/07/cfa</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;回应CFA传人对我的攻击&lt;/h2&gt;&lt;p&gt;发表了之前的文章《&lt;a href=&quot;http://www.jianshu.com/p/b94a2b19ebcc&quot;&gt;我为什么不再做PL人&lt;/a&gt;》之后，我发现有人（其实是一位CFA技术的传人）在知乎上发表文章黑我。现在我把这篇文章的&lt;a href=&quot;http://zhuanlan.zhihu.com/p/20699215&quot;&gt;链接&lt;/a&gt;放在这里。评论的最后是我的回复，技术性比较强，不过有兴趣的人可以看看。&lt;/p&gt;&lt;p&gt;文章作者彭飞的导师是Jens Palsberg，其实就是曾在CFA领域做过研究的一位学者。我本来对Palsberg没有意见，因为他的研究不只限于CFA。Palsberg还跟我很尊敬的Neil Jones教授做过很多其它方面的研究，所以我无意与他为敌，也从来没有在批评CFA的时候点过Palsberg的名。但由于我指出了CFA领域的弊病，彭飞恐怕就是一心一意研究这个的，所以觉得“祖业”受到了攻击，想要反驳我，支持CFA的“先进性”，这样以后才可能在学术界混下去。这可以理解，然而彭飞的文章，其实破绽百出，这些都从我的评论里可以看得出来。&lt;/p&gt;&lt;p&gt;CFA领域的理论从来没有成功实现，展示过它的功效。CFA最强大的版本，CFA2和P4F的作者Dimitris Vardoulakis，当年在Mozilla实习的时候试图在JavaScript上实现CFA2算法。最后的产物叫做“DrJS”，还做了一个网站让人试用。可是在不久之后DrJS不了了之，消失了。后来跟Mozilla的research director聊天时，他告诉我DrJS其实根本不好用，理论过度复杂，实现起来非常困难，而且达不到号称可以达到的效果，Mozilla以后不想再赞助类似的项目。&lt;/p&gt;&lt;p&gt;PySonar2比CFA2，P4F都要强大的原因很简单，因为它根本没有CFA所用的continuation passing style（CPS变换）所带来的所谓“call/return”匹配的问题。所有的call和它们的return，被abstract interpreter自然而然的匹配好了，根本不可能错位。我很惊讶的是CFA领域研究了20年，就在解决这种根本不存在的问题。彭飞抓住PySonar2表面上的一些小问题指指点点，貌似好大个事情，而其实很多都是由于他自己理解不够深入。详情请见我的评论。&lt;/p&gt;&lt;p&gt;另外，我真的对Python，Ruby，JavaScript这些动态语言做type inference不感兴趣了。PySonar2虽然比CFA先进很多年，但是我从来没想维护PySonar2的“先进性”，我从来没想推广PySonar2，因为我根本不在乎Python，也没把PySonar2当回事。给Python这样的语言做一个很先进的工具，有什么意义吗？未来的方向是直接写上type annotation，就像Java和C#那样。所以我们做的都是无用功，只不过我没花20年时间研究CFA，只用了加起来几个月时间，而且还比他们做得更好。&lt;/p&gt;&lt;p&gt;彭飞错误地认为我很把PySonar2当回事，然而它只是我曾经做过的一个小玩具。我一直在探索和展望更加实在，对人可以产生真正效益的领域。只是随便提了一下CFA就得到如此强烈而具体的攻击，我对学术界人士的自我保护意识真的很惊讶。如果你观察到彭飞在知乎上发表挺多PL的入门级文章，也许会意识到，他其实是想在知乎上建立自己的“权威地位”。由于最近研究的CFA受到了攻击，发表文章想要重新树立起小白们对于CFA的崇敬之情，倒也可以理解。知乎，真不愧是民科的天堂 :)&lt;/p&gt;&lt;p&gt;以下是我评论的内容，可能会略有改动：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;不要以为我不上知乎你就可以随便胡扯。你的导师Jens Palsberg就是那帮CFA扯淡的人之一，你当然那么说了。CFA2的发明人在Mozilla做的那个东西（DrJS)，后来发现根本不能用（Mozilla research director亲自跟我说的），所以现在网站都消失了。&lt;/p&gt;

&lt;p&gt;Pushdown Control Flow Analysis完全干的就是PySonar2很简单就能完成的事情，而PySonar2根本不需要什么pushdown automaton，完全依靠自然的abstract interpreter call/return。你们2016年才发那样的paper，PySonar2早在2010年就解决了这个问题。&lt;/p&gt;

&lt;p&gt;另外那几个链接没有指向，是因为当时在Sourcegraph，他们需要一个fully qualified name，所以没法再同时指向两个地方。然而实际上reference其实都是有的。至于Hindley-Milner那种generic type的抽象，对于Python这种非常polymorphic的语言是不可行的。简单的a-&amp;gt;a可以，但是控制流复杂一点就不能再有效。&lt;/p&gt;

&lt;p&gt;另外，我真的对这种动态语言inference不感兴趣了。PySonar2虽然还是比你们的CFA先进很多年，但是我从来没想维护PySonar2的“先进性”。给Python这样的语言做一个很先进的工具，有什么意义吗？未来的方向是直接写上type annotation，就像Java和C#那样。所以我们做的都是无用功，只不过我没花你们那20年，而且还做得更好 ;)&lt;/p&gt;

&lt;p&gt;另外我在2014年末的样子给CFA的“鼻祖”Olin Shivers写了封email，寻找合作机会。讲述了我的PySonar2的做法，而且问他为什么他的call/return match用那么复杂的方法来做。如果他们的2016论文加入了我的想法，也不足为怪。但是真的不care这些了。你们学术界随便胡搞好了，反正也不可能有什么用处。这些东西做static analysis的人早就明白，CFA远远落后，只能在自己的圈子里发表点paper。&lt;/p&gt;

&lt;p&gt;另外，推导出的 {int -&amp;gt; int} | {bool -&amp;gt;bool}表示的其实是一个intersection type，而不是union type。我不知道你到底明不明白什么是intersection type。这个type表示这个函数“同时”是int-&amp;gt;int和bool-&amp;gt;bool，而不是表示“有时”是int-&amp;gt;int而另外的时候是bool-&amp;gt;bool。这是对于Python最多能做到的事情。&lt;/p&gt;

&lt;p&gt;你说的forall a. a -&amp;gt; a对于复杂点的Python代码是不可行的。PySonar做过HM那样的系统，能推出forall a. a -&amp;gt; a那样的类型，但是后来发现遇到复杂点的代码根本不可能准确的generalize。有本事你用CFA给我们show一下推导出forall类型？我随便写段代码你的推导就完蛋了。&lt;/p&gt;

&lt;p&gt;我从来没说过PySonar2是sound的。其实你们的CFA2和P4F，对于Python也不可能是sound的，因为本来就是undecidable的问题。这些工具能做的，只是最大限度的发现类型错误而已。它们并不能完全排除类型错误。&lt;/p&gt;

&lt;p&gt;不得不引用一下Linus的话（虽然我鄙视这句话）：Talk is cheap. Show me some code。你把CFA实现出来，给我们show一下它能生成什么样的结果？哈哈。CFA2的发明人已经在Mozilla试过了不是吗？过度复杂的理论，根本不能实现和work。&lt;/p&gt;&lt;/blockquote&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">cfa</guid>
<pubDate>Thu, 07 Apr 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>我为什么不再做PL人</title>
<link>http://yinwang.org/blog-cn/2016/03/31/no-longer-pl</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;我为什么不再做PL人&lt;/h2&gt;&lt;p&gt;我不做程序语言（PL）的工作已经半年了。在这半年里，我变得快乐了很多，对世界也有了新的观点。现在我想来讲一讲，我为什么不想再做PL的工作和研究。我只希望这些观点可以给正在做PL，或者考虑进入这个领域的人们，作为一份参考。&lt;/p&gt;&lt;h3&gt;学校里的PL人&lt;/h3&gt;&lt;p&gt;PL看似计算机科学最精髓的部分，事实确实也是这样的。没有任何一个其它领域，可以让你对程序的本质形成如此深入的领悟，然而这并不等于你就应该进入PL的博士班。这是为什么呢？&lt;/p&gt;&lt;h4&gt;炒冷饭&lt;/h4&gt;&lt;p&gt;PL这个领域几十年来，已经发展到了非常成熟的阶段。这里面的问题，要么在20年前已经被人解决掉了，要么就是类似“&lt;a href=&quot;https://en.wikipedia.org/wiki/Halting_problem&quot;&gt;停机问题&lt;/a&gt;”一样，不可能解决的问题。然而，博士毕业却要求你发表“创新”的论文，那怎么办呢？于是你就只有扯淡，把别人已经解决的问题换个名字，或者制造一些看似新鲜却不管用的概念，在大会上煞有介事的宣讲。俗话说就是“炒冷饭”。&lt;/p&gt;&lt;p&gt;最开头进入这个领域的时候，你可能不觉得是这样，因为似乎有那么多的东西可以学习，那么多的大牛可以瞻仰，那么多的新鲜名词，什么“lambda calculus”啊，“语义”啊，各种各样的“类型系统”啊，这样那样的“逻辑”…… 可是时间久了，看透了，你就发现一些这个圈子里的规律。&lt;/p&gt;&lt;h4&gt;崇拜古人&lt;/h4&gt;&lt;p&gt;几乎每篇PL领域的论文，里面必有一页弯弯曲曲，让人看花眼的逻辑公式。程序语言的论文，不是用程序来描述，而是用一些老古董的逻辑符号，像这样：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-eae6c6cd2eecfb4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;图1：PL论文里的公式&quot;&gt;&lt;/p&gt;&lt;p&gt;绝大部分PL领域的专家们，似乎都酷爱逻辑符号，视逻辑学家高人一等。这种崇尚古人的倾向，使得PL专家们看不见这些符号背后，类似电路一样的直觉。他们看不见逻辑学的历史局限，所以他们也许能够发展和扩充一个理论，却无法创造一个新的。&lt;/p&gt;&lt;p&gt;说到古人，却并不是所有古人都这么晦涩。如果你考古一下就会发现，其实现代逻辑学的鼻祖&lt;a href=&quot;https://en.wikipedia.org/wiki/Gottlob_Frege&quot;&gt;Gottlob Frege&lt;/a&gt;最初的论文里，是没有这些稀奇古怪的符号的。他整篇论文都在画图，一些像电路一样的东西。比如下图，就是Frege的创始论文《&lt;a href=&quot;https://en.wikipedia.org/wiki/Begriffsschrift&quot;&gt;Begriffsschrift&lt;/a&gt;》里最复杂的“公式”之一：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-80571c70a82c1850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200&quot; alt=&quot;图2：Frege的“公式”&quot;&gt;&lt;/p&gt;&lt;p&gt;你可以把这里的每根线理解成一根电线。图1里那些诡异的逻辑符号，都是一些好事的后人（比如&lt;a href=&quot;https://en.wikipedia.org/wiki/Gerhard_Gentzen&quot;&gt;Gentzen&lt;/a&gt;）加进去的，最后搞得乌七八糟，失去了Frege理论的简单性。所以PL专家们虽然崇尚古人，却没有发现大部分古人，其实并没能获得鼻祖Frege的真传。&lt;/p&gt;&lt;p&gt;如果你看透了那些公式，自己动手实现过各种解释器，就会发现PL论文里的那些公式，其实相当于解释器的代码，只不过是用一种叫做“XX逻辑”的晦涩的语言写出来的。逻辑，其实本质上是一种相当落伍的程序语言。如果你精通解释器的代码，也许就会发现，这些公式其实用非常蹩脚的方式，实现了哈希表等数据结构。逻辑语言只运行于逻辑学家的脑子里面，用它写出的代码一样可能有bug，而且由于这语言如此障眼难读，而且没有debugger，所以bug非常难发现。逻辑学家们成天为自己的设计失误和bug伤透了脑筋，PL专家们却认为他们具有数学的美感，是比自己聪明的高人 :)&lt;/p&gt;&lt;p&gt;所以当你看透了所有这些，就会发现PL的学术界，其实反反复复在解决一些早已经解决了的问题，只不过给它们起了不同的名字，使用不同的方式来描述。有时候好几个子领域，其实解决的是同一个问题，然而每个子领域的人，却都说自己的问题在本质上是不一样的，号称自己是那个子领域的鼻祖。甚至有人在20多年的时间里，制造出一代又一代的PhD和教授职位。他们的理论一代代的更新，最后却无法解决实际的问题。所谓的“控制流分析”（control-flow analysis，CFA），就是这样的一个子领域。&lt;/p&gt;&lt;h4&gt;不知道谁是真的高人&lt;/h4&gt;&lt;p&gt;进入一个领域做研究，你总该知道那些人是真正厉害的。可惜的是，PL这个领域里，你往往不知道谁是真正掌握了精髓的学者，甚至好几年之后你仍然蒙在鼓里。我的历史教训是，写教科书的人，往往不是最聪明，最理解本质的。真正深刻的PL研究者，你可能根本没听说过他们的名字。&lt;/p&gt;&lt;p&gt;一般程序员提到PL，就会跟“编译器”这个领域混淆在一起，就会想起大学时候上编译器课，看《&lt;a href=&quot;http://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811&quot;&gt;龙书&lt;/a&gt;》时焦头烂额的情景。然后由于&lt;a href=&quot;https://en.wikipedia.org/wiki/Stockholm_syndrome&quot;&gt;斯德哥尔摩综合症&lt;/a&gt;，他们就会崇拜龙书的作者们。直到遇到了真正厉害的PL专家，你才发现编译器这个领域，跟PL根本是两回事，它其实比PL要低一个档次，里面充满了死记硬背的知识甚至误导。龙书的作者，其实也不是最厉害的编译器作者，他们更不是合格的PL专家。&lt;/p&gt;&lt;p&gt;上过“正统”的PL课程的学生，往往用一本经典大部头教材叫《&lt;a href=&quot;https://mitpress.mit.edu/index.php?q=books/types-and-programming-languages&quot;&gt;TAPL&lt;/a&gt;》，然后就会误认为此书的作者是最厉害的PL专家，然而他们再一次被名气给蒙蔽了。TAPL这书其实不但照本宣科，没有揭示实质，而且冗长没有选择，有用的没用的过时的理论，一股脑的灌输给你。等你研究到了所谓“交集类型”（intersection types），看到TAPL作者当年的博士论文才发现，其实他把简单的问题搞复杂了，而且那些理论几乎完全不能实用。真正厉害的intersection types专家，其实默默无闻的待在Boston University，而且研究到最后，intersection types这个领域其实被他们证明为完全不能实用。&lt;/p&gt;&lt;p&gt;由于TAPL这本书，以及&lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language&quot;&gt;ML&lt;/a&gt;)，Haskell等语言在PL界的“&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%99%BD%E8%B1%A1&quot;&gt;白象&lt;/a&gt;”地位，于是很多人又对&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley-Milner&lt;/a&gt;类型系统（HM）充满了崇敬之情，以为HM系统的发明者&lt;a href=&quot;https://en.wikipedia.org/wiki/Robin_Milner&quot;&gt;Robin Milner&lt;/a&gt;是最厉害的PL学者。他的确不错，然而等你随手就能实现出HM系统，看清了它的实质，就会发现所有这样能够“倒推”出类型的系统，其实都具有很大的局限性。&lt;/p&gt;&lt;p&gt;HM系统的“&lt;a href=&quot;https://en.wikipedia.org/wiki/Unification_(computer_science&quot;&gt;unification&lt;/a&gt;)”机制，依赖于数学上的“&lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;等价关系&lt;/a&gt;”，所以它不可能兼容子类型（subtyping）关系。原因很简单：因为子类型没有交换性，不是一个等价关系。而子类型关系却是对现实世界进行直观的建模所必不可少的，于是你就发现Haskell这类基于HM系统的语言，为了弥补这些缺陷而出现各种“扩展”，却永远无法达到简单和直观。一开头就错了，所以无论Haskell如何发展，这个缺陷也无法弥补。如果没有了HM系统，Haskell就不再是Haskell。&lt;/p&gt;&lt;p&gt;Robin Milner的另外一个贡献&lt;a href=&quot;https://en.wikipedia.org/wiki/%CE%A0-calculus&quot;&gt;π-calculus&lt;/a&gt;，虽然看起来吓人，其实看透了之后你发现它里面并没有很多东西。π-calculus对并发进行“建模”，却不能解决并发所带来的各种问题，比如竞争（race condition）。实际上普通的语言也能对并发进行简单的建模，所以π-calculus其实只停留于纸面上，不可能应用到现实中去。跟π-calculus类似的一个概念&lt;a href=&quot;https://en.wikipedia.org/wiki/Communicating_sequential_processes&quot;&gt;CSP&lt;/a&gt;也有类似的问题，属于“白象理论”。很多语言（比如Go）扯着CSP的旗号，引起很多人无厘头的膜拜，可见白象的威力有多大 :)&lt;/p&gt;&lt;p&gt;我在学校研究PL的时候就是这样，每天都发现天外有天，每天都发现曾经的偶像其实很多时候是错觉。最后我发现，PL领域其实最后就剩下那么一点点实质的内容，其它的都是人们造出来的浮云。所以每当有人问我推荐PL书籍，我都比较无语，因为我的PL知识只有非常少数是看书得来的。自己动手琢磨出来的知识，才是最管用的。&lt;/p&gt;&lt;h4&gt;没人知道你是谁&lt;/h4&gt;&lt;p&gt;PL的学生还有一个问题，那就是毕业后工作不好找。只有极少数公司（像微软，Intel，Oracle）里的少数团队，可以发挥PL专家的特殊才能。绝大部分其它公司根本不知道PL是什么，PL专家是干什么的。你跟他们说你的专业是“程序语言”，他们还以为你只是学会了“编程”而已，还问你想做“前端”还是“后端” :) 诚然，PL学生一般都有很好的编程能力，然而公司往往只关心自己的实际需求。PL学生毕业之后，很容易被普通公司作为没有任何专长的人对待。&lt;/p&gt;&lt;p&gt;另外，PL的圈子相当的小，而且门派宗教观念严重，所以就算你从名师手下毕业，想进入另一个老师的门徒掌权的公司，很可能因为两个门派的敌视而无法被接纳，就算进去了也经常会因为对于PL的理念不同而发生冲突。所以，学习PL最精髓的理论是有好处的，然而进入PhD投身PL的研究，我觉得应该三思。&lt;/p&gt;&lt;h3&gt;公司里的PL人：过度工程&lt;/h3&gt;&lt;p&gt;PL人在学校里跟着教授炒冷饭，毕业进入了公司之后，他们的行为方式还是非常类似。他们喜欢在公司里做的一件事情，叫做“过度工程”。本来很直接，很容易解决的一个问题，非要给你扯到各种炫酷的PL名词，然后用无比复杂的方案来解决。&lt;/p&gt;&lt;p&gt;有一些PL人喜欢推广他们认为高大上的语言，比如Haskell，OCaml，Scala等。这些语言在PL学术界很受尊重，所以他们以为这些语言能够奇迹般的解决实际的问题，然而事实却不是这样的。事实是，这些学术界出来的语言，其实缺乏处理现实问题的机制。为了能够在学术上证明程序的所谓“正确性”，而且由于类型系统本身的局限性，这些语言往往被设计得过于简单，具有过度的约束性，以至于表达能力欠缺。&lt;/p&gt;&lt;p&gt;最后，你发现用这些语言来写代码，总是这也不能做，那也不能做，因为你要是那么做了，编译器就无法发现“类型错误”。到最后你发现，这些语言的约束，其实是无需有的。如果放宽这些约束，其实可以更优雅，更简单的对问题进行建模。对正确性的过分关注，其实导致了PL人选择蹩脚的语言，写出绕着弯子，难以理解的代码。&lt;/p&gt;&lt;p&gt;还有一类PL人，喜欢设计不必要存在的语言。因为他们认为设计语言是PL人的特异功能，所以随时随地都想把问题往“语言设计”的方向上靠。这样的趋势是非常危险的，因为有原则的PL人，其实都明白一条重要的道理：不到万不得已的时候，千万不要制造语言。&lt;/p&gt;&lt;p&gt;很多PL人在公司里盲目的制造新的语言，导致的问题是，到最后谁也无法理解这种新语言写出来的代码。这一方面是新语言必然导致的结果，另一方面是由于，并不是每一个PL人都有全面的知识和很好的“品味”。每个PL学生毕业，往往只深入研究了PL的某个子领域，而对其它方面只是浮光掠影，所以他们有可能在那上面犯错。有些PL人喜欢照猫画虎，所以可能盲目的模仿Go语言，Haskell或者Python的特性，设计出非常蹊跷难用的语法。这些新的语言，其实让其他人苦不堪言。最后你发现，他们声称新语言能解决的问题，其实用像Java一样的老语言，照样可以很容易的解决。&lt;/p&gt;&lt;p&gt;喜欢钻牛角尖，把问题搞复杂，就是很多公司里的PL人的共同点。制造语言是PL人应该尽量避免的事情，这恰恰跟PL人的专长是矛盾的。所以有原则的PL人，生活怎么可能不苦 :)&lt;/p&gt;&lt;h3&gt;PL人的天才病&lt;/h3&gt;&lt;p&gt;很多研究PL的人喜欢看低其它程序员，认为自己能设计实现程序语言，就是天之骄子。我之所以从Dan Friedman那里学到了好东西，却没有成为他的PhD学生，一方面就是因为看不惯围绕在他身边那些自认为是“天才”的人。&lt;/p&gt;&lt;p&gt;总是有那么一群本科生，自认为掌握了Friedman所讲授的精髓，所以高人一等。其实呢，他们的水平比起我这样的，其实差的天远。于是我就经常无奈的看着他们，吵吵闹闹的宣讲他们解决的“新问题”，貌似什么了不起的发明一样，受到Friedman的肯定就受宠若惊的样子。而其实呢，那些都是我几年前就已经试过并且抛弃的方案……&lt;/p&gt;&lt;p&gt;其它的PL人，包括PhD学生，也有一样的毛病。不管在三流大学，还是在Harvard，Princeton，MIT这样的“牛校”出来的，只要是PL人，几乎必然有这种天才作风。另外你可能不知道的是，牛校往往并不产出优秀的PL人才。像Stanford，Berkeley，MIT这样的传统CS牛校，其实在PL方面是相当差的。&lt;/p&gt;&lt;p&gt;这种天才病的危害在于，它蒙蔽了这些人的眼睛。他们不再能设计出让“普通人”可以容易使用的产品。如果你不会用，他们就会嘲笑你笨，而其实呢，是因为他们的设计不好。他们喜欢用含混晦涩的方式（所谓“函数式”）的写法来构造代码，让其它人阅读和修改都极其困难，……&lt;/p&gt;&lt;p&gt;这些所谓天才，看不到简单直观的解决方案，为了显示自己的聪明而采用繁复的抽象，其实是一种愚蠢。真正的天才，必须能够让事情变得简单。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">no-longer-pl</guid>
<pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Go语言，Docker和Kubernetes</title>
<link>http://yinwang.org/blog-cn/2016/03/27/docker</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;Go语言，Docker和Kubernetes&lt;/h2&gt;&lt;p&gt;当我嘲笑Go语言的时候，有些人跟我说，你说Go语言是垃圾，可是你看像Docker和Kubernetes之类的云计算项目，为什么是Go语言写的呢？&lt;/p&gt;&lt;p&gt;其实答案很简单：这些东西并不是非得用Go语言写才可以，用其他语言实现它们其实并没有什么问题，只不过它们碰巧是用Go语言写的而已。Docker和Kubernetes之类的项目，其实只依赖于操作系统的构架细节，对语言没有特别的要求，而且也没什么性能需求，所以它们其实可以用任何语言（包括Shell，Perl，Python，Ruby，C，Java……）来实现。只因为有人跟风，用Go语言写了这些东西，并不能说明Go语言是好东西。在当今混乱的IT业界，随便你做个东西都会有人拿来用，更不要说是挂着Go-ogle的羊头的语(go)言(rou) ;)&lt;/p&gt;&lt;p&gt;如果你不相信我，可以看看这个叫“&lt;a href=&quot;https://github.com/p8952/bocker/blob/master/bocker&quot;&gt;Bocker&lt;/a&gt;”的项目，它只用了100行shell script，就实现了Docker最重要的功能。 说白了，Docker的原理就是建立一些目录，把系统文件和相关库代码拷贝进去，然后&lt;a href=&quot;https://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;，这样你的代码在里面运行的时候，就以为自己独占一个Linux系统。Shell语言之恶劣，我已经有&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/03/29/scripting-language&quot;&gt;专文&lt;/a&gt;介绍，所以就不多说了。本来可以用shell脚本实现的项目，现在有人用Go来做，能说明Go是一个好的语言吗？&lt;/p&gt;&lt;p&gt;另外也许很多人不知道的是，Docker和Kubernetes，虽然很火，但其实并不是什么了不起的技术。Docker并不能解决Unix的根本问题。Unix从来就不是一个具有良好模块化设计的系统。各种稀奇古怪的配置文件，设计缺乏条理和章法。各种模块之间，版本逻辑依赖关系错综复杂，纠缠不清。所以不管你事后怎么补救，其实都难以变成结构清晰的设计。很多项目做成了container之后，它们之间用REST和HTTP进行通信，其实让系统模块之间的通信变得更加困难和复杂。&lt;/p&gt;&lt;p&gt;使用了Docker之后，你也许会发现，Unix的狂热分子们其实重新折腾出了Windows一开头就有的应用程序构架，然而这些应用程序之间的通信方式，却远远没有达到&lt;a href=&quot;https://en.wikipedia.org/wiki/Component_Object_Model&quot;&gt;COM&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/.NET_Framework&quot;&gt;.NET&lt;/a&gt;的成熟程度。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">docker</guid>
<pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>为什么自动车完全不可以犯错误</title>
<link>http://yinwang.org/blog-cn/2016/03/19/self-driving-car-liability</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;为什么自动车完全不可以犯错误&lt;/h2&gt;&lt;p&gt;有人跟我讲，我对Google的自动车要求太苛刻了。人无完人，所以Google的产品也不需要是完美的，只要“够好用”就有市场。世界上有那么多糟糕的司机，酒后驾车的，开车时发短信的，打瞌睡的，判断失误的…… 导致了那么多的车祸，可比Google的自动车差多了。所以自动车不需要完美，只要99.9%的情况下可以正确工作，能大幅度减少车祸率，就是人类的福气了。&lt;/p&gt;&lt;p&gt;首先，现在的情况是，Google自动车现在只能在非常局限的情况下出来：白天，天气好，交通简单，而且就算是这样理想的条件下，一年之中仍然会发生270多起需要“&lt;a href=&quot;http://www.forbes.com/sites/brookecrothers/2016/01/13/google-self-driving-car-failures-total-272-over-one-year-but-improvement-seen&quot;&gt;人工干预&lt;/a&gt;”的事件，所以自动车的“驾驶技术”最后能不能超过最低级别的人类驾驶员，其实还很值得怀疑。其次，就算我们抛开这个问题不谈，假设自动车能够超过绝大部分人类驾驶员，能在99.9%的情况下判断正确，那么它也是不可行的。其实自动车必须能在100%的情况下做出正确的判断，不能犯任何错误，才有可能被人接受。这是为什么呢？&lt;/p&gt;&lt;p&gt;这其实是因为伦理和法律的原则。法律上的责任，并不是从宏观角度出发的。也就是说，法律不会因为自动车在99.9%的情况下判断正确，就免除那0.1%的情况下，Google对车祸的责任。法律的原则很简单，谁犯错误导致了车祸，谁就得负责，不管它是人还是机器都一样。是的，自动车也许不需要完美就可以用，但如果它犯错误引起了事故，责任就必须完全由Google，而不是车主来承担。因为如果车主是驾驶员，他开车引起车祸，那么车主就得负责。现在车主不是驾驶员，Google的软件才是驾驶员，所以如果自动车引起车祸，Google就得负完全的责任。&lt;/p&gt;&lt;p&gt;如果你还没有明白，我们来设想一个实例好了。假设Google自动车在99.9%的情况下，判断都是正确的，可就那么0.1%的情况下，它会判断失误而导致车祸。现在你就是这些不幸的人其中之一，你乘坐的Google自动车由于软件判断失误，导致车祸，让你双腿截肢，终生残疾。你把Google告上法庭。Google对法官讲，因为我们的自动车在99.9%的情况下都是可靠的，大幅度降低了社会的总体车祸率，对人类做出了巨大贡献。这个人很不幸，遇上了这0.1%判断失误的情况，所以Google对此不负责任。你觉得这可以接受吗？ ;)&lt;/p&gt;&lt;p&gt;0.1%的出错概率，落到一个人的头上，就等于100%的不幸。如果你本来是一个安全的驾驶员，那就更加不幸，因为如果是你自己开车，其实完全不会犯那样的错误。在这种情况下，就算自动车使得社会的总体车祸率急剧降低，对你来说其实毫无意义，因为残废的人是你。这就是为什么从伦理上讲，对机器和人，我们必须有两种不同的标准。自动车的判断力，并不是超越了大部分的驾驶员就可以的，它必须超过所有人！有些人开车时会犯的那些错误，自动车却完全不可以犯。因为坐了这辆犯错的自动车，导致身体残疾的人，他可以说：“如果是我自己开车，根本就不可能犯这样的错误。诚然，其它人在这种情况下可能会犯错，但我不会！所以Google的自动车对此负有严重的责任。”&lt;/p&gt;&lt;p&gt;明白了吗？只是能从宏观上减少车祸是不够的。自动车的驾驶技术，必须超越世界上最安全的驾驶员，它完全不可以犯错误。现在世界上虽然有许多的车祸，可是因为人是驾驶员，所以责任分摊在很多当事人的头上，谁犯错误谁负责。可是如果Google的自动车进入市场，代替了大部分的驾驶员，以后自动车引起的车祸的责任，全都会落到Google的头上。所以这样的生意，是非常困难而不切实际的。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">self-driving-car-liability</guid>
<pubDate>Sat, 19 Mar 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Google的眼光</title>
<link>http://yinwang.org/blog-cn/2016/03/17/google-vision</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;Google的眼光&lt;/h2&gt;&lt;p&gt;你知道吗，Google（Alphabet）要卖掉&lt;a href=&quot;http://www.bloomberg.com/news/articles/2016-03-17/google-is-said-to-put-boston-dynamics-robotics-unit-up-for-sale&quot;&gt;Boston Dynamics&lt;/a&gt;，一个它收购才没多久的机器人公司。这也意味着，Google准备完全退出机器人的领域。新闻传言说，是因为Google觉得这些机器人太吓人了，把它踢倒在地，居然能像终结者一样爬起来！还有舆论说Google研究机器人，是想抢走人类的饭碗，所以现在Google为了人类的幸福，放弃了这个计划。呵呵，这借口多么美妙呀！你们真以为Google有这么好心，会为你们的生存着想吗？&lt;/p&gt;&lt;h3&gt;Boston Dynamics&lt;/h3&gt;&lt;p&gt;卖掉Boston Dynamics（以下简称BD）真正的原因，其实是因为BD的机器人，只是一些研究性质的原型。它们离能够投入实用，其实差的老远。研究经费的需求，却是一个无底洞。你们只要仔细看看这些BD机器人的视频（&lt;a href=&quot;https://www.youtube.com/watch?v=rVlhMGQgDkY&quot;&gt;视频1&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=M8YjvHYbZ9w&quot;&gt;视频2&lt;/a&gt;），就会发现虽然貌似很先进的样子，跟科幻片里的很像，然而由于人工智能和机器视觉的局限性，它们其实仍然处于玩具阶段。&lt;/p&gt;&lt;p&gt;特别是从第一个视频中你可以看到，这机器人头部旋转着一个很大的光学雷达（&lt;a href=&quot;https://en.wikipedia.org/wiki/Lidar&quot;&gt;Lidar&lt;/a&gt;），虽然能拿起箱子，然而它只能在很简单，理想化的环境下才能做到，而且动作相当的缓慢和笨拙。箱子必须是方形的，而且必须有特殊的记号或者二维码在上面，这样机器人才能知道从哪里下手。拿起箱子的时候，它并不像人那样，可以感受到箱子的重心在哪里，所以它只是随意的把“手”（其实是两个橡胶垫）夹上去。箱子重心不稳，所以摇摇晃晃的，很容易滑落下来。至于机器人推门出去雪地上走的镜头，其实是&lt;a href=&quot;http://www.bloomberg.com/news/articles/2016-03-18/why-google-wants-to-sell-its-robots-reality-is-hard&quot;&gt;有人遥控&lt;/a&gt;的，它并不能完全独立的探索外面的世界。被人踢倒在地，它真的是像“终结者”一样爬起来的吗？不是的。它爬起来的动作，很像一只蚂蚱，而且很慢。我很难想象，这样的机器人在战场上被人踹倒之后，能够及时爬起并且活下来。&lt;/p&gt;&lt;p&gt;所以BD的机器人，其实是拿来做搬运工都不合格的，更不要说做士兵了。它们的“智能”，其实跟家用的&lt;a href=&quot;https://www.neatorobotics.com/&quot;&gt;机器人吸尘器&lt;/a&gt;，没有很大的差别。在如此理想化的条件下，普通的工业机器人其实就能搬运箱子，而且效率高很多。看看这些&lt;a href=&quot;https://www.youtube.com/watch?v=UtBa9yVZBJM&quot;&gt;Amazon配送中心的机器人&lt;/a&gt;就知道，制造人形的机器人来做一些事情，完全是多此一举。只要你简化环境，就可以让普通没有智能的机器人，做很多有用的事情。&lt;/p&gt;&lt;p&gt;BD之前是由美国国防部和和海军陆战队投资，进行机器人的研究。我们都知道，军方的钱是非常容易骗，可以放心大胆的烧。到时候东西做出来能不能用，就是另外一回事。拿军方的钱多舒服，没压力，所以这样的公司不拿军方的钱，把自己卖给Google，说明军方已经不想资助这样的项目了。Google的眼光有问题，买下来才发现这些个玩具，离能够投入实际使用，恐怕还需要几十年上百年。于是暗自惊呼上当，赶快转手。&lt;/p&gt;&lt;p&gt;另外一种谣言是说，Google早就知道BD的机器人是不能用的。买下这公司，其实是拿来给Android的创始人Andy Rubin做玩具（圣诞礼物）的。因为Rubin很喜欢机器人，从小就梦想做自己的机器人，却壮志未酬。哪知道Rubin后来离开了Google，所以这玩具公司也就没必要留着了。Google创始人对高层领导的宠幸和溺爱，由此可见一斑。&lt;/p&gt;&lt;h3&gt;D-Wave量子计算机&lt;/h3&gt;&lt;p&gt;Google似乎总是喜欢做这种吸引眼球的项目，显得自己高大上，却不能真正的成功。Google投资的另外一个泡沫项目，叫做D-Wave量子计算机。D-Wave是一个加拿大公司，号称利用低温超导技术，制造出了具有上千个&lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot;&gt;qubit&lt;/a&gt;的量子计算机，能解决NP-Complete的问题。Google图着量子计算的虚名，花了很大的价钱买了一台D-Wave的机器，于是时不时的要冒出一些新闻。比如&lt;a href=&quot;http://www.techtimes.com/articles/114614/20151209/googles-d-wave-2x-quantum-computer-100-million-times-faster-than-regular-computer-chip.htm&quot;&gt;这个新闻&lt;/a&gt;说，Google声称经过自己测试，D-Wave的计算速度，是普通计算机的一亿倍！&lt;/p&gt;&lt;p&gt;然而，真正的量子计算专家，比如&lt;a href=&quot;http://scottaaronson.com/blog/?s=dwave&quot;&gt;Scott Aaronson&lt;/a&gt;，早就揭露过，由于环境对量子的干扰，要实现一千个qubit的量子计算机，难度是非常大，甚至是不可能的。D-Wave所谓的“量子计算机”，其实并不具有正确的“量子态”，不具有真正的量子计算能力，它其实最多算是一台“模拟计算机”。对于模拟计算机，其实研究已经很多了。模拟计算机确实可以在某些非常特殊的问题上，比数字计算机快几个数量级。然而，由于模拟计算机与生俱来的“误差问题”，它不能用于通用的计算，更不能用来解决NP-Complete的问题。实际上没有任何研究表明，量子计算机是可以解决NP-Complete问题的。&lt;/p&gt;&lt;p&gt;Google声称D-Wave的机器比普通计算机快一亿倍，用的是什么样的测试呢？他们的测试并不是一个全面的benchmark，它其实只包括一个问题：模拟退火。望文生义你就可以知道，退火这问题，本来就是非常适合用模拟计算机来解决的。D-Wave是个模拟计算机，它做退火的速度，当然比数字计算机快很多了。解决一个问题快了一亿倍，可是它却不能以同样的速度解决其它的问题，甚至无法解决普通计算机能解决的那些问题。一个机器要被叫做“计算机”，它应该具有比较全面的解题能力。如果只能解决一个问题，那它根本就不算是一个计算机，最多算是个物理实验 :P&lt;/p&gt;&lt;p&gt;再来看看，D-Wave解决了量子计算机本来应该可以解决的问题吗？没有。否则的话，一千个qubit的机器，应该能实现著名的“&lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot;&gt;Shor算法&lt;/a&gt;”，从而可以很快的分解很大的整数，从而就能破解相当长度的RSA秘钥！Google为何不用D-Wave来破解RSA，引起全球轰动和震惊呢？因为它做不到。D-Wave压根就不是量子计算机，所以不能实现快速的大数分解。&lt;/p&gt;&lt;p&gt;其实很多人早就知道，D-Wave不是真正的量子计算机，而Google却堂而皇之的以讹传讹，打着“量子计算”的招牌，发布自己的测试结果。我不知道他们是真的不知道，还是故弄玄虚，吸引外行的眼球，长自己的威风。&lt;/p&gt;&lt;h3&gt;Google Glass&lt;/h3&gt;&lt;p&gt;世界忘不了你，Google Glass。当它刚出现的时候，Google可秀了不少神奇的视频。要查地图导航，滴滴滴，Glass直接把导航路线投射到地面上，指引你前进！在书店里说想找的书名，刷刷，Glass在空气中划出一条明亮的路线，在书架之间蜿蜒穿行，指引你到摆放它的位置，…… 多么神奇，多么美好！&lt;/p&gt;&lt;p&gt;可是到最后，Google Glass做到了这些炫酷的功能吗？门都没有摸到！一开头Google就应该意识到，这样的视网膜光学投影，把虚拟的线条和人眼看到的实际物体合并在一起，是非常难办的问题。电影特效倒好做，实现起来就发现按照Google Glass的硬件能力，完全不可能。而且Google怎么可能有时间和精力，去输入书店里摆放书的位置。这年头还有多少人逛书店，这功能不是吃饱了撑着是什么 :P&lt;/p&gt;&lt;p&gt;这教训就是，一开头牛皮不要吹得太大，不然会摔得很惨。最后的Google Glass，感觉就是一个戴在头上的手机屏而已，并没有发挥头戴设备的任何特点。电池寿命不到半小时，而且它的镜腿还不能折叠，取下来就不知道该放哪里了。所以买了的人都发现没什么用处，可是价格不菲啊，只想把它转手倒卖出去。&lt;/p&gt;&lt;p&gt;Google Glass吹够了牛皮，忽然人间蒸发了。可惜的是，粉丝们仍然没有看透Google的一贯作风，他们仍然相信Google夸出的各种海口，盼望这位“巨人”制造出伟大的新产品。&lt;/p&gt;&lt;h3&gt;自动车&lt;/h3&gt;&lt;p&gt;关于Google的自动车，我已经有&lt;a href=&quot;http://www.jianshu.com/p/01d1b2542036&quot;&gt;专文&lt;/a&gt;介绍了。自动车是一个美好的幻想，可是物体识别等AI问题，却很难解决。&lt;/p&gt;&lt;p&gt;有人可能以为这种自动车“够好用”就可以，因为世界上有那么多糟糕的司机，酒后驾车的，意外情况判断失误的，…… 所以Google的自动车也不需要完美，能大幅度减少车祸概率，就是人类的福气了。然而从道德和法律意义上来讲，自动车却必须要接近完美才可以。可能有人会犯的错误，它却不可以犯。这是为什么呢？原因在于，坐这辆犯了错误的自动车，导致身体残疾的人，如果是他自己开车，他可能根本不会烦这样的错误。诚然，其它人可能在这种情况也会犯错误，但其他人会犯错误，跟这个受害的人毫无关系。他会告上法庭，说：“如果是我开车，肯定不会导致车祸，以至于我自己变成残疾。所以Google的自动车对此负有严重的责任。” 明白了吗？只是能从“宏观”意义上减少车祸是不够的。自动车的驾驶技术，必须超过世界上最安全的驾驶员，它完全不可以犯错误。&lt;/p&gt;&lt;p&gt;所以Google的自动车，离能够实用差的天远，却喜欢到处游说，甚至要求政府监管部门大开绿灯。Google为何如此执着？我的猜测是，Google并不是真的想让自动车能够投入实用。显然，研究这些东西，可以显得自己很高大上，技术实力强。这样一来，recruiter们就可以对刚毕业的学生们说：“看那，我们Google有各种刺激的，开创未来的项目。快加入我们吧！” 等你进去，才发现那些炫酷的项目，其实根本没机会进去。虽然拿着机器视觉的PhD，却无法进入自动车的项目。只有老老实实写些JavaScript，改进一下Adwords，给Gmail加个小不点的功能进去，…… 然后你走出Google的时候，就不小心变成了这个样子：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-70d90bceba863a4b.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;其实完全无人控制的自动车，且不说能不能实现，它真的有必要吗？现在很多汽车公司（&lt;a href=&quot;http://www.subaru.com/engineering/eyesight.html&quot;&gt;Subaru&lt;/a&gt;，&lt;a href=&quot;http://automobiles.honda.com/accord-sedan/features.aspx#sensing&quot;&gt;本田&lt;/a&gt;，&lt;a href=&quot;https://www.mbusa.com/mercedes/benz/safety#module-2&quot;&gt;奔驰&lt;/a&gt;，……）都可以实现自动防撞刹车功能，这才是人们最需要的，而且难度不是特别高。一旦人们发现满足了基本的安全需求，就不会想要完全自动的车了。所以我预测，Google自动车很可能再过一阵子就会跟Google Glass一样，人间蒸发掉。我们走着瞧吧 :)&lt;/p&gt;&lt;h3&gt;Chromecast&lt;/h3&gt;&lt;p&gt;再来看看Chromecast吧。Chromecast刚出现的时候，有些人也是热情高涨，甚至有国内朋友托我帮他买一个寄回国。我说这玩意比起Apple TV有什么特色吗？回答说：这是Google造的，肯定很牛，比Apple TV牛很多，一定要帮我买！于是等我要帮他买的时候，发现已经供不应求断货了。&lt;/p&gt;&lt;p&gt;直到我自己用过Chromecast，才发现这东西就像一个未完工的intern项目，根本不能用！我当然不会去买个Chromecast。我用它是因为有天买了个投影机，免费附送了一个Chromecast。心想免费送的就试试呗，结果用了几次之后，发现简直bug百出。虽然我的是免费附送，但是这东西单独卖也要$35。这样质量的东西，Google你也好意思拿出来卖钱吗？！&lt;/p&gt;&lt;p&gt;放YouTube视频的时候，它可以把视频加入播放队列，或者可以立即播放。可是队列播放和立即播放的逻辑，却是混乱的。有时候你本来想让它立即播放，它却把你之前放进去的视频给放了出来，仿佛你是在队列播放。所以我后来发现，这东西总是不放我现在想看的视屏，烦死人了。&lt;/p&gt;&lt;p&gt;更搞笑的是它的Chrome插件，有时候播放列表里面，忽然出现“[object Object]”这样的东西。显然是某些初级JavaScript码工，把某个对象给直接“+”到了一个字符串上面。试试吧，在浏览器里打开开发界面，输入&lt;code&gt;&quot;&quot;+{x:1}&lt;/code&gt;，你就得到&lt;code&gt;&quot;[object Object]&quot;&lt;/code&gt;。连这么低级的bug都放进去了，我就怀疑他们到底自己有没有用过自己的产品。&lt;/p&gt;&lt;p&gt;我永远无法理解人们对这类Google产品的热情。最后，由于我对那个投影机也不是很满意，所以把投影机和Chromecast一起退给了Amazon。后来买了Apple TV，发现跟Chromecast比起来，简直天壤之别，好用顺畅很多，一点问题没有。&lt;/p&gt;&lt;p&gt;可能因为退货比例太高，Chromecast现在已经从Amazon下架了。&lt;/p&gt;&lt;h3&gt;Go语言&lt;/h3&gt;&lt;p&gt;Go语言，也是Google最爱炫耀的技术之一。我之前的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/04/18/golang&quot;&gt;文章&lt;/a&gt;已经分析的很清楚了，Go语言就是一坨屎。每个研究过PL的人，都在嘲笑Go语言的设计，笑掉了大牙。&lt;/p&gt;&lt;p&gt;Google对于真正的计算机科学，程序语言的研究，远远不如微软，Intel，Oracle（Sun），IBM，Cisco。基本就是业余水平。很可惜的是，Google仍然可以靠着自己在网络界的影响力，面对专家们的嘲笑，明目张胆在业界推广Go这个大垃圾，祸害其他人。你说我们这些PL人士，怎么可能不鄙视Google？&lt;/p&gt;&lt;p&gt;对了，Google还有另外一个垃圾语言，叫做Dart。Google内部还有一个自用的垃圾语言，叫做Sawzall。Sawzall的&lt;a href=&quot;https://en.wikipedia.org/wiki/Rob_Pike&quot;&gt;创造者&lt;/a&gt;，后来创造了Go。此人之前设计了&lt;a href=&quot;https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs&quot;&gt;Plan 9&lt;/a&gt;操作系统，自以为超越了Unix，而其实呢继承了Unix的所有糟粕，只含有一些肤浅的界面改动，而且还不怎么好用，所以后来根本没人用。不是我有偏见哈，可我发现的规律就是，制造垃圾的自大狂，永远都只会制造垃圾。&lt;/p&gt;&lt;p&gt;因为内行人都知道Google对于语言的造诣和态度之肤浅，所以几乎没有科班出生的程序语言专家愿意去Google工作。大部分最好的PL人员进入了微软，少数去了其它地方。&lt;/p&gt;&lt;h3&gt;Google的水平&lt;/h3&gt;&lt;p&gt;另外，Google的无线路由器OnHub，出来的时候大家也是热情高涨。最后一看Amazon的review，恶评如潮。自称“speak human”，可怎么就那么不人性化，那么难用呢！&lt;/p&gt;&lt;p&gt;别忘了Blogger，别忘了Orkut，Chrome OS, Chrome book，…… 哎，Google还有其它一系列失败的的产品和项目，公司里很多人做着一些穷途末路的项目，我就不多说了……&lt;/p&gt;&lt;p&gt;所以总的来说，Google有它的特长。它是一个不错的互联网公司，Google的搜索引擎做得很好，Gmail，收购来的YouTube，地图，Android什么的，也比较好用。但是Google的特长，也就停留在那里了。做其他事情，几乎全都是业余水准，却自以为了不起，喜欢宣传自己，制造高大形象。最近AlphaGo搞得沸沸扬扬，也是一样的用意，煽风造势，以此吸引懵懂没经验的年轻人，进去为它做一些琐碎的杂活，帮助它赚更多的广告钱。&lt;/p&gt;&lt;p&gt;这就是我眼里的Google。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">google-vision</guid>
<pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>AlphaGo与人工智能</title>
<link>http://yinwang.org/blog-cn/2016/03/09/alpha-go</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;AlphaGo与人工智能&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-585d20981fef6a5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;在之前的一篇&lt;a href=&quot;http://www.jianshu.com/p/01d1b2542036&quot;&gt;文章&lt;/a&gt;中我指出，自动驾驶所需要的“视觉识别能力”和“常识判断能力”，对于机器来说是非常困难的问题。至今没有任何机器可以在视觉方面达到驴的水平，更不要说和人比。可是最近Google的&lt;a href=&quot;https://deepmind.com/alpha-go.html&quot;&gt;AlphaGo&lt;/a&gt;战胜了围棋世界冠军，挺闹腾的，以至于对AI的误解又加深了。&lt;/p&gt;&lt;p&gt;本来玩个游戏而已，恁要吹成是“历史性的人机大战”，说得好像是机器挑战了人类的智能，伤了人类的自尊似的。这整个项目打着一个相当高大上的招牌，叫做“&lt;a href=&quot;http://deepmind.com&quot;&gt;Deep Mind&lt;/a&gt;”。当然，其中的技术也有一些吓人的名字，什么“神经网络”啊，“深度学习”啊……&lt;/p&gt;&lt;p&gt;听到这些，总有一知半解的人，根据科幻电影的情节开始展望，这样厉害的技术，应该可以用来做更加“智能”的事情，然后就开始对“人类的未来”作出一些猜想，比如自动车就要实现，人的工作很快都要被机器取代，甚至&lt;a href=&quot;https://en.wikipedia.org/wiki/Skynet_(Terminator&quot;&gt;Skynet&lt;/a&gt;)就要控制人类，云云。&lt;/p&gt;&lt;p&gt;我只想在这里给这些人提个醒：还是别做科幻梦了，回到现实吧。&lt;/p&gt;&lt;h3&gt;棋类是相对容易的AI问题&lt;/h3&gt;&lt;p&gt;一个常见的外行想法，是以为AlphaGo真的具有“人类智能”，所以Google利用同样的技术，应该可以实现自动车。这些人不但大大的高估了所谓“AI”的能力，而且他们不明白，不同的“AI问题”的难度，其实有着天壤之别。&lt;/p&gt;&lt;p&gt;围棋是简单的，世界是复杂的。机器视觉和自动车，难度比围棋要大许多倍，根本不在一个量级。要达到准确的视觉判断能力，机器必须拥有真正的认知能力和常识，这并不是AlphaGo所用的树搜索和神经网络，就可以解决的。由于需要以极高的速度处理“模拟信号”，这根本就不是人们常用的“数字计算机”可以解决的问题。也就是说，不是写代码就可以搞定的。&lt;/p&gt;&lt;p&gt;很早以前，人工智能专家们就发现一个很有趣的现象，是这样：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;对于人来说很难，很烦的事情（复杂的计算，下棋，推理……），对于计算机来说，其实算是相对容易的事情。&lt;/li&gt;
&lt;li&gt;对于人来说很容易的事情（认人，走路，开车，打球……），对于计算机来说，却非常困难。&lt;/li&gt;
&lt;li&gt;计算机不能应付复杂的环境，只能在相对完美的环境下工作，需要精确的，离散的输入。&lt;/li&gt;
&lt;li&gt;人对环境的适应能力很高，擅长于处理模糊的，连续的，不完美的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从以上几点你可以看出，棋类活动正好符合了计算机的特点，因为它总是处于一种隔离的，完美的环境，具有离散的，精确的，有限的输入。棋盘上就那么几十，几百个点，不是随便放在哪里都可以的。一人走一步，轮流着走，不能乱来。整个棋盘的信息是完全可见的，没有隐藏和缺损的信息。棋局的“解空间”虽然很大，却非常规整，有规律可循。如果完全不靠经验和技巧的话，围棋的第一步可以有361种情况，第二步有360种情况，……&lt;/p&gt;&lt;p&gt;这对机器是非常有利的情况，因为计算机可以有计划有步骤，兢兢业业的把各种可能出现的情况算出来，一直到许多步以后，然后从中选择最有优势的走法。所以下棋归根结底，就是一个“树搜索”问题，只不过因为规模太大，需要加入一些优化。围棋的解空间虽然大，却是一个已知数，它最多有250&lt;sup&gt;150&lt;/sup&gt;种情况。AlphaGo使用所谓“神经网络”，就是为了在搜索的时候进行优化，尽早的排除不大可能取胜的情况，免得浪费计算的时间。&lt;/p&gt;&lt;p&gt;这种精确而死板的活动，就跟计算一个比较大的乘法算式（比如2463757 x 65389）的性质类似，只不过规模大很多。显然，人做这类事情很繁，很累，容易出错，计算机对此却任劳任怨，因为它本来就是个机器。当年“深蓝”战胜国际象棋世界冠军的时候，我就已经预测到，计算机成为围棋世界冠军是迟早的事，所以没必要玩这些虐待自己脑子的游戏了。可惜的是，挺多人仍然把精通棋艺作为一种荣耀（因为“琴棋书画剑”嘛）。很多中国人认为，中国人下围棋总是输给韩国人，是一种耻辱。现在看来这是多么可笑的事情，这就像心算乘法不如韩国人快，就觉得是耻辱一样 :)&lt;/p&gt;&lt;h3&gt;认知是真正困难的AI问题&lt;/h3&gt;&lt;p&gt;现在来对比一下人们生活中的琐事，就说倒水端茶吧。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-a2a10fbeb02f06e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;让一个机器来给你倒水，有多难呢？意想不到的难！看看这个场景，如果你的电脑配备有摄像头，那么它怎么知道茶壶在哪里呢？要知道，茶壶的材料，颜色，形状，和角度，可以有几乎无穷多的变化。甚至有些茶壶跟哈哈镜一样，会把旁边的物体的形状都扭曲反射出来。桌上的物品附近都有各种反光和阴影，不同材料的反光特性还不一样，这些都会大幅度的影响机器对物品的识别。&lt;/p&gt;&lt;p&gt;为了识别物体，机器需要常识，它的头脑里必须有概念，必须知道什么样的东西才能叫做“茶壶”和“茶杯”。不要小看这一步的难度，这意味着机器必须理解基本的“拓扑结构”，什么叫做“连续的平面”，什么叫做“洞”，什么是“凹”和“凸”，什么是“里”和“外”…… 另外，这机器必须能够分辨物体和阴影。它必须知道水是什么，水有什么样的运动特性，什么叫做“流动”。它必须知道“水往低处流”，然后它又必须知道什么叫“低”和“高”…… 它必须知道茶杯为什么可以盛水，茶壶的嘴在哪里，把手在哪里，怎样才能拿起茶壶。如果一眼没有看见茶壶的把手，那它在哪里？茶壶的哪一面是“上面”，要怎样才可以把水从茶壶的嘴里倒出来，而不是从盖子上面泼出来？什么是裂掉的茶杯，它为什么会漏水，什么是缺口的茶杯，它为什么仍然可以盛水而不漏？干净的茶杯是什么样子的，什么是脏的茶杯，什么是茶垢，为什么茶垢不算是脏东西？如何控制水的流速和落点，什么叫做“水溅出来了”，要怎么倒水才不会溅出来？……&lt;/p&gt;&lt;p&gt;你也许没有想到，倒茶这么简单的事情，需要用到如此多的常识。所有这些变数加在一起，其实远远的大于围棋棋局的数量，人却可以不费力的完成。这能力，真是应该让人自己都吓一跳，然而人却对此不以为然，称之为“琐事”！因为其他人都可以做这样的事情，甚至猴子都可以，怎么能显得出我很了不起呢？人的自尊和虚荣，再一次的蒙蔽了他自己。他没有意识到，这其实是非常宝贵，让机器难以匹敌的能力。他说：“机器经过大量的学习，总有一天会做到的。看我们有神经网络呢，还有深度学习！”&lt;/p&gt;&lt;h3&gt;机器学习是什么&lt;/h3&gt;&lt;p&gt;有些人喜欢拿“机器学习”或者“深度学习”来吓唬人，以为出现了“学习”两个字，就可以化腐朽为神奇。而其实所谓机器学习，跟人类的学习，完全是两回事。机器的“学习能力”，并没有比石头高出很多，因为机器学习说白了，只不过是通过大量的数据，&lt;a href=&quot;https://en.wikipedia.org/wiki/Curve_fitting&quot;&gt;统计拟合&lt;/a&gt;出某些函数的参数。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-e80aecf3dfb56edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;比如，你采集到一些二维数据点。你猜测它们符合一个简单的函数 y = ax&lt;sup&gt;3&lt;/sup&gt; + bx&lt;sup&gt;2&lt;/sup&gt; + cx + d，但不知道a, b, c和d该是多少。于是你就利用所谓“机器学习”（也就是数学统计），推断出参数a, b, c和d的值，使得采集到的数据尽可能的靠近这函数的曲线。可是这函数是怎么来的呢？终究还是人想出来的。机器无论如何也跳不出y = ax&lt;sup&gt;3&lt;/sup&gt; + bx&lt;sup&gt;2&lt;/sup&gt; + cx + d这个框子。如果数据不符合这个范式，还是只有靠人，才能找到更加符合数据特性的函数。&lt;/p&gt;&lt;p&gt;所谓神经网络，其实也是一个函数，它在本质上跟y = ax&lt;sup&gt;3&lt;/sup&gt; + bx&lt;sup&gt;2&lt;/sup&gt; + cx + d并没有不同，只不过输入的参数多一些，逻辑复杂一些。“神经网络”跟神经，其实完全没有关系，却偏喜欢说是受到了神经元的启发而来的。神经网络是一个非常聪明的广告词，它不知道迷惑了多少人。因为有“神经”两个字在里面，很多人以为它会让机器具有智能，而其实这些就是统计学家们斯通见惯的事情：拟合一个函数。你可以拟合出很好的函数，然而这跟智能没什么关系。&lt;/p&gt;&lt;h3&gt;AlphaGo并不是人工智能历史性的突破&lt;/h3&gt;&lt;p&gt;这次AlphaGo战胜了围棋冠军，跟之前IBM的“&lt;a href=&quot;http://www.theverge.com/2016/3/12/11211306/ibm-deep-blue-murray-campbell-alphago-deepmind-interview&quot;&gt;深蓝&lt;/a&gt;”电脑战胜国际象棋世界冠军，意义其实差不多。能够写出程序，在这些事情上打败世界冠军，的确是一个进步，它肯定会对某些特定的应用带来改善。然而，这并不说明AI取得了革命性的进步，更不能表明电脑具有了真正的，通用的智能。恰恰相反，电脑能够在棋类游戏中战胜人类，正好说明下棋这种活动，其实并不需要很多的智能。从事棋类活动的能力，并不足以衡量人的智力。&lt;/p&gt;&lt;p&gt;著名的认知科学家&lt;a href=&quot;http://www.theatlantic.com/magazine/archive/2013/11/the-man-who-would-teach-machines-to-think/309529&quot;&gt;Douglas Hofstadter&lt;/a&gt;（《&lt;a href=&quot;https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach&quot;&gt;GEB&lt;/a&gt;》的作者），早就指出AI领域的那些热门话题，比如电脑下棋，跟真正意义上的人类智能，几乎完全不搭边。绝大部分人其实不明白思考和智能到底是什么。大部分所谓AI专家，对人脑的工作原理所知甚少，甚至完全不关心。&lt;/p&gt;&lt;p&gt;AlphaGo所用的技术，也许能够用于其它同类的游戏，然而它并不能作为解决现实问题的通用方法。特别是，这种技术不可能对自动车的发展带来突破。自动车如果只比开车技术很差的人强一点，是不可接受的。它必须要近乎完美的工作，才有可能被人接受，然而这就要求它必须具有人类级别的视觉认知能力。比如，它必须能够察觉到前面车上绑了个家具，没绑稳，快要掉下来了，赶快换车道，超过它。可惜的是，自动车的“眼睛”里看到的，只是一个个的立方块，它几乎完全不理解身边到底发生着什么，它只是在跟随和避让一些线条和方块…… 我们多希望马路都是游戏一样简单，清晰，完美，没有意外的，可惜它不是那样的。每一个细节都可能关系到人的生死，这就是现实世界。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.dailymail.co.uk/sciencetech/article-3491916/Google-admits-self-driving-car-got-wrong-Bus-crash-caused-software-trying-predict-driver-do.html&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-585cdc79ddbab240.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;为AlphaGo热血沸腾的人们，别再沉迷于自动车和Skynet之类的幻想了。看清AI和“神经网络”的实质，用它们来做点有用的东西就可以，没必要对实现“人类智能”抱太大的希望。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">alpha-go</guid>
<pubDate>Wed, 09 Mar 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>不要去SeaWorld</title>
<link>http://yinwang.org/blog-cn/2016/02/25/sea-world</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;不要去SeaWorld&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;displayed&quot; src=&quot;http://www.yinwang.org/images/orca.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;很多人喜欢海洋动物，比如海豚和“杀人鲸”（orca），但是我建议不要去海洋世界看它们。海豚和杀人鲸都是有灵性的，跟人类的智慧很接近，而且对人极其友好的动物。“杀人鲸”名字吓人，但是其实根本不吃人，野生的杀人鲸从来没有伤过人。&lt;/p&gt;&lt;p&gt;事实是，像SeaWorld之类的所谓“海洋世界”，无情的把这些动物绑架，把它们从小与自己的父母分离。在SeaWorld里，这些动物如同坐牢。住的，吃的，都比它们原来的生活差很多，更是没有父母的关爱，兄弟姐妹的温暖。本来可以活上百年的杀人鲸，在SeaWorld里只能活一二十年。&lt;/p&gt;&lt;p&gt;花钱去SeaWorld之类的地方，等同于给绑架者送钱，请不要再带着小孩子去赞助这些绑架者了！如果你真的爱这些动物，请坐船去海里拜访他们吧。如果你还不明白我在说什么，建议你看看一些关于杀人鲸的片子，比如《&lt;a href=&quot;http://www.imdb.com/title/tt2545118&quot;&gt;Blackfish&lt;/a&gt;》和《&lt;a href=&quot;http://www.imdb.com/title/tt0106965&quot;&gt;Free Willy&lt;/a&gt;》。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.imdb.com/title/tt2545118&quot;&gt;&lt;img src=&quot;http://www.yinwang.org/images/blackfish.jpg&quot; width=&quot;45%&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;http://www.imdb.com/title/tt0106965&quot;&gt;&lt;img src=&quot;http://www.yinwang.org/images/free-willy.jpg&quot; width=&quot;45%&quot;&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">sea-world</guid>
<pubDate>Thu, 25 Feb 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>我看自动驾驶技术</title>
<link>http://yinwang.org/blog-cn/2016/02/12/self-driving-car</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;我看自动驾驶技术&lt;/h2&gt;&lt;p&gt;这段时间，Google的自动车，Tesla的autopilot，经常出现在新闻头条。人们热烈的讨论自动驾驶技术，对这“科幻般”的技术充满了憧憬，好奇，甚至恐惧。Google说：“自动车很安全。人类是糟糕的驾驶员。” 很多人不假思索就接受了这种观点，以为自己不久以后就会被自动车所代替，所以我今天想谈谈对这些“自动车”的看法。&lt;/p&gt;&lt;p&gt;从我的另一篇&lt;a href=&quot;http://www.jianshu.com/p/1f6f624d9815&quot;&gt;文章&lt;/a&gt;，你应该已经看到，Tesla的autopilot其实根本不算是“自动驾驶”，它完全不能和Google的自动车相比。Tesla把这种不成熟的软件推送到用户的车里，为的只是跟Google抢风头，塑造自己的高大形象。看，我们先出了自动车！可是呢，Tesla那东西顶多算一个“adaptive cruise control”，离真正的自动驾驶还很遥远。可惜的是，Tesla为了自己的名声，拿用户的性命当儿戏，还有些人为它叫好。&lt;/p&gt;&lt;p&gt;然而就算是Google的自动车，离能够投入使用，其实还差得很远。我这里说的“很远”，不是像某些人预测的10年，20年，而是至少100年，1000年…… 甚至永远无法实现。这是为什么呢？Google不是声称，每天都要让它的自动车“学习”上百万mile的行驶记录吗？难道学习了如此的“大数据”，不能让这车子变得跟人一样聪明吗？&lt;/p&gt;&lt;p&gt;如果你这么想，那你可能根本不了解人工智能（AI）。需要“学习上百万mile”，并不能说明自动车很聪明。恰恰相反，这说明它们很笨。只需要问自己一个问题：一个人要学会开车，需要开多少里程？普通人从完全不会，到能安全上路，一般只需要12节课，每节课1小时。就算这一个小时你都在高速公路上开，也就80 mile的样子。12个小时就960 mile。也就是说，普通人只需要小于1000 mile的驾驶，就能成为比较可靠的司机。&lt;/p&gt;&lt;p&gt;对比一下Google的自动车，它们每天“分析”和“学习”一百万mile的“虚拟里程”，而且经常在外面采集数据，累计上百万的mile。然而这些自动车，仍然只能在白天，天气好的时候，在道路环境非常简单的Mountain View行驶。Mountain View就是一个小镇子，总共就没几条路，路上几乎没有行人。我从未在时速超过50mph的公路上，或者交通复杂的大城市，见到过Google的自动车。&lt;/p&gt;&lt;p&gt;另外据最近的&lt;a href=&quot;http://www.forbes.com/sites/brookecrothers/2016/01/13/google-self-driving-car-failures-total-272-over-one-year-but-improvement-seen&quot;&gt;报道&lt;/a&gt;，Google的自动车在过去一年时间里，发生了272起需要“人工干预”的错误情况。如果人不及时抢过控制权，不少情况会出现车祸。在如此简单的条件下，还需要如此多的人工干预。如果环境稍微复杂一些，自动车恐怕就完全不知所措了。&lt;/p&gt;&lt;p&gt;这里还有一个“特殊关照”的问题，由于Google的自动车身上有着明显的标志，行人和其它驾驶员看到它，其实都有点提心吊胆的，不敢轻举妄动，怕它犯傻撞了自己，这也变相的降低了自动车的环境复杂度。一旦Google把车身上的标志去掉，大家看不出来谁是自动车，不对它们进行特殊的关照，我行我素，事故率恐怕就上去了。&lt;/p&gt;&lt;p&gt;所以Google的自动车，离能够投入真正的使用，差距还非常远。在这种情况下就妄言“自动车很安全”，“人类是糟糕的驾驶员”，…… 未免也太早了些吧？自动车跟人类差距到底有多远呢？天壤之别。普通人只需要开1000 mile就能学会开车，而这些自动车学习了几百万，几千万，几亿mile，仍然门都没有摸到。这说明自动车跟人类的运动神经，有着根本的区别。&lt;/p&gt;&lt;p&gt;人在运动的时候看见一个物体，他的头脑里会立即闪现与之相应的“概念”，然后很快浮现出这种东西的运动特点，以及相应的对策。相比之下，自动车看到物体，它并不能准确的判断它是什么东西：它是一个车，一个人，一棵树，一个施工路障，一个大坑，还是前面的车掉下来的床垫呢？所以自动车就像一个智障儿童，学了这么久连什么是什么都不知道，却有人指望它们在十年之内能开车穿越美国。&lt;/p&gt;&lt;p&gt;对的，自动车配备了GPS，激光，雷达，…… 它的“感官”接收到很多的数据，有些是人类无法感觉到的。然而自动车的“头脑”（电脑），是没有认知能力的，所以就算收集到了大量的数据，它仍然不知道那东西是什么，它们之间是什么关系。电脑没有这些“常识”，所以它无法为人做出正确的判断。在危急的关头，它很可能会做出危及乘客安全的决定。“认知”是一个根本性的问题，AI领域至今没有解决它，甚至根本没有动手去研究它。&lt;/p&gt;&lt;p&gt;自动车使用的所谓“机器学习”的技术，跟人类的“学习”，完全是两回事。举个例子，一个小孩从来没见过猫，你只需要给她一只猫，告诉他这是“猫咪”。下一次，当她见到不管什么颜色的猫，不管它摆出什么姿势，都知道这是“猫咪”。现在的电脑，认知能力其实比小孩子，甚至其它动物都差很多。你先让电脑分析上百万张猫的照片，各种颜色，各种姿势，各种角度，拿一只猫摆在它的摄像头面前，让它看整整一年…… 最后它仍然不理解猫是什么，不能准确的判断一个东西是否是猫。如果说电脑有智商，那么它的级别就像一个蠕虫，甚至连蠕虫都不如。电脑没有认识和适应环境的能力，所以就算它再用功，“学习”再多的数据，都是白费劲。&lt;/p&gt;&lt;p&gt;很多人听说“人工智能”（AI），或者“机器学习”（machine learning），“深度学习”（deep learning）这类很酷的名词，就想起科幻小说里的智能机器人，就以为科幻就要成为现实。等你真的进入“机器学习”这领域，才发现一堆堆莫名其妙，稀里糊涂的做法，最后其实不怎么管用。这些大口号，包括所谓“深度学习”，其实跟人的思维方式，几乎完全不搭边。所谓“机器学习”，不过是一些普通的统计方法，拟合一些函数参数。吹得神乎其神，倒让统计专业的人士笑话。&lt;/p&gt;&lt;p&gt;人工智能在80年代出现过一次热潮。当时人们乐观的相信，电脑在不久就会拥有人类的智能。日本还号称要动员全国的力量，制造所谓“第五代计算机”，发展智能的编程语言（比如Prolog）。结果最后呢？人们意识到，超越人类（动物）的智能，比他们想象的困难太多太多。浮夸的许诺没能实现，AI领域进入了冬天。最近因为“大数据”，“自动车”和“Internet of Things”等热门话题的出现，“AI热”又死灰复燃。然而当今的AI，其实并没有比80年代的进步很多。人们对于自己的脑子以及感官的工作原理，仍然所知甚少，却盲目的认为那些从统计学偷来的概念，改名换姓叫“机器学习”，就能造出跟自己的头脑媲美的机器。这些人其实大大的低估了自己身体的神奇程度。&lt;/p&gt;&lt;p&gt;视觉和认知能力，是动物（包括人类）特有的，卓越的能力。它们让动物能够准确的感知身边复杂的世界，对此作出适合自己生存的计划。一辆能够穿越整个国家的自动车，它必须适应各种复杂的环境：天气，路况，交通，意外情况…… 所以它需要动物的认知能力。我并不是说机器永远不可能具有这种能力，然而如果你根本不去欣赏，研究和理解这种能力，倒以为所谓“机器学习”就能办到这些事情，张口闭口拿“人类”说事，你又怎么可能用机器实现它呢？我的预测是，直到人类能够完全的理解动物的脑子和感官如何工作，才有可能制造出能够接近人类能力的自动车。&lt;/p&gt;&lt;p&gt;诚然，有少数人开车不小心，甚至酒后驾车，导致了很多的车祸。然而因此就声称“人类是糟糕的驾驶员”，那就是以偏概全了。大部分的人还是遵纪守法，注意安全的。很多人开车几十年，从没出过车祸。另外，我们必须把“态度”和“能力”区分开来看。酒后驾车的人，不是技术不够好，而是态度有问题。电脑当然没有态度问题，然而它的技术确实难以达到人的水平。就算那些酒后驾车的人，他们的能力其实也远远在电脑之上。我无法想象当今的电脑技术，要如何才能超越驾驶技术好的人，以及职业赛车手。&lt;/p&gt;&lt;p&gt;如果你还没明白，也许下面这个图片可以把你拉回到现实世界：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68562-39e22022670591ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;一个机器，如何能知道旁边的车上正在发生什么，即将可能发生什么样的危险情况呢？它如何知道，需要赶快避开这辆车呢？它不能。一个没有认知能力的机器，是难以应付复杂多变的现实世界的。&lt;/p&gt;&lt;p&gt;现在人们对于自动车技术的关注，热情，盲目乐观和浮夸，感觉跟文化大革命，“大跃进”年代的思维方式类似。只不过现在“毛泽东”换成了Google或者Tesla，“每亩产量十万”换成了“两年之内自动驾驶穿越美国”…… 我觉得与其瞎折腾自动驾驶技术，不如做点脚踏实地，在短期内能够见效，改善人们生活的东西。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">self-driving-car</guid>
<pubDate>Fri, 12 Feb 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>给Java说句公道话</title>
<link>http://yinwang.org/blog-cn/2016/01/18/java</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;给Java说句公道话&lt;/h2&gt;&lt;p&gt;有些人问我，在现有的语言里面，有什么好的推荐？我说：“Java。” 他们很惊讶：“什么？Java！” 所以我现在来解释一下。&lt;/p&gt;&lt;h3&gt;Java超越了所有咒骂它的“动态语言”&lt;/h3&gt;&lt;p&gt;也许是因为年轻人的逆反心理，人们都不把自己的入门语言当回事。很早的时候，计算机系的学生用Scheme或者Pascal入门，现在大部分学校用Java。这也许就是为什么很多人恨Java，瞧不起用Java的人。提到Java，感觉就像是爷爷那辈人用的东西。大家都会用Java，怎么能显得我优秀出众呢？于是他们说：“Java老气，庞大，复杂，臃肿。我更愿意探索新的语言……”&lt;/p&gt;&lt;p&gt;某些Python程序员，在论坛里跟初学者讲解Python有什么好，其中一个原因竟然是：“因为Python不是Java！” 他们喜欢这样宣传：“看Python多简单清晰啊，都不需要写类型……” 对于Java的无缘无故的恨，盲目的否认，导致了他们看不到它很重要的优点，以至于迷失自己的方向。虽然气势上占上风，然而其实Python作为一个编程语言，是完全无法和Java抗衡的。&lt;/p&gt;&lt;p&gt;在性能上，Python比Java慢几十倍。由于缺乏静态类型等重要设施，Python代码有bug很不容易发现，发现了也不容易debug，所以Python无法用于构造大规模的，复杂的系统。你也许发现某些startup公司的主要代码是Python写的，然而这些公司的软件，质量其实相当的低。在成熟的公司里，Python最多只用来写工具性质的东西，或者小型的，不会影响系统可靠性的脚本。&lt;/p&gt;&lt;p&gt;静态类型的缺乏，也导致了Python不可能有很好的IDE支持，你不能完全可靠地“跳转到定义”，不可能完全可靠地重构（refactor）Python代码。PyCharm对于早期的Python编程环境，是一个很大的改进，然而理论决定了，它不可能完全可靠地进行“变量换名”等基本的重构操作。就算是比PyCharm强大很多的PySonar，对此也无能为力。由于Python的设计过度的“动态”，没有类型标记，使得完全准确的定义查找，成为了不可判定（undecidable）的问题。&lt;/p&gt;&lt;p&gt;在设计上，Python，Ruby比起Java，其实复杂很多。缺少了很多重要的特性，有毛病的“强大特性”倒是多了一堆。由于盲目的推崇所谓“正宗的面向对象”方式，所谓“&lt;a href=&quot;https://en.wikipedia.org/wiki/Late_binding&quot;&gt;late binding&lt;/a&gt;”，这些语言里面有太多可以“重载”语义的地方，不管什么都可以被重定义，这导致代码具有很大的不确定性和复杂性，很多bug就是被隐藏在这些被重载的语言结构里面了。因此，Python和Ruby代码很容易被滥用，不容易理解，容易写得很乱，容易出问题。&lt;/p&gt;&lt;p&gt;很多JavaScript程序员也盲目地鄙视Java，而其实JavaScript比Python和Ruby还要差。不但具有它们的几乎所有缺点，而且缺乏一些必要的设施。JavaScript的各种“WEB框架”，层出不穷，似乎一直在推陈出新，而其实呢，全都是在黑暗里瞎蒙乱撞。JavaScript的社区以幼稚和愚昧著称。你经常发现一些非常基本的常识，被JavaScript“专家”们当成了不起的发现似的，在大会上宣讲。我看不出来JavaScript社区开那些会议，到底有什么意义，仿佛只是为了拉关系找工作。&lt;/p&gt;&lt;p&gt;Python凑合可以用在不重要的地方，Ruby是垃圾，JavaScript是垃圾中的垃圾。原因很简单，因为Ruby和JavaScript的设计者，其实都是一知半解的民科。然而世界就是这么奇怪，一个彻底的垃圾语言，仍然可以宣称是“程序员最好的朋友”，从而得到某些人的爱戴……&lt;/p&gt;&lt;h3&gt;Java的“继承人”没能超越它&lt;/h3&gt;&lt;p&gt;最近一段时间，很多人热衷于Scala，Clojure，Go等新兴的语言，他们以为这些是比Java更现代，更先进的语言，以为它们最终会取代Java。然而这些狂热分子们逐渐发现，Scala，Clojure和Go其实并没有解决它们声称能解决的问题，反而带来了它们自己的毛病，而这些毛病很多是Java没有的。然后他们才意识到，Java离寿终正寝的时候，还远得很……&lt;/p&gt;&lt;p&gt;&lt;em&gt;Go语言&lt;/em&gt;&lt;/p&gt;&lt;p&gt;关于Go，我已经评论过很多了，有兴趣的人可以看&lt;a href=&quot;http://www.yinwang.org/blog-cn/2014/04/18/golang&quot;&gt;这里&lt;/a&gt;。总之，Go是民科加自大狂的产物，奇葩得不得了。这里我就不多说它了，只谈谈Scala和Clojure。&lt;/p&gt;&lt;p&gt;&lt;em&gt;Scala&lt;/em&gt;&lt;/p&gt;&lt;p&gt;我认识一些人，开头很推崇Scala，仿佛什么救星似的。我建议他们别去折腾了，老老实实用Java。没听我的，结果到后来，成天都在骂Scala的各种毛病。但是没办法啊，项目上了贼船，不得不继续用下去。我不喜欢进行人身攻击，然而我发现一个语言的好坏，往往取决于它的设计者的背景，觉悟，人品和动机。很多时候我看人的直觉是异常的准，以至于依据对语言设计者的第一印象，我就能预测到这个语言将来会怎么发展。在这里，我想谈一下对Scala和Clojure的设计者的看法。&lt;/p&gt;&lt;p&gt;Scala的设计者Martin Odersky，在PL领域有所建树，发表了不少学术论文（ 包括著名的《&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.1889&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;The Call-by-Need Lambda Calculus&lt;/a&gt;》），而且还是大名鼎鼎的&lt;a href=&quot;https://en.wikipedia.org/wiki/Niklaus_Wirth&quot;&gt;Niklaus Wirth&lt;/a&gt;的门徒，我因此以为他还比较靠谱。可是开始接触Scala没多久，我就很惊讶的发现，有些非常基本的东西，Scala都设计错了。这就是为什么我几度试图采用Scala，最后都不了了之。因为我一边看，一边发现让人跌眼镜的设计失误，而这些问题都是Java没有的。这样几次之后，我就对Odersky失去了信心，对Scala失去了兴趣。&lt;/p&gt;&lt;p&gt;回头看看Odersky那些论文的本质，我发现虽然理论性貌似很强，其实很多是在故弄玄虚（包括那所谓的“call-by-need lambda calculus”）。他虽然对某些特定的问题有一定深度，然而知识面其实不是很广，眼光比较片面。对于语言的整体设计，把握不够好。感觉他是把各种语言里的特性，强行拼凑在一起，并没有考虑过它们是否能够“和谐”的共存，也很少考虑“可用性”。&lt;/p&gt;&lt;p&gt;由于Odersky是大学教授，名声在外，很多人想找他拿个PhD，所以东拉西扯，喜欢往Scala里面加入一些不明不白，有潜在问题的“特性”，其目的就是发paper，混毕业。这导致Scala不加选择的加入过多的特性，过度繁复。加入的特性很多后来被证明没有多大用处，反而带来了问题。学生把代码实现加入到Scala的编译器，毕业就走人不管了，所以Scala编译器里，就留下一堆堆的历史遗留垃圾和bug。这也许不是Odersky一个人的错，然而至少说明他把关不严，或者品位确实有问题。&lt;/p&gt;&lt;p&gt;最有名的采用Scala的公司，无非是Twitter。其实像Twitter那样的系统，用Java照样写得出来。Twitter后来怎么样了呢？CEO都跑了 :P 新CEO上台就裁员300多人，包括工程师在内。我估计Twitter裁员的一个原因是，有太多的Scala程序员，扯着各种高大上不实用的口号，比如“函数式编程”，进行过度工程，浪费公司的资源。花着公司的钱，开着各种会议，组织各种meetup和hackathon，提高自己在open source领域的威望，其实没有为公司创造很多价值……&lt;/p&gt;&lt;p&gt;&lt;em&gt;Clojure&lt;/em&gt;&lt;/p&gt;&lt;p&gt;再来说一下Clojure。当Clojure最初“横空面世”的时候，有些人热血沸腾地向我推荐。于是我看了一下它的设计者Rich Hickey做的宣传讲座视频。当时我就对他一知半解拍胸脯的本事，印象非常的深刻。Rich Hickey真的是半路出家，连个CS学位都没有。可他那种气势，仿佛其他的语言设计者什么都不懂，只有他看到了真理似的。不过也只有这样的人，才能创造出“宗教”吧？&lt;/p&gt;&lt;p&gt;满口热门的名词，什么lazy啊，pure啊，STM啊，号称能解决“大规模并发”的问题，…… 这就很容易让人上钩。其实他这些词儿，都是从别的语言道听途说来，却又没能深刻理解其精髓。有些“函数式语言”的特性，本来就是有问题的，却为了主义正确，为了显得高大上，抄过来。所以最后你发现这语言是挂着羊头卖狗肉，狗皮膏药一样说得头头是道，用起来怎么就那么蹩脚。&lt;/p&gt;&lt;p&gt;Clojure的社区，一直忙着从Scheme和Racket的项目里抄袭思想，却又想标榜是自己的发明。比如Typed Clojure，就是原封不动抄袭Typed Racket。有些一模一样的基本概念，在Scheme里面都几十年了，恁是要改个不一样的名字，免得你们发现那是Scheme先有的。甚至有人把SICP，The Little Schemer等名著里的代码，全都用Clojure改写一遍，结果完全失去了原作的简单和清晰。最后你发现，Clojure里面好的地方，全都是Scheme已经有的，Clojure里面新的特性，几乎全都有问题。我参加过一些Clojure的meetup，可是后来发现，里面竟是各种喊着大口号的小白，各种趾高气昂的民科，愚昧之至。&lt;/p&gt;&lt;p&gt;如果现在要做一个系统，真的宁可用Java，也不要浪费时间去折腾什么Scala或者Clojure。错误的人设计了错误的语言，拿出来浪费大家的时间。&lt;/p&gt;&lt;h3&gt;Java没有特别讨厌的地方&lt;/h3&gt;&lt;p&gt;我至今不明白，很多人对Java的仇恨和鄙视，从何而来。它也许缺少一些方便的特性，然而长久以来用Java进行教学，用Java工作，用Java开发PySonar，RubySonar，Yin语言，…… 我发现Java其实并不像很多人传说的那么可恶。我发现自己想要的95%以上的功能，在Java里面都能找到比较直接的用法。剩下的5%，用稍微笨一点的办法，一样可以解决问题。&lt;/p&gt;&lt;p&gt;盲目推崇Scala和Clojure的人们，很多最后都发现，这些语言里面的“新特性”，几乎都有毛病，里面最重要最有用的特性，其实早就已经在Java里了。有些人跟我说：“你看，Java做不了这件事情！” 后来经我分析，发现他们在潜意识里早已死板的认定，非得用某种最新最酷的语言特性，才能达到目的。Java没有这些特性，他们就以为非得用另外的语言。其实，如果你换一个角度来看问题，不要钻牛角尖，专注于解决问题，而不是去追求最新最酷的“写法”，你就能用Java解决它，而且解决得干净利落。&lt;/p&gt;&lt;p&gt;很多人说Java复杂臃肿，其实是因为早期的&lt;a href=&quot;https://en.wikipedia.org/wiki/Design_Patterns&quot;&gt;Design Patterns&lt;/a&gt;，试图提出千篇一律的模板，给程序带来了不必要的复杂性。然而Java语言本身跟Design Patterns并不是等价的。Java的设计者，跟Design Pattern的设计者，完全是不同的人。你完全可以使用Java写出非常简单的代码，而不使用Design Patterns。&lt;/p&gt;&lt;p&gt;Java只是一个语言。语言只提供给你基本的机制，至于代码写的复杂还是简单，取决于人。把对一些滥用Design Patterns的Java程序员的恨，转移到Java语言本身，从而完全抛弃它的一切，是不明智的。&lt;/p&gt;&lt;h3&gt;结论&lt;/h3&gt;&lt;p&gt;我平时用着Java偷着乐，本来懒得评论其它语言的。可是实在不忍心看着有些人被Scala和Clojure忽悠，所以在这里说几句。如果没有超级高的性能和资源需求（可能要用C这样的低级语言），目前我建议就老老实实用Java吧。虽然不如一些新的语言炫酷，然而实际的系统，还真没有什么是Java写不出来的。少数地方可能需要绕过一些限制，或者放宽一些要求，然而这样的情况不是很多。&lt;/p&gt;&lt;p&gt;编程使用什么工具是重要的，然而工具终究不如自己的技术重要。很多人花了太多时间，折腾各种新的语言，希望它们会奇迹一般的改善代码质量，结果最后什么都没做出来。选择语言最重要的条件，应该是“够好用”就可以，因为项目的成功最终是靠人，而不是靠语言。既然Java没有特别大的问题，不会让你没法做好项目，为什么要去试一些不靠谱的新语言呢？&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">java</guid>
<pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Tesla Autopilot</title>
<link>http://yinwang.org/blog-cn/2016/01/10/tesla-autopilot</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;Tesla Autopilot&lt;/h2&gt;&lt;p class=&quot;notice&quot;&gt;以下内容是《&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/12/12/tesla-model-s&quot;&gt;Tesla Model S的设计失误&lt;/a&gt;》一文中新加入的小节。由于写作时间相距太远，而且由于它的&lt;a href=&quot;http://www.reuters.com/article/us-tesla-autopilot-idUSKCN0UO0NM20160110&quot;&gt;时效性&lt;/a&gt;，现在也把它单独提出来，独立成文。&lt;/p&gt;&lt;p&gt;两个月前，Tesla通过“软件更新”，使Model S具有了初级的“自动驾驶”（autopilot）功能。这个功能可以让Model S自动地，沿着有“清晰边界线”的车道行驶，根据前后车辆的速度相应的加速和减速。&lt;/p&gt;&lt;p&gt;这貌似一个很新很酷的功能，咋一看跟Google的自动车有的一拼（其实差得天远）。然而在推出后不久，YouTube上出现了一些视频（&lt;a href=&quot;https://www.youtube.com/watch?v=MrwxEX8qOxA&quot;&gt;视频1&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=Lx3-epk_ztQ&quot;&gt;视频2&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=LJnYCEQwtHs&quot;&gt;视频3&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=rkZ-jhLxrVc&quot;&gt;视频4&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=mLOG1bw3vSM&quot;&gt;视频5&lt;/a&gt;）。它们显示，autopilot在某些情况下有可能进行错误的判断和操作，有些险些造成严重的迎面车祸。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=MrwxEX8qOxA&quot;&gt;
&lt;img src=&quot;http://www.yinwang.org/images/model-s-autopilot-frontal.png&quot; width=&quot;80%&quot;&gt;
&lt;/a&gt;&lt;/p&gt;&lt;p&gt;特别是&lt;a href=&quot;https://www.youtube.com/watch?v=MrwxEX8qOxA&quot;&gt;视频1&lt;/a&gt;显示，在路面线条清晰，天气很好的路上，autopilot忽然向左，试图转向反方向的车道，差点导致严重的对撞车祸。仔细观察autopilot转向之前的情况，是由于路面上有阳光投下来的树影。Autopilot误以为那是一个障碍物，所以试图把车转上反方向的车道！&lt;/p&gt;&lt;p&gt;从这个简单的视频我们可以看出：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Autopilot没有对图像进行基本的“阴影消除”，它不能区分阴影和障碍物。阳光强烈，阴影明显的时候，autopilot可能把阴影当成障碍物。阴影消除在计算机视觉已经研究挺多了，这说明Tesla有可能没有进行基础的计算机视觉研究。缺乏分辨阴影和障碍物的能力，这样的自动驾驶系统是完全不可接受的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;道路中间有明显的，表示“禁止超车”的双黄线，对面有来车。Autopilot为了避开“障碍”，冒着对撞的危险，左转跨越双黄线。这表示autopilot连基本的交通规则，紧急情况下的正确操作方式都搞不清楚。或者也许这软件里面连双黄线都没有识别，甚至连这个概念都没有。&lt;/p&gt;

&lt;p&gt;对于一个有经验的驾驶员来说，如果发现前方有障碍物，正确的作法不应该是猛烈地转弯避开，而应该是紧急刹车。从视频上我们看出，车子没有刹车减速（保持在37~38），而是猛烈地左转。而且是等树影到了面前，才忽然进行操作，没有计算提前量。这说明设计autopilot的人，连基本的开车常识都不明白。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;让我感到悲哀的是，这些视频的很多评论，大部分都在谩骂车主是傻逼：“这是车主自己的责任！”，“Autopilot只能在高速公路上使用”，“只能在车道上有明确的边界线的时候使用！”，“不能在有很多弯道的地方“，“只能在能够看见前方300米道路的地方使用”，“谁叫你不看说明书的！”…… Elon Musk也在一次&lt;a href=&quot;https://www.youtube.com/watch?v=60-b09XsyqU&quot;&gt;采访&lt;/a&gt;中明确的告诉记者：“如果用户因为使用autopilot而导致了车祸，是用户自己的责任！” 他反复地声明：“autopilot还处于beta版本……” 意思是，你们小心着用！&lt;/p&gt;&lt;p&gt;我对这些说法持不同的观点。首先，Tesla根本就不应该把一个处于&quot;beta状态&quot;的功能，自动推送到所有Model S的系统里面。实际上，像autopilot这种功能，关系到人的生命安全，根本就不应该有&quot;beta版本&quot;或者“测试版本”之说。Tesla把这样不成熟的系统，强制推送给用户，然后又说如果出了事故，用户负所有责任，这是一种推卸责任的做法。要知道，没有任何人愿意拿自己的生命给Tesla做“beta测试”。&lt;/p&gt;&lt;p&gt;另外，就算是用户没有仔细阅读autopilot的使用说明，在“不该”用它的地方（比如路面线条不清晰的地方）使用了autopilot，如果出了车祸，Tesla也应该负完全的责任。理由如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;作为用户，他们没有义务阅读并且深刻的理解autopilot的局限性。在软件行业，存在一种习惯性的“责备用户”的不良风气。如果软件的设计有问题，用户没记住它的毛病，没能有效地绕过，那么如果出了问题，一般被认为是用户的错。Tesla想把软件行业的这种不正之风，引入到人命关天的汽车行业，那显然是行不通的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tesla的autopilot实现方式幼稚，局限性实在太多。天气不好的时候不行，路面上的边界线不清晰也不行，光线不好或者有阴影不行，路上有施工的路桩不行，高速出口不行，…… 实际上，在如此苛刻的限定条件下，任何一个汽车厂商都可以做出Tesla那种autopilot。&lt;/p&gt;

&lt;p&gt;我自己的便宜Honda车，就有偏离车道时发出警告的功能（Lane Drift Warning，LDW）。装个摄像头，来点最简单的图像处理就搞定。在Indiana大学的时候，我们有一门本科级别的课程，就是写代码控制一辆高尔夫球车（也是电动车呢），沿着路面上的线条自动行驶。这根本没什么难度，因为它能正确行驶的条件，实在是太苛刻了。&lt;/p&gt;

&lt;p&gt;其它汽车厂商很清楚这种功能的局限性，所以他们没有大肆吹嘘这种“线检测”的技术，或者把它做成autopilot。他们只是把它作为辅助的，提示性的功能。这些汽车厂商理解，作为一个用户，他们不可能，也不应该记住autopilot能正确工作的种种前提条件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户没有足够的能力来“判断”autopilot正常工作的条件是否满足。比如，路上的线还在，但是被磨损了，颜色很浅，那么autopilot到底能不能用呢？谁也不知道。把判断这些条件是否满足的任务推给用户，就像是在要求用户帮Tesla的工程师debug代码。这显然是不可行的。如果autopilot能够在检测到道路条件不满足的情况下，自动警告用户，并且退出自动驾驶模式，那还稍微合理一些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户也许没有足够的时间来响应条件的改变。Autopilot自动驾驶的时候，车子有可能最初行驶在较好的条件下（天气好，路面线条清晰），然而随着高速行驶，路面条件有可能急速的变化。有可能上一秒还好好的，下一秒路面线条就不再清晰（&lt;a href=&quot;https://www.youtube.com/watch?v=mLOG1bw3vSM&quot;&gt;视频5&lt;/a&gt;貌似这种情况）。路面条件的变化突如其来，驾驶员没有料到。等他们反应过来，想关闭autopilot的时候，车祸已经发生了。这种情况如果上诉到法庭，稍微明理一点的法官，都应该判Tesla败诉。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Autopilot显摆出的“高科技”形象，容易使人产生盲目的信任，以至于疏忽而出现车祸。既然叫做“autopilot”，这意味着它能够不需要人干预，自动驾驶一段时间。既然用户觉得它能自动驾驶，那么他们完全有理由在到达高速路口之前（比如GPS显示还有一个小时才到出口），做一些自己的事情：比如看看手机啊，看看书啊，甚至刷刷牙…… 不然，谁让你叫它是“autopilot”的呢？我坐飞机时，就见过飞行员打开autopilot，上厕所去了。如果启用了autopilot还得一秒钟不停地集中注意力，那恐怕比自己开车还累。自己开车只需要看路，现在有了autopilot，不但要看路，还要盯着方向盘，防止autopilot犯傻出错……&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tesla把“beta版”的autopilot推送给所有的Model S，是对社会安全不负责任的做法。你要明白Murphy&#39;s Law：如果一个东西可能出问题，那么就一定会有人让它出问题。Autopilot的功能不成熟，限制条件很多，不容易被正确使用，这不但对Model S的车主自己，而且对其他人也是一种威胁。汽车不是玩具，随便做个新功能，beta版，让人来试用，是会玩出人命的。我觉得Tesla的autopilot，跟无照驾驶的人一样，应该被法律禁止。由于autopilot的复杂性和潜在的危险性，使用autopilot的用户，应该经过DMV考核，在驾照上注明“能正确使用Tesla autopilot”，才准上路。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关系到人的生命安全的“免责声明”和“用户协议”，在法律上是无效的。在美国，到处都存在“免责声明”之说。比如你去参加学校组织的春游活动，都要叫你签一个“waiver”，说如果出了安全事故或者意外，你不能把学校告上法庭。这种免责声明，一般在法律上都是无效的。如果由于学校的过错而致使你的身体受了损伤，就算你签了这种waiver，照样可以把学校告上法庭。我估计Tesla的autopilot在启动时，也有这样的免责声明，说如果使用autopolit而出现车祸，Tesla不负责任。由于autopilot直接操控了你的车子，如果真的出了车祸，这跟其它的waiver一样，都是无效的。你照样可以上法庭告他们。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于意识到这个问题，知道出了问题自己是逃不掉责任的，Tesla最近又通过强制的软件更新，对autopilot的功能进行了一些&lt;a href=&quot;http://www.reuters.com/article/us-tesla-autopilot-idUSKCN0UO0NM20160110&quot;&gt;限制&lt;/a&gt;，说是为了防止用户“滥用”autopilot做一些“疯狂”的事情。Tesla很疯狂，反倒指责用户“滥用”和“疯狂”。这让人很愤慨。&lt;/p&gt;&lt;p&gt;对autopilot进行限制的同时，Tesla又推出了beta版的“&lt;a href=&quot;http://www.cnet.com/news/tesla-cars-can-now-self-park-at-your-command&quot;&gt;自动趴车&lt;/a&gt;”和“召唤”（summon）功能。这些功能貌似很酷，然而它们也附带了许多的限制条件。你只能在某些地方，满足某种特定条件，才能用这些功能。如果你违反这些条件，出了事故，Tesla声称不负责。&lt;/p&gt;&lt;p&gt;这些能够让车子自己移动的功能，跟autopilot一样，同样会给社会带来安全隐患。比如，有人在不该使用自动趴车和summon功能的地方用了它，就可能会导致车祸。这不是用户的问题，而是Tesla根本不应该发布这些不成熟的技术来哗众取巧。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">tesla-autopilot</guid>
<pubDate>Sun, 10 Jan 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>给Las Vegas的差评</title>
<link>http://yinwang.org/blog-cn/2016/01/04/las-vegas</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;给Las Vegas的差评&lt;/h2&gt;&lt;p&gt;新年的旅行，大部分是浪漫而快乐的，然而也有不如人意的一两天。这一两天的不如意，来自于一个错误的，类似“朝圣”的理念：要去赌城Las Vegas看看，人生才算完整。其实本来没什么兴趣的，但因为一路开车观光，欣赏风景和美食，走得比较近了，就想顺路去Vegas看看也无妨，不看也许会后悔。哪知道这一失足，差点毁了整个旅行的心情。旅程完成之后，我只有一个遗憾——我希望自己没去过Vegas这鬼地方。&lt;/p&gt;&lt;p&gt;不知道为什么，Vegas仿佛是很多中国人在美国旅游，必去的一个“胜地”。对于在国内从没见过赌场的人，它充满了神秘。对于在美国的各种小村子里面（比如大学啊，硅谷啊）待久了，无聊了，想去“城里逛逛”的中国人，它充满了魅力。电视上总是看到这里灯红酒绿，街上熙熙攘攘的人群，club里激情洋溢的艳影，疯狂的party，各种“有名”的show，遍地散发漂亮小姐的广告，甚至还可以去赌场里感受一下……&lt;/p&gt;&lt;p&gt;然而真的到了Vegas，却发现那些朦胧的幻想，被扫得一干二净。如果你来Vegas的目的不是赌钱，那么你多半会失望的。如果你来了却没失望，那你的脑子恐怕患了某种神奇的疾病 :)&lt;/p&gt;&lt;p&gt;下面我就把自己对Vegas的感受简要说一下。&lt;/p&gt;&lt;h3&gt;自然环境恶劣&lt;/h3&gt;&lt;p&gt;Vegas真的是在沙漠里。去Vegas的路，从沙漠中间穿过。风呼呼的吹呀，如果不好好扶稳方向盘，恐怕车子就会被风吹到路边去。Vegas的冬天又冷又干，本来鲜活的一个人，到了Vegas，整个人都不好了。夜里相对湿度低于20%，到的当天晚上就舌头干，喉咙干，鼻子干，咳嗽不止，嘴唇干裂疼痛，各种不爽……&lt;/p&gt;&lt;p&gt;然而再恶劣的自然条件，都不能跟恶劣的人心相比。Vegas最让人厌恶的，其实是这里的人。&lt;/p&gt;&lt;h3&gt;服务人员素质低下&lt;/h3&gt;&lt;p&gt;我评价一个地方的生活质量，最重要的指标，在于它的服务业人员是否对所有人发自心底的友好，而不只是对有钱人点头哈腰。在我看来，Vegas是一个虚伪势利，对人极其不友好的城市。它就像一只哈巴狗，只对又有钱又傻的人摇尾巴。当然它摇尾巴的目的，不过是想从这些傻人身上榨取最大的利润。&lt;/p&gt;&lt;p&gt;酒店里西装革履的招待员，对你貌似彬彬有礼，可是眼神对视的时候，你却能感觉到他们高冷的气势。那笑容不是发自心底的，你看得到他们内心的傲慢，居高临下的态度，甚至歧视。这些服务人员，仿佛随时在上下打量你是什么人种，穿的衣服是否名牌，口袋里是否有钱可以拿出来。当你来的时候，你感觉她的眼睛不是在说“欢迎你来到Vegas！”，而是在说：“OK，我们开恩让你住这里了，好自为之吧！”当你走的时候，他的眼睛打量一下你，仿佛在说：“就这样？没赌钱就走人了？”&lt;/p&gt;&lt;p&gt;态度生硬的酒店服务员还算是好点的了，商店和饭店里，服务人员态度恶劣露骨的，实在多的去了。那态度，仿佛你花了高价，反倒是来跟他们要饭的一样。在Vegas，我算是开了眼界了，这是我一生中见过服务态度最差的地方。我可以说，Vegas 60%以上的服务人员，素质低下，态度恶劣和虚假，对人冷眼相对，非常没有礼貌。这里面感觉到的委屈和歧视，真是不忍回首，一天要被各种各样的服务人员坏好几次心情。&lt;/p&gt;&lt;h3&gt;吃的东西很难找，排长队&lt;/h3&gt;&lt;p&gt;Vegas的餐厅非常少，质量非常低。在街上走老半天也看不到什么吃的东西。每次走进看似商场的地方，清一色的奢侈品：LV，GUCCI，…… 然后就进到赌场了。恁是看不到吃的东西！&lt;/p&gt;&lt;p&gt;好不容易看到点吃的，大家排着长队，服务态度还非常差。跟纽约，三藩，洛杉矶不一样，Vegas似乎没有任何本地人开的，受好评的餐厅。可以吃的东西，基本上都是在别的地方都有的连锁店快餐。&lt;/p&gt;&lt;p&gt;去吃排名Top 10的“Vegas自助餐”，付了不菲的价钱，排了两个小时，拐了5道弯的长队。店员像学校食堂大妈一样满脸的鄙夷，吆喝着叫你进去，像是赏给你吃的。最后吃到的东西还不如公司的免费午餐，进餐环境还不如嘲杂拥挤的广东dimsum店。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/buffet.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;这现象恐怕只有在Vegas才能遇到。按照普通的标准，排队一小时的餐厅，必然非常好。排队两个小时的餐厅，一定要超级好才行。洛杉矶最好的韩国烧烤，才有可能在过年的时候排两小时的队。在Vegas，这套标准行不通了！而且这些buffet被设计来，在排队的时候，你没法看到里面的食物。等你等了几个小时排到了，进去才发现是那样的质量，后悔已经来不及了。&lt;/p&gt;&lt;p&gt;所有价格合理一点的地方，全都排长队，这包括各种有名的“Vegas自助餐”，Outback Steakhouse, Cheesecake Factory一类的连锁店。Vegas的自助餐名气大，质量差。不要以为排长队，价钱高就是好东西，因为大家到处找不到吃的，只好排长队吃自助了，吃的竟是一些残羹冷炙，连新鲜水果都没有，还不如别的地方的China Buffet。&lt;/p&gt;&lt;p&gt;当然，如果你肯花大价钱去吃某轮胎公司给评了级的餐厅，巨大的盘子里放一勺子东西那种，就另当别论了。反正我是不会给这种谋暴利的人送钱去的，又不想排长队，所以最后发现只有Panda Express和Chipotle之类的快餐可以吃了。如果这些地方都关门了，那就只有到Walgreens里面买块三明治了。如果怕冷不想去Walgreens，那就在房间里吃泡面吧。哦对了，我告诉过你，Vegas的酒店房间里是没有咖啡机的吧？所以也没有开水给你泡面了。&lt;/p&gt;&lt;p&gt;吃的东西质量是如此的差，队是如此的长，以至于M&amp;amp;M&#39;s和Hershey&#39;s这些摆在超市里都没人买的巧克力品牌，居然都可以在大街上开店。各个Starbucks和Walgreens也经常排长队，因为游客找不到吃的，所以跑到这些地方来买三明治和面包当晚餐了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/m-and-m.jpg&quot; width=&quot;40%&quot;&gt;&lt;/p&gt;&lt;p&gt;在Vegas，我第一次遇到Starbucks的店员，为了15美元之小的买卖，要求我出示身份ID，还“指导”我在收据上签字，显示出一副“你会用信用卡吗？”的神色。由于我的信用记录和可靠性极好，从来没丢过信用卡，在其它城市的类似Starbucks的大店，我刷卡是根本不需要签字的，更不要说出示ID了。刷了卡收据也不要，就去等咖啡了，利索得很。一般说来，贫穷地区的小店里使用信用卡，店员要求出示身份ID的几率要大一些，因为如果是被盗的信用卡，他们赔不起。现在这居然发生在了Vegas大街上的Starbucks。这绚丽的霓虹灯之下，到底是什么穷地方，破地方啊，我真的很无语。&lt;/p&gt;&lt;p&gt;Sigh，来到Vegas就意味着营养不良，外带各种心酸……&lt;/p&gt;&lt;h3&gt;想钱想疯了&lt;/h3&gt;&lt;p&gt;到了Vegas，你不是被当成一个人，而是被当成了用来宰割的牛羊。你感觉各种服务设施，不仅是在骗钱，而且是在抢钱。天然条件恶劣的地方，人们一般都特别友好和温暖，乐于助人，然而Vegas是一个例外。它不但是自然界的沙漠，而且是人性的沙漠。你自己要到这沙漠里来，那么所有东西我们都要卖高价，因为你不得不买！&lt;/p&gt;&lt;p&gt;从酒店，商场，到外面的饭店，交通工具，各种show，人们都想给垃圾标上大价钱，不是让虚荣心驱使你去买，就是让“求生”的欲望逼你去买。我是一个不吝惜钱的人，我用的东西都是高质量的。我愿意出大价钱买东西，然而我要求它必须值那个钱，我要求的是优质的产品和服务。Vegas的几乎所有东西都很贵，然而花了钱，你却买不到相应质量的产品和服务。&lt;/p&gt;&lt;p&gt;看似高档的四星级酒店，房间里连咖啡机这么基本的设施都没有。我走遍美国这么多的地方：纽约，波士顿，奥兰多，迈阿密，旧金山，西雅图，夏威夷…… 高中低档的酒店都住过，这是唯一一个没有咖啡机的酒店。连最便宜的Motel，全都有咖啡机。夏威夷海边的高档resort，有咖啡机。唯独Vegas的四星级酒店没有。咖啡机是一个重要的东西，不是因为它可以做咖啡，而是因为它可以用来烧热水。Vegas的自来水，喝起来味道很不好，貌似水质很硬。晚上又冷又干，却只能去售货机买$3一瓶的冷冻瓶装水，喝得直打哆嗦。因为气候实在太干，不一会儿又渴了……&lt;/p&gt;&lt;p&gt;收了每天$30的所谓“Resort Fee”，几乎跟夏威夷设施完善的resort一个价，却没见到酒店为此提供了什么服务。去游泳池泡泡居然还要按天收费，每人每天$17。房间里缺少本来该有的设施，是为了逼迫你到外面去花钱。饿了出去找不到吃的，点个汉堡到房间，20美元！起床稍微晚了一点，回到酒店，发现房间都没有打扫，毛巾都没有换！&lt;/p&gt;&lt;p&gt;路上堵得一塌糊涂，开车还不如走路快。没有通畅的公交工具，只有一个叫“monorail”的架空单轨电车，可以载你经过少于2英里的路程。这个monorail的车子，也不知是哪个城市淘汰的产品，开起来摇摇晃晃，嘎吱的响，仿佛要从半空中掉下去似的。短短不到2英里的路程，单程票价是$5。比较一下，其它城市好几十英里的地铁，也只收$2。&lt;/p&gt;&lt;p&gt;本来这种架空电车应该是用来观光的，然而如此的高价之下，车身窗户上还遮上障眼的纱网，印上巨幅的广告，导致车内光线暗淡，没法畅快的看到外面的风景，像是在坐囚车。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/vegas-monorail.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;&lt;p&gt;作为这个交通工具的消费者，付了高价却不受尊重，被剥夺了一览窗外景物的基本权利。现在世界上的东西，一般是免费的靠广告赚钱，收费的就不会在上面打广告。可是Vegas的monorail既要收高额票价，又要里外打上广告，妨碍视线，真是什么钱都赚。谁叫你没有别的交通工具可以用呢？&lt;/p&gt;&lt;h3&gt;赌场，赌场，还是赌场&lt;/h3&gt;&lt;p&gt;本来对赌场没有什么反感的，觉得小赌娱乐一下也无妨。到了Vegas，却真的对赌场产生了严重的反感。&lt;/p&gt;&lt;p&gt;在Vegas，你被完全剥夺了回避赌场的权利，你无法不经过赌场而到达任何地方。不管多么高大上的酒店，要进到房间，必须走过狭长的赌场过道。要去坐monorail？必须穿过赌场。要买吃的，喝的，穿的？必须穿过赌场。要买show的票？必须穿过赌场。&lt;/p&gt;&lt;p&gt;赌场里空气很不好，充满了烟味，二氧化碳严重超标，氧气不足，所以一进去就觉得胸闷，呼吸不畅，嗓子发痒，甚至头晕目眩。想想吧，你支付着高昂的酒店费用，却被剥夺了直接进入自己房间，而不呼吸污浊空气的基本权利。在这种情况下，本来想小赌一把的我，就打消了这个念头。&lt;/p&gt;&lt;p&gt;到了房间，整装出门逛街。回到酒店，却又不知道客房电梯在哪个旮旯里了。看路牌说“Guest Elevator走这边”，走到一半，发现还是没看见电梯，却没了路牌。不得不找赌场工作人员问（当然，他们态度也不怎么好），才找到回房间的电梯。每一次进酒店，都要经过这么一番摸索折腾，累不累，烦不烦呀。&lt;/p&gt;&lt;p&gt;有些酒店里有看show的剧场，你找到了剧场，却发现剧场旁边找不到售票处（box office）。你需要穿过赌场，跑到另外一边，才能找到box office。如果你用了ticket master之类的服务，还会发现ticket master的取票机不在剧场旁边，也不在box office旁边，而是在赌场的不知道哪个旮旯里……&lt;/p&gt;&lt;p&gt;这其实是赌场老板故意针对人的心理设计的。Vegas的酒店，几个重要设计原则就是：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计一定要没有组织，没有逻辑，让人摸不着头脑，容易迷路。这可以最大限度的迫使人接收到赌场的诱惑。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;迫使你必须经过赌场的诱惑，才能回到自己的房间。途中还会听到一些人歇斯底里的叫声：“哇！赢钱啦！”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;赌场里换气设施故意不做好。这样空气里氧气含量低，二氧化碳和烟味重，可以使人在赌钱的时候头脑不清醒，不能有效地控制自己的行为，以至于输了钱还不赶快撤退。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样的设计，使得你不得不经受很大的诱惑，或许有些人本来不赌钱的，就开始赌，最后输得精光。说真的，你把空气弄好一点，也许我还真的上钩了，可惜就是空气太差，再大的赚钱诱惑对我来说也是白搭。遇到我这么珍惜自己的生命和健康的人，算你们倒霉 :P&lt;/p&gt;&lt;h3&gt;丑陋的Vegas人&lt;/h3&gt;&lt;p&gt;Vegas路上走着的人，除了少数游客，大多穿着老气过时，粗人酒鬼模样。很少看到打扮有格调，有教养的人。不然就是怒目相向，不然就是鬼鬼祟祟的神情。&lt;/p&gt;&lt;p&gt;Vegas是妓女合法化的地方，在这里找小姐是“规范”的，合法的。所以你就可以在大街上看到一些车，打着穿着暴露的美女照片和电话号码，招摇过市。路边也站着很多散发美女小卡片的丑陋男人。&lt;/p&gt;&lt;p&gt;不要被那些靓丽性感的照片迷惑了。请看看大街上的妹纸们，有看得过去的吗？土爆了！如果大街上都没有好看点的妹纸，你觉得花了大价钱就会有漂亮妹纸陪你睡觉吗？你做梦吧。&lt;/p&gt;&lt;p&gt;早就有人报道过说，在Vegas找小姐，是按“项目”收费的。给你一个类似涮涮锅点菜的单子，打几个勾，加起来随便就两三千美元。结果到时候看人，各种穷形尽相的大妈，倒贴钱都没人要的。&lt;/p&gt;&lt;p&gt;所以Vegas的小姐跟其他东西一样，垃圾卖大价钱。所以欲求不满的中国同学们，还是把钱省着回咋们东莞用吧 :P&lt;/p&gt;&lt;p&gt;……还好，我自带了可人的美女来，发小广告的小混混们看到，就自惭形秽的躲开了 :)&lt;/p&gt;&lt;h3&gt;退休明星的舞台&lt;/h3&gt;&lt;p&gt;Vegas最著名的另一个地方，就是它的各种show。Topless的Jubilee show，太阳马戏团的O show和其它，大卫科波菲尔魔术，Elton John演唱会，最近Britney Spears也开始在这里演出。这貌似一个文化丰富的地方？&lt;/p&gt;&lt;p&gt;可是你有没有发现，这些常驻Vegas演show的，其实都不再是当红的明星？你有多少年没看过马戏表演了？你有十几年没见过大卫科波菲尔，Elton John，Britney Spears这些人了吧？能亲眼见到这些儿时崇拜的明星，是不是很激动呢？可惜，他们已经不再是当年的，英俊美丽的，身材不变形，唱歌不走调的他们了。&lt;/p&gt;&lt;p&gt;花了上百的票价，看到的竟是一些人老珠黄。特别是Britney Spears，大街上放着她的广告，各种SM的场景，感觉跟Vegas跳脱衣舞的大妈们差不多了。有一个理论是，当一个明星开始在Vegas常驻现场演出，而不是在电视里面出现的时候，你就知道他已经没落了。&lt;/p&gt;&lt;p&gt;在Vegas，你还会惊讶的发现，多年没在电视上见过的“吉尼斯世界纪录”之类的无聊东西，在街上开店卖票…… 不过呢说真的，那个topless的Jubilee show还真是不错的，属于Vegas比较有特色，有质量的一个show。虽然是topless两点暴露，却一点不感觉色情。还是有点舞台效果和艺术价值的。&lt;/p&gt;&lt;h3&gt;人造风景名胜&lt;/h3&gt;&lt;p&gt;越是文化匮乏的地方越是喜欢附庸风雅。Vegas的酒店，喜欢人造一些“迷你版”的欧洲名胜。比如有个叫Paris的酒店门口，造了一个小型的埃菲尔铁塔…… 等等。这些所谓的名胜，让Vegas成为了一个类似国内“世界乐园”的地方。这些东西材料也不怎么好，所以看上去各种cheap。Caesar Palace门口那雕像，石料肯定不好，不然不会看起来那么脏那么旧。&lt;/p&gt;&lt;p&gt;很多人在这些假的名胜旁边合影留念，让人哭笑不得，仿佛他们从来没见过好的风景。这些人完全不明白旅行的意义是什么，他们照相的目的在于表示自己“到此一游”。在某个酒店里的大厅，我看到大群的人们，对着一些假花和三流水准的圣诞装饰物照相，真是让人匪夷所思。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/photographing.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;&lt;h3&gt;休闲设施匮乏&lt;/h3&gt;&lt;p&gt;Vegas的大街上，Mall里面，很少看到有椅子可以坐。少数人坐在喷水池边上，很冷，其它人都在走路或者站着。你感觉在Vegas最深刻的记忆，就是在不停地走路。这种休闲设施的缺乏，使得Vegas不适合作为休闲旅游的去处。&lt;/p&gt;&lt;p&gt;唯一不缺座位，不需要排队的地方，就是赌场。&lt;/p&gt;&lt;h3&gt;总结&lt;/h3&gt;&lt;p&gt;我怀着一个“朝圣”的心，结果自己颠覆了Vegas，这座很多中国人心目中的“旅游胜地”。如果你是为了赌钱来到Vegas，你也许会喜欢它，然而它绝对不是一个休闲度假的好去处。如果你希望见到热情好客的人民，温馨周到的服务，你一定是会失望的。&lt;/p&gt;&lt;p&gt;如果说去Vegas旅行有它的价值的话，那就是它给了我一个反面的教材，一场心灵的洗礼。我亲眼看见并且经历了人类文明最没落地方。我清楚地知道，我不希望我的国家，我的人民变成那个样子。我不再对赌场之类的“成人游戏”有好奇心，我更加珍惜自己身边美好的人和事物。这是我第一次，也是最后一次，来Las Vegas旅行。我想它还是值得的。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">las-vegas</guid>
<pubDate>Mon, 04 Jan 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>Tesla Model X的车门设计问题</title>
<link>http://yinwang.org/blog-cn/2015/12/21/tesla-model-x</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;Tesla Model X的车门设计问题&lt;/h2&gt;&lt;p&gt;Tesla即将推出的SUV（Model X），不但继承了以上提到的Model S的各种问题（触摸屏，门把，……），而且还制造了新的问题。Model X具有一个别出心裁的车门设计，这车子看起来像一只展翅的鸟：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-x-door.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;这样开的车门貌似更省空间，方便在狭窄的地方开门，而且看起来更酷，有点像McLaren或者Lamborghini。然而这样的设计，在我看来有以下几个问题：&lt;/p&gt;&lt;h3&gt;安全性问题&lt;/h3&gt;&lt;p&gt;由于后门完全由电机控制，在车子失去电力的时候要打开后门，过程复杂得离谱。首先在失去电力的时候，无论如何是不可能在车外把门打开的。这意味着，如果出车祸着火了，消防队员可能没法很快帮你打开车门。&lt;/p&gt;&lt;p&gt;如果你运气好，没有受伤，头脑还清醒，气囊和安全带也没挡住你，那么你必须完成三件复杂的操作，才能逃离Model X：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;揭开车门上扬声器的盖子&lt;/li&gt;
&lt;li&gt;扳动一个隐蔽在那里的机关&lt;/li&gt;
&lt;li&gt;然后自己把车门举起来&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我比较无语…… 如何揭开扬声器的盖子？你需要随时在车里准备好榔头和改锥吗？螺丝藏在哪里的？要知道，用户可不是Tesla雇佣的机械师。这对于车祸逃生是非常不利的设计。如果撞坏了电源，后面的人恐怕无法在合理时间之内逃离。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/falcon-wing-door-powerless.png&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;h3&gt;雨雪天气的麻烦&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/suv-in-snow.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;车门升起时，车的后部上方有很大的空挡。下雨或者下雪的时候，雨雪会乘着车门张开的时候，大量飘进车里。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当车门升起来的时候，夹在门缝里的灰尘和渣滓会掉进车里。车顶上如果有积雪，也会掉进去。设想一下，下雪天开了一会车，打开后门，结果车顶上的雪都掉在后面的人头上了……&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下大雪的时候，后面的车门可能被大雪压住打不开，或者导致电动机超负荷损坏。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于门上的缝隙太长，这种设计更加容易出现由于密封圈老化而漏水的问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;趴车的麻烦&lt;/h3&gt;&lt;p&gt;在顶棚很低的车库里可能会碰到天花板。这是一个很现实的问题，因为很多车库旁边的空间很多，顶棚却很低。比如，这次我到洛杉矶和拉斯维加斯旅游，经常遇到这样的车库：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/garage-low-roof.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;p&gt;总的说来，在非常狭窄的地方开门，其实并不是什么很需要解决的事情。有钱买Model X的人，难道会经常把车停在狭窄的夹缝里吗？为了这种不常见的应用，用得着花这么大功夫设计个车门吗？就算你能开门，人出去之后挤不挤得出去，是另外一回事。如果地方实在太窄，你完全可以让后面的人先下车，然后再进车位。&lt;/p&gt;&lt;p&gt;另外，滑动式的车门同样可以解决这个问题，根本用不着花大成本来实现升起来的车门。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/suv-sliding-door.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;p&gt;如果你知道，Model X的车身宽度为81.6英寸，比Hummer H2, Cadillac Escalade和Ford F-150这样的庞然大物还要宽，你就会发现真正的问题不在于空间不够，而是在于这车实在太宽了。有多少人愿意开这么宽的车，是一个问题。&lt;/p&gt;&lt;h3&gt;实用性问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;顶棚不再能安装货架。不知道滑雪板和kayak之类该绑在哪里。这降低了Model X作为一个SUV（Sport Utility Vehicle）的使用价值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/suv-kayak.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后门上不再能放随身物品。这样后面的乘客会不是很方便。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/suv-back-door.png&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;制造和维修的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这种车门机械非常复杂，容易出问题，维修起来很麻烦。制造起来也很麻烦，以至于一家很有经验的，为奔驰和通用提供配件的德国设备厂商，都没法满足Tesla的要求。请参考这篇&lt;a href=&quot;http://www.theverge.com/2016/1/20/10800140/tesla-lawsuit-hoerbiger-model-x-falcon-wing-door&quot;&gt;新闻&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/falcon-wing-door-machinery.png&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">tesla-model-x</guid>
<pubDate>Mon, 21 Dec 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>写书计划</title>
<link>http://yinwang.org/blog-cn/2015/12/19/book-plan</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;写书计划&lt;/h2&gt;&lt;p&gt;好些人问过我写书的事情。我确实该写本书了。计算机科学，其实根本不是科学，它缺乏基本的科学精神。计算机“科学”里面的少量真知灼见，已经被大量的商业动机和“天才语录”给淹没。这个领域的所谓“知识”，其实90%以上都是扯淡，或者是死板的教条和本本主义。剩下不到10%，却是非常好的东西。&lt;/p&gt;&lt;p&gt;这种瞎蒙混骗的风气，从&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/10/18/turing&quot;&gt;图灵&lt;/a&gt;那一辈就开始了，以至于好的东西和不好的东西，永远的混在了一起，没法区分开来。你可以提出一个完全没用的理论，却仍然有人相信它是伟大的发明，并且拿到图灵奖。很多经典的书籍，其实让人知其然而不知其所以然，很多甚至把简单的问题复杂化。因为它们的目的，其实在于掩盖真相，传播谬论，让人恐惧和糊涂，以至于人们以为计算机科学博大精深，有无穷无尽的东西要学。&lt;/p&gt;&lt;p&gt;我希望能够改变这个格局。上次写的《&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy/&quot;&gt;编程的智慧&lt;/a&gt;》，其实就是这样一本书的开端。这其中的内容，真不是拿一个名校的CS PhD，当个教授或者Principle Engineer，甚至Chief Architect就能搞清楚的。之所以叫做“开端”，是因为它还没有达到我希望的组织和清晰程度。这样的内容以blog的形式出现，已经显示出它的弊端了。Blog组织内容的方式是按时间，blog的单元是文章。由于我希望写出的内容，有效性是接近“永恒”，而且由于内容比较多，需要多层的目录，逻辑组织上blog也无法应付。所以我必须用书的形式写出来。&lt;/p&gt;&lt;p&gt;写这样一本书，不是什么大不了的事情，然而它对于混沌不堪的计算机科学界，恐怕具有转折性的意义，所以我必须使用一种世界上大部分人都能看懂的语言。那种语言在现在看来就是英语。我会把这本书的初稿放在网络上，供人们免费下载阅读，这样他们可以给我有益的反馈，提醒我谬误和不清晰之处。这本书会覆盖计算机科学的方方面面，从程序语言，操作系统，到数据库，网络系统，……&lt;/p&gt;&lt;p&gt;有人可能以为这是一个可望而不可即的，包罗万象的宏伟目标，那只是因为他们没有看穿CS里面的迷雾。如果要面面俱到，照本宣科，把每个子领域的死知识都一股脑写进去，包括每种操作系统命令，每种语言的用法，每个数据库的API，各种乱七八糟的WEB技术，…… 那当然是一辈子也写不完的。然而如果你看透了这层迷雾，就会发现CS里面的精髓部分其实没有很多，它们完全是可以在短时间里掌握的。&lt;/p&gt;&lt;p&gt;所以这本书的定位，在于精髓和创造，而不是细节和死记硬背。我希望把它们共同的精髓提取出来，而去掉其中肤浅的死知识部分。如果你希望它教会你所有的东西，包括某最新语言新加入的特性，或者某最新big data工具的API，那显然是不可能的。有太多的书籍可以教会你那些东西，所以不用我来费工夫。然而我所介绍的精髓概念，应该可以帮助你设计和创造出这样的语言特性和大数据工具，而不只是成为一个被动的使用者。&lt;/p&gt;&lt;p&gt;在初期的时候，我会把书的内容放在网上，供大家免费阅读，提出宝贵意见。等到这本书达到我满意的程度之时，我也愿意让高水平的出版社，印成纸张出版。不过出版社的位置，应该处于“转载”的位置。免费下载的PDF，会一直得到更新和补充。只有这样不断地改进，这本书才能达到我满意的地步。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">book-plan</guid>
<pubDate>Sat, 19 Dec 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>Tesla Model S的设计失误</title>
<link>http://yinwang.org/blog-cn/2015/12/12/tesla-model-s</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;Tesla Model S的设计失误&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-interior.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;这幅美丽的图片，就是红极一时的Tesla电动车Model S的内景。然而你有没有发现，其中有一些不大对劲的地方？虽然我看好电动汽车，它们环保，安静，运动敏捷，然而我发现Tesla的这款Model S，其实有一些严重的设计失误。&lt;/p&gt;&lt;h3&gt;缺少硬件开关，过度依赖软件和触摸屏&lt;/h3&gt;&lt;p&gt;纵观Model S的内景，你会发现这车里面怎么光溜溜的，就没看到几个按钮。确实如此，Model S内部设施的控制，基本上完全靠中间那个很大的触摸屏。&lt;/p&gt;&lt;p&gt;顶棚上有一个天窗，却没看见天窗的开关。通常说来，当人们看见门或者窗户，他们期望有一个开关，设在旁边顺手的地方。然而你在Model S里面一抬头，却看不见任何可以按下或者掰动的开关。顶棚上面几乎是光溜溜的一片：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-sunroof.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;有些人可能觉得这样的设计，比其它车子更加美观，简洁。然而你可能没想到，这种“美观”其实是有代价的。一个很简单的问题是：你怎么打开天窗？答案：你必须使用触摸屏！&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-screen.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;你要在触摸屏上找到一个叫“Controls”的页面，然后从左边的控制栏选择“Sunroof”，然后在右边会出现一个车子的图片，和一个滚动条。你把滚动条往下拉，天窗就打开了……&lt;/p&gt;&lt;h3&gt;把简单的问题复杂化&lt;/h3&gt;&lt;p&gt;然而这种依赖于触摸屏的设计，其实是让简单的问题变复杂，变麻烦了。其它车的天窗开关都是很明显，不需要“找”的，而Tesla的天窗开关，你要找一会儿，甚至找到了还要琢磨一下，才会知道该怎么用。我现在把导致这种结果的原因，详细分析如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;天窗控制器不在天窗旁边。触摸屏跟天窗，处于风马不及的位置。这违反了一条基本的设计原理：控制器应该很容易找到，最好在它所控制的东西上面或者旁边。如果用户想打开天窗，他应该能够在天窗旁边，找到一个明显是用来打开它的开关。几乎所有其它车子，天窗开关都在顶棚上，不知Model S的设计者，为何要抛弃这种久经考验的设计。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;触摸屏上干扰信息太多，不容易找到正确的按钮。触摸屏太大，上面显示着所有控制器的信息。这些控制器的位置，本来可以分布在车的各个部位，现在却集中到了一个仅十几寸的屏幕上面。这当然显示不下，只有放到好几个菜单里面去。&lt;/p&gt;

&lt;p&gt;这些“软件控件”的位置，也不是很符合逻辑。例如，为什么有些控件（比如天窗）在tab里面藏着，而另外有些（比如门锁）直接露在外面？以至于你一眼看去，会不知所措。&lt;/p&gt;

&lt;p&gt;相比之下，大部分其它车的硬件天窗控制器，附近没有很多干扰信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/mercedes-sunroof-control.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个控制器在顶棚上，而且处于控制板的中央位置。旁边只有几个顶灯的开关。这些开关，对应着灯在顶棚上的位置。后面的灯，控制器在后面；前面的灯，控制器在前面；左边的灯，控制器在左边；右边的灯，控制器在右边……&lt;/p&gt;

&lt;p&gt;这种排列方式，在设计学上叫做“自然映射”（natural mapping）。你不需要多次的摸索和记忆，甚至不需要看开关上的标记。只根据开关的相对位置，你就知道哪一个开关控制哪一盏灯。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查找天窗控制器的“逻辑路径”太深。从最开头的触摸屏界面，直到找到打开天窗的控件，你需要进入至少两层菜单。如果菜单之前停留在另外的状态，你还需要点击某个按钮，回到“主界面”，然后还要从上往下进入两级菜单。这种设计所需要的“逻辑路径”，长度&amp;gt;=3。&lt;/p&gt;

&lt;p&gt;这种多层的“间接访问”，很容易把人搞糊涂。对年纪大点的人，几乎是不可用的。就算是年轻人，恐怕也需要摸索一阵子。如果在紧急情况下，或者事先没熟悉过这车的情况下，需要找到控制器（比如通过天窗逃生），恐怕会不知所措。&lt;/p&gt;

&lt;p&gt;比较一下其它车子的设计吧。其它牌子车的顶棚上，一般有一个比较大的，明显是用来打开天窗的开关。不管车子当时处于什么状态，直接伸手就可以摸到这个开关。这种设计所需要的“逻辑路径”，长度=1，也就是说是直接的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;触屏的界面并不直观。仔细观察触屏上的控件，它们的操作方式并不是那么直观的。看到那个滚动条一样的东西，我该是点击呢，还是拖动呢？“VENT”，“OPEN”那几个字的位置，到底表示什么呢？我如何让天窗向上倾斜通风（tilt）？真是有点莫名其妙的感觉，恐怕要看说明书，摸索一会儿才能知道这到底怎么用。&lt;/p&gt;

&lt;p&gt;相比之下，其它牌子汽车的硬件开关的设计，其实非常的直观。开关向后一拉，天窗就打开。向前一推，天窗就关闭。有些车子的天窗可以向上倾斜一定的角度（tilt），所以你可以把这按钮向上一推，天窗就进入倾斜通风的状态。&lt;/p&gt;

&lt;p&gt;这种硬件开关的设计，符合了“自然映射”的原理。天窗的开关，成为了天窗的一个“模型”（model）。开关的位置，正好跟天窗平行。开关的运动方式，跟天窗的运动方式，产生一种“自然”的对应关系。开关向后，天窗也向后。开关向前，天窗也向前。开关被向上推，天窗也向上倾斜。这是非常好的设计。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;触感，力反馈和行车安全&lt;/h3&gt;&lt;p&gt;触摸屏缺乏触感和“力反馈”，无法进行“盲操作”。由于触摸屏是平的，所以它无法提供触觉和力反馈。你无法光靠手就摸到按钮的位置，而必须用眼睛看屏幕。当你找到并且拖动屏幕上的滚动条，你的手指不能得到任何力和振动的反馈。你不能立即感觉到，是否已经真的触发了“开天窗”这个操作。只有当天窗开始移动，你才知道刚才的操作是否成功。&lt;/p&gt;&lt;p&gt;相比之下，硬件天窗开关具有很大的优势。有些车子的天窗开关，设计得符合人体工学，正好符合你的手指的形状。摸起来容易，掰起来舒服，有感觉。手往上一摸，就能找到天窗控制器，之后不用眼睛就能操作。&lt;/p&gt;&lt;p&gt;像天窗开关这种“盲操作”，在开车的时候特别重要，因为开车时你的眼睛应该随时注视前方的道路。如果眼睛开小差去看屏幕了，就可能出车祸。这就跟开车时用手机发短信一样危险。触摸屏看起来很酷，而其实是降低了汽车的安全性。&lt;/p&gt;&lt;h3&gt;系统可靠性：触摸屏是“中央薄弱环节”&lt;/h3&gt;&lt;p&gt;仔细观察一下Model S，你会发现它的内部几乎没有硬件的开关。几乎所有的设施：天窗，空调气孔，窗户，门，后备箱，充电盖，…… 全都是用这个触摸屏来控制。&lt;/p&gt;&lt;p&gt;从系统设计的角度来看，这个触摸屏就是一个“中央薄弱环节”（single point of failure）。只要触摸屏一出问题，你就会失去对几乎所有设施的控制。根据这篇&lt;a href=&quot;http://www.autonews.com/article/20140811/OEM06/140819992/tesla-model-s-has-more-than-its-share-of-problems-consumer-reports&quot;&gt;文章&lt;/a&gt;，有的Tesla用户报告说，他的Model S在12000英里的时候，触摸屏突然坏掉，以至于门把都没法用了！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Just before the car went in for its annual service, at a little over 12,000 miles, the center screen went blank, eliminating access to just about every function of the car…&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;相比之下，其它汽车的硬件开关位置是分散的，它们的电路逻辑是相对独立的。一个开关坏掉了，另外一个还可以用。其它车子的屏幕，一般只用来显示倒车摄像信息，以及音乐娱乐等无关紧要的东西。Tesla用这个屏幕来控制所有的配件，真的是发挥过度了。&lt;/p&gt;&lt;h3&gt;门把的设计问题&lt;/h3&gt;&lt;p&gt;Model S的门把设计也有问题。它的门把是电动的，而其它车的门把，都是机械的。在停止的状态，Model S的门把会自动缩回去，不露一点缝隙：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-door-handle-down.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;当你接近车子的时候，内部的电机会让门把伸出来，这样你就能拉开车门：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-door-handle-up.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;按照Tesla设计师的&lt;a href=&quot;http://www.carbodydesign.com/2013/11/tesla-chief-designer-creating-a-car-from-the-ground-up&quot;&gt;思路&lt;/a&gt;：“第一次接近这部车的时候，你首先接触到的是门把：这应该是一个印象深刻的经历。在你走近的同时，门把也伸出来——就好像是这车子想起了你……”&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;As you approach the car for the first time, the first contact you have with the vehicle is through the door handle: it needs to be a memorable experience […] The idea of this door handles that protrudes from the car as you approach it – [it’s like] the car is already thinking for you.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;多么诗情画意的场景，一部会想起你的车，一个朋友！可惜这美好的第一印象，是经不起现实考验的。等你买下这车，实际用起来的时候，问题就来了。首先，这个门把被人手抓握的部分，是扁平的形状。这种形状非常的不符合人体工学，捏起来会很不舒服，使不上劲。如果车门被冰冻住，或者门被撞变形了，或者有紧急情况需要很快的开门，这门把就会带来很大的麻烦，甚至可能是很危险的。&lt;/p&gt;&lt;p&gt;另外，在寒冷的地区，车停在外面，缩进去的门把会被冰冻住。等你要开门的时候，才发现门把被冻住了，出不来。如果软件出了故障，也可能导致门把出不来。一旦出了这些事情，你就完全失去了打开车门的能力。如果门把是机械的，就算上面有一点冰，一拉把手，冰就碎掉，门就开了。如果实在冻得严重了，你把冰稍微凿一下，一拉就开。Tesla的设计者，貌似完全没考虑过这些“意外”的情况。&lt;/p&gt;&lt;p&gt;没有任何其它牌子的汽车采用像这样的门把设计。从丰田一直到&lt;a href=&quot;http://www.bugatti.com&quot;&gt;Bugatti&lt;/a&gt;，它们的门把全都是机械的，粗壮的，直接就可以拉的。没人在这上面耍花样。你想这应该有原因的吧？由于人的生命安全，在事故的时候依赖于快速地打开车门，门把的设计需要是坚固而可靠的。&lt;/p&gt;&lt;p&gt;只有Tesla别出心裁，搞得门把完全缩进去，跟车门平齐，连个可以用力的地方都没有。门把和车门之间的缝隙很小，所以冻在里面的冰没法凿开。很多人发现这是个讨厌的问题。看看这篇&lt;a href=&quot;https://my.teslamotors.com/it_IT/forum/forums/those-door-handles&quot;&gt;讨论&lt;/a&gt;，你就会发现人们为了这个门把，费了多少脑筋，想出五花八门的解决方案：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;提前远程启动车子，让内部温度起来，化掉把手上的冰&lt;/li&gt;
&lt;li&gt;往门把上泼热水&lt;/li&gt;
&lt;li&gt;放热水袋放在门把上&lt;/li&gt;
&lt;li&gt;停车的时候在门把上贴一块透明胶，发现冻上了就把胶布撕掉&lt;/li&gt;
&lt;li&gt;用电吹风吹&lt;/li&gt;
&lt;li&gt;... ...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管这些方式可不可行，有没有效果，你都可以看到，这门把的设计，其实带来了不必要的麻烦。这样的设计，除了看起来很“未来”几乎没有任何实用价值。买了辆酷车，活得可真累。&lt;/p&gt;&lt;h3&gt;人体工学和舒适性问题&lt;/h3&gt;&lt;p&gt;另外，我发现Model S的触摸屏，其实在一个很不舒服的位置。如果我靠在司机的座位上，我的手是无法顺利地碰到屏幕右边的。我必须启用我的腹肌，稍微坐起来一点，努力伸出右手，才能够得着那个位置。&lt;/p&gt;&lt;p&gt;如果触摸屏的位置稍微往下放一点，倾斜度降低一些，就会方便很多。另外，这个触摸屏真的不需要做那么大。&lt;/p&gt;&lt;p&gt;另外一个奇葩的地方是，触摸屏下方，座位之间，有一片很低的，光溜溜的平面，像个微型的保龄球球道……&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-console.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;&lt;p&gt;这貌似是用来放随身物品的。然而这个空间，由于位置和形状的问题，恐怕不会得到有效的利用。由于平台位置太低，几乎到了地板上，如果往里面放置物品，拿起来会非常的不顺手，甚至需要弯腰下去，而且恐怕会被不小心踢翻。因为整个平面是光滑的，中间也没有挡板，车子加减速时，东西可能会到处乱跑。从美学角度看，这个区域的边界，跟触摸屏线条错位，感觉不流畅，不美观。&lt;/p&gt;&lt;p&gt;另外有用户&lt;a href=&quot;https://my.teslamotors.com/it_CH/forum/forums/cup-holders-and-spilled-coffee&quot;&gt;反映&lt;/a&gt;，Model S的咖啡杯座，被设置在一个很容易被手肘碰翻的位置。某些Tesla的“专家用户”对此的建议是，去买“防溅”的咖啡杯。有些聪明人甚至自己设计，并且用3D打印机山寨了一个架子来放咖啡：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-3d-printed-cup-holder.png&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;我对此举动非常的无语。本来Tesla的设计师应该做好的东西，居然需要自己动手。很不可思议的是，这样不舒服的车，被叫做“豪华车”，价钱是其它牌子的两三倍……&lt;/p&gt;&lt;h3&gt;可靠性问题&lt;/h3&gt;&lt;p&gt;虽然这篇文章里面，我只想指出Model S的设计问题，它其实也有很多可靠性的问题。&lt;/p&gt;&lt;p&gt;最近的一些&lt;a href=&quot;http://jalopnik.com/report-two-thirds-of-early-tesla-model-s-drivetrains-m-1747222846&quot;&gt;报道&lt;/a&gt;指出，由于动力系统的问题，2/3以上的早期Model S，动力系统的寿命都不会超过6万英里。Consumer Reports也&lt;a href=&quot;http://www.consumerreports.org/cars/tesla-reliability-doesnt-match-its-high-performance&quot;&gt;报道&lt;/a&gt;，Model S的可靠性“低于平均水平”。报告指出，Model S存在各种质量问题：触摸屏崩溃，门把失灵，发动机故障，天窗漏水，各种部件嘎吱作响，等等。另外一篇Consumer Report的&lt;a href=&quot;http://www.roadandtrack.com/new-cars/car-technology/news/a27094/consumer-reports-tesla-model-s-not-recommended-on-reliability&quot;&gt;文章&lt;/a&gt;，对各种电动车的可靠性进行了排名，Model S名列倒数第一。&lt;/p&gt;&lt;h3&gt;安全性问题&lt;/h3&gt;&lt;p&gt;2016年1月1号，在挪威的一个Tesla充电站，有一台Model S在充电的时候，莫名其妙起火燃烧（见&lt;a href=&quot;http://www.extremetech.com/extreme/220237-tesla-model-s-catches-fire-at-supercharger-station-in-norway&quot;&gt;新闻&lt;/a&gt;和&lt;a href=&quot;https://www.youtube.com/watch?v=CWXN7ni4FTc&quot;&gt;视频&lt;/a&gt;）。由于着火的材料是锂金属，消防队无法用水控制火势，只能用泡沫覆盖隔离，等待烈火把车子完全融化。最后这台车被完全烧毁，幸好没有人员伤亡。事故起因正在调查之中。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/model-s-burn.jpg&quot; width=&quot;90%&quot;&gt;&lt;/p&gt;&lt;p&gt;Elon Musk对此事故的反应比较让人失望，他说：“美国每年有上万辆汽车起火事故，没有人报道。为什么Tesla的车一起火，媒体就争相报道？” 不好好调查和检讨起火的原因，反倒笑别人“一百步”，这种态度是不可取的。&lt;/p&gt;&lt;p&gt;其实媒体报道Tesla车起火，是有他们的原因的。汽油车着火，一般都是因为有人犯了严重的错误，导致严重的车祸，油箱破裂，又遇上火源或者重击。或者由于车体老化漏油，又碰上火源。而电动车起火，不需要有人犯错误，不需要有严重的车祸，莫名其妙就着火了。你有见过崭新的汽油车，在加油站加油，忽然自己着火吗？&lt;/p&gt;&lt;p&gt;这不是第一辆起火的Model S。世界上只有3万多辆Model S，却已经出现过4起&lt;a href=&quot;https://www.youtube.com/watch?v=q0kjI08n4fg&quot;&gt;起火事件&lt;/a&gt;。之前的一个Model S，半路上底部被硬物撞击。屏幕提示说，电池出了问题，请停车并且撤离。幸好车主按照电脑的指示做了，结果撤离不久之后，车就开始燃烧。如果车主没有停车撤离，后果是相当可怕的。这种对生命危险缺乏明确警示信号，其实也是一种严重的设计问题。&lt;/p&gt;&lt;p&gt;锂电池起火的原因很奇怪，&lt;a href=&quot;https://en.wikipedia.org/wiki/Boeing_787_Dreamliner_battery_problems&quot;&gt;波音787客机&lt;/a&gt;上，出现过多次锂电池起火事故，引起了很大的关注。最后分析原因在于：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;日本GS Yuasa公司制造的电池存在缺陷。&lt;/li&gt;
&lt;li&gt;波音工程师，没有考虑到worse case的电池故障。&lt;/li&gt;
&lt;li&gt;FAA，在认证过程中没有考虑到电池的危险性问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;既然锂电池有这么蹊跷的潜在危险，Tesla的起火事件，当然也应该受到重视。这问题不像Elon Musk说的那么可靠，那么不值一提。&lt;/p&gt;&lt;h3&gt;Autopilot的事故责任问题&lt;/h3&gt;&lt;p&gt;两个月前，Tesla通过“软件更新”，使Model S具有了初级的“自动驾驶”（autopilot）功能。这个功能可以让Model S自动地，沿着有“清晰边界线”的车道行驶，根据前后车辆的速度相应的加速和减速。&lt;/p&gt;&lt;p&gt;这貌似一个很新很酷的功能，咋一看跟Google的自动车有的一拼（其实差得天远）。然而在推出后不久，YouTube上出现了一些视频（&lt;a href=&quot;https://www.youtube.com/watch?v=MrwxEX8qOxA&quot;&gt;视频1&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=Lx3-epk_ztQ&quot;&gt;视频2&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=LJnYCEQwtHs&quot;&gt;视频3&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=rkZ-jhLxrVc&quot;&gt;视频4&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=mLOG1bw3vSM&quot;&gt;视频5&lt;/a&gt;）。它们显示，autopilot在某些情况下有可能进行错误的判断和操作，有些险些造成严重的迎面车祸。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=MrwxEX8qOxA&quot;&gt;
&lt;img src=&quot;http://www.yinwang.org/images/model-s-autopilot-frontal.png&quot; width=&quot;80%&quot;&gt;
&lt;/a&gt;&lt;/p&gt;&lt;p&gt;特别是&lt;a href=&quot;https://www.youtube.com/watch?v=MrwxEX8qOxA&quot;&gt;视频1&lt;/a&gt;显示，在路面线条清晰，天气很好的路上，autopilot忽然向左转向迎面方向的车道，差点导致严重的对撞车祸。仔细观察autopilot转向之前的情况，是由于路面上有阳光投下来的树影。Autopilot误以为那是一个障碍物，所以把车转上了反方向的车道！&lt;/p&gt;&lt;p&gt;从这个简单的视频我们可以看出：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Autopilot没有对图像进行基本的“阴影消除”，它不能区分阴影和障碍物。阳光强烈，阴影明显的时候，autopilot可能把阴影当成障碍物。阴影消除在计算机视觉已经研究挺多了，这说明Tesla有可能没有进行基础的计算机视觉研究。缺乏分辨阴影和障碍物的能力，这样的自动驾驶系统是完全不可接受的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;道路中间有明显的，表示“禁止超车”的双黄线，对面有来车。Autopilot为了避开“障碍”，冒着对撞的危险，左转跨越双黄线。这表示autopilot连基本的交通规则，紧急情况下的正确操作方式都搞不清楚。或者也许这软件里面连双黄线都没有识别，甚至连这个概念都没有。&lt;/p&gt;

&lt;p&gt;对于一个有经验的驾驶员来说，如果发现前方有障碍物，正确的作法不应该是猛烈地转弯避开，而应该是紧急刹车。从视频上我们看出，车子没有刹车减速（保持在37~38），而是猛烈地左转。而且是等树影到了面前，才忽然进行操作，没有计算提前量。这说明设计autopilot的人，连基本的开车常识都不明白。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;让我感到悲哀的是，这些视频的很多评论，大部分都在谩骂车主是傻逼：“这是车主自己的责任！”，“Autopilot只能在高速公路上使用”，“只能在车道上有明确的边界线的时候使用！”，“不能在有很多弯道的地方“，“只能在能够看见前方300米道路的地方使用”，“谁叫你不看说明书的！”…… Elon Musk也在一次&lt;a href=&quot;https://www.youtube.com/watch?v=60-b09XsyqU&quot;&gt;采访&lt;/a&gt;中明确的告诉记者：“如果用户因为使用autopilot而导致了车祸，是用户自己的责任！” 他反复地声明：“autopilot还处于beta版本……” 意思是，你们小心着用！&lt;/p&gt;&lt;p&gt;我对这些说法持不同的观点。首先，Tesla根本就不应该把一个处于&quot;beta状态&quot;的功能，自动推送到所有Model S的系统里面。实际上，像autopilot这种功能，关系到人的生命安全，根本就不应该有&quot;beta版本&quot;或者“测试版本”之说。Tesla把这样不成熟的系统，强制推送给用户，然后又说如果出了事故，用户负所有责任，这是一种推卸责任的做法。要知道，没有任何人愿意拿自己的生命给Tesla做“beta测试”。&lt;/p&gt;&lt;p&gt;另外，就算是用户没有仔细阅读autopilot的使用说明，在“不该”用它的地方（比如路面线条不清晰的地方）使用了autopilot，如果出了车祸，Tesla也应该负完全的责任。理由如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;作为用户，他们没有义务阅读并且深刻的理解autopilot的局限性。在软件行业，存在一种习惯性的“责备用户”的不良风气。如果软件的设计有问题，用户没记住它的毛病，没能有效地绕过，那么如果出了问题，一般被认为是用户的错。Tesla想把软件行业的这种不正之风，引入到人命关天的汽车行业，那显然是行不通的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tesla的autopilot实现方式幼稚，局限性实在太多。天气不好的时候不行，路面上的边界线不清晰也不行，光线不好或者有阴影不行，路上有施工的路桩不行，高速出口不行，…… 实际上，在如此苛刻的限定条件下，任何一个汽车厂商都可以做出Tesla那种autopilot。&lt;/p&gt;

&lt;p&gt;我自己的便宜Honda车，就有偏离车道时发出警告的功能（Lane Drift Warning，LDW）。装个摄像头，来点最简单的图像处理就搞定。在Indiana大学的时候，我们有一门本科级别的课程，就是写代码控制一辆高尔夫球车（也是电动车呢），沿着路面上的线条自动行驶。这根本没什么难度，因为它能正确行驶的条件，实在是太苛刻了。&lt;/p&gt;

&lt;p&gt;其它汽车厂商很清楚这种功能的局限性，所以他们没有大肆吹嘘这种“线检测”的技术，或者把它做成autopilot。他们只是把它作为辅助的，提示性的功能。这些汽车厂商理解，作为一个用户，他们不可能，也不应该记住autopilot能正确工作的种种前提条件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户没有足够的能力来“判断”autopilot正常工作的条件是否满足。比如，路上的线还在，但是被磨损了，颜色很浅，那么autopilot到底能不能用呢？谁也不知道。把判断这些条件是否满足的任务推给用户，就像是在要求用户帮Tesla的工程师debug代码。这显然是不可行的。如果autopilot能够在检测到道路条件不满足的情况下，自动警告用户，并且退出自动驾驶模式，那还稍微合理一些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户也许没有足够的时间来响应条件的改变。Autopilot自动驾驶的时候，车子有可能最初行驶在较好的条件下（天气好，路面线条清晰），然而随着高速行驶，路面条件有可能急速的变化。有可能上一秒还好好的，下一秒路面线条就不再清晰（&lt;a href=&quot;https://www.youtube.com/watch?v=mLOG1bw3vSM&quot;&gt;视频5&lt;/a&gt;貌似这种情况）。路面条件的变化突如其来，驾驶员没有料到。等他们反应过来，想关闭autopilot的时候，车祸已经发生了。这种情况如果上诉到法庭，稍微明理一点的法官，都应该判Tesla败诉。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Autopilot显摆出的“高科技”形象，容易使人产生盲目的信任，以至于疏忽而出现车祸。既然叫做“autopilot”，这意味着它能够不需要人干预，自动驾驶一段时间。既然用户觉得它能自动驾驶，那么他们完全有理由在到达高速路口之前（比如GPS显示还有一个小时才到出口），做一些自己的事情：比如看看手机啊，看看书啊，甚至刷刷牙…… 不然，谁让你叫它是“autopilot”的呢？我坐飞机时，就见过飞行员打开autopilot，上厕所去了。如果启用了autopilot还得一秒钟不停地集中注意力，那恐怕比自己开车还累。自己开车只需要看路，现在有了autopilot，不但要看路，还要盯着方向盘，防止autopilot犯傻出错……&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tesla把“beta版”的autopilot推送给所有的Model S，是对社会安全不负责任的做法。你要明白Murphy&#39;s Law：如果一个东西可能出问题，那么就一定会有人让它出问题。Autopilot的功能不成熟，限制条件很多，不容易被正确使用，这不但对Model S的车主自己，而且对其他人也是一种威胁。汽车不是玩具，随便做个新功能，beta版，让人来试用，是会玩出人命的。我觉得Tesla的autopilot，跟无照驾驶的人一样，应该被法律禁止。由于autopilot的复杂性和潜在的危险性，使用autopilot的用户，应该经过DMV考核，在驾照上注明“能正确使用Tesla autopilot”，才准上路。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关系到人的生命安全的“免责声明”和“用户协议”，在法律上是无效的。在美国，到处都存在“免责声明”之说。比如你去参加学校组织的春游活动，都要叫你签一个“waiver”，说如果出了安全事故或者意外，你不能把学校告上法庭。这种免责声明，一般在法律上都是无效的。如果由于学校的过错而致使你的身体受了损伤，就算你签了这种waiver，照样可以把学校告上法庭。我估计Tesla的autopilot在启动时，也有这样的免责声明，说如果使用autopolit而出现车祸，Tesla不负责任。由于autopilot直接操控了你的车子，如果真的出了车祸，这跟其它的waiver一样，都是无效的。你照样可以上法庭告他们。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于意识到这个问题，知道出了问题自己是逃不掉责任的，Tesla最近又通过强制的软件更新，对autopilot的功能进行了一些&lt;a href=&quot;http://www.reuters.com/article/us-tesla-autopilot-idUSKCN0UO0NM20160110&quot;&gt;限制&lt;/a&gt;，说是为了防止用户“滥用”autopilot做一些“疯狂”的事情。Tesla很疯狂，反倒指责用户“滥用”和“疯狂”。这让人很愤慨。&lt;/p&gt;&lt;p&gt;对autopilot进行限制的同时，Tesla又推出了beta版的“&lt;a href=&quot;http://www.cnet.com/news/tesla-cars-can-now-self-park-at-your-command&quot;&gt;自动趴车&lt;/a&gt;”和“召唤”（summon）功能。这些功能貌似很酷，然而它们也附带了许多的限制条件。你只能在某些地方，满足某种特定条件，才能用这些功能。如果你违反这些条件，出了事故，Tesla声称不负责。&lt;/p&gt;&lt;p&gt;这些能够让车子自己移动的功能，跟autopilot一样，同样会给社会带来安全隐患。比如，有人在不该使用自动趴车和summon功能的地方用了它，就可能会导致车祸。这不是用户的问题，而是Tesla根本不应该发布这些不成熟的技术来哗众取巧。&lt;/p&gt;&lt;h3&gt;对待设计的态度问题&lt;/h3&gt;&lt;p&gt;我发现Tesla的设计团队，在态度上有一些严重的问题。Tesla的总设计师Franz von Holzhausen，在一个&lt;a href=&quot;http://gigaom.com/2013/11/06/how-tesla-overcame-the-challenges-of-electric-car-design-from-the-ground-up&quot;&gt;采访&lt;/a&gt;中谈到，Tesla是如何在“完全没有汽车设计经验”的背景之下，“从零开始”（from ground up）设计出了Model S，好像是非常了不起的成就似的。这位设计师提到：“Tesla是从一张白纸（clean slate）开始，没有已有的思想可以借鉴……”&lt;/p&gt;&lt;p&gt;这其实是而夸大其词。世界上没有任何成功的设计，真的可以从所谓“白纸”开始的，你总是有前人的经验可以学习。不管是前人的成功还是失败，都有借鉴的意义。电动车比起汽油车，其实并不是一个全新的领域，它只不过是动力系统不一样而已。像门，窗，内饰，轮子，减震器，方向盘之类，里面的设计原理，其实都是一样的。&lt;/p&gt;&lt;p&gt;仅仅因为动力不一样，就对前人的经验视而不见，甚至盲目的藐视。这样的态度给用户带来的，是潜在的麻烦甚至危险。有些人喜欢把一个领域说成是全新的，往往是因为他们想“圈地”。所以Tesla的设计师其实是在说，电动车这个领域跟其它汽车公司的都不一样，所以你们都不用跟我竞争啦。同时这也可以让用户以为，只有Tesla才能做出电动车。&lt;/p&gt;&lt;p&gt;另外，我觉得人们对Elon Musk的个人崇拜，导致了很多人对Tesla的问题视而不见，盲目的以为Tesla是好车，豪华车，是最先进的技术。很多人盲目的相信Elon Musk，以为他是天才，他说的，他做的都是对的，而其实并不是这样。有传言说，Model S最早的设计，很多是Elon Musk自作聪明提出来的。后来其中特别不堪的一些，被设计师给去掉了。然而这种盲目“创新”的传统，却在Tesla遗留下来，并且利用媒体向全世界辐射，给大家洗脑。&lt;/p&gt;&lt;p&gt;Tesla标榜自己重视“设计”，其实却歪曲了“设计”这个词的含义。喜欢谈论所谓“用户体验”（User Experience），然而他们所谓的用户体验，只是浮于表面。真正的用户体验，应该是在实质上方便，可靠，舒服，易用。而Tesla所谓的用户体验，强调的是一些肤浅的，没有实质意义的方面，比如让门把自动伸出来，让你感觉它是你的朋友。&lt;/p&gt;&lt;p&gt;Elon Musk甚至在一次&lt;a href=&quot;http://www.cc.com/video-clips/o26y1r/the-colbert-report-elon-musk-pt--1&quot;&gt;采访&lt;/a&gt;中提到，你应该能够给你的车子起个名字，它应该就像你的宠物一样。由此可见，他关心的是什么 :) 说实话，真的有人在乎一个车的门把吗？我怎么觉得他的vision或者价值观有问题。花费很大工夫，试图让你在买车之前产生良好的第一印象，以至于不惜重金。结果买下来之后的日子里，你就发现它的各种毛病——连最便宜的车都没有的毛病。&lt;/p&gt;&lt;p&gt;汽车的设计，很多方面关系到人的生命安全。车上的各种设备，为什么是那个形状，为什么在那个位置，很多都是有理由的。不是你想它是个什么样子，就可以是什么样子的。很多这些经验甚至可能是用生命换来的，经历了战火和各种恶劣环境的考验。这真的不是一个新的公司短短几年就可以摸索清楚的。&lt;/p&gt;&lt;p&gt;有些设计貌似很新，很酷，很未来，像科幻电影里面的一样。直到你开始用它，才发现是有问题的。很多人把Elon Musk比作&lt;a href=&quot;http://www.imdb.com/title/tt0371746&quot;&gt;钢铁侠&lt;/a&gt;，然而他们没有意识到，科幻和现实是有很大区别的。Elon Musk的背景（物理系PhD辍学），也许可以做出高性能的电动机，然而一辆汽车除了发动机，还有很多关键的方面。忘记历史就等于毁灭未来，标新立异，不吸取前人的经验教训，把好的东西学过来，这样做设计是很难成功的。&lt;/p&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">tesla-model-s</guid>
<pubDate>Sat, 12 Dec 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程的智慧</title>
<link>http://yinwang.org/blog-cn/2015/11/21/programming-philosophy</link>
<description>&lt;p&gt;
  　　
  &lt;/p&gt;&lt;h2&gt;编程的智慧&lt;/h2&gt;&lt;p&gt;编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而由于软件行业喜欢标新立异，喜欢把简单的事情搞复杂，我希望这些文字能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。&lt;/p&gt;&lt;h3&gt;反复推敲代码&lt;/h3&gt;&lt;p&gt;既然“天才是百分之一的灵感，百分之九十九的汗水”，那我先来谈谈这汗水的部分吧。有人问我，提高编程水平最有效的办法是什么？我想了很久，终于发现最有效的办法，其实是反反复复地修改和推敲代码。&lt;/p&gt;&lt;p&gt;在IU的时候，由于Dan Friedman的严格教导，我们以写出冗长复杂的代码为耻。如果你代码多写了几行，这老顽童就会大笑，说：“当年我解决这个问题，只写了5行代码，你回去再想想吧……” 当然，有时候他只是夸张一下，故意刺激你的，其实没有人能只用5行代码完成。然而这种提炼代码，减少冗余的习惯，却由此深入了我的骨髓。&lt;/p&gt;&lt;p&gt;有些人喜欢炫耀自己写了多少多少万行的代码，仿佛代码的数量是衡量编程水平的标准。然而，如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。你会制造出越来越多平庸甚至糟糕的代码。在这种意义上，很多人所谓的“工作经验”，跟他代码的质量，其实不一定成正比。如果有几十年的工作经验，却从来不回头去提炼和反思自己的代码，那么他也许还不如一个只有一两年经验，却喜欢反复推敲，仔细领悟的人。&lt;/p&gt;&lt;p&gt;有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。&lt;/p&gt;&lt;p&gt;就像文学作品一样，代码是不可能一蹴而就的。灵感似乎总是零零星星，陆陆续续到来的。任何人都不可能一笔呵成，就算再厉害的程序员，也需要经过一段时间，才能发现最简单优雅的写法。有时候你反复提炼一段代码，觉得到了顶峰，没法再改进了，可是过了几个月再回头来看，又发现好多可以改进和简化的地方。这跟写文章一模一样，回头看几个月或者几年前写的东西，你总能发现一些改进。&lt;/p&gt;&lt;p&gt;所以如果反复提炼代码已经不再有进展，那么你可以暂时把它放下。过几个星期或者几个月再回头来看，也许就有焕然一新的灵感。这样反反复复很多次之后，你就积累起了灵感和智慧，从而能够在遇到新问题的时候直接朝正确，或者接近正确的方向前进。&lt;/p&gt;&lt;h3&gt;写优雅的代码&lt;/h3&gt;&lt;p&gt;人们都讨厌“面条代码”（spaghetti code），因为它就像面条一样绕来绕去，没法理清头绪。那么优雅的代码一般是什么形状的呢？经过多年的观察，我发现优雅的代码，在形状上有一些明显的特征。&lt;/p&gt;&lt;p&gt;如果我们忽略具体的内容，从大体结构上来看，优雅的代码看起来就像是一些整整齐齐，套在一起的盒子。如果跟整理房间做一个类比，就很容易理解。如果你把所有物品都丢在一个很大的抽屉里，那么它们就会全都混在一起。你就很难整理，很难迅速的找到需要的东西。但是如果你在抽屉里再放几个小盒子，把物品分门别类放进去，那么它们就不会到处乱跑，你就可以比较容易的找到和管理它们。&lt;/p&gt;&lt;p&gt;优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。这是因为程序所做的几乎一切事情，都是信息的传递和分支。你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的if语句，它看起来就会像这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (...) {
  if (...) {
    ...
  } else {
    ...
  }
} else if (...) {
  ...
} else {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意到了吗？在我的代码里面，if语句几乎总是有两个分支。它们有可能嵌套，有多层的缩进，而且else分支里面有可能出现少量重复的代码。然而这样的结构，逻辑却非常严密和清晰。在后面我会告诉你为什么if语句最好有两个分支。&lt;/p&gt;&lt;h3&gt;写模块化的代码&lt;/h3&gt;&lt;p&gt;有些人吵着闹着要让程序“模块化”，结果他们的做法是把代码分部到多个文件和目录里面，然后把这些目录或者文件叫做“module”。他们甚至把这些目录分放在不同的VCS repo里面。结果这样的作法并没有带来合作的流畅，而是带来了许多的麻烦。这是因为他们其实并不理解什么叫做“模块”，肤浅的把代码切割开来，分放在不同的位置，其实非但不能达到模块化的目的，而且制造了不必要的麻烦。&lt;/p&gt;&lt;p&gt;真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。&lt;/p&gt;&lt;p&gt;想要达到很好的模块化，你需要做到以下几点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免写太长的函数。如果发现函数太大了，就应该把它拆分成几个更小的。通常我写的函数长度都不超过40行。对比一下，一般笔记本电脑屏幕所能容纳的代码行数是50行。我可以一目了然的看见一个40行的函数，而不需要滚屏。只有40行而不是50行的原因是，我的眼球不转的话，最大的视角只看得到40行代码。&lt;/p&gt;

&lt;p&gt;如果我看代码不转眼球的话，我就能把整片代码完整的映射到我的视觉神经里，这样就算忽然闭上眼睛，我也能看得见这段代码。我发现闭上眼睛的时候，大脑能够更加有效地处理代码，你能想象这段代码可以变成什么其它的形状。40行并不是一个很大的限制，因为函数里面比较复杂的部分，往往早就被我提取出去，做成了更小的函数，然后从原来的函数里面调用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;制造小的工具函数。如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。有些帮助函数也许就只有两行，然而它们却能大大简化主要函数里面的逻辑。&lt;/p&gt;

&lt;p&gt;有些人不喜欢使用小的函数，因为他们想避免函数调用的开销，结果他们写出几百行之大的函数。这是一种过时的观念。现代的编译器都能自动的把小的函数内联（inline）到调用它的地方，所以根本不产生函数调用，也就不会产生任何多余的开销。&lt;/p&gt;

&lt;p&gt;同样的一些人，也爱使用宏（macro）来代替小函数，这也是一种过时的观念。在早期的C语言编译器里，只有宏是静态“内联”的，所以他们使用宏，其实是为了达到内联的目的。然而能否内联，其实并不是宏与函数的根本区别。宏与函数有着巨大的区别（这个我以后再讲），应该尽量避免使用宏。为了内联而使用宏，其实是滥用了宏，这会引起各种各样的麻烦，比如使程序难以理解，难以调试，容易出错等等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个函数只做一件简单的事情。有些人喜欢制造一些“通用”的函数，既可以做这个又可以做那个，它的内部依据某些变量和条件，来“选择”这个函数所要做的事情。比如，你也许写出这样的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  if (getOS().equals(&quot;MacOS&quot;)) {
    a();
  } else {
    b();
  }
  c();
  if (getOS().equals(&quot;MacOS&quot;)) {
    d();
  } else {
    e();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写这个函数的人，根据系统是否为“MacOS”来做不同的事情。你可以看出这个函数里，其实只有&lt;code&gt;c()&lt;/code&gt;是两种系统共有的，而其它的&lt;code&gt;a()&lt;/code&gt;, &lt;code&gt;b()&lt;/code&gt;, &lt;code&gt;d()&lt;/code&gt;, &lt;code&gt;e()&lt;/code&gt;都属于不同的分支。&lt;/p&gt;

&lt;p&gt;这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooMacOS() {
  a();
  c();
  d();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooOther() {
  b();
  c();
  e();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  a();
  b()
  c();
  if (getOS().equals(&quot;MacOS&quot;)) {
    d();
  } else {
    e();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;a()&lt;/code&gt;，&lt;code&gt;b()&lt;/code&gt;，&lt;code&gt;c()&lt;/code&gt;都是一样的，只有&lt;code&gt;d()&lt;/code&gt;和&lt;code&gt;e()&lt;/code&gt;根据系统有所不同。那么你可以把&lt;code&gt;a()&lt;/code&gt;，&lt;code&gt;b()&lt;/code&gt;，&lt;code&gt;c()&lt;/code&gt;提取出去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void preFoo() {
  a();
  b()
  c();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后制造两个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooMacOS() {
  preFoo();
  d();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooOther() {
  preFoo();
  e();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，我们既共享了代码，又做到了每个函数只做一件简单的事情。这样的代码，逻辑就更加清晰。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。有些人写代码，经常用类成员来传递信息，就像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`&quot;&gt; class A {
   String x;

   void findX() {
      ...
      x = ...;
   }

   void foo() {
     findX();
     ...
     print(x);
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 首先，他使用&lt;code&gt;findX()&lt;/code&gt;，把一个值写入成员&lt;code&gt;x&lt;/code&gt;。然后，使用&lt;code&gt;x&lt;/code&gt;的值。这样，&lt;code&gt;x&lt;/code&gt;就变成了&lt;code&gt;findX&lt;/code&gt;和&lt;code&gt;print&lt;/code&gt;之间的数据通道。由于&lt;code&gt;x&lt;/code&gt;属于&lt;code&gt;class A&lt;/code&gt;，这样程序就失去了模块化的结构。由于这两个函数依赖于成员x，它们不再有明确的输入和输出，而是依赖全局的数据。&lt;code&gt;findX&lt;/code&gt;和&lt;code&gt;foo&lt;/code&gt;不再能够离开&lt;code&gt;class A&lt;/code&gt;而存在，而且由于类成员还有可能被其他代码改变，代码变得难以理解，难以确保正确性。&lt;/p&gt;

&lt;p&gt; 如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个class，而且更加容易理解，不易出错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`&quot;&gt; String findX() {
    ...
    x = ...;
    return x;
 }
 void foo() {
   int x = findX();
   print(x);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;写可读的代码&lt;/h3&gt;&lt;p&gt;有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。&lt;/p&gt;&lt;p&gt;实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。&lt;/p&gt;&lt;p&gt;有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。这样的情况应该少出现，否则这意味着整个代码的设计都有问题。&lt;/p&gt;&lt;p&gt;如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// put elephant1 into fridge2
put(elephant1, fridge2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我的函数名&lt;code&gt;put&lt;/code&gt;，加上两个有意义的变量名&lt;code&gt;elephant1&lt;/code&gt;和&lt;code&gt;fridge2&lt;/code&gt;，已经说明了这是在干什么（把大象放进冰箱），所以上面那句注释完全没有必要。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部变量应该尽量接近使用它的地方。有些人喜欢在函数最开头定义很多局部变量，然后在下面很远的地方使用它，就像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  int index = ...;
  ...
  ...
  bar(index);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于这中间都没有使用过&lt;code&gt;index&lt;/code&gt;，也没有改变过它所依赖的数据，所以这个变量定义，其实可以挪到接近使用它的地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  ...
  ...
  int index = ...;
  bar(index);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样读者看到&lt;code&gt;bar(index)&lt;/code&gt;，不需要向上看很远就能发现&lt;code&gt;index&lt;/code&gt;是如何算出来的。而且这种短距离，可以加强读者对于这里的“计算顺序”的理解。否则如果index在顶上，读者可能会怀疑，它其实保存了某种会变化的数据，或者它后来又被修改过。如果index放在下面，读者就清楚的知道，index并不是保存了什么可变的值，而且它算出来之后就没变过。&lt;/p&gt;

&lt;p&gt;如果你看透了局部变量的本质——它们就是电路里的导线，那你就能更好的理解近距离的好处。变量定义离用的地方越近，导线的长度就越短。你不需要摸着一根导线，绕来绕去找很远，就能发现接收它的端口，这样的电路就更容易理解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部变量名字应该简短。这貌似跟第一点相冲突，简短的变量名怎么可能有意义呢？注意我这里说的是局部变量，因为它们处于局部，再加上第2点已经把它放到离使用位置尽量近的地方，所以根据上下文你就会容易知道它的意思：&lt;/p&gt;

&lt;p&gt;比如，你有一个局部变量，表示一个操作是否成功：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boolean successInDeleteFile = deleteFile(&quot;foo.txt&quot;);
if (successInDeleteFile) {
  ...
} else {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个局部变量&lt;code&gt;successInDeleteFile&lt;/code&gt;大可不必这么啰嗦。因为它只用过一次，而且用它的地方就在下面一行，所以读者可以轻松发现它是&lt;code&gt;deleteFile&lt;/code&gt;返回的结果。如果你把它改名为&lt;code&gt;success&lt;/code&gt;，其实读者根据一点上下文，也知道它表示&quot;success in deleteFile&quot;。所以你可以把它改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boolean success = deleteFile(&quot;foo.txt&quot;);
if (success) {
  ...
} else {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的写法不但没漏掉任何有用的语义信息，而且更加易读。&lt;code&gt;successInDeleteFile&lt;/code&gt;这种&quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/CamelCase&quot;&gt;camelCase&lt;/a&gt;&quot;，如果超过了三个单词连在一起，其实是很碍眼的东西。所以如果你能用一个单词表示同样的意义，那当然更好。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要重用局部变量。很多人写代码不喜欢定义新的局部变量，而喜欢“重用”同一个局部变量，通过反复对它们进行赋值，来表示完全不同意思。比如这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String msg;
if (...) {
  msg = &quot;succeed&quot;;
  log.info(msg);
} else {
  msg = &quot;failed&quot;;
  log.info(msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然这样在逻辑上是没有问题的，然而却不易理解，容易混淆。变量&lt;code&gt;msg&lt;/code&gt;两次被赋值，表示完全不同的两个值。它们立即被&lt;code&gt;log.info&lt;/code&gt;使用，没有传递到其它地方去。这种赋值的做法，把局部变量的作用域不必要的增大，让人以为它可能在将来改变，也许会在其它地方被使用。更好的做法，其实是定义两个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (...) {
  String msg = &quot;succeed&quot;;
  log.info(msg);
} else {
  String msg = &quot;failed&quot;;
  log.info(msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于这两个&lt;code&gt;msg&lt;/code&gt;变量的作用域仅限于它们所处的if语句分支，你可以很清楚的看到这两个&lt;code&gt;msg&lt;/code&gt;被使用的范围，而且知道它们之间没有任何关系。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把复杂的逻辑提取出去，做成“帮助函数”。有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，这样你就可以使用有意义的函数名来代替注释。举一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
// put elephant1 into fridge2
openDoor(fridge2);
if (elephant1.alive()) {
  ...
} else {
   ...
}
closeDoor(fridge2);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你把这片代码提出去定义成一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void put(Elephant elephant, Fridge fridge) {
  openDoor(fridge);
  if (elephant.alive()) {
    ...
  } else {
     ...
  }
  closeDoor(fridge);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样原来的代码就可以改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
put(elephant1, fridge2);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更加清晰，而且注释也没必要了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把复杂的表达式提取出去，做成中间变量。有些人听说“函数式编程”是个好东西，也不理解它的真正含义，就在代码里大量使用嵌套的函数。像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pizza pizza = makePizza(crust(salt(), butter()),
   topping(onion(), tomato(), sausage()));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码一行太长，而且嵌套太多，不容易看清楚。其实训练有素的函数式程序员，都知道中间变量的好处，不会盲目的使用嵌套的函数。他们会把这代码变成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Crust crust = crust(salt(), butter());
Topping topping = topping(onion(), tomato(), sausage());
Pizza pizza = makePizza(crust, topping);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写，不但有效地控制了单行代码的长度，而且由于引入的中间变量具有“意义”，步骤清晰，变得很容易理解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在合理的地方换行。对于绝大部分的程序语言，代码的逻辑是和空白字符无关的，所以你可以在几乎任何地方换行，你也可以不换行。这样的语言设计是个好东西，因为它给了程序员自由控制自己代码格式的能力。然而，它也引起了一些问题，因为很多人不知道如何合理的换行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  有些人喜欢利用IDE的自动换行机制，编辑之后用一个热键把整个代码重新格式化一遍，IDE就会把超过行宽限制的代码自动折行。可是这种自动这行，往往没有根据代码的逻辑来进行，不能帮助理解代码。自动换行之后可能产生这样的代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   if (someLongCondition1() &amp;amp;&amp;amp; someLongCondition2() &amp;amp;&amp;amp; someLongCondition3() &amp;amp;&amp;amp; 
     someLongCondition4()) {
     ...
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   由于&lt;code&gt;someLongCondition4()&lt;/code&gt;超过了行宽限制，被编辑器自动换到了下面一行。虽然满足了行宽限制，换行的位置却是相当任意的，它并不能帮助人理解这代码的逻辑。这几个boolean表达式，全都用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;连接，所以它们其实处于平等的地位。为了表达这一点，当需要折行的时候，你应该把每一个表达式都放到新的一行，就像这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   if (someLongCondition1() &amp;amp;&amp;amp; 
       someLongCondition2() &amp;amp;&amp;amp; 
       someLongCondition3() &amp;amp;&amp;amp; 
       someLongCondition4()) {
     ...
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   这样每一个条件都对齐，里面的逻辑就很清楚了。再举个例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   log.info(&quot;failed to find file {} for command {}, with exception {}&quot;, file, command,
     exception);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   这行因为太长，被自动折行成这个样子。&lt;code&gt;file&lt;/code&gt;，&lt;code&gt;command&lt;/code&gt;和&lt;code&gt;exception&lt;/code&gt;本来是同一类东西，却有两个留在了第一行，最后一个被折到第二行。它就不如手动换行成这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;```&quot;&gt;   log.info(&quot;failed to find file {} for command {}, with exception {}&quot;,
     file, command, exception);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   把格式字符串单独放在一行，而把它的参数一并放在另外一行，这样逻辑就更加清晰。&lt;/p&gt;&lt;p&gt;   为了避免IDE把这些手动调整好的换行弄乱，很多IDE（比如IntelliJ）的自动格式化设定里都有“保留原来的换行符”的设定。如果你发现IDE的换行不符合逻辑，你可以修改这些设定，然后在某些地方保留你自己的手动换行。&lt;/p&gt;&lt;p&gt;说到这里，我必须警告你，这里所说的“不需注释，让代码自己解释自己”，并不是说要让代码看起来像某种自然语言。有个叫Chai的JavaScript测试工具，可以让你这样写代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;expect(foo).to.be.a(&#39;string&#39;);
expect(foo).to.equal(&#39;bar&#39;);
expect(foo).to.have.length(3);
expect(tea).to.have.property(&#39;flavors&#39;).with.length(3);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种做法是极其错误的。程序语言本来就比自然语言简单清晰，这种写法让它看起来像自然语言的样子，反而变得复杂难懂了。&lt;/p&gt;&lt;h3&gt;写简单的代码&lt;/h3&gt;&lt;p&gt;程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。&lt;/p&gt;&lt;p&gt;并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，“新”的特性，我基本都只用经过千锤百炼，我觉得值得信赖的那一套。&lt;/p&gt;&lt;p&gt;现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免使用自增减表达式（i++，++i，i--，--i）。这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。&lt;/p&gt;

&lt;p&gt;其实这两个表达式完全可以分解成两步，把读和写分开：一步更新i的值，另外一步使用i的值。比如，如果你想写&lt;code&gt;foo(i++)&lt;/code&gt;，你完全可以把它拆成&lt;code&gt;int t = i; i += 1; foo(t);&lt;/code&gt;。如果你想写&lt;code&gt;foo(++i)&lt;/code&gt;，可以拆成&lt;code&gt;i += 1; foo(i);&lt;/code&gt; 拆开之后的代码，含义完全一致，却清晰很多。到底更新是在取值之前还是之后，一目了然。&lt;/p&gt;

&lt;p&gt;有人也许以为i++或者++i的效率比拆开之后要高，这只是一种错觉。这些代码经过基本的编译器优化之后，生成的机器代码是完全没有区别的。自增减表达式只有在两种情况下才可以安全的使用。一种是在for循环的update部分，比如&lt;code&gt;for(int i = 0; i &amp;lt; 5; i++)&lt;/code&gt;。另一种情况是写成单独的一行，比如&lt;code&gt;i++;&lt;/code&gt;。这两种情况是完全没有歧义的。你需要避免其它的情况，比如用在复杂的表达式里面，比如&lt;code&gt;foo(i++)&lt;/code&gt;，&lt;code&gt;foo(++i) + foo(i)&lt;/code&gt;，…… 没有人应该知道，或者去追究这些是什么意思。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;永远不要省略花括号。很多语言允许你在某种情况下省略掉花括号，比如C，Java都允许你在if语句里面只有一句话的时候省略掉花括号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (...) 
  action1();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;咋一看少打了两个字，多好。可是这其实经常引起奇怪的问题。比如，你后来想要加一句话&lt;code&gt;action2()&lt;/code&gt;到这个if里面，于是你就把代码改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (...) 
  action1();
  action2();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了美观，你很小心的使用了&lt;code&gt;action1()&lt;/code&gt;的缩进。咋一看它们是在一起的，所以你下意识里以为它们只会在if的条件为真的时候执行，然而&lt;code&gt;action2()&lt;/code&gt;却其实在if外面，它会被无条件的执行。我把这种现象叫做“光学幻觉”（optical illusion），理论上每个程序员都应该发现这个错误，然而实际上却容易被忽视。&lt;/p&gt;

&lt;p&gt;那么你问，谁会这么傻，我在加入&lt;code&gt;action2()&lt;/code&gt;的时候加上花括号不就行了？可是从设计的角度来看，这样其实并不是合理的作法。首先，也许你以后又想把&lt;code&gt;action2()&lt;/code&gt;去掉，这样你为了样式一致，又得把花括号拿掉，烦不烦啊？其次，这使得代码样式不一致，有的if有花括号，有的又没有。况且，你为什么需要记住这个规则？如果你不问三七二十一，只要是if-else语句，把花括号全都打上，就可以想都不用想了，就当C和Java没提供给你这个特殊写法。这样就可以保持完全的一致性，减少不必要的思考。&lt;/p&gt;

&lt;p&gt;有人可能会说，全都打上花括号，只有一句话也打上，多碍眼啊？然而经过实行这种编码规范几年之后，我并没有发现这种写法更加碍眼，反而由于花括号的存在，使得代码界限明确，让我的眼睛负担更小了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合理使用括号，不要盲目依赖操作符优先级。利用操作符的优先级来减少括号，对于&lt;code&gt;1 + 2 * 3&lt;/code&gt;这样常见的算数表达式，是没问题的。然而有些人如此的仇恨括号，以至于他们会写出&lt;code&gt;2 &amp;lt;&amp;lt; 7 - 2 * 3&lt;/code&gt;这样的表达式，而完全不用括号。&lt;/p&gt;

&lt;p&gt;这里的问题，在于移位操作&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的优先级，是很多人不熟悉，而且是违反常理的。由于&lt;code&gt;x &amp;lt;&amp;lt; 1&lt;/code&gt;相当于把&lt;code&gt;x&lt;/code&gt;乘以2，很多人误以为这个表达式相当于&lt;code&gt;(2 &amp;lt;&amp;lt; 7) - (2 * 3)&lt;/code&gt;，所以等于250。然而实际上&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的优先级比加法&lt;code&gt;+&lt;/code&gt;还要低，所以这表达式其实相当于&lt;code&gt;2 &amp;lt;&amp;lt; (7 - 2 * 3)&lt;/code&gt;，所以等于4！&lt;/p&gt;

&lt;p&gt;解决这个问题的办法，不是要每个人去把操作符优先级表给硬背下来，而是合理的加入括号。比如上面的例子，最好直接加上括号写成&lt;code&gt;2 &amp;lt;&amp;lt; (7 - 2 * 3)&lt;/code&gt;。虽然没有括号也表示同样的意思，但是加上括号就更加清晰，读者不再需要死记&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的优先级就能理解代码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免使用continue和break。循环语句（for，while）里面出现return是没问题的，然而如果你使用了continue或者break，就会让循环的逻辑和终止条件变得复杂，难以确保正确。&lt;/p&gt;

&lt;p&gt;出现continue或者break的原因，往往是对循环的逻辑没有想清楚。如果你考虑周全了，应该是几乎不需要continue或者break的。如果你的循环里出现了continue或者break，你就应该考虑改写这个循环。改写循环的办法有多种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。&lt;/li&gt;
&lt;li&gt;如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。&lt;/li&gt;
&lt;li&gt;有时候你可以把break替换成return，从而去掉break。&lt;/li&gt;
&lt;li&gt;如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;下面我对这些情况举一些例子。&lt;/p&gt;

&lt;p&gt;情况1：下面这段代码里面有一个continue：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; goodNames = new ArrayList&amp;lt;&amp;gt;();
for (String name: names) {
  if (name.contains(&quot;bad&quot;)) {
    continue;
  }
  goodNames.add(name);
  ...
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它说：“如果name含有&#39;bad&#39;这个词，跳过后面的循环代码……” 注意，这是一种“负面”的描述，它不是在告诉你什么时候“做”一件事，而是在告诉你什么时候“不做”一件事。为了知道它到底在干什么，你必须搞清楚continue会导致哪些语句被跳过了，然后脑子里把逻辑反个向，你才能知道它到底想做什么。这就是为什么含有continue和break的循环不容易理解，它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。&lt;/p&gt;

&lt;p&gt;其实，我们只需要把continue的条件反向，这段代码就可以很容易的被转换成等价的，不含continue的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; goodNames = new ArrayList&amp;lt;&amp;gt;();
for (String name: names) {
  if (!name.contains(&quot;bad&quot;)) {
    goodNames.add(name);
    ...
  }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;goodNames.add(name);&lt;/code&gt;和它之后的代码全部被放到了if里面，多了一层缩进，然而continue却没有了。你再读这段代码，就会发现更加清晰。因为它是一种更加“正面”地描述。它说：“在name不含有&#39;bad&#39;这个词的时候，把它加到goodNames的链表里面……”&lt;/p&gt;

&lt;p&gt;情况2：for和while头部都有一个循环的“终止条件”，那本来应该是这个循环唯一的退出条件。如果你在循环中间有break，它其实给这个循环增加了一个退出条件。你往往只需要把这个条件合并到循环头部，就可以去掉break。&lt;/p&gt;

&lt;p&gt;比如下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (condition1) {
  ...
  if (condition2) {
    break;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当condition成立的时候，break会退出循环。其实你只需要把condition2反转之后，放到while头部的终止条件，就可以去掉这种break语句。改写后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (condition1 &amp;amp;&amp;amp; !condition2) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情况表面上貌似只适用于break出现在循环开头或者末尾的时候，然而其实大部分时候，break都可以通过某种方式，移动到循环的开头或者末尾。具体的例子我暂时没有，等出现的时候再加进来。&lt;/p&gt;

&lt;p&gt;情况3：很多break退出循环之后，其实接下来就是一个return。这种break往往可以直接换成return。比如下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean hasBadName(List&amp;lt;String&amp;gt; names) {
    boolean result = false;

    for (String name: names) {
        if (name.contains(&quot;bad&quot;)) {
            result = true;
            break;
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数检查names链表里是否存在一个名字，包含“bad”这个词。它的循环里包含一个break语句。这个函数可以被改写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean hasBadName(List&amp;lt;String&amp;gt; names) {
    for (String name: names) {
        if (name.contains(&quot;bad&quot;)) {
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改进后的代码，在name里面含有“bad”的时候，直接用&lt;code&gt;return true&lt;/code&gt;返回，而不是对result变量赋值，break出去，最后才返回。如果循环结束了还没有return，那就返回false，表示没有找到这样的名字。使用return来代替break，这样break语句和result这个变量，都一并被消除掉了。&lt;/p&gt;

&lt;p&gt;我曾经见过很多其他使用continue和break的例子，几乎无一例外的可以被消除掉，变换后的代码变得清晰很多。我的经验是，99%的break和continue，都可以通过替换成return语句，或者翻转if条件的方式来消除掉。剩下的1%含有复杂的逻辑，但也可以通过提取一个帮助函数来消除掉。修改之后的代码变得容易理解，容易确保正确。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;写直观的代码&lt;/h3&gt;&lt;p&gt;我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。比如，Unix命令行有一种“巧妙”的写法是这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;command1 &amp;amp;&amp;amp; command2 &amp;amp;&amp;amp; command3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于Shell语言的逻辑操作&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;具有“短路”的特性，如果&lt;code&gt;a&lt;/code&gt;等于false，那么&lt;code&gt;b&lt;/code&gt;就没必要执行了。这就是为什么当command1成功，才会执行command2，当command2成功，才会执行command3。同样，&lt;/p&gt;&lt;pre&gt;&lt;code&gt;command1 || command2 || command3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;操作符&lt;code&gt;||&lt;/code&gt;也有类似的特性。上面这个命令行，如果command1成功，那么command2和command3都不会被执行。如果command1失败，command2成功，那么command3就不会被执行。&lt;/p&gt;&lt;p&gt;这比起用if语句来判断失败，似乎更加巧妙和简洁，所以有人就借鉴了这种方式，在程序的代码里也使用这种方式。比如他们可能会写这样的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (action1() || action2() &amp;amp;&amp;amp; action3()) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你看得出来这代码是想干什么吗？action2和action3什么条件下执行，什么条件下不执行？也许稍微想一下，你知道它在干什么：“如果action1失败了，执行action2，如果action2成功了，执行action3”。然而那种语义，并不是直接的“映射”在这代码上面的。比如“失败”这个词，对应了代码里的哪一个字呢？你找不出来，因为它包含在了&lt;code&gt;||&lt;/code&gt;的语义里面，你需要知道&lt;code&gt;||&lt;/code&gt;的短路特性，以及逻辑或的语义才能知道这里面在说“如果action1失败……”。每一次看到这行代码，你都需要思考一下，这样积累起来的负荷，就会让人很累。&lt;/p&gt;&lt;p&gt;其实，这种写法是滥用了逻辑操作&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;和&lt;code&gt;||&lt;/code&gt;的短路特性。这两个操作符可能不执行右边的表达式，原因是为了机器的执行效率，而不是为了给人提供这种“巧妙”的用法。这两个操作符的本意，只是作为逻辑操作，它们并不是拿来给你代替if语句的。也就是说，它们只是碰巧可以达到某些if语句的效果，但你不应该因此就用它来代替if语句。如果你这样做了，就会让代码晦涩难懂。&lt;/p&gt;&lt;p&gt;上面的代码写成笨一点的办法，就会清晰很多：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (!action1()) {
  if (action2()) {
    action3();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我很明显的看出这代码在说什么，想都不用想：如果action1()失败了，那么执行action2()，如果action2()成功了，执行action3()。你发现这里面的一一对应关系吗？&lt;code&gt;if&lt;/code&gt;=如果，&lt;code&gt;!&lt;/code&gt;=失败，…… 你不需要利用逻辑学知识，就知道它在说什么。&lt;/p&gt;&lt;h3&gt;写无懈可击的代码&lt;/h3&gt;&lt;p&gt;在之前一节里，我提到了自己写的代码里面很少出现只有一个分支的if语句。我写出的if语句，大部分都有两个分支，所以我的代码很多看起来是这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (...) {
  if (...) {
    ...
    return false;
  } else {
    return true;
  }
} else if (...) {
  ...
  return false;
} else {
  return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。&lt;/p&gt;&lt;p&gt;很多人写if语句喜欢省略else的分支，因为他们觉得有些else分支的代码重复了。比如我的代码里，两个else分支都是&lt;code&gt;return true&lt;/code&gt;。为了避免重复，他们省略掉那两个else分支，只在最后使用一个&lt;code&gt;return true&lt;/code&gt;。这样，缺了else分支的if语句，控制流自动“掉下去”，到达最后的&lt;code&gt;return true&lt;/code&gt;。他们的代码看起来像这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (...) {
  if (...) {
    ...
    return false;
  } 
} else if (...) {
  ...
  return false;
} 
return true;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种写法看似更加简洁，避免了重复，然而却很容易出现疏忽和漏洞。嵌套的if语句省略了一些else，依靠语句的“控制流”来处理else的情况，是很难正确的分析和推理的。如果你的if条件里使用了&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;和&lt;code&gt;||&lt;/code&gt;之类的逻辑运算，就更难看出是否涵盖了所有的情况。&lt;/p&gt;&lt;p&gt;由于疏忽而漏掉的分支，全都会自动“掉下去”，最后返回意想不到的结果。即使你看一遍之后确信是正确的，每次读这段代码，你都不能确信它照顾了所有的情况，又得重新推理一遍。这简洁的写法，带来的是反复的，沉重的头脑开销。这就是所谓“面条代码”，因为程序的逻辑分支，不是像一棵枝叶分明的树，而是像面条一样绕来绕去。&lt;/p&gt;&lt;p&gt;另外一种省略else分支的情况是这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String s = &quot;&quot;;
if (x &amp;lt; 5) {
  s = &quot;ok&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写这段代码的人，脑子里喜欢使用一种“缺省值”的做法。&lt;code&gt;s&lt;/code&gt;缺省为null，如果x&amp;lt;5，那么把它改变（mutate）成“ok”。这种写法的缺点是，当&lt;code&gt;x&amp;lt;5&lt;/code&gt;不成立的时候，你需要往上面看，才能知道s的值是什么。这还是你运气好的时候，因为s就在上面不远。很多人写这种代码的时候，s的初始值离判断语句有一定的距离，中间还有可能插入一些其它的逻辑和赋值操作。这样的代码，把变量改来改去的，看得人眼花，就容易出错。&lt;/p&gt;&lt;p&gt;现在比较一下我的写法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String s;
if (x &amp;lt; 5) {
  s = &quot;ok&quot;;
} else {
  s = &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种写法貌似多打了一两个字，然而它却更加清晰。这是因为我们明确的指出了&lt;code&gt;x&amp;lt;5&lt;/code&gt;不成立的时候，s的值是什么。它就摆在那里，它是&lt;code&gt;&quot;&quot;&lt;/code&gt;（空字符串）。注意，虽然我也使用了赋值操作，然而我并没有“改变”s的值。s一开始的时候没有值，被赋值之后就再也没有变过。我的这种写法，通常被叫做更加“函数式”，因为我只赋值一次。&lt;/p&gt;&lt;p&gt;如果我漏写了else分支，Java编译器是不会放过我的。它会抱怨：“在某个分支，s没有被初始化。”这就强迫我清清楚楚的设定各种条件下s的值，不漏掉任何一种情况。&lt;/p&gt;&lt;p&gt;当然，由于这个情况比较简单，你还可以把它写成这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String s = x &amp;lt; 5 ? &quot;ok&quot; : &quot;&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于更加复杂的情况，我建议还是写成if语句为好。&lt;/p&gt;&lt;h3&gt;正确处理错误&lt;/h3&gt;&lt;p&gt;使用有两个分支的if语句，只是我的代码可以达到无懈可击的其中一个原因。这样写if语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。&lt;/p&gt;&lt;p&gt;程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。&lt;/p&gt;&lt;p&gt;错误处理是一个古老的问题，可是经过了几十年，还是很多人没搞明白。Unix的系统API手册，一般都会告诉你可能出现的返回值和错误信息。比如，Linux的&lt;a href=&quot;http://man7.org/linux/man-pages/man2/read.2.html&quot;&gt;read&lt;/a&gt;系统调用手册里面有如下内容：&lt;/p&gt;&lt;pre&gt;
RETURN VALUE 
On success, the number of bytes read is returned... 

On error, -1 is returned, and errno is set appropriately.
&lt;p&gt;
ERRORS

EAGAIN, EBADF, EFAULT, EINTR, EINVAL, ...
&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;很多初学者，都会忘记检查&lt;code&gt;read&lt;/code&gt;的返回值是否为-1，觉得每次调用&lt;code&gt;read&lt;/code&gt;都得检查返回值真繁琐，不检查貌似也相安无事。这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就必须要对这个-1作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。&lt;/p&gt;&lt;p&gt;对于Java来说，这相对方便一些。Java的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union类型”。比如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String foo() throws MyException {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里MyException是一个错误返回。你可以认为这个函数返回一个union类型：&lt;code&gt;{String, MyException}&lt;/code&gt;。任何调用&lt;code&gt;foo&lt;/code&gt;的代码，必须对MyException作出合理的处理，才有可能确保程序的正确运行。Union类型是一种相当先进的类型，目前只有极少数语言（比如Typed Racket）具有这种类型，我在这里提到它，只是为了方便解释概念。掌握了概念之后，你其实可以在头脑里实现一个union类型系统，这样使用普通的语言也能写出可靠的代码。&lt;/p&gt;&lt;p&gt;由于Java的类型系统强制要求函数在类型里面声明可能出现的异常，而且强制调用者处理可能出现的异常，所以基本上不可能出现由于疏忽而漏掉的情况。但有些Java程序员有一种恶习，使得这种安全机制几乎完全失效。每当编译器报错，说“你没有catch这个foo函数可能出现的异常”时，有些人想都不想，直接把代码改成这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;try {
  foo();
} catch (Exception e) {}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者最多在里面放个log，或者干脆把自己的函数类型上加上&lt;code&gt;throws Exception&lt;/code&gt;，这样编译器就不再抱怨。这些做法貌似很省事，然而都是错误的，你终究会为此付出代价。&lt;/p&gt;&lt;p&gt;如果你把异常catch了，忽略掉，那么你就不知道foo其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。这当然迟早会出问题，因为你根本不知道自己在干什么。&lt;/p&gt;&lt;p&gt;catch异常的时候，你不应该使用Exception这么宽泛的类型。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，因为它会不经意的catch住另外的异常（比如B）。你的代码逻辑是基于判断A是否出现，可你却catch所有的异常（Exception类），所以当其它的异常B出现的时候，你的代码就会出现莫名其妙的问题，因为你以为A出现了，而其实它没有。这种bug，有时候甚至使用debugger都难以发现。&lt;/p&gt;&lt;p&gt;如果你在自己函数的类型加上&lt;code&gt;throws Exception&lt;/code&gt;，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着&lt;code&gt;throws Exception&lt;/code&gt;，这毛病就传得更远。我的经验是，尽量在异常出现的当时就作出处理。否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。&lt;/p&gt;&lt;p&gt;另外，try { ... } catch里面，应该包含尽量少的代码。比如，如果&lt;code&gt;foo&lt;/code&gt;和&lt;code&gt;bar&lt;/code&gt;都可能产生异常A，你的代码应该尽可能写成：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;try {
  foo();
} catch (A e) {...}

try {
  bar();
} catch (A e) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不是&lt;/p&gt;&lt;pre&gt;&lt;code&gt;try {
  foo();
  bar();
} catch (A e) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一种写法能明确的分辨是哪一个函数出了问题，而第二种写法全都混在一起。明确的分辨是哪一个函数出了问题，有很多的好处。比如，如果你的catch代码里面包含log，它可以提供给你更加精确的错误信息，这样会大大地加速你的调试过程。&lt;/p&gt;&lt;h3&gt;正确处理null指针&lt;/h3&gt;&lt;p&gt;穷举的思想是如此的有用，依据这个原理，我们可以推出一些基本原则，它们可以让你无懈可击的处理null指针。&lt;/p&gt;&lt;p&gt;首先你应该知道，许多语言（C，C++，Java，C#，……）的类型系统对于null的处理，其实是完全错误的。这个错误源自于&lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;Tony Hoare&lt;/a&gt;最早的设计，Hoare把这个错误称为自己的“&lt;a href=&quot;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&quot;&gt;billion dollar mistake&lt;/a&gt;”，因为由于它所产生的财产和人力损失，远远超过十亿美元。&lt;/p&gt;&lt;p&gt;这些语言的类型系统允许null出现在任何对象（指针）类型可以出现的地方，然而null其实根本不是一个合法的对象。它不是一个String，不是一个Integer，也不是一个自定义的类。null的类型本来应该是NULL，也就是null自己。根据这个基本观点，我们推导出以下原则：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制。虽然写法上有点别扭，然而Java的异常，和函数的返回值合并在一起，基本上可以当成union类型来用。比如，如果你有一个函数find，可以帮你找到一个String，也有可能什么也找不到，你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String find() throws NotFoundException {
  if (...) {
    return ...;
  } else {
    throw new NotFoundException();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java的类型系统会强制你catch这个NotFoundException，所以你不可能像漏掉检查null一样，漏掉这种情况。Java的异常也是一个比较容易滥用的东西，不过我已经在上一节告诉你如何正确的使用异常。&lt;/p&gt;

&lt;p&gt;Java的try...catch语法相当的繁琐和蹩脚，所以如果你足够小心的话，像&lt;code&gt;find&lt;/code&gt;这类函数，也可以返回null来表示“没找到”。这样稍微好看一些，因为你调用的时候不必用try...catch。很多人写的函数，返回null来表示“出错了”，这其实是对null的误用。“出错了”和“没有”，其实完全是两码事。“没有”是一种很常见，正常的情况，比如查哈希表没找到，很正常。“出错了”则表示罕见的情况，本来正常情况下都应该存在有意义的值，偶然出了问题。如果你的函数要表示“出错了”，应该使用异常，而不是null。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要catch NullPointerException。有些人写代码很nice，他们喜欢“容错”。首先他们写一些函数，这些函数里面不大小心，没检查null指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  String found = find();
  int len = found.length();
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当foo调用产生了异常，他们不管三七二十一，就把调用的地方改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
  foo();
} catch (Exception e) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当found是null的时候，NullPointerException就会被捕获并且得到处理。这其实是很错误的作法。首先，上一节已经提到了，&lt;code&gt;catch (Exception e)&lt;/code&gt;这种写法是要绝对避免的，因为它捕获所有的异常，包括NullPointerException。这会让你意外地捕获try语句里面出现的NullPointerException，从而把代码的逻辑搅得一塌糊涂。&lt;/p&gt;

&lt;p&gt;另外就算你写成&lt;code&gt;catch (NullPointerException e)&lt;/code&gt;也是不可以的。由于foo的内部缺少了null检查，才出现了NullPointerException。现在你不对症下药，倒把每个调用它的地方加上catch，以后你的生活就会越来越苦。正确的做法应该是改动foo，而不改调用它的代码。foo应该被改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo() {
  String found = find();
  if (found != null) {
    int len = found.length();
    ...
  } else {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 在null可能出现的当时就检查它是否是null，然后进行相应的处理。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要把null放进“容器数据结构”里面。所谓容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。&lt;/p&gt;

&lt;p&gt;解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。&lt;/p&gt;

&lt;p&gt;需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A {
  String name = null;
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之所以可以这样，是因为null只可能在A对象的name成员里出现，你不用怀疑其它的成员因此成为null。所以你每次访问name成员时，检查它是否是null就可以了，不需要对其他成员也做同样的检查。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播。null很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”。有时候它表示“出错了”，“失败了”。有时候它甚至可以表示“成功了”，…… 这其中有很多误用之处，不过无论如何，你必须理解每一个null的意义，不能给混淆起来。&lt;/p&gt;

&lt;p&gt;如果你调用的函数有可能返回null，那么你应该在第一时间对null做出“有意义”的处理。比如，上述的函数&lt;code&gt;find&lt;/code&gt;，返回null表示“没找到”，那么调用&lt;code&gt;find&lt;/code&gt;的代码就应该在它返回的第一时间，检查返回值是否是null，并且对“没找到”这种情况，作出有意义的处理。&lt;/p&gt;

&lt;p&gt;“有意义”是什么意思呢？我的意思是，使用这函数的人，应该明确的知道在拿到null的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。如果你违反了这一点，就有可能采用一种不负责任，危险的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String foo() {
  String found = find();
  if (found == null) {
    return null;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当看到find()返回了null，foo自己也返回null。这样null就从一个地方，游走到了另一个地方，而且它表示另外一个意思。如果你不假思索就写出这样的代码，最后的结果就是代码里面随时随地都可能出现null。到后来为了保护自己，你的每个函数都会写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void foo(A a, B b, C c) {
  if (a == null) { ... }
  if (b == null) { ... }
  if (c == null) { ... }
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数作者：明确声明不接受null参数，当参数是null时立即崩溃。不要试图对null进行“容错”，不要让程序继续往下执行。如果调用者使用了null作为参数，那么调用者（而不是函数作者）应该对程序的崩溃负全责。&lt;/p&gt;

&lt;p&gt;上面的例子之所以成为问题，就在于人们对于null的“容忍态度”。这种“保护式”的写法，试图“容错”，试图“优雅的处理null”，其结果是让调用者更加肆无忌惮的传递null给你的函数。到后来，你的代码里出现一堆堆nonsense的情况，null可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了null是什么意思，该做什么，所有人都把null踢给其他人。最后这null像瘟疫一样蔓延开来，到处都是，成为一场噩梦。&lt;/p&gt;

&lt;p&gt;正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是null，如果你给我null，程序崩溃了该你自己负责。至于调用者代码里有null怎么办，他自己该知道怎么处理（参考以上几条），不应该由函数作者来操心。&lt;/p&gt;

&lt;p&gt;采用强硬态度一个很简单的做法是使用&lt;code&gt;Objects.requireNonNull()&lt;/code&gt;。它的定义很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; T requireNonNull(T obj) {
  if (obj == null) {
    throw new NullPointerException();
  } else {
    return obj;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以用这个函数来检查不想接受null的每一个参数，只要传进来的参数是null，就会立即触发&lt;code&gt;NullPointerException&lt;/code&gt;崩溃掉，这样你就可以有效地防止null指针不知不觉传递到其它地方去。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用@NotNull和@Nullable标记。IntelliJ提供了@NotNull和@Nullable两种标记，加在类型前面，这样可以比较简洁可靠地防止null指针的出现。IntelliJ本身会对含有这种标记的代码进行静态分析，指出运行时可能出现&lt;code&gt;NullPointerException&lt;/code&gt;的地方。在运行时，会在null指针不该出现的地方产生&lt;code&gt;IllegalArgumentException&lt;/code&gt;，即使那个null指针你从来没有deference。这样你可以在尽量早期发现并且防止null指针的出现。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Optional类型。Java 8和Swift之类的语言，提供了一种叫Optional的类型。正确的使用这种类型，可以在很大程度上避免null的问题。null指针的问题之所以存在，是因为你可以在没有“检查”null的情况下，“访问”对象的成员。&lt;/p&gt;

&lt;p&gt;Optional类型的设计原理，就是把“检查”和“访问”这两个操作合二为一，成为一个“原子操作”。这样你没法只访问，而不进行检查。这种做法其实是ML，Haskell等语言里的模式匹配（pattern matching）的一个特例。模式匹配使得类型判断和访问成员这两种操作合二为一，所以你没法犯错。&lt;/p&gt;

&lt;p&gt;比如，在Swift里面，你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let found = find()
if let content = found {
  print(&quot;found: &quot; + content)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你从&lt;code&gt;find()&lt;/code&gt;函数得到一个Optional类型的值&lt;code&gt;found&lt;/code&gt;。假设它的类型是&lt;code&gt;String?&lt;/code&gt;，那个问号表示它可能包含一个String，也可能是nil。然后你就可以用一种特殊的if语句，同时进行null检查和访问其中的内容。这个if语句跟普通的if语句不一样，它的条件不是一个Bool，而是一个变量绑定&lt;code&gt;let content = found&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我不是很喜欢这语法，不过这整个语句的含义是：如果found是nil，那么整个if语句被略过。如果它不是nil，那么变量content被绑定到found里面的值（unwrap操作），然后执行&lt;code&gt;print(&quot;found: &quot; + content)&lt;/code&gt;。由于这种写法把检查和访问合并在了一起，你没法只进行访问而不检查。&lt;/p&gt;

&lt;p&gt;Java 8的做法比较蹩脚一些。如果你得到一个Optional&lt;string&gt;类型的值found，你必须使用“函数式编程”的方式，来写这之后的代码：&lt;/string&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Optional&amp;lt;String&amp;gt; found = find();
found.ifPresent(content -&amp;gt; System.out.println(&quot;found: &quot; + content));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段Java代码跟上面的Swift代码等价，它包含一个“判断”和一个“取值”操作。ifPresent先判断found是否有值（相当于判断是不是null）。如果有，那么将其内容“绑定”到lambda表达式的content参数（unwrap操作），然后执行lambda里面的内容，否则如果found没有内容，那么ifPresent里面的lambda不执行。&lt;/p&gt;

&lt;p&gt;Java的这种设计有个问题。判断null之后分支里的内容，全都得写在lambda里面。在函数式编程里，这个lambda叫做“&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation&quot;&gt;continuation&lt;/a&gt;”，Java把它叫做
“&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html&quot;&gt;Consumer&lt;/a&gt;”，它表示“如果found不是null，拿到它的值，然后应该做什么”。由于lambda是个函数，你不能在里面写&lt;code&gt;return&lt;/code&gt;语句返回出外层的函数。比如，如果你要改写下面这个函数（含有null）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  String found = find();
  if (found != null) {
    return found;
  } else {
    return &quot;&quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会比较麻烦。因为如果你写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  Optional&amp;lt;String&amp;gt; found = find();
  found.ifPresent(content -&amp;gt; {
    return content;    // can&#39;t return from foo here
  });
  return &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;里面的&lt;code&gt;return a&lt;/code&gt;，并不能从函数&lt;code&gt;foo&lt;/code&gt;返回出去。它只会从lambda返回，而且由于那个lambda（&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#accept-T-&quot;&gt;Consumer.accept&lt;/a&gt;）的返回类型必须是&lt;code&gt;void&lt;/code&gt;，编译器会报错，说你返回了String。由于Java里closure的自由变量是只读的，你没法对lambda外面的变量进行赋值，所以你也不能采用这种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  Optional&amp;lt;String&amp;gt; found = find();
  String result = &quot;&quot;;
  found.ifPresent(content -&amp;gt; {
    result = content;    // can&#39;t assign to result
  });
  return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，虽然你在lambda里面得到了found的内容，如何使用这个值，如何返回一个值，却让人摸不着头脑。你平时的那些Java编程手法，在这里几乎完全废掉了。实际上，判断null之后，你必须使用Java 8提供的一系列古怪的&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html&quot;&gt;函数式编程操作&lt;/a&gt;：&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;orElse&lt;/code&gt;之类，想法把它们组合起来，才能表达出原来代码的意思。比如之前的代码，只能改写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String foo() {
  Optional&amp;lt;String&amp;gt; found = find();
  return found.orElse(&quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这简单的情况还好。复杂一点的代码，我还真不知道怎么表达，我怀疑Java 8的Optional类型的方法，到底有没有提供足够的表达力。那里面少数几个东西表达能力不咋的，论工作原理，却可以扯到functor，continuation，甚至monad等高深的理论…… 仿佛用了Optional之后，这语言就不再是Java了一样。&lt;/p&gt;

&lt;p&gt;所以Java虽然提供了Optional，但我觉得可用性其实比较低，难以被人接受。相比之下，Swift的设计更加简单直观，接近普通的过程式编程。你只需要记住一个特殊的语法&lt;code&gt;if let content = found {...}&lt;/code&gt;，里面的代码写法，跟普通的过程式语言没有任何差别。&lt;/p&gt;

&lt;p&gt;总之你只要记住，使用Optional类型，要点在于“原子操作”，使得null检查与取值合二为一。这要求你必须使用我刚才介绍的特殊写法。如果你违反了这一原则，把检查和取值分成两步做，还是有可能犯错误。比如在Java 8里面，你可以使用&lt;code&gt;found.get()&lt;/code&gt;这样的方式直接访问found里面的内容。在Swift里你也可以使用&lt;code&gt;found!&lt;/code&gt;来直接访问而不进行检查。&lt;/p&gt;

&lt;p&gt;你可以写这样的Java代码来使用Optional类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Option&amp;lt;String&amp;gt; found = find();
if (found.isPresent()) {
  System.out.println(&quot;found: &quot; + found.get());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用这种方式，把检查和取值分成两步做，就可能会出现运行时错误。&lt;code&gt;if (found.isPresent())&lt;/code&gt;本质上跟普通的null检查，其实没什么两样。如果你忘记判断&lt;code&gt;found.isPresent()&lt;/code&gt;，直接进行&lt;code&gt;found.get()&lt;/code&gt;，就会出现&lt;code&gt;NoSuchElementException&lt;/code&gt;。这跟&lt;code&gt;NullPointerException&lt;/code&gt;本质上是一回事。所以这种写法，比起普通的null的用法，其实换汤不换药。如果你要用Optional类型而得到它的益处，请务必遵循我之前介绍的“原子操作”写法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;防止过度工程&lt;/h3&gt;&lt;p&gt;人的脑子真是奇妙的东西。虽然大家都知道过度工程（over-engineering）不好，在实际的工程中却经常不由自主的出现过度工程。我自己也犯过好多次这种错误，所以觉得有必要分析一下，过度工程出现的信号和兆头，这样可以在初期的时候就及时发现并且避免。&lt;/p&gt;&lt;p&gt;过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”……&lt;/p&gt;&lt;p&gt;这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，把手头的问题先搞定了，再谈以后扩展的问题。&lt;/p&gt;&lt;p&gt;另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。为了让代码可以重用，最后被自己搞出来的各种框架捆住手脚，最后连可用的代码就没写好。如果可用的代码都写不好，又何谈重用呢？很多一开头就考虑太多重用的工程，到后来被人完全抛弃，没人用了，因为别人发现这些代码太难懂了，自己从头开始写一个，反而省好多事。&lt;/p&gt;&lt;p&gt;过度地关心“测试”，也会引起过度工程。有些人为了测试，把本来很简单的代码改成“方便测试”的形式，结果引入很多复杂性，以至于本来一下就能写对的代码，最后复杂不堪，出现很多bug。&lt;/p&gt;&lt;p&gt;世界上有两种“没有bug”的代码。一种是“没有明显的bug的代码”，另一种是“明显没有bug的代码”。第一种情况，由于代码复杂不堪，加上很多测试，各种coverage，貌似测试都通过了，所以就认为代码是正确的。第二种情况，由于代码简单直接，就算没写很多测试，你一眼看去就知道它不可能有bug。你喜欢哪一种“没有bug”的代码呢？&lt;/p&gt;&lt;p&gt;根据这些，我总结出来的防止过度工程的原则如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。&lt;/li&gt;
&lt;li&gt;先写出可用的代码，反复推敲，再考虑是否需要重用的问题。&lt;/li&gt;
&lt;li&gt;先写出可用，简单，明显没有bug的代码，再考虑测试的问题。&lt;/li&gt;
&lt;/ol&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">programming-philosophy</guid>
<pubDate>Sat, 21 Nov 2015 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
