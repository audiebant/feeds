<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 27 Apr 2016 23:35:09 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>[新闻] Chez Scheme开源了</title>
<link>https://zhuanlan.zhihu.com/p/20808925</link>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/cisco/ChezScheme&quot; data-editable=&quot;true&quot; data-title=&quot;GitHub - cisco/ChezScheme: Chez Scheme&quot;&gt;GitHub - cisco/ChezScheme: Chez Scheme&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有人说不就是开源了个Scheme编译器么有啥那么激动的。&lt;/p&gt;当然激动啦。这是Chez Scheme啊。&lt;p&gt;我大三开始学Scheme和啃SICP是从Petite Chez Scheme 7.4开始的。能一睹完整版Chez Scheme的芳容真是太爽了——即便是重写过的新Chez Scheme，不应该说重写过了更好哇哈哈。&lt;/p&gt;&lt;p&gt;近来各种原本根本无法想像会开源的项目居然都开源了，特别是在编译器和托管运行时这边，整个潮流就很让人激动。传闻6月份IBM J9配套的JIT编译器Testarossa的核心部分也会开源到OMR项目中，又是一重磅产品。&lt;/p&gt;&lt;p&gt;现在的小朋友要学习这方面，从入门级到高度优化的产品级项目都有众多开源项目可参考，多方便啊。我都恨不得想迟个十来年出生了，正好能在学校里赶上这浪潮 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;P.S. 请不要等我“评论”Chez Scheme，我自己还得好好学习一下它到底做了什么，都怎么做的，无力“评论”啊。我也想坐等大神来指条明路如何学习它嗯。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20808925</guid>
<pubDate>Wed, 27 Apr 2016 07:40:58 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>ChakraCore的dump开关</title>
<link>https://zhuanlan.zhihu.com/p/20792855</link>
<description>&lt;a href=&quot;https://github.com/Microsoft/ChakraCore&quot; data-editable=&quot;true&quot; data-title=&quot;ChakraCore&quot;&gt;ChakraCore&lt;/a&gt;开源也有一阵了，作为最后开源的一个主流JS引擎，在GitHub上已经有了5000+的star，说明有很多人关注。对于想要研究ChakraCore的童鞋，如果直接从代码入手，不太容易下手和实验。对此，ChakraCore已经自带了不少dump开关来输出整个编译过程的中间结果，可以据此一窥整个编译的过程。这里就介绍下ChakraCore里面的常用dump开关。&lt;p&gt;ChakraCore编译出来是chakracore.dll，如果不想自己写一个host，可以用ChakraCore自带的host CH.exe. CH.exe使用的是JSRT接口来访问ChakraCore的编译功能。比如用ChakraCore运行下面的JS文件。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function foo(a, b) {
    return a + b
}

print(foo(3, 4))

print(foo(5, 6))&lt;/code&gt;当CH.exe和chakracore.dll都编译好后（CH.exe依赖于后者，所以只要在Visual Studio编译CH.exe就可以），可以运行 “ch.exe foo.js -bgjit- -maxinterpretercount:1 -off:simplejit -dump:backend&quot;, 这样除了script运行的输出，编译的时候的中间结果也会输出到控制台。西面先解释下上面传入的各个参数。&lt;ul&gt;&lt;li&gt;-bgjit-，禁止JIT运行的background线程。ChakraCore里面JIT默认运行在专门的线程里面接收script线程发来的编译请求（CodeGenWorkItem), 这样的好处是不会阻塞script线程继续运行（interpret），但是也会给调试过程带来不确定性，所以不是调试相关的bug可以关掉。&lt;/li&gt;&lt;li&gt;-maxinterpretercount:1, 仅允许Javascript function被interpret一次。ChakraCore里面有Interpreter, SimpleJit, FullJit, 优化程度和耗时是依次递增，比较hot的函数也会一次进入这几个阶段。ChakraCore里面有heuristic机制来决定function何时进入下一个阶段。Debug的时候自然不能依赖这个来进入JIT，所以对interpret count设置固定值。一般这里推荐设置成1而不是0，因为需要运行一次interpreter来收集profile data供后面JIT使用。另外这个选项可以缩写成 &quot;-mic:1&quot;。&lt;/li&gt;&lt;li&gt;off:simplejit，关掉SimpleJIT。这个作为第二层优化，比FullJIT简单很多，作为interpreter和FullJIT之间的一个平衡，研究中可以关掉。&lt;/li&gt;&lt;li&gt;-dump:backend，输出JIT过程中的中间结果。Chakra的JIT分成了很多个phase（这个和UTC（VC++的c2.dll）很像，但是相比还是简单很多，其实phase dump也和UTC的很像，不得不说ChakraCore的JIT受了UTC的很大影响），第一个phase是IRBuilder把Parser生成的bytecode转成内部的IR结构（intermediate representation），后面典型的phase有Inline, GlobOpt, Lower, Encoder等。每个phase都会在IR上收集些信息供后面的phase使用，或者直接在IR上做变换。运行 ”ch.exe -?&quot;就可以看到phase列表。这里会列出相当多的phase，但实际上并不代表ChakraCore有这么多阶段来做优化，里面很多phase实际上代表了中比较具体的优化，这样可以通过 &quot;-off&quot; 选项来关闭相关的优化，比如CSE (common sub-expression elimination)，CopyProp都被列为一个phase，但是他们都是在GlobOpt里面做的。&quot;-dump&quot; 选项接收一个实际的phase做参数（比如IRBuilder, Lower)从而在相关phase结束后dump相应的中间结果。在研究JIT bug的是有经常需要把JIT的所有phase的结果都dump出来看看是哪个phase除了问题，全部都写上比较浪费时间，就有了一个“backend”来代表所有的phases。ChkaraCore的JIT主要是针对function的（另外一个是loop），这样dump一个有很多function的JS文件而已知问题出在某个function里面的时候，会很不方便，这里的dump选项还接受一个function Id来过滤，比如“-dump:backend:1” （function Id可以在不带function Id过滤的dump里面找到，如下面“#1.1”后面的1就是）。后续再介绍这里其他数字（从源代码也比较容易看出来）和每条IR的意思。最后需要注意的是所有的dump代码指编译在Debug版本的chakracore.dll里。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面的JS在ChakraCore里面的实际dump如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-----------------------------------------------------------------------------



************   IR after IRBuilder (FullJit)  ************
-----------------------------------------------------------------------------
Function foo ( (#1.1), #2)                        Instr Count:13

                       FunctionEntry                                          #
    s1[Object].var  =  Ld_A           0xXXXXXXXX (GlobalObject)[Object].var   #
    s2[LikelyCanBeTaggedValue_Int].var = ArgIn_A  prm2&amp;lt;40&amp;gt;.var                #
    s3[LikelyCanBeTaggedValue_Int].var = ArgIn_A  prm3&amp;lt;48&amp;gt;.var                #


  Line   2: return a + b
  Col    5: ^
                       StatementBoundary  #0                                  #0000
    s0.var          =  Add_A          s2.var, s3.var                          #0000
                       Br             $L1                                     #0004
    s0.var          =  Ld_A           0xXXXXXXXX (undefined)[Undefined].var   #0007
$L1:                                                                          #0009


  Line   3: }
  Col    1: ^
                       StatementBoundary  #1                                  #0009
                       StatementBoundary  #-1                                 #0009
                       Ret            s0.var                                  #0009

                       FunctionExit                                           #&lt;/code&gt;</description>
<author>Thomson</author>
<guid isPermaLink="false">20792855</guid>
<pubDate>Sat, 23 Apr 2016 14:51:47 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>lisp0</title>
<link>https://zhuanlan.zhihu.com/p/20689554</link>
<description>&lt;p&gt;代码没写完，广告先打起来&lt;a class=&quot;&quot; data-title=&quot;GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/bhuztez/lisp0&quot;&gt; GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;学习高级语言Runtime最好的办法，当然是自己动手写一个啦。毫无疑问假如你不是特别喜欢走弯路的轮子哥，肯定选从容易的开始。那么就选最最原始的LISP好了(Brainfuck之类的过于简单，这里先忽略他们的存在)。lisp0不会像Lisp Machine是一台单独的机器，lisp0就是一个普通的运行在Linux的程序。&lt;/p&gt;&lt;p&gt;既然是把Runtime实现一遍，那么在操作系统之上全都自己来实现，连CRT和libc也不要用。因为Lisp语言自己就又栈了，所以C程序没事别递归，用的栈是非常有限的，于是用bss段里的一段内存当C语言的栈，而操作系统在启动时，分配来的栈，给Lisp用。这样虽然奇葩了点，非常省事啊。&lt;/p&gt;&lt;p&gt;因为(假装)lisp0是immutable的，所以只要简单的引用计数就可以了。不过这写起来麻烦，用一次就要增减一次。还不如先用个简单的Mark sweep GC。因为immutable，所以新的不能被旧的引用，在allocate后把他们串成一个栈，只要从新往旧扫一遍，在扫到时还没被标记，那就一定不会被标记到，可以放心的free。至于memory allocator，就用简陋的TLSF算法就好了，这算法看上去就像个增强版的Buddy allocator。&lt;br&gt;&lt;/p&gt;&lt;p&gt;既然Lisp霸占了原本给C用的栈，使用方式也就和C保持一致好了。因为GCC支持Labels as Values，所以只要在CALL之后放一个label，那个label的值就是返回地址了。同时，因为symbol只接受[_0-9A-Za-z]+，所以长度小于等于8的symbol，经过base64解码之后长度就只有6字节了，而64位机器上去掉3位tag，还有61位，完全放的下。&lt;/p&gt;&lt;p&gt;接下来，lisp0应该改用HAMT来实现environment，换一个更好的GC。本文到此就结束了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20689554</guid>
<pubDate>Wed, 30 Mar 2016 23:01:05 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Java局部类型推导（var）的试玩版</title>
<link>https://zhuanlan.zhihu.com/p/20646039</link>
<description>&lt;p&gt;上一篇新闻提到了未来版本的Java（或许是Java 10）会有局部类型推导功能，也就是“var”隐式声明变量类型的功能。大家有兴趣现在就玩玩它的话，有好人build了当前的原型实现：&lt;/p&gt;&lt;a href=&quot;http://iteratrlearning.com/jep286.html&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 286: Type Inference for Java Builds&quot; class=&quot;&quot;&gt;JEP 286: Type Inference for Java Builds&lt;/a&gt;&lt;p&gt;目前该网站提供了Mac OS X和Linux版JDK build。Windows版“coming soon”。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20646039</guid>
<pubDate>Tue, 15 Mar 2016 06:54:55 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Java也要有局部类型推导（var）了</title>
<link>https://zhuanlan.zhihu.com/p/20635474</link>
<description>请跳传送门：&lt;a href=&quot;http://openjdk.java.net/jeps/286&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 286: Local-Variable Type Inference&quot;&gt;JEP 286: Local-Variable Type Inference&lt;/a&gt;&lt;p&gt;看来有希望赶上Java 10。诶终于啊。&lt;/p&gt;&lt;p&gt;等JEP 286完成之后，Java的局部类型推导就比C#的还要神奇了…看：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;List&amp;lt;String&amp;gt; strs1 = new ArrayList&amp;lt;String&amp;gt;(); // Java 5 generics
List&amp;lt;String&amp;gt; strs2 = new ArrayList&amp;lt;&amp;gt;();       // Java 7 diamond syntax
var strs3 = new ArrayList&amp;lt;String&amp;gt;();          // JEP 286 var syntax&lt;/code&gt;&lt;p&gt;左边能推导到右边（Java 7 diamond），右边也能推导到左边（JEP 286 var），多欢乐 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;另外，C# 3.0里的var是个“&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/the35c6y.aspx&quot;&gt;上下文相关关键字&lt;/a&gt;”，也就是说只有在合适的地方写var才会被看作变量声明隐式声明类型的关键字，而其它地方（例如说作为变量名）则不算关键字而是普通标识符。JEP 286把这个设计基本找搬了，只是换了个名字叫做“reserved type name”。&lt;/p&gt;&lt;p&gt;========================================&lt;/p&gt;&lt;br&gt;&lt;p&gt;另外Java 10还有希望看到&lt;a href=&quot;http://openjdk.java.net/projects/valhalla/&quot; data-editable=&quot;true&quot; data-title=&quot;OpenJDK: Valhalla&quot;&gt;Project Valhalla&lt;/a&gt;的完成。到时候就可以写：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;var xs = new ArrayList&amp;lt;int&amp;gt;(); // Valhalla: generics over value types
&lt;/code&gt;&lt;p&gt;好棒好棒 &amp;gt;_&amp;lt;|||&lt;/p&gt;&lt;p&gt;但Valhalla当前到了第三版原型的设计，把彻底的类型特化给抛弃了，改为只对value type做特化。泪奔啊。这就意味着当前的原型设计不让这样写：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;  public static &amp;lt;T, U&amp;gt; T make(U arg0) {
    return new T(arg0);
  }&lt;/code&gt;&lt;p&gt;呜呜。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20635474</guid>
<pubDate>Thu, 10 Mar 2016 16:04:28 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] IBM OMR项目正式开源</title>
<link>https://zhuanlan.zhihu.com/p/20631665</link>
<description>代码在GitHub上：&lt;a href=&quot;https://github.com/eclipse/omr&quot; data-editable=&quot;true&quot; data-title=&quot;GitHub - eclipse/omr: OMR project&quot;&gt;GitHub - eclipse/omr: OMR project&lt;/a&gt;&lt;p&gt;项目负责人Mark Stoodley刚刚在EclipseCon上做了相关的演讲：&lt;a href=&quot;http://www.slideshare.net/MarkStoodley/omr-a-modern-toolkit-for-building-language-runtimes&quot; data-editable=&quot;true&quot; data-title=&quot;slideshare.net 的页面&quot; class=&quot;&quot;&gt;OMR: a modern toolkit for building language runtimes, EclipseCON 2016&lt;/a&gt;&lt;/p&gt;&lt;p&gt;IBM官方新闻稿：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/open/omr/&quot; data-editable=&quot;true&quot; data-title=&quot;OMR | developerWorks Open&quot; class=&quot;&quot;&gt;OMR | developerWorks Open&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/open/2016/03/08/introducing-omr-building-language-runtimes/&quot; data-editable=&quot;true&quot; data-title=&quot;Introducing OMR: Building language runtimes&quot;&gt;Introducing OMR: Building language runtimes&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;初始开源的组件有下面这些：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;port: platform porting library&lt;br&gt;&lt;/li&gt;&lt;li&gt;thread: a cross platform pthread-like threading library&lt;br&gt;&lt;/li&gt;&lt;li&gt;util: general utilities useful for building cross platform runtimes&lt;br&gt;&lt;/li&gt;&lt;li&gt;omrsigcompat: signal handling compatibility library&lt;br&gt;&lt;/li&gt;&lt;li&gt;omrtrace: tracing library for communication with IBM Health Center monitoring tools&lt;br&gt;&lt;/li&gt;&lt;li&gt;tool: code generation tools for the build system&lt;br&gt;&lt;/li&gt;&lt;li&gt;gc: garbage collection framework for managed heaps&lt;br&gt;&lt;/li&gt;&lt;li&gt;vm: APIs to manage per-interpreter and per-thread contexts&lt;br&gt;&lt;/li&gt;&lt;li&gt;example: demonstration code to show how a language runtime might consume some OMR components&lt;br&gt;&lt;/li&gt;&lt;li&gt;fvtest: a language-independent test framework so that OMR components can be tested outside of a language runtime&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;嗯最重磅的JIT部分还没出来，还在准备开源。&lt;/p&gt;&lt;br&gt;&lt;p&gt;知乎上之前的相关讨论：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; data-editable=&quot;true&quot; data-title=&quot;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&quot; class=&quot;&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20581695&quot; data-editable=&quot;true&quot; data-title=&quot;[新闻] CPython / 微软 Pyjion / IBM Python+OMR - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&quot;&gt;[新闻] CPython / 微软 Pyjion / IBM Python+OMR - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20631665</guid>
<pubDate>Wed, 09 Mar 2016 10:19:36 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[八卦] 据说Dropbox要试着在内部推广PyPy</title>
<link>https://zhuanlan.zhihu.com/p/20616374</link>
<description>去年年底的消息。就跟Pyston talk差不多时间吧。&lt;p&gt;- &quot;What about Pyston?&quot;&lt;/p&gt;&lt;p&gt;- &quot;At least one of them works.&quot;&lt;/p&gt;&lt;p&gt;还挺好玩。不过看着&lt;a href=&quot;https://github.com/dropbox/pyston/commits/master&quot;&gt;Pyston还不断在开发中&lt;/a&gt;，大概Pyston也不会就此挂掉吧…&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20616374</guid>
<pubDate>Thu, 03 Mar 2016 09:43:19 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Azul Systems正式宣布32位ARM上的Zulu Embedded</title>
<link>https://zhuanlan.zhihu.com/p/20595654</link>
<description>新闻稿：&lt;a href=&quot;https://www.azul.com/press_release/azul-systems-enhances-zulu-embedded-to-support-32-bit-arm-processors/&quot; data-editable=&quot;true&quot; data-title=&quot;Azul Systems enhances Zulu Embedded to support 32-bit ARM processors&quot;&gt;Azul Systems enhances Zulu Embedded to support 32-bit ARM processors&lt;/a&gt;&lt;p&gt;这是Azul Systems在OpenJDK的基础上做的ARMv7 / AArch32 port。目前已经有解释器以及完整的Client Compiler（C1）实现。&lt;/p&gt;&lt;p&gt;贯彻Zulu产品线的一贯作风，这个ARM port的所有代码都会在&lt;a href=&quot;http://openjdk.java.net/projects/aarch32-port/&quot; data-title=&quot;OpenJDK AArch32项目&quot; class=&quot;&quot;&gt;OpenJDK AArch32项目&lt;/a&gt;下完全开源。同事最近发的&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/aarch32-port-dev/2016-February/000094.html&quot;&gt;一个大patch&lt;/a&gt;就是为接下来提交C1代码而做的铺垫。&lt;/p&gt;&lt;p&gt;欢迎关注ARM上的Zulu Embedded！&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595654</guid>
<pubDate>Wed, 24 Feb 2016 08:15:57 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] Cliff Click大神也看上给Python加JIT了</title>
<link>https://zhuanlan.zhihu.com/p/20595643</link>
<description>&lt;a href=&quot;http://www.cliffc.org/blog/2016/02/19/winds-of-change&quot; data-editable=&quot;true&quot; data-title=&quot;Winds of Change&quot; class=&quot;&quot;&gt;Winds of Change - Cliff Click&#39;s Blog&lt;/a&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Python Go Fast:&lt;/strong&gt; Do Unto Python as Thou hast Done Unto Java. I hack the guts of Python; add a high power JIT, a full-fledged low-pause GC, true multi-threading support, i.e. make Python as fast and as parallel as Java (about the same speed as C).  This blog is really a request for an open discussion on this topic.  Is the Python community interested?  How does this get funded?  (uber Kickstarter?)  I’ll only go here with the full support of the core Python committers, and general “feel goods” from the general python community – and I’m hoping to start a discussion.  At this point I’m a premier language implementer, and making Python Go Fast is well within my abilities and past experiences. Take about 2 years &amp;amp; $2M for this effort to be self-sustaining (build all the core new tech and hand it off to other contributors).&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;困难啊…Cliff大神可能还没体会过CPython社区对“改变”的抗拒orz&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595643</guid>
<pubDate>Wed, 24 Feb 2016 08:09:04 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Pyjion的代码质量一例 [20160221]</title>
<link>https://zhuanlan.zhihu.com/p/20591139</link>
<description>&lt;p&gt;&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20581695&quot; data-title=&quot;上一篇文章&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;上一篇文章&lt;/a&gt;简单介绍了一下&lt;a href=&quot;https://github.com/Microsoft/Pyjion&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion项目&quot;&gt;Pyjion项目&lt;/a&gt;的目标与概况。相信很多同学都很好奇，目前的Pyjion到底效果如何对不对？&lt;/p&gt;&lt;p&gt;那我们就从一个再简单不过的例子来一探究竟。非常感谢&lt;a href=&quot;https://www.zhihu.com/people/f12d62dfdf1236e961460798455b1718&quot; data-hash=&quot;f12d62dfdf1236e961460798455b1718&quot; class=&quot;member_mention&quot; data-tip=&quot;p$b$f12d62dfdf1236e961460798455b1718&quot;&gt;@Thomson&lt;/a&gt;大大帮忙做实验，下面的实验结果都是拜托他帮忙获得的。&lt;/p&gt;&lt;p&gt;考虑下面的Python代码：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def foo(a, b):
  return a + b
&lt;/code&gt;&lt;p&gt;它由CPython编译得到的字节码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0 LOAD_FAST                0 (a)
3 LOAD_FAST                1 (b)
6 BINARY_ADD          
7 RETURN_VALUE
&lt;/code&gt;&lt;p&gt;（Pyjion目前是基于CPython 3.6.0 alpha 1，不过这里用CPython 2.x系列和3.x系列得到的字节码一样，不影响例子）&lt;/p&gt;&lt;p&gt;经过上一篇文章提到的编译流程，Pyjion会生成下面这样的MSIL来表达foo()函数的内容：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// function prologue
    ldarg.1
    ldc.i4       0x88                // offsetof(PyFrameObject, f_lasti)
    conv.i
    add
    stloc.0
    ldarg.1
    call         METHOD_PY_PUSHFRAME // PyJit_PushFrame
// 0: LOAD_FAST 0 (a)
    ldloc.0
    ldc.i4       0x0
    conv.i
    stind.i4
    ldarg.1
    ldc.i4       0x188               // offsetof(PyFrameObject, f_localsplus) + 0 * sizeof(size_t)
    conv.i
    add
    ldind.i
    dup
    ldc.i4       0x10                // offsetof(PyObject, ob_refcnt)
    conv.i
    add
    dup
    ldind.i4
    ldc.i4.1
    add
    stind.i4
// 3: LOAD_FAST 1 (b)
    ldloc.0
    ldc.i4       0x3
    conv.i
    stind.i4
    ldarg.1
    ldc.i4       0x190               // offsetof(PyFrameObject, f_localsplus) + 1 * sizeof(size_t)
    conv.i
    add
    ldind.i
    dup
    ldc.i4       0x10                // offsetof(PyObject, ob_refcnt)
    conv.i
    add
    dup
    ldind.i4
    ldc.i4.1
    add
    stind.i4
// 6: BINARY_ADD
    ldloc.0
    ldc.i4       0x6
    conv.i
    stind.i4
    call         METHOD_ADD_TOKEN    // PyJit_Add
    dup
    stloc.2
    ldc.i4.0
    conv.i
    bne.un       L_success
    br           L_Raise
L_success:
    ldloc.2
// 7: RETURN_VALUE
    ldloc.0
    ldc.i4       0x7
    conv.i
    stind.i4
    stloc.1
    leave        L_ret

// default exception handler
L_Raise:
    ldarg.1
    call         METHOD_EH_TRACE     // PyJit_EhTrace
L_Reraise:
    ldc.i4.0
    conv.i
    br           L_finalRet

// function epilogue
L_ret:
    ldloc.1
L_finalRet:
    ldarg.1
    call         METHOD_PY_POPFRAME  // PyJit_PopFrame
    ret
&lt;/code&gt;&lt;p&gt;看起来好像很夸张有没有？&lt;/p&gt;&lt;p&gt;其实完全没有。上面的MSIL，如果用类似C的伪代码表达，会是这个样子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;// emulate generated code in pseudo C
PyObject* foo_compiled_code(void* unused, PyFrameObject* frame) {
  // function prologue
  int* lasti = &amp;amp;frame-&amp;gt;f_lasti; // updates are needed to keep the frame state available for inspection
  PyJit_PushFrame(frame); // PyThreadState_Get()-&amp;gt;frame = frame;

  PyObject* errorCheckLocal;

  __try {                      // conceptual. Not a protected region in MSIL.
    // 0: LOAD_FAST 0 (a)
    *lasti = 0;
    PyObject* _a = frame-&amp;gt;f_localsplus[0];
    _a-&amp;gt;ob_refcnt++;
    // 3: LOAD_FAST 1 (b)
    *lasti = 3;
    PyObject* _b = frame-&amp;gt;f_localsplus[1];
    _b-&amp;gt;ob_refcnt++;
    // 6: BINARY_ADD
    *lasti = 6;
    PyObject* _sum = PyJit_Add(_a, _b);
    errorCheckLocal = _sum;
    if (_sum == NULL) {
      goto L_Raise;
    } else {
      _sum = errorCheckLocal;
    }
    // 7: RETURN_VALUE
    *lasti = 7;
    PyObject* retValue = _sum;
    goto L_ret;                // MSIL leave.s instruction, for clearing evaluation stack
  } __finally {                // conceptual. Not a fault handler in MSIL.
    // default exception handler
    // for error handling when we have no EH handlers, return NULL.
L_Raise:
    PyJit_EhTrace(frame);
L_Reraise:
    retValue = NULL;
  }

  // function epilogue
L_ret:
  PyJit_PopFrame(frame); // PyThreadState_Get()-&amp;gt;frame = frame-&amp;gt;f_back;
  return retValue;
}
&lt;/code&gt;&lt;p&gt;稍微解释一下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;上面的伪代码里，局部变量名有下划线（&#39;_&#39;）开头的实际上并不在MSIL层面的局部变量，而是在求值栈（evaluation stack）上，而没有下划线开头的则是真正的MSIL层面的局部变量。&lt;br&gt;&lt;/li&gt;&lt;li&gt;伪代码里的 __try { ... } __finally { ... } 并不是MSIL层面上的异常处理，而是逻辑上它是用来实现Python代码的异常处理语义用的。实际涉及的跳转我都在伪代码里用goto来表达了。CPython解释器自身经常通过返回值为NULL来表达要抛异常，Pyjion也完全继承了这个设计。要说有啥不同，那就是Pyjion会在编译时把CPython特别偷懒的“block stack”给展开来，于是就不用到运行时还每次跳出循环或者抛异常都去慢慢展开block stack了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以看到，Pyjion生成的MSIL所代表的逻辑，其实就是把CPython解释器中每个字节码的逻辑展开来粘合到一起。这样就消除了解释器循环自身带来的开销，所以肯定是要比CPython原本的解释执行要快。不过在此基础上它并没有做多少优化，而是为了兼容性而尽可能的去模仿CPython解释器原本的行为。例如说所有Python代码里的局部变量都还是跟CPython解释器一样从PyFrameObject的f_localsplus数组访问，最大限度的保证任何想inspect CPython执行状态的功能都还能正常运行。&lt;/p&gt;&lt;p&gt;在伪代码里还可以看到每条CPython字节码处理的开头都有一个对 frame-&amp;gt;f_lasti 的赋值。这同样是为了保证严格的兼容性而做的——CPython有许多地方在泄漏解释器的内部状态，例如&lt;a href=&quot;https://docs.python.org/3/library/traceback.html&quot; data-title=&quot;traceback函数&quot; class=&quot;&quot;&gt;traceback模块&lt;/a&gt;，例如&lt;a href=&quot;https://docs.python.org/3/library/inspect.html&quot; data-title=&quot;inspect模块&quot; class=&quot;&quot;&gt;inspect模块&lt;/a&gt;，又例如&lt;a href=&quot;https://docs.python.org/3/c-api/index.html&quot; data-title=&quot;毫无保护的C API&quot; class=&quot;&quot;&gt;毫无保护的C API&lt;/a&gt;，它们都可以去查看Python解释器栈的状态，而这个由 PyFrameObject 构成的栈中很重要的内容就是“当前执行到哪里了”，也就是这个 f_lasti 字段。要想百分百兼容依赖了这些抽象泄漏的众多现有的Python库，要么就得这样死板的实现，否则就得实现得非常非常非常麻烦。&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外可以发现，生成的MSIL里还嵌入着一些native函数调用。Pyjion把这些函数叫做intrinsics，也可以叫做runtime helper function。Pyjion通过这种方式来支持Python字节码里隐含的“复杂操作”，例如那个&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp#L87&quot; data-editable=&quot;true&quot; data-title=&quot;PyJit_Add()&quot;&gt;PyJit_Add()&lt;/a&gt;。它的实现长啥样呢？&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;PyObject* PyJit_Add(PyObject *left, PyObject *right) {
    // TODO: Verify ref counting...
    PyObject *sum;
    if (PyUnicode_CheckExact(left) &amp;amp;&amp;amp; PyUnicode_CheckExact(right)) {
        PyUnicode_Append(&amp;amp;left, right);
        sum = left;
    }
    else {
        sum = PyNumber_Add(left, right);
        Py_DECREF(left);
    }
    Py_DECREF(right);
    return sum;
}
&lt;/code&gt;&lt;p&gt;这其实就跟CPython解释器里的&lt;a href=&quot;https://github.com/python/cpython/blob/efe0e11c78f890146375f1d4cbed4b513cdffa3c/Python/ceval.c#L1559&quot; data-title=&quot;BINARY_ADD字节码&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;BINARY_ADD字节码&lt;/a&gt;的内部实现几乎是一样的，只是把求值栈的操作映射到了MSIL层面上。&lt;/p&gt;&lt;p&gt;而面对这样的runtime helper函数，RyuJIT只能当它们是黑盒子而无法进一步分析与优化，也就无从內联这些函数的调用。&lt;/p&gt;&lt;p&gt;在Windows x86-64上的RyuJIT，最终会把上面的foo()函数例子编译为这样的机器码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// function prologue
    push    rdi
    push    rsi
    sub     rsp,28h
    mov     rsi,rdx
    lea     rdi,[rsi+88h]
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_PY_PUSHFRAME+0x38
    call    qword ptr [rax]
// 0: LOAD_FAST 0 (a)
    xor     ecx,ecx
    mov     dword ptr [rdi],ecx
    mov     rcx,qword ptr [rsi+188h]
    lea     rdx,[rcx+10h]
    add     dword ptr [rdx],1
// 3: LOAD_FAST 1 (b)
    mov     dword ptr [rdi],3
    mov     rdx,qword ptr [rsi+190h]
    lea     rax,[rdx+10h]
    add     dword ptr [rax],1
// 6: BINARY_ADD
    mov     dword ptr [rdi],6
    mov     rax,offset pyjit!gMETHOD_ADD_TOKEN+0x38
    call    qword ptr [rax]
    test    rax,rax
    je      L_Raise
// 7: RETURN_VALUE
    mov     dword ptr [rdi],7
    jmp     L_ret
// default exception handler
L_Raise:
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_EH_TRACE+0x38
    call    qword ptr [rax]
L_Reraise:
    xor     edi,edi
    jmp     L_finalRet
// function epilogue
L_ret:
    mov     rdi,rax
L_finalRet:
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_PY_POPFRAME+0x38
    call    qword ptr [rax]
    mov     rax,rdi
    add     rsp,28h
    pop     rsi
    pop     rdi
    ret
&lt;/code&gt;&lt;p&gt;嗯…跟上面的MSIL层面的逻辑几乎完全一样，只是MSIL层面的求值栈和局部变量都被优化到x86-64指令集的寄存器上了，其它就跟伪代码里写的一模一样。&lt;/p&gt;&lt;p&gt;Pyjion要真的让CPython的性能有突飞猛进的发展，还有很长的路要走。&lt;/p&gt;&lt;p&gt;就这个例子来说，其实它的 *lasti = 0 和 *lasti = 3 都是完全冗余的，因为可以假设CPython不会有机会观察到这俩状态——直到下次Pyjion要通过periodic_work进入CPython runtime，或者下次调用可能暴露实现细节的CPython函数 (*)。诸如这样的冗余可以通过更彻底的静态分析来消除掉，只是要实现它就得堆人力和时间了。&lt;/p&gt;&lt;p&gt;而许多能有效提升动态语言性能的技巧，在当前的CPython上都行不通，因为它对自己的内部状态实在没有啥封装可言，内部实现细节泄漏得到处都是。如果能堵上那些抽象泄漏，就可以把隐藏类（hidden class）、多态內联（polymorphic inline caching）、类型推导以及进一步优化一股脑的堆上去了。不幸的是CPython社区就喜欢这些泄漏的抽象，怕是难说服社区接受这种程度的改变——不然大家现在都该在用Pyston或者PyPy了。&lt;/p&gt;&lt;p&gt;另外，Pyjion未来要想进一步提升性能，需要在“哪些东西暴露在MSIL / IR层面“与”哪些东西封装在intrinsics / runtime helper function“之间找到一个更好的平衡。现在因为Pyjion把很多操作都放在了intrinsics里，RyuJIT无法理解也无法优化它们，失去了优化的机会；但如果把太多细节暴露给RyuJIT的话，方法体可能又会太大，让RyuJIT工作得太吃力。如何在两者间找到个好的平衡是门艺术。做得好的话，一些冗余的引用技术更新也应该可以消除掉，那就很爽。&lt;/p&gt;&lt;br&gt;&lt;p&gt;下次有机会再展示一下Pyjion目前已经做了的一种优化——带标记的指针（tagged pointer）。&lt;/p&gt;&lt;p&gt;(*) 这个思路就跟JVM里某些优化可以在两个safepoint之间进行，但不能跨越safepoint边界一样。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20591139</guid>
<pubDate>Mon, 22 Feb 2016 17:50:07 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
