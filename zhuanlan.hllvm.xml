<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 24 Apr 2016 15:30:14 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>ChakraCore的dump开关</title>
<link>http://zhuanlan.zhihu.com/p/20792855</link>
<description>&lt;a href=&quot;https://github.com/Microsoft/ChakraCore&quot; data-editable=&quot;true&quot; data-title=&quot;ChakraCore&quot;&gt;ChakraCore&lt;/a&gt;开源也有一阵了，作为最后开源的一个主流JS引擎，在GitHub上已经有了5000+的star，说明有很多人关注。对于想要研究ChakraCore的童鞋，如果直接从代码入手，不太容易下手和实验。对此，ChakraCore已经自带了不少dump开关来输出整个编译过程的中间结果，可以据此一窥整个编译的过程。这里就介绍下ChakraCore里面的常用dump开关。&lt;p&gt;ChakraCore编译出来是chakracore.dll，如果不想自己写一个host，可以用ChakraCore自带的host CH.exe. CH.exe使用的是JSRT接口来访问ChakraCore的编译功能。比如用ChakraCore运行下面的JS文件。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function foo(a, b) {
    return a + b
}

print(foo(3, 4))

print(foo(5, 6))&lt;/code&gt;当CH.exe和chakracore.dll都编译好后（CH.exe依赖于后者，所以只要在Visual Studio编译CH.exe就可以），可以运行 “ch.exe foo.js -bgjit- -maxinterpretercount:1 -off:simplejit -dump:backend&quot;, 这样除了script运行的输出，编译的时候的中间结果也会输出到控制台。西面先解释下上面传入的各个参数。&lt;ul&gt;&lt;li&gt;-bgjit-，禁止JIT运行的background线程。ChakraCore里面JIT默认运行在专门的线程里面接收script线程发来的编译请求（CodeGenWorkItem), 这样的好处是不会阻塞script线程继续运行（interpret），但是也会给调试过程带来不确定性，所以不是调试相关的bug可以关掉。&lt;/li&gt;&lt;li&gt;-maxinterpretercount:1, 仅允许Javascript function被interpret一次。ChakraCore里面有Interpreter, SimpleJit, FullJit, 优化程度和耗时是依次递增，比较hot的函数也会一次进入这几个阶段。ChakraCore里面有heuristic机制来决定function何时进入下一个阶段。Debug的时候自然不能依赖这个来进入JIT，所以对interpret count设置固定值。一般这里推荐设置成1而不是0，因为需要运行一次interpreter来收集profile data供后面JIT使用。另外这个选项可以缩写成 &quot;-mic:1&quot;。&lt;/li&gt;&lt;li&gt;off:simplejit，关掉SimpleJIT。这个作为第二层优化，比FullJIT简单很多，作为interpreter和FullJIT之间的一个平衡，研究中可以关掉。&lt;/li&gt;&lt;li&gt;-dump:backend，输出JIT过程中的中间结果。Chakra的JIT分成了很多个phase（这个和UTC（VC++的c2.dll）很像，但是相比还是简单很多，其实phase dump也和UTC的很像，不得不说ChakraCore的JIT受了UTC的很大影响），第一个phase是IRBuilder把Parser生成的bytecode转成内部的IR结构（intermediate representation），后面典型的phase有Inline, GlobOpt, Lower, Encoder等。每个phase都会在IR上收集些信息供后面的phase使用，或者直接在IR上做变换。运行 ”ch.exe -?&quot;就可以看到phase列表。这里会列出相当多的phase，但实际上并不代表ChakraCore有这么多阶段来做优化，里面很多phase实际上代表了中比较具体的优化，这样可以通过 &quot;-off&quot; 选项来关闭相关的优化，比如CSE (common sub-expression elimination)，CopyProp都被列为一个phase，但是他们都是在GlobOpt里面做的。&quot;-dump&quot; 选项接收一个实际的phase做参数（比如IRBuilder, Lower)从而在相关phase结束后dump相应的中间结果。在研究JIT bug的是有经常需要把JIT的所有phase的结果都dump出来看看是哪个phase除了问题，全部都写上比较浪费时间，就有了一个“backend”来代表所有的phases。ChkaraCore的JIT主要是针对function的（另外一个是loop），这样dump一个有很多function的JS文件而已知问题出在某个function里面的时候，会很不方便，这里的dump选项还接受一个function Id来过滤，比如“-dump:backend:1” （function Id可以在不带function Id过滤的dump里面找到，如下面“#1.1”后面的1就是）。后续再介绍这里其他数字（从源代码也比较容易看出来）和每条IR的意思。最后需要注意的是所有的dump代码指编译在Debug版本的chakracore.dll里。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面的JS在ChakraCore里面的实际dump如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-----------------------------------------------------------------------------



************   IR after IRBuilder (FullJit)  ************
-----------------------------------------------------------------------------
Function foo ( (#1.1), #2)                        Instr Count:13

                       FunctionEntry                                          #
    s1[Object].var  =  Ld_A           0xXXXXXXXX (GlobalObject)[Object].var   #
    s2[LikelyCanBeTaggedValue_Int].var = ArgIn_A  prm2&amp;lt;40&amp;gt;.var                #
    s3[LikelyCanBeTaggedValue_Int].var = ArgIn_A  prm3&amp;lt;48&amp;gt;.var                #


  Line   2: return a + b
  Col    5: ^
                       StatementBoundary  #0                                  #0000
    s0.var          =  Add_A          s2.var, s3.var                          #0000
                       Br             $L1                                     #0004
    s0.var          =  Ld_A           0xXXXXXXXX (undefined)[Undefined].var   #0007
$L1:                                                                          #0009


  Line   3: }
  Col    1: ^
                       StatementBoundary  #1                                  #0009
                       StatementBoundary  #-1                                 #0009
                       Ret            s0.var                                  #0009

                       FunctionExit                                           #&lt;/code&gt;</description>
<author>Thomson</author>
<guid isPermaLink="false">20792855</guid>
<pubDate>Sat, 23 Apr 2016 14:51:47 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>lisp0</title>
<link>http://zhuanlan.zhihu.com/p/20689554</link>
<description>&lt;p&gt;代码没写完，广告先打起来&lt;a class=&quot;&quot; data-title=&quot;GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/bhuztez/lisp0&quot;&gt; GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;学习高级语言Runtime最好的办法，当然是自己动手写一个啦。毫无疑问假如你不是特别喜欢走弯路的轮子哥，肯定选从容易的开始。那么就选最最原始的LISP好了(Brainfuck之类的过于简单，这里先忽略他们的存在)。lisp0不会像Lisp Machine是一台单独的机器，lisp0就是一个普通的运行在Linux的程序。&lt;/p&gt;&lt;p&gt;既然是把Runtime实现一遍，那么在操作系统之上全都自己来实现，连CRT和libc也不要用。因为Lisp语言自己就又栈了，所以C程序没事别递归，用的栈是非常有限的，于是用bss段里的一段内存当C语言的栈，而操作系统在启动时，分配来的栈，给Lisp用。这样虽然奇葩了点，非常省事啊。&lt;/p&gt;&lt;p&gt;因为(假装)lisp0是immutable的，所以只要简单的引用计数就可以了。不过这写起来麻烦，用一次就要增减一次。还不如先用个简单的Mark sweep GC。因为immutable，所以新的不能被旧的引用，在allocate后把他们串成一个栈，只要从新往旧扫一遍，在扫到时还没被标记，那就一定不会被标记到，可以放心的free。至于memory allocator，就用简陋的TLSF算法就好了，这算法看上去就像个增强版的Buddy allocator。&lt;br&gt;&lt;/p&gt;&lt;p&gt;既然Lisp霸占了原本给C用的栈，使用方式也就和C保持一致好了。因为GCC支持Labels as Values，所以只要在CALL之后放一个label，那个label的值就是返回地址了。同时，因为symbol只接受[_0-9A-Za-z]+，所以长度小于等于8的symbol，经过base64解码之后长度就只有6字节了，而64位机器上去掉3位tag，还有61位，完全放的下。&lt;/p&gt;&lt;p&gt;接下来，lisp0应该改用HAMT来实现environment，换一个更好的GC。本文到此就结束了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20689554</guid>
<pubDate>Wed, 30 Mar 2016 23:01:05 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Java局部类型推导（var）的试玩版</title>
<link>http://zhuanlan.zhihu.com/p/20646039</link>
<description>&lt;p&gt;上一篇新闻提到了未来版本的Java（或许是Java 10）会有局部类型推导功能，也就是“var”隐式声明变量类型的功能。大家有兴趣现在就玩玩它的话，有好人build了当前的原型实现：&lt;/p&gt;&lt;a href=&quot;http://iteratrlearning.com/jep286.html&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 286: Type Inference for Java Builds&quot; class=&quot;&quot;&gt;JEP 286: Type Inference for Java Builds&lt;/a&gt;&lt;p&gt;目前该网站提供了Mac OS X和Linux版JDK build。Windows版“coming soon”。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20646039</guid>
<pubDate>Tue, 15 Mar 2016 06:54:55 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Java也要有局部类型推导（var）了</title>
<link>http://zhuanlan.zhihu.com/p/20635474</link>
<description>请跳传送门：&lt;a href=&quot;http://openjdk.java.net/jeps/286&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 286: Local-Variable Type Inference&quot;&gt;JEP 286: Local-Variable Type Inference&lt;/a&gt;&lt;p&gt;看来有希望赶上Java 10。诶终于啊。&lt;/p&gt;&lt;p&gt;等JEP 286完成之后，Java的局部类型推导就比C#的还要神奇了…看：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;List&amp;lt;String&amp;gt; strs1 = new ArrayList&amp;lt;String&amp;gt;(); // Java 5 generics
List&amp;lt;String&amp;gt; strs2 = new ArrayList&amp;lt;&amp;gt;();       // Java 7 diamond syntax
var strs3 = new ArrayList&amp;lt;String&amp;gt;();          // JEP 286 var syntax&lt;/code&gt;&lt;p&gt;左边能推导到右边（Java 7 diamond），右边也能推导到左边（JEP 286 var），多欢乐 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;另外，C# 3.0里的var是个“&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/the35c6y.aspx&quot;&gt;上下文相关关键字&lt;/a&gt;”，也就是说只有在合适的地方写var才会被看作变量声明隐式声明类型的关键字，而其它地方（例如说作为变量名）则不算关键字而是普通标识符。JEP 286把这个设计基本找搬了，只是换了个名字叫做“reserved type name”。&lt;/p&gt;&lt;p&gt;========================================&lt;/p&gt;&lt;br&gt;&lt;p&gt;另外Java 10还有希望看到&lt;a href=&quot;http://openjdk.java.net/projects/valhalla/&quot; data-editable=&quot;true&quot; data-title=&quot;OpenJDK: Valhalla&quot;&gt;Project Valhalla&lt;/a&gt;的完成。到时候就可以写：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;var xs = new ArrayList&amp;lt;int&amp;gt;(); // Valhalla: generics over value types
&lt;/code&gt;&lt;p&gt;好棒好棒 &amp;gt;_&amp;lt;|||&lt;/p&gt;&lt;p&gt;但Valhalla当前到了第三版原型的设计，把彻底的类型特化给抛弃了，改为只对value type做特化。泪奔啊。这就意味着当前的原型设计不让这样写：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;  public static &amp;lt;T, U&amp;gt; T make(U arg0) {
    return new T(arg0);
  }&lt;/code&gt;&lt;p&gt;呜呜。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20635474</guid>
<pubDate>Thu, 10 Mar 2016 16:04:28 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] IBM OMR项目正式开源</title>
<link>http://zhuanlan.zhihu.com/p/20631665</link>
<description>代码在GitHub上：&lt;a href=&quot;https://github.com/eclipse/omr&quot; data-editable=&quot;true&quot; data-title=&quot;GitHub - eclipse/omr: OMR project&quot;&gt;GitHub - eclipse/omr: OMR project&lt;/a&gt;&lt;p&gt;项目负责人Mark Stoodley刚刚在EclipseCon上做了相关的演讲：&lt;a href=&quot;http://www.slideshare.net/MarkStoodley/omr-a-modern-toolkit-for-building-language-runtimes&quot; data-editable=&quot;true&quot; data-title=&quot;slideshare.net 的页面&quot; class=&quot;&quot;&gt;OMR: a modern toolkit for building language runtimes, EclipseCON 2016&lt;/a&gt;&lt;/p&gt;&lt;p&gt;IBM官方新闻稿：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/open/omr/&quot; data-editable=&quot;true&quot; data-title=&quot;OMR | developerWorks Open&quot; class=&quot;&quot;&gt;OMR | developerWorks Open&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/open/2016/03/08/introducing-omr-building-language-runtimes/&quot; data-editable=&quot;true&quot; data-title=&quot;Introducing OMR: Building language runtimes&quot;&gt;Introducing OMR: Building language runtimes&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;初始开源的组件有下面这些：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;port: platform porting library&lt;br&gt;&lt;/li&gt;&lt;li&gt;thread: a cross platform pthread-like threading library&lt;br&gt;&lt;/li&gt;&lt;li&gt;util: general utilities useful for building cross platform runtimes&lt;br&gt;&lt;/li&gt;&lt;li&gt;omrsigcompat: signal handling compatibility library&lt;br&gt;&lt;/li&gt;&lt;li&gt;omrtrace: tracing library for communication with IBM Health Center monitoring tools&lt;br&gt;&lt;/li&gt;&lt;li&gt;tool: code generation tools for the build system&lt;br&gt;&lt;/li&gt;&lt;li&gt;gc: garbage collection framework for managed heaps&lt;br&gt;&lt;/li&gt;&lt;li&gt;vm: APIs to manage per-interpreter and per-thread contexts&lt;br&gt;&lt;/li&gt;&lt;li&gt;example: demonstration code to show how a language runtime might consume some OMR components&lt;br&gt;&lt;/li&gt;&lt;li&gt;fvtest: a language-independent test framework so that OMR components can be tested outside of a language runtime&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;嗯最重磅的JIT部分还没出来，还在准备开源。&lt;/p&gt;&lt;br&gt;&lt;p&gt;知乎上之前的相关讨论：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; data-editable=&quot;true&quot; data-title=&quot;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&quot; class=&quot;&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20581695&quot; data-editable=&quot;true&quot; data-title=&quot;[新闻] CPython / 微软 Pyjion / IBM Python+OMR - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&quot;&gt;[新闻] CPython / 微软 Pyjion / IBM Python+OMR - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20631665</guid>
<pubDate>Wed, 09 Mar 2016 10:19:36 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[八卦] 据说Dropbox要试着在内部推广PyPy</title>
<link>http://zhuanlan.zhihu.com/p/20616374</link>
<description>去年年底的消息。就跟Pyston talk差不多时间吧。&lt;p&gt;- &quot;What about Pyston?&quot;&lt;/p&gt;&lt;p&gt;- &quot;At least one of them works.&quot;&lt;/p&gt;&lt;p&gt;还挺好玩。不过看着&lt;a href=&quot;https://github.com/dropbox/pyston/commits/master&quot;&gt;Pyston还不断在开发中&lt;/a&gt;，大概Pyston也不会就此挂掉吧…&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20616374</guid>
<pubDate>Thu, 03 Mar 2016 09:43:19 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Azul Systems正式宣布32位ARM上的Zulu Embedded</title>
<link>http://zhuanlan.zhihu.com/p/20595654</link>
<description>新闻稿：&lt;a href=&quot;https://www.azul.com/press_release/azul-systems-enhances-zulu-embedded-to-support-32-bit-arm-processors/&quot; data-editable=&quot;true&quot; data-title=&quot;Azul Systems enhances Zulu Embedded to support 32-bit ARM processors&quot;&gt;Azul Systems enhances Zulu Embedded to support 32-bit ARM processors&lt;/a&gt;&lt;p&gt;这是Azul Systems在OpenJDK的基础上做的ARMv7 / AArch32 port。目前已经有解释器以及完整的Client Compiler（C1）实现。&lt;/p&gt;&lt;p&gt;贯彻Zulu产品线的一贯作风，这个ARM port的所有代码都会在&lt;a href=&quot;http://openjdk.java.net/projects/aarch32-port/&quot; data-title=&quot;OpenJDK AArch32项目&quot; class=&quot;&quot;&gt;OpenJDK AArch32项目&lt;/a&gt;下完全开源。同事最近发的&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/aarch32-port-dev/2016-February/000094.html&quot;&gt;一个大patch&lt;/a&gt;就是为接下来提交C1代码而做的铺垫。&lt;/p&gt;&lt;p&gt;欢迎关注ARM上的Zulu Embedded！&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595654</guid>
<pubDate>Wed, 24 Feb 2016 08:15:57 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] Cliff Click大神也看上给Python加JIT了</title>
<link>http://zhuanlan.zhihu.com/p/20595643</link>
<description>&lt;a href=&quot;http://www.cliffc.org/blog/2016/02/19/winds-of-change&quot; data-editable=&quot;true&quot; data-title=&quot;Winds of Change&quot; class=&quot;&quot;&gt;Winds of Change - Cliff Click&#39;s Blog&lt;/a&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Python Go Fast:&lt;/strong&gt; Do Unto Python as Thou hast Done Unto Java. I hack the guts of Python; add a high power JIT, a full-fledged low-pause GC, true multi-threading support, i.e. make Python as fast and as parallel as Java (about the same speed as C).  This blog is really a request for an open discussion on this topic.  Is the Python community interested?  How does this get funded?  (uber Kickstarter?)  I’ll only go here with the full support of the core Python committers, and general “feel goods” from the general python community – and I’m hoping to start a discussion.  At this point I’m a premier language implementer, and making Python Go Fast is well within my abilities and past experiences. Take about 2 years &amp;amp; $2M for this effort to be self-sustaining (build all the core new tech and hand it off to other contributors).&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;困难啊…Cliff大神可能还没体会过CPython社区对“改变”的抗拒orz&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595643</guid>
<pubDate>Wed, 24 Feb 2016 08:09:04 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Pyjion的代码质量一例 [20160221]</title>
<link>http://zhuanlan.zhihu.com/p/20591139</link>
<description>&lt;p&gt;&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20581695&quot; data-title=&quot;上一篇文章&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;上一篇文章&lt;/a&gt;简单介绍了一下&lt;a href=&quot;https://github.com/Microsoft/Pyjion&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion项目&quot;&gt;Pyjion项目&lt;/a&gt;的目标与概况。相信很多同学都很好奇，目前的Pyjion到底效果如何对不对？&lt;/p&gt;&lt;p&gt;那我们就从一个再简单不过的例子来一探究竟。非常感谢&lt;a href=&quot;https://www.zhihu.com/people/f12d62dfdf1236e961460798455b1718&quot; data-hash=&quot;f12d62dfdf1236e961460798455b1718&quot; class=&quot;member_mention&quot; data-tip=&quot;p$b$f12d62dfdf1236e961460798455b1718&quot;&gt;@Thomson&lt;/a&gt;大大帮忙做实验，下面的实验结果都是拜托他帮忙获得的。&lt;/p&gt;&lt;p&gt;考虑下面的Python代码：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def foo(a, b):
  return a + b
&lt;/code&gt;&lt;p&gt;它由CPython编译得到的字节码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0 LOAD_FAST                0 (a)
3 LOAD_FAST                1 (b)
6 BINARY_ADD          
7 RETURN_VALUE
&lt;/code&gt;&lt;p&gt;（Pyjion目前是基于CPython 3.6.0 alpha 1，不过这里用CPython 2.x系列和3.x系列得到的字节码一样，不影响例子）&lt;/p&gt;&lt;p&gt;经过上一篇文章提到的编译流程，Pyjion会生成下面这样的MSIL来表达foo()函数的内容：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// function prologue
    ldarg.1
    ldc.i4       0x88                // offsetof(PyFrameObject, f_lasti)
    conv.i
    add
    stloc.0
    ldarg.1
    call         METHOD_PY_PUSHFRAME // PyJit_PushFrame
// 0: LOAD_FAST 0 (a)
    ldloc.0
    ldc.i4       0x0
    conv.i
    stind.i4
    ldarg.1
    ldc.i4       0x188               // offsetof(PyFrameObject, f_localsplus) + 0 * sizeof(size_t)
    conv.i
    add
    ldind.i
    dup
    ldc.i4       0x10                // offsetof(PyObject, ob_refcnt)
    conv.i
    add
    dup
    ldind.i4
    ldc.i4.1
    add
    stind.i4
// 3: LOAD_FAST 1 (b)
    ldloc.0
    ldc.i4       0x3
    conv.i
    stind.i4
    ldarg.1
    ldc.i4       0x190               // offsetof(PyFrameObject, f_localsplus) + 1 * sizeof(size_t)
    conv.i
    add
    ldind.i
    dup
    ldc.i4       0x10                // offsetof(PyObject, ob_refcnt)
    conv.i
    add
    dup
    ldind.i4
    ldc.i4.1
    add
    stind.i4
// 6: BINARY_ADD
    ldloc.0
    ldc.i4       0x6
    conv.i
    stind.i4
    call         METHOD_ADD_TOKEN    // PyJit_Add
    dup
    stloc.2
    ldc.i4.0
    conv.i
    bne.un       L_success
    br           L_Raise
L_success:
    ldloc.2
// 7: RETURN_VALUE
    ldloc.0
    ldc.i4       0x7
    conv.i
    stind.i4
    stloc.1
    leave        L_ret

// default exception handler
L_Raise:
    ldarg.1
    call         METHOD_EH_TRACE     // PyJit_EhTrace
L_Reraise:
    ldc.i4.0
    conv.i
    br           L_finalRet

// function epilogue
L_ret:
    ldloc.1
L_finalRet:
    ldarg.1
    call         METHOD_PY_POPFRAME  // PyJit_PopFrame
    ret
&lt;/code&gt;&lt;p&gt;看起来好像很夸张有没有？&lt;/p&gt;&lt;p&gt;其实完全没有。上面的MSIL，如果用类似C的伪代码表达，会是这个样子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;// emulate generated code in pseudo C
PyObject* foo_compiled_code(void* unused, PyFrameObject* frame) {
  // function prologue
  int* lasti = &amp;amp;frame-&amp;gt;f_lasti; // updates are needed to keep the frame state available for inspection
  PyJit_PushFrame(frame); // PyThreadState_Get()-&amp;gt;frame = frame;

  PyObject* errorCheckLocal;

  __try {                      // conceptual. Not a protected region in MSIL.
    // 0: LOAD_FAST 0 (a)
    *lasti = 0;
    PyObject* _a = frame-&amp;gt;f_localsplus[0];
    _a-&amp;gt;ob_refcnt++;
    // 3: LOAD_FAST 1 (b)
    *lasti = 3;
    PyObject* _b = frame-&amp;gt;f_localsplus[1];
    _b-&amp;gt;ob_refcnt++;
    // 6: BINARY_ADD
    *lasti = 6;
    PyObject* _sum = PyJit_Add(_a, _b);
    errorCheckLocal = _sum;
    if (_sum == NULL) {
      goto L_Raise;
    } else {
      _sum = errorCheckLocal;
    }
    // 7: RETURN_VALUE
    *lasti = 7;
    PyObject* retValue = _sum;
    goto L_ret;                // MSIL leave.s instruction, for clearing evaluation stack
  } __finally {                // conceptual. Not a fault handler in MSIL.
    // default exception handler
    // for error handling when we have no EH handlers, return NULL.
L_Raise:
    PyJit_EhTrace(frame);
L_Reraise:
    retValue = NULL;
  }

  // function epilogue
L_ret:
  PyJit_PopFrame(frame); // PyThreadState_Get()-&amp;gt;frame = frame-&amp;gt;f_back;
  return retValue;
}
&lt;/code&gt;&lt;p&gt;稍微解释一下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;上面的伪代码里，局部变量名有下划线（&#39;_&#39;）开头的实际上并不在MSIL层面的局部变量，而是在求值栈（evaluation stack）上，而没有下划线开头的则是真正的MSIL层面的局部变量。&lt;br&gt;&lt;/li&gt;&lt;li&gt;伪代码里的 __try { ... } __finally { ... } 并不是MSIL层面上的异常处理，而是逻辑上它是用来实现Python代码的异常处理语义用的。实际涉及的跳转我都在伪代码里用goto来表达了。CPython解释器自身经常通过返回值为NULL来表达要抛异常，Pyjion也完全继承了这个设计。要说有啥不同，那就是Pyjion会在编译时把CPython特别偷懒的“block stack”给展开来，于是就不用到运行时还每次跳出循环或者抛异常都去慢慢展开block stack了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以看到，Pyjion生成的MSIL所代表的逻辑，其实就是把CPython解释器中每个字节码的逻辑展开来粘合到一起。这样就消除了解释器循环自身带来的开销，所以肯定是要比CPython原本的解释执行要快。不过在此基础上它并没有做多少优化，而是为了兼容性而尽可能的去模仿CPython解释器原本的行为。例如说所有Python代码里的局部变量都还是跟CPython解释器一样从PyFrameObject的f_localsplus数组访问，最大限度的保证任何想inspect CPython执行状态的功能都还能正常运行。&lt;/p&gt;&lt;p&gt;在伪代码里还可以看到每条CPython字节码处理的开头都有一个对 frame-&amp;gt;f_lasti 的赋值。这同样是为了保证严格的兼容性而做的——CPython有许多地方在泄漏解释器的内部状态，例如&lt;a href=&quot;https://docs.python.org/3/library/traceback.html&quot; data-title=&quot;traceback函数&quot; class=&quot;&quot;&gt;traceback模块&lt;/a&gt;，例如&lt;a href=&quot;https://docs.python.org/3/library/inspect.html&quot; data-title=&quot;inspect模块&quot; class=&quot;&quot;&gt;inspect模块&lt;/a&gt;，又例如&lt;a href=&quot;https://docs.python.org/3/c-api/index.html&quot; data-title=&quot;毫无保护的C API&quot; class=&quot;&quot;&gt;毫无保护的C API&lt;/a&gt;，它们都可以去查看Python解释器栈的状态，而这个由 PyFrameObject 构成的栈中很重要的内容就是“当前执行到哪里了”，也就是这个 f_lasti 字段。要想百分百兼容依赖了这些抽象泄漏的众多现有的Python库，要么就得这样死板的实现，否则就得实现得非常非常非常麻烦。&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外可以发现，生成的MSIL里还嵌入着一些native函数调用。Pyjion把这些函数叫做intrinsics，也可以叫做runtime helper function。Pyjion通过这种方式来支持Python字节码里隐含的“复杂操作”，例如那个&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp#L87&quot; data-editable=&quot;true&quot; data-title=&quot;PyJit_Add()&quot;&gt;PyJit_Add()&lt;/a&gt;。它的实现长啥样呢？&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;PyObject* PyJit_Add(PyObject *left, PyObject *right) {
    // TODO: Verify ref counting...
    PyObject *sum;
    if (PyUnicode_CheckExact(left) &amp;amp;&amp;amp; PyUnicode_CheckExact(right)) {
        PyUnicode_Append(&amp;amp;left, right);
        sum = left;
    }
    else {
        sum = PyNumber_Add(left, right);
        Py_DECREF(left);
    }
    Py_DECREF(right);
    return sum;
}
&lt;/code&gt;&lt;p&gt;这其实就跟CPython解释器里的&lt;a href=&quot;https://github.com/python/cpython/blob/efe0e11c78f890146375f1d4cbed4b513cdffa3c/Python/ceval.c#L1559&quot; data-title=&quot;BINARY_ADD字节码&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;BINARY_ADD字节码&lt;/a&gt;的内部实现几乎是一样的，只是把求值栈的操作映射到了MSIL层面上。&lt;/p&gt;&lt;p&gt;而面对这样的runtime helper函数，RyuJIT只能当它们是黑盒子而无法进一步分析与优化，也就无从內联这些函数的调用。&lt;/p&gt;&lt;p&gt;在Windows x86-64上的RyuJIT，最终会把上面的foo()函数例子编译为这样的机器码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// function prologue
    push    rdi
    push    rsi
    sub     rsp,28h
    mov     rsi,rdx
    lea     rdi,[rsi+88h]
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_PY_PUSHFRAME+0x38
    call    qword ptr [rax]
// 0: LOAD_FAST 0 (a)
    xor     ecx,ecx
    mov     dword ptr [rdi],ecx
    mov     rcx,qword ptr [rsi+188h]
    lea     rdx,[rcx+10h]
    add     dword ptr [rdx],1
// 3: LOAD_FAST 1 (b)
    mov     dword ptr [rdi],3
    mov     rdx,qword ptr [rsi+190h]
    lea     rax,[rdx+10h]
    add     dword ptr [rax],1
// 6: BINARY_ADD
    mov     dword ptr [rdi],6
    mov     rax,offset pyjit!gMETHOD_ADD_TOKEN+0x38
    call    qword ptr [rax]
    test    rax,rax
    je      L_Raise
// 7: RETURN_VALUE
    mov     dword ptr [rdi],7
    jmp     L_ret
// default exception handler
L_Raise:
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_EH_TRACE+0x38
    call    qword ptr [rax]
L_Reraise:
    xor     edi,edi
    jmp     L_finalRet
// function epilogue
L_ret:
    mov     rdi,rax
L_finalRet:
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_PY_POPFRAME+0x38
    call    qword ptr [rax]
    mov     rax,rdi
    add     rsp,28h
    pop     rsi
    pop     rdi
    ret
&lt;/code&gt;&lt;p&gt;嗯…跟上面的MSIL层面的逻辑几乎完全一样，只是MSIL层面的求值栈和局部变量都被优化到x86-64指令集的寄存器上了，其它就跟伪代码里写的一模一样。&lt;/p&gt;&lt;p&gt;Pyjion要真的让CPython的性能有突飞猛进的发展，还有很长的路要走。&lt;/p&gt;&lt;p&gt;就这个例子来说，其实它的 *lasti = 0 和 *lasti = 3 都是完全冗余的，因为可以假设CPython不会有机会观察到这俩状态——直到下次Pyjion要通过periodic_work进入CPython runtime，或者下次调用可能暴露实现细节的CPython函数 (*)。诸如这样的冗余可以通过更彻底的静态分析来消除掉，只是要实现它就得堆人力和时间了。&lt;/p&gt;&lt;p&gt;而许多能有效提升动态语言性能的技巧，在当前的CPython上都行不通，因为它对自己的内部状态实在没有啥封装可言，内部实现细节泄漏得到处都是。如果能堵上那些抽象泄漏，就可以把隐藏类（hidden class）、多态內联（polymorphic inline caching）、类型推导以及进一步优化一股脑的堆上去了。不幸的是CPython社区就喜欢这些泄漏的抽象，怕是难说服社区接受这种程度的改变——不然大家现在都该在用Pyston或者PyPy了。&lt;/p&gt;&lt;p&gt;另外，Pyjion未来要想进一步提升性能，需要在“哪些东西暴露在MSIL / IR层面“与”哪些东西封装在intrinsics / runtime helper function“之间找到一个更好的平衡。现在因为Pyjion把很多操作都放在了intrinsics里，RyuJIT无法理解也无法优化它们，失去了优化的机会；但如果把太多细节暴露给RyuJIT的话，方法体可能又会太大，让RyuJIT工作得太吃力。如何在两者间找到个好的平衡是门艺术。做得好的话，一些冗余的引用技术更新也应该可以消除掉，那就很爽。&lt;/p&gt;&lt;br&gt;&lt;p&gt;下次有机会再展示一下Pyjion目前已经做了的一种优化——带标记的指针（tagged pointer）。&lt;/p&gt;&lt;p&gt;(*) 这个思路就跟JVM里某些优化可以在两个safepoint之间进行，但不能跨越safepoint边界一样。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20591139</guid>
<pubDate>Mon, 22 Feb 2016 17:50:07 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] CPython / 微软 Pyjion / IBM Python+OMR</title>
<link>http://zhuanlan.zhihu.com/p/20581695</link>
<description>&lt;h2&gt;&lt;b&gt;大背景&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;在进入主题前，请先看看IBM Research以前做过的类似项目的经验：Fiorano项目。&lt;/p&gt;&lt;p&gt;Fiorano是IBM Research做的一次尝试，将IBM J9 JVM所使用的Testarossa（TR）编译器单独拿出来，插入到CPython运行时中为后者提供JIT编译服务。&lt;/p&gt;&lt;p&gt;传送门：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p169.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;Adding Dynamically-Typed Language Support to a Statically-Typed Language Compiler: Performance Evaluation, Analysis, and Tradeoffs&quot; class=&quot;&quot;&gt;Adding Dynamically-Typed Language Support to a Statically-Typed Language Compiler: Performance Evaluation, Analysis, and Tradeoffs&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://researcher.watson.ibm.com/researcher/files/us-pengwu/oopsla12-final-dsl.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;ibm.com 的页面&quot; class=&quot;&quot;&gt;On the Benefits and Pitfalls of Extending a Statically Typed Language JIT Compiler for Dynamic Scripting Languages&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;结果呢？当然Fiorano没有被整合到官方CPython里，不然现在大家就已经在用它了。但作为研究性项目它还是有点意思的——我觉得最重要的一点，是在一个原本没有打算与高性能JIT编译器搭配使用的runtime上，很难实现出特别有效的优化。在主流JVM上，JIT编译后的代码的速度可以轻易达到解释器速度的10x水平；而Fiorano带上了JIT却也就达到了纯解释执行的CPython的速度的1.2x～2.74x的水平范围，并没有给大家带来多少震撼…&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;Pyjion&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Microsoft/Pyjion&quot; data-editable=&quot;true&quot; data-title=&quot;GitHub - Microsoft/Pyjion: Pyjion&quot; class=&quot;&quot;&gt;GitHub - Microsoft/Pyjion: Pyjion&lt;/a&gt;&lt;/p&gt;&lt;p&gt;开源许可证：MIT&lt;/p&gt;&lt;p&gt;是的，微软近期也加入了给&lt;a href=&quot;https://www.python.org/&quot; data-editable=&quot;true&quot; data-title=&quot;CPython&quot;&gt;CPython&lt;/a&gt;加JIT编译器的大混战。微软甚至还有一个寄身于Data Group in Azure组的Python研发组，最近&lt;a href=&quot;https://blogs.msdn.microsoft.com/pythonengineering/2016/02/12/welcome/&quot; data-title=&quot;开始宣传&quot; class=&quot;&quot;&gt;开始对外宣传&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;项目名是“Pyjion”，读作“pigeon”（鸽子），因为项目主力成员Dino大大想要有Python的Py音节、JIT的Ji音节的词…就找（sheng）到（zao）了这么个词出来。GJ！&lt;br&gt;&lt;/p&gt;&lt;p&gt;说起项目主要成员之一的&lt;a href=&quot;http://blogs.msdn.com/b/dinoviehland/&quot; data-editable=&quot;true&quot; data-title=&quot;Dino Viehland&quot; class=&quot;&quot;&gt;Dino Viehland&lt;/a&gt;大大，他以前是IronPython与DLR的主力开发之一，后来也参与了&lt;a href=&quot;http://microsoft.github.io/PTVS/&quot; data-editable=&quot;true&quot; data-title=&quot;Python Tools for Visual Studio（PTVS）&quot;&gt;Python Tools for Visual Studio（PTVS）&lt;/a&gt;的开发。大家用Visual Studio / VS Express开发Python爽不？里面就有Dino大大的功劳。&lt;/p&gt;&lt;p&gt;可见他对Python那可是有深深的怨念…是真爱啊！&lt;/p&gt;&lt;p&gt;而Pyjion项目的另一个主要成员是Brett Cannon。他从2003年开始就是CPython的core commiter了。这也是真爱啊！&lt;/p&gt;&lt;p&gt;未来传送门：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PyCon US 2016：&lt;a href=&quot;https://us.pycon.org/2016/schedule/presentation/1866/&quot; data-editable=&quot;true&quot; data-title=&quot;Presentation: Pyjion: who doesn’t want faster for free?&quot; class=&quot;&quot;&gt;Presentation: Pyjion: who doesn’t want faster for free?&lt;/a&gt; - 2016-05-30&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;言归正传，这Pyjion到底是啥呢？它是Brett和Dino做的&lt;b&gt;实验产物&lt;/b&gt;，为了在保持完全兼容的前提下提升CPython的性能。目前基于的CPython版本是3.6 alpha 1。&lt;/p&gt;&lt;br&gt;&lt;p&gt;项目官网的一句话说明是：&quot;A JIT for Python based upon CoreCLR&quot;。它目前的项目目标有三个：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;Add a C API to CPython for plugging in a JIT&lt;/b&gt;（&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/master/Patches/python.diff&quot; data-editable=&quot;true&quot; data-title=&quot;代码&quot;&gt;代码&lt;/a&gt;） &amp;lt;- 最主要的目标&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;ol&gt;&lt;li&gt;Develop a JIT module using CoreCLR utilizing the C API mentioned in goal #1（&lt;a href=&quot;https://github.com/Microsoft/Pyjion/tree/master/Pyjion&quot; data-editable=&quot;true&quot; data-title=&quot;代码&quot;&gt;代码&lt;/a&gt;） &amp;lt;- 概念验证用&lt;br&gt;&lt;/li&gt;&lt;li&gt;Develop a C++ framework&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;目标1很简单，就是给CPython添加一组新的C API及其实现，来为外部的JIT编译器提供接入CPython运行时的钩子。这部分目前设计和实现都很直观，看看上面的代码链接的patch就知道它是啥了——在解释器入口处添加钩子，当有JIT编译器注册进来时，一个函数在即将开始被解释执行时会先尝试JIT编译，如果成功以后就执行JIT出来的机器码；如果不成功就会把该函数标记为不可JIT编译，以后就不再尝试了。&lt;/p&gt;&lt;p&gt;目前这C API并不太灵活，只允许以Python函数为单元来编译，编译必须对整个函数成功，否则就得整个函数留在解释器里跑。这个API没有考虑到在函数中间跳进JIT编译的代码（On-Stack Replacement，OSR）或从JIT编译的代码中途跳回到解释器（deoptimization）之类的需求。&lt;/p&gt;&lt;p&gt;目标2的描述方式挺有趣的：把&lt;a href=&quot;https://github.com/dotnet/coreclr&quot; data-editable=&quot;true&quot; data-title=&quot;CoreCLR&quot;&gt;CoreCLR&lt;/a&gt;当作JIT编译器插入CPython。啥？难道为了JIT还得把整个CoreCLR都拉进来么？太可怕了！&lt;/p&gt;&lt;p&gt;实际上当然没那么糟糕。这个描述方式感觉是故意说得模糊一些。其实Pyjion只是要使用CoreCLR里带着的&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md&quot; data-editable=&quot;true&quot; data-title=&quot;RyuJIT编译器&quot;&gt;RyuJIT编译器&lt;/a&gt;来为CPython服务。但是当前的RyuJIT的实现依赖了CLR / CoreCLR提供的JIT编译器接口，所以要单独使用RyuJIT的话，得要把原本由CLR / CoreCLR提供的一些服务/接口给模拟出来才行。这个模拟层在Pyjion代码里就是CExecutionEngine、CorJitInfo等类。&lt;/p&gt;&lt;p&gt;换言之，Pyjion自身在pyjit.dll中，而它并不真的需要依赖整个CoreCLR（主体位于coreclr.dll），而只需要其中的RyuJIT（位于clrjit.dll）及其必须依赖的库（例如gcinfo），然后提供CExecutionEngine、CorJitInfo等类的实现给RyuJIT模拟出它所依赖CoreCLR的一些功能。&lt;/p&gt;&lt;p&gt;据说RyuJIT其实是希望未来与CLR / CoreCLR分离开，变得更独立，便于在诸如Pyjion这样的场景单独使用。目前RyuJIT与CLR确实不是由同一个组负责开发的，要分家也很合理。但未来会如何发展，外界也只能拭目以待了。&lt;/p&gt;&lt;p&gt;那么Pyjion是如何使用RyuJIT的呢？&lt;/p&gt;&lt;p&gt;它并没有实现一个RyuJIT的前端，直接把CPython字节码转换为RyuJIT的IR；而是把CPython字节码先转换为CLR的&lt;a href=&quot;https://en.wikipedia.org/wiki/Common_Intermediate_Language&quot; data-editable=&quot;true&quot; data-title=&quot;MSIL&quot;&gt;MSIL&lt;/a&gt;字节码，然后再让RyuJIT去把这MSIL编译成机器码，最后安装到CPython运行时里去运行。这种做法或许多少与项目组成员之前做IronPython的经历有关系，或者是与RyuJIT现在与CLR / CoreCLR的偶和有关系。&lt;/p&gt;&lt;p&gt;不过这里生成的MSIL只用了MSIL的指令集，而没有完全实现标准的Assembly格式；其元数据相关部分都是Pyjion用自己的数据结构模拟出来的，所以无法将生成的MSIL交给诸如ildasm之类的工具来查看。&lt;/p&gt;&lt;p&gt;具体的转换步骤是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;CPython的解释器入口&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Patches/python.diff#L364&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion/python.diff at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub&quot; class=&quot;&quot;&gt;PyEval_EvalFrameEx()&lt;/a&gt;调用JIT编译器JitCompile()函数，传入CPython字节码。&lt;br&gt;&lt;/li&gt;&lt;li&gt;JIT编译器入口&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pyjit.cpp#L52&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion/pyjit.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub&quot; class=&quot;&quot;&gt;JitCompile()&lt;/a&gt;创建AbstractInterpreter与PythonCompiler，调用&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L2971&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion/absint.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub&quot; class=&quot;&quot;&gt;AbstractInterpreter::compile()&lt;/a&gt;开始编译流程。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.h#L157&quot; data-editable=&quot;true&quot; data-title=&quot;AbstractInterpreter&quot; class=&quot;&quot;&gt;AbstractInterpreter&lt;/a&gt;类充当CPython字节码的解析器（parser），一边抽象解释CPython字节码一边调用PythonCompiler来生成MSIL。&lt;br&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L59&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion/absint.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub&quot; class=&quot;&quot;&gt;AbstractInterpreter::preprocess()&lt;/a&gt;先把CPython字节码里偷懒而设计的&quot;Block&quot;给预处理掉，把循环的跳转目标、异常处理块的边界给找出来并扁平化。可能有同学不理解“偷懒”是什么意思：Python的字节码编译器在处理循环和异常相关的控制流时，没有在编译器里处理嵌套关系，而是把“作用域栈”留到了解释器里。而正确的做法是&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.h#L185&quot;&gt;在编译器里处理掉它&lt;/a&gt;，例如这样：&lt;a href=&quot;https://www.zhihu.com/question/28992261/answer/43400987&quot; data-editable=&quot;true&quot; data-title=&quot;如何对C语言的FOR语句给出一个生成中间代码的语法制导定义？ - RednaxelaFX 的回答&quot; class=&quot;&quot;&gt;如何对C语言的FOR语句给出一个生成中间代码的语法制导定义？ - RednaxelaFX 的回答&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L190&quot; data-editable=&quot;true&quot; data-title=&quot;AbstractInterpreter::interpret()&quot; class=&quot;&quot;&gt;AbstractInterpreter::interpret()&lt;/a&gt;遍历一遍整个CPython函数的字节码，找出基本块边界、异常处理块的边界，以及收集一些后续优化可能用到的信息。例如说它会做个很保守的逃逸分析来判断哪些值没有逃逸，后面就可以选择对它们做进一步特殊优化，例如下文提到的tagged pointer。&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L1796&quot; data-editable=&quot;true&quot; data-title=&quot;AbstractInterpreter::compile_worker()&quot; class=&quot;&quot;&gt;AbstractInterpreter::compile_worker()&lt;/a&gt;一个个基本块遍历CPython字节码并生成MSIL字节码。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.h#L221&quot; data-editable=&quot;true&quot; data-title=&quot;PythonCompiler&quot; class=&quot;&quot;&gt;PythonCompiler&lt;/a&gt;会把每种CPython字节码的操作映射为合适的MSIL字节码序列。简单的CPython字节码可以直接映射为一条或多条MSIL字节码，而复杂的字节码则映射为Pyjion的&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.h&quot; data-editable=&quot;true&quot; data-title=&quot;intrinsic函数&quot;&gt;intrinsic函数&lt;/a&gt;的调用。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;例如两个Python对象相加，会映射为对Pyjion提供的“&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp#L87&quot; data-editable=&quot;true&quot; data-title=&quot;PyJit_Add()&quot;&gt;PyJit_Add()&lt;/a&gt;”函数的调用，而这个函数会调用回到CPython运行时里的实现。&lt;/li&gt;&lt;li&gt;具体生成MSIL的有一个&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/ilgen.h#L66&quot; data-editable=&quot;true&quot; data-title=&quot;ILGenerator&quot;&gt;ILGenerator&lt;/a&gt;类。它与.NET的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.reflection.emit.ilgenerator.aspx&quot; data-title=&quot;System.Reflection.Emit.ILGenerator&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;System.Reflection.Emit.ILGenerator&lt;/a&gt;颇为神似。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.cpp#L1084&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion/pycomp.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub&quot; class=&quot;&quot;&gt;PythonCompiler::emit_compile()&lt;/a&gt; -&amp;gt; &lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/ilgen.h#L470&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Pyjion/ilgen.h at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub&quot;&gt;ILGenerator::compile()&lt;/a&gt; -&amp;gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/b16ff5935ff9df3211798f18f0c951666ae27774/src/jit/ee_il_dll.cpp#L135&quot; data-editable=&quot;true&quot; data-title=&quot;CILJit::compileMethod()&quot;&gt;CILJit::compileMethod()&lt;/a&gt; MSIL传入RyuJIT开始编译。&lt;br&gt;&lt;/li&gt;&lt;li&gt;接下来就交给RyuJIT编译，得到编译好的机器码以及一些相关的元数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;换句话说，Pyjion这种实现JIT编译的方式，实际的效果是把一个Python函数的字节码全部粘合到一起，去掉了解释器循环自身的开销，但是大部分复杂的操作还是调用回到CPython运行时去处理的。&lt;/p&gt;&lt;p&gt;要说在语义层面上的优化，Pyjion尝试了给CPython添加&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/taggedptr.h&quot; data-editable=&quot;true&quot; data-title=&quot;tagged pointer&quot; class=&quot;&quot;&gt;tagged pointer&lt;/a&gt;来减少小整数的内存开销，顺带提高运行性能（因为实际数据就伪装在指针里，离运算更近了）。但为了保证兼容性，tagged pointer只在被JIT编译的函数内部使用，一到&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L3051&quot;&gt;return_value&lt;/a&gt;之类的要暴露（escape）出去的地方就还是装箱（box）回到原本的对象形态。对应的intrinsic实现在&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp#L2291&quot; data-editable=&quot;true&quot; data-title=&quot;TAGGED_METHOD宏&quot;&gt;TAGGED_METHOD宏&lt;/a&gt;里（例如&lt;a href=&quot;https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.cpp#L1277&quot; data-editable=&quot;true&quot; data-title=&quot;PyJit_Add_Int()&quot; class=&quot;&quot;&gt;PyJit_Add_Int()&lt;/a&gt;就是这样来的）。&lt;/p&gt;&lt;p&gt;原本CPython解释器在解释执行每N条字节码指令后都会做些周期性检查，例如是否应该释放GIL来给别的线程机会执行。Pyjion把Python代码JIT编译后，这些周期性检查就安放在用户代码里的循环回跳（backedge）的地方。这跟HotSpot VM的JIT编译代码选择的放置safepoint polling的位置一样。&lt;/p&gt;&lt;p&gt;总体来说，Pyjion采用了一种非常保守的实现方式，很容易保证正确性，但能带来的性能提升也会非常有限。保守是否就意味着容易被接受呢？难说…搞不好会给人太多想像空间结果很失望orz&lt;/p&gt;&lt;p&gt;希望当前的保守设计只是一个过渡阶段。毕竟这个设计比Fiorano的做法还要保守，能带来的性能提升就更有限了。&lt;/p&gt;&lt;p&gt;在JIT编译之外，Pyjion还有没有向CPython注入任何其它东西呢？一点也没有。GIL、GC、监控之类的额外功能一概没碰。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;IBM Python+OMR&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;回头一点点更新。先放个传送门讲解背景：&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; data-editable=&quot;true&quot; data-title=&quot;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20581695</guid>
<pubDate>Thu, 18 Feb 2016 15:44:23 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
