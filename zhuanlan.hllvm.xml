<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 17 Feb 2016 04:29:34 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>[新闻][JavaScript引擎] WebKit JavaScriptCore又扔掉了LLVM…</title>
<link>http://zhuanlan.zhihu.com/hllvm/20577490</link>
<description>传送门：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//webkit.org/blog/5852/introducing-the-b3-jit-compiler/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Introducing the B3 JIT Compiler&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;p&gt;Filip大大再次立功。苹果内部果然也开撕了嘛…&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这次更新后，JavaScriptCore仍旧会使用4层编译系统：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第1层：解释器 LLInt&lt;br&gt;&lt;/li&gt;&lt;li&gt;第2层：简易JIT编译器 Baseline JIT&lt;/li&gt;&lt;li&gt;第3层：优化JIT编译器 DFG JIT&lt;/li&gt;&lt;li&gt;第4层：高度优化JIT编译器 FTL JIT&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;只不过，这个FTL的意思变了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;老：Fourth Tier LLVM = DFG++ + LLVM&lt;br&gt;&lt;/li&gt;&lt;li&gt;新：Faster Than Light = DFG++ + B3&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;…名字的更新当然是故意的。以前就有人开玩笑说FTL是faster than light，现在把LLVM扔掉了这名字就干脆也改过来了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;不得不说Filip大大带的JavaScriptCore团队还挺厉害的。去年10月开始写这个新的名为“B3”的后端，过了4个月就已经上了正轨了。&lt;/p&gt;&lt;p&gt;B3本质上是对LLVM的剪裁与特化，针对JavaScriptCore的需求而生。它与LLVM在相似的抽象层，B3 IR的构造API也与LLVM IR相似，这样FTL::Output就可以方便的从原本构造LLVM IR切换到构造B3 IR。&lt;/p&gt;&lt;p&gt;这个B3后端最最核心的关注点就是减少内存开销。这再次展示了&lt;b&gt;编译器中IR在内存里的布局对编译速度的影响&lt;/b&gt;——但主要关注AOT编译场景的编译器（例如GCC和LLVM）大多不够注重这一点。&lt;/p&gt;&lt;p&gt;以前跟JRockit的JIT编译器开发聊天的时候，他们也提到JRockit的JIT编译器IR有过一次重要的更新，大幅减少了内存开销而并没有做什么别的特别优化，光是这样就让编译速度提升了50%而编译出来的代码质量与以前一样。JRockit减少编译器IR的内存开销主要是通过几种思路：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;减少数据结构中指针的使用，改为用更紧凑的整数ID/下标来表示引用关系；&lt;/li&gt;&lt;li&gt;尽量用固定大小的结构表示常用信息，而把可变长并且不常用的信息挪到外部；&lt;/li&gt;&lt;li&gt;尽量把数据紧凑的放在数组/vector里。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;无独有偶，B3的思路和JRockit非常非常相似。这也是比较新的、干净的IR设计流行的做法。&lt;/p&gt;&lt;br&gt;&lt;p&gt;B3目前采用的寄存器分配器是一个graph coloring算法的变种，叫做&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cs.princeton.edu/research/techreps/TR-498-95&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Iterated Register Coalescing&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。LLVM默认的寄存器分配器则是一种linear scan算法的比较复杂的变种，叫做Greedy。Greedy虽然比原始的linear scan慢一些，但是总体来说还是比graph coloring系的算法快而效果相近。所以Filip大大也说会一边继续优化B3基于IRC的寄存器分配器，一边考虑&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//bugs.webkit.org/show_bug.cgi%3Fid%3D153797&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;把Greedy分配算法移植到JavaScriptCore里&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20577490</guid>
<pubDate>Wed, 17 Feb 2016 04:05:15 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>给类型求导</title>
<link>http://zhuanlan.zhihu.com/hllvm/20570808</link>
<description>熟识类型的用家可能都知道两个非常常见的类型构造：二元组和标签并，在代数类型（Algebraic type）中分别映射到乘法和加法，于是多项式&lt;img src=&quot;https://zhihu.com/equation?tex=1%2Bt%5E2&quot; alt=&quot;1+t^2&quot; eeimg=&quot;1&quot;&gt;可以用来表示&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BEither%7D%5C%3B%28%29%5C%3B%28t%2Ct%29&quot; alt=&quot;\mathrm{Either}\;()\;(t,t)&quot; eeimg=&quot;1&quot;&gt;这样的构造。继续扩展下去，比如把递归类型引入的话，就得到了许多递归类型的有理式表示，比如列表，它可以表示成&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D%5Cfrac%7B1%7D%7B1-a%7D&quot; alt=&quot;L(a)=\frac{1}{1-a}&quot; eeimg=&quot;1&quot;&gt;，因为它是方程&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D1%2BaL%28a%29&quot; alt=&quot;L(a)=1+aL(a)&quot; eeimg=&quot;1&quot;&gt;的解 [注 1]，而这个方程是列表的递归类型表示（在 Isorecursive 语义下，它表示&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29&quot; alt=&quot;L(a)&quot; eeimg=&quot;1&quot;&gt;和&lt;img src=&quot;https://zhihu.com/equation?tex=1%2BaL%28a%29&quot; alt=&quot;1+aL(a)&quot; eeimg=&quot;1&quot;&gt;之间存在一一映射，在实现时则用「指针」表示这种映射）。&lt;p&gt;上面的列表若是实现出来的话，是用链表实现的，对于双向遍历的话性能很差，于是我们发明一个 Zipper 类型，它同时存储一个焦点项目和它的左右两侧：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Zipper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;向左右两侧遍历的操作就可以写成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;left&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;反向遍历的复杂度也降低到了 O(1)，性能获得了很可观的提升。除了列表，其他更复杂的数据结构，如二叉树等，也可以定义出 Zipper。&lt;/p&gt;&lt;p&gt;从代数类型的角度看，Zipper 的方程可以写作&lt;img src=&quot;https://zhihu.com/equation?tex=Z%28a%29%3DL%28a%29%5Ccdot+a+%5Ccdot+L%28a%29%3DaL%28a%29%5E2&quot; alt=&quot;Z(a)=L(a)\cdot a \cdot L(a)=aL(a)^2&quot; eeimg=&quot;1&quot;&gt;，换言之，一个列表的 Zipper 可以看作一个「焦点」和两个列表的积，而后者则是原来列表类型敲掉一个空位。&lt;img src=&quot;https://pic1.zhimg.com/0ed4cd4fd0e3bae9483c9a58ae37461c_b.png&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;49&quot; class=&quot;content_image&quot; width=&quot;400&quot;&gt;&lt;/p&gt;&lt;p&gt;给数据结构挖个洞是个不太罕见的需求，我们已经知道&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C+%5Cfrac%7B1%7D%7B1-a%7D%3D%5Cleft%28%5Cfrac%7B1%7D%7B1-a%7D%5Cright%29%5E2&quot; alt=&quot;\mathrm{Hole}_a\ \frac{1}{1-a}=\left(\frac{1}{1-a}\right)^2&quot; eeimg=&quot;1&quot;&gt;。对于更简单的类型，我们也可以试试在上面挖洞，比如，类型 1 因为挖不出来洞，所以&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a+1%3D+0&quot; alt=&quot;\mathrm{Hole}_a 1= 0&quot; eeimg=&quot;1&quot;&gt;；「一元组」a 挖洞之后都变一样了，于是&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%3D1&quot; alt=&quot;\mathrm{Hole}_a\;a=1&quot; eeimg=&quot;1&quot;&gt;；而对于二元组&lt;img src=&quot;https://zhihu.com/equation?tex=a%5E2&quot; alt=&quot;a^2&quot; eeimg=&quot;1&quot;&gt;，因为存在两种可能的「挖」法（左或右），所以&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%5E2%3D%28%28%29%2Ca%29%2B%28a%2C%28%29%29%3D2a&quot; alt=&quot;\mathrm{Hole}_a\;a^2=((),a)+(a,())=2a&quot; eeimg=&quot;1&quot;&gt;。这可以推广到所有的简单元祖，我们总可以得到&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%5En%3Dna%5E%7Bn-1%7D&quot; alt=&quot;\mathrm{Hole}_a\;a^n=na^{n-1}&quot; eeimg=&quot;1&quot;&gt;。&lt;/p&gt;&lt;p&gt;看上去怎么那么眼熟。&lt;/p&gt;&lt;p&gt;…………………………&lt;/p&gt;&lt;p&gt;这不是求导么？&lt;/p&gt;&lt;p&gt;对，Conor McBride 的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//strictlypositive.org/diff.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;论文&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;中，就论述了类型上的导子（Derivation）&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a&quot; alt=&quot;\partial_a&quot; eeimg=&quot;1&quot;&gt;，并且证明了它和「挖洞」行为之间的联系。导子的三个基础法则——和法则、莱布尼兹法则和链式法则，都可以用挖洞的行为「证明」。&lt;img src=&quot;https://pic1.zhimg.com/40d585a0d6a2e0bf510df7b3a984e5b4_b.png&quot; data-rawwidth=&quot;1828&quot; data-rawheight=&quot;344&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1828&quot; data-original=&quot;https://pic1.zhimg.com/40d585a0d6a2e0bf510df7b3a984e5b4_r.png&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/a5830a07404680c707a5a911582d0902_b.png&quot; data-rawwidth=&quot;1875&quot; data-rawheight=&quot;688&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1875&quot; data-original=&quot;https://pic3.zhimg.com/a5830a07404680c707a5a911582d0902_r.png&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/7f40b2bfe902ccd0782cd2801579e807_b.png&quot; data-rawwidth=&quot;1774&quot; data-rawheight=&quot;556&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1774&quot; data-original=&quot;https://pic4.zhimg.com/7f40b2bfe902ccd0782cd2801579e807_r.png&quot;&gt;&lt;/p&gt;&lt;p&gt;除此之外隐函数的「微分」同样适用于数据类型。考虑将导子作用到二叉树&lt;img src=&quot;https://zhihu.com/equation?tex=T%28a%29%3D1%2BaT%28a%29%5E2&quot; alt=&quot;T(a)=1+aT(a)^2&quot; eeimg=&quot;1&quot;&gt;上：&lt;/p&gt;&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3DT%28a%29%5E2%2B2aT%28a%29%5Ccdot%5Cpartial_a+T%28a%29&quot; alt=&quot;\partial_a T(a)=T(a)^2+2aT(a)\cdot\partial_a T(a)&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;p&gt;可以解得&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3D%5Cfrac%7BT%28a%29%5E2%7D%7B1-2aT%28a%29%7D%3DT%28a%29%5E2%5Ccdot+L%282%5Ccdot+a%5Ccdot+T%28a%29%29&quot; alt=&quot;\partial_a T(a)=\frac{T(a)^2}{1-2aT(a)}=T(a)^2\cdot L(2\cdot a\cdot T(a))&quot; eeimg=&quot;1&quot;&gt; [注 2]&lt;/p&gt;&lt;p&gt;这个式子表明，带有空位的二叉树可以用两个子树和一个列表的二元组表示，这个列表的每项包含三个部分：一个布尔值，一个节点和一个子树。事实上，这个列表就表示了从树根到空位走过的路径：布尔值分辨每次是左转还是右转，节点值标记路过的节点，子树值标记另一侧的东西；而前面那两个树则是空位下面的子树。&lt;/p&gt;&lt;p&gt;——&lt;/p&gt;&lt;p&gt;最后，如果说数学家就是在寻找相似性的话，那么这个应该是一个非常好的案例了。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;————————&lt;/p&gt;&lt;p&gt;[注 1]：考虑到一般来说，类型的相反数和倒数并没有良好定义，此处&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D%5Cfrac%7B1%7D%7B1-a%7D&quot; alt=&quot;L(a)=\frac{1}{1-a}&quot; eeimg=&quot;1&quot;&gt;可以理解为泰勒展式&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D%5Csum_%7Bj%3D0%7D%5E%5Cinfty+a%5Ej&quot; alt=&quot;L(a)=\sum_{j=0}^\infty a^j&quot; eeimg=&quot;1&quot;&gt;。更严谨的表述需要使用&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmu&quot; alt=&quot;\mu&quot; eeimg=&quot;1&quot;&gt;符号。&lt;/p&gt;&lt;p&gt;[注 2]：用级数表示的话，&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3D%5Csum_%7Bk%3D0%7D%5E%7B%5Cinfty%7D+T%28a%29%5B2aT%28a%29%5D%5Ek&quot; alt=&quot;\partial_a T(a)=\sum_{k=0}^{\infty} T(a)[2aT(a)]^k&quot; eeimg=&quot;1&quot;&gt;。此外也可以解出，&lt;img src=&quot;https://zhihu.com/equation?tex=T%28a%29%3D%5Csum_k+%5Cfrac%7Ba%5Ek%7D%7Bk%2B1%7D%7B2k+%5Cchoose+k%7D&quot; alt=&quot;T(a)=\sum_k \frac{a^k}{k+1}{2k \choose k}&quot; eeimg=&quot;1&quot;&gt;&lt;/p&gt;</description>
<author>Belleve</author>
<guid isPermaLink="false">20570808</guid>
<pubDate>Sun, 14 Feb 2016 06:33:25 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻][小道消息] ART又要考虑用基于LLVM的编译器了…</title>
<link>http://zhuanlan.zhihu.com/hllvm/20569303</link>
<description>如题。真就跟国内修公路一样，修了拆拆了修…&amp;gt;_&amp;lt;&lt;br&gt;&lt;p&gt;另外一方面，ART在向着使用OpenJDK类库的方面倒是有扎实的进展。看这个 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/6c37e9adf7afc547a0fdf4db29249f6982845162/runtime/openjdkjvm/OpenjdkJvm.cc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;runtime/openjdkjvm/OpenjdkJvm.cc&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 就是HotSpot的hotspot/src/share/vm/prims/jvm.cpp的对应物。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20569303</guid>
<pubDate>Sat, 13 Feb 2016 03:10:49 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] ART有了新的汇编写的解释器</title>
<link>http://zhuanlan.zhihu.com/hllvm/20491978</link>
<description>&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/c3ba07ef76549129705af28173070b88a1c39531&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Merge &quot;Fast Art interpreter&quot;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;p&gt;觉得Android Runtime（ART）的解释器比不上Dalvik用汇编写的解释器的同学，你们得到了：汇编解释器卷土重来 ^_^&lt;/p&gt;&lt;p&gt;——显然，ART还是有相当部分的代码要在解释器里跑，不然解释器性能再差又如何呢。&lt;/p&gt;&lt;p&gt;而dex2oat对PGO的支持也如火如荼进行中：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/27e17fd81cc30e16e86c9c15498cae7f920c9dfe&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Enable profiled guided compilation in dex2oat&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20491978</guid>
<pubDate>Sat, 16 Jan 2016 15:39:30 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>新手上路学习JavaScript引擎实现——路线图</title>
<link>http://zhuanlan.zhihu.com/hllvm/20505562</link>
<description>&lt;p&gt;最近在知乎接连看到几个相关的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/39468189&quot; class=&quot;internal&quot;&gt;如何阅读 ChakraCore 的代码?&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/39014659&quot; class=&quot;internal&quot;&gt;新手应该如何读Google V8引擎源代码？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/38332604&quot; class=&quot;internal&quot;&gt;Kinoma XS6 是一款怎样的 JavaScript 引擎？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;这些问题都是试图从阅读源码着手去学习JavaScript引擎的实现的。然而，对新手而言，直接从一个复杂的实现的源码着手，不可避免的是事倍功半的做法。&lt;/p&gt;&lt;p&gt;要学习JavaScript引擎的实现，就跟学习其它东西一样，最好是循序渐进的来，先打好基础，再去结合现实学习主流实现。&lt;/p&gt;&lt;p&gt;我推荐的学习路线是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;临摹：先找个比较简单语言的简单解释器实现，以它为模子，自己抄一个解释器出来。这个过程中可以学习到编程语言的解释器的基本构造，特别是其组成部分的划分，以及这些组成部分在工作流程中各自处于什么位置。整个流程串起来之后，思路就会清晰许多，接下去学习就可以有针对性了。&lt;/li&gt;&lt;li&gt;巩固：临摹的时候必然只能一个解释器的各部分的一种特定的简单实现。然而其背后的原理是怎样的，同一个组件是否有别的更先进（或不同取舍）的做法，就需要进一步学习了。此时可以针对各部分去读不同的书，例如编译原理、GC、对象模型等方面。学习原理，巩固基础，拓展视野。&lt;/li&gt;&lt;li&gt;规范：到此有足够基础可以着手学习/实现真正的JavaScript引擎了。但在动手之前，应该熟读&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/6.0/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMAScript规范&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，了解到底JavaScript语言所要求的语义是怎样的，解决“是什么”的问题。觉得新的ECMAScript 2015太复杂的话，从&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/5.1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMAScript 5.1&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习是个不错的开始。有个带注解的ECMAScript 5.1规范特别适合学习：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//es5.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Annotated ECMAScript 5.1&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。另外，更喜欢阅读中文文档的同学可以看&lt;a href=&quot;https://www.zhihu.com/people/b2abeb901f0608346f2517bebcd224aa&quot; data-hash=&quot;b2abeb901f0608346f2517bebcd224aa&quot; class=&quot;member_mention&quot; data-tip=&quot;p$b$b2abeb901f0608346f2517bebcd224aa&quot;&gt;@呂康豪&lt;/a&gt;大大在评论区推荐的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.w3.org/html/ig/zh/wiki/ES5&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ES5 - HTML5 Chinese Interest Group Wiki&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，那是他的怨念喔。&lt;/li&gt;&lt;li&gt;接轨：把前面学习的知识都结合起来，按照规范实现自己的简单的JavaScript引擎；或者此时也可以去阅读现成的比较简单的JavaScript引擎的实现，但还是自己动手写过一次能有更深刻的理解。&lt;/li&gt;&lt;li&gt;进阶：到这个阶段，再去阅读现实中主流的、高性能的JavaScript引擎的源码，就可以做到有的放矢了。快速阅读一下官方文档，浏览一下代码组织结构，就应该能大概掌握一个实现的大致架构。然后再抓住JavaScript引擎实现可能存在的重要设计点去看看，就可以知道这个实现在每个部分都选择了哪些实现方式。其实就像搭积木一样，每个部分能有什么选择都了然于心，这样再去深入到细节读代码，就可以事半功倍的提取出自己想要知道的信息了。很多时候看目录结构和源码文件名就能大概猜到需要的信息在哪个文件里，进去确认一下就好。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;我推荐这个学习路线，是因为上面的阶段我全都走过一遍了，亲测有效。国内有不少从事JavaScript引擎研发的同行们，不知道大家的学习路线又是怎样的呢？&lt;/p&gt;&lt;p&gt;以&lt;a href=&quot;https://www.zhihu.com/question/38332604/answer/75904396&quot; class=&quot;internal&quot;&gt;Kinoma XS6的讨论&lt;/a&gt;为例，我从看到问题到开始阅读源码，到写完整个回答，总共只用了几分钟。这个回答就包含了我在阅读一个JavaScript引擎实现时会首先关注的设计点，抓住这些点去阅读源码就可以很快的了解这个实现的全貌、其大体的设计思路和取舍方向。换言之，我并不需要为了了解它的概况而需要去从细节开始学习很多新的知识，而只要在已有知识里印证这个实现在可能的实现方式里到底选择了哪些。&lt;/p&gt;&lt;p&gt;另外也想提一下Constellation大大的lv5 JavaScript引擎（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Constellation/iv&quot; class=&quot;internal&quot;&gt;Constellation/iv · GitHub&lt;/a&gt;）。它的发展历程见证了Constellation的成长，也跟上面的学习路线中“规范-接轨-进阶”的过程完全吻合——一开始lv5是作者边读ES5规范边用最直观的方式把规范实现出来的。整个流程走通之后，他就开始从开源的主流JavaScript引擎学习先进的做法，并逐步实现到lv5当中，渐渐将其发展成一个颇为实在的、现代的实现。&lt;/p&gt;&lt;p&gt;我在这里也提到过lv5：&lt;a href=&quot;https://www.zhihu.com/question/34589661/answer/79792354&quot; class=&quot;internal&quot;&gt;准大三，计算机专业如何确定工作方向？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;我从2012年开始其实也有断断续续积累一些文字，希望能规整到一个系统的知识体系下写成一本书，以便更好的把这些相关知识传播给大家。不过目前这个计划还在早期阶段，暂时不接受催稿谢谢…&lt;/p&gt;&lt;p&gt;虽然书离成形还尚远，但我曾经试过把积累的内容的一部分汇总起来发出来：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/37596&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;[链接帖] 各JavaScript引擎的简介，及相关资料/博客收集帖&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，欢迎大家参考和提建议。这系列帖子已好久没更新就是了…&lt;/p&gt;&lt;br&gt;&lt;p&gt;话说回来，万事开头难，按照上面的路线，得找个最初的临摹对象来学习。&lt;/p&gt;&lt;p&gt;可以选择的对象有很多，不过这里我还是想再次推荐&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/4118518/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『プログラミング言語を作る』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中文版&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/25735333/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《自制编程语言》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）一书。我在这里发过一个简介帖：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/39194&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《自制编程语言》集中讨论帖&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//kmaebashi.com/programmer/devlang/crowbar.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Crowbar&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;语言及其解释器实现，就是我想推荐作为入门临摹的对象。&lt;br&gt;&lt;/p&gt;&lt;p&gt;欲知它究竟是怎样设计与实现，且看下回分晓 ^_^&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20505562</guid>
<pubDate>Sat, 16 Jan 2016 15:33:20 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] 微软如期开源ChakraCore JavaScript引擎</title>
<link>http://zhuanlan.zhihu.com/hllvm/20498427</link>
<description>&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blogs.windows.com/msedgedev/2016/01/13/chakracore-now-open/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ChakraCore GitHub repository is now open&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft/ChakraCore · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Chakra-Samples&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft/Chakra-Samples · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;官方推账号：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/ChakraCore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@ChakraCore&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;开发路线图：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore/wiki/Roadmap&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Roadmap · Microsoft/ChakraCore Wiki · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ChakraCore架构文档：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore/wiki/Architecture-Overview&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Architecture Overview · Microsoft/ChakraCore Wiki · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 。&lt;a href=&quot;https://www.zhihu.com/people/f34d97ee3caf7250348b566a89025c31&quot; data-hash=&quot;f34d97ee3caf7250348b566a89025c31&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@彭飞&quot; data-tip=&quot;p$b$f34d97ee3caf7250348b566a89025c31&quot;&gt;@彭飞&lt;/a&gt; 翻译了一份&lt;a href=&quot;http://zhuanlan.zhihu.com/fiigii/20501758&quot; class=&quot;internal&quot;&gt;中文版&lt;/a&gt;。基本上跟之前在IE Blog / Windows Blog上有的信息一样，还没有啥新的信息。开源后能获取的新信息看来都得从源码里挖掘了。&lt;/p&gt;&lt;p&gt;ChakraCore源码目录结构：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore/wiki/ChakraCore-Code-Structure&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ChakraCore Code Structure · Microsoft/ChakraCore Wiki · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//azure.microsoft.com/en-us/blog/the-road-ahead-for-azure-documentdb-with-chakracore/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Running JavaScript in Azure DocumentDB with Chakra&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;h3&gt;Bytecode serialization&lt;/h3&gt;&lt;p&gt;Upon registering a server-side script, DocumentDB uses Chakra to pre-compile and serialize the script to bytecode. In a normal JavaScript execution pipeline, the engine needs to parse the code, produce syntax trees and generate bytecode prior to execution. Chakra’s bytecode serialization allows DocumentDB to pre-process scripts up until (and including) bytecode generation and save a cached copy of the bytecode for re-use. This allows users to avoid the cost of re-parsing the script each time it is executed, which leads to substantial performance savings over time.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;基于寄存器的字节码设计。有一套扩展的字节码专门用于表达asm.js的语义。&lt;/p&gt;&lt;p&gt;等俺有空读读代码再补充点内容上来。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/38238351/answer/75496276&quot; class=&quot;internal&quot;&gt;如何看待微软 12 月 5 日宣布准备开源其 JavaScript 引擎 Chakra 的核心部分？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20498427</guid>
<pubDate>Thu, 14 Jan 2016 02:27:44 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] 看图猜语言实现——答案</title>
<link>http://zhuanlan.zhihu.com/hllvm/20445566</link>
<description>&lt;p&gt;之前发的&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20416295&quot; class=&quot;internal&quot;&gt;[号外] 看图猜语言实现&lt;/a&gt;帖大概也不会有新的跟帖回答，是时候放答案了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实答案就在这个回答里：&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; class=&quot;internal&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一组图的关键字：J9&lt;br&gt;&lt;/li&gt;&lt;li&gt;第二组图的关键字：Testarossa&lt;br&gt;&lt;/li&gt;&lt;li&gt;第三组图的关键字：Modron&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;结合起来就是：&lt;/p&gt;&lt;p&gt;IBM J9 Java虚拟机，以及其使用的JIT编译器Testarossa，以及其GC框架Modron。&lt;/p&gt;&lt;p&gt;之前看到J9的开源项目——OMR的技术预览版——发布的消息实在是兴奋，手痒就发了这么个猜谜。&lt;/p&gt;&lt;p&gt;您猜对了么？&lt;/p&gt;&lt;br&gt;&lt;p&gt;祝大家圣诞快乐——如果您过这个节的话 &amp;gt;_&amp;lt; 只是应景说说&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20445566</guid>
<pubDate>Fri, 25 Dec 2015 07:59:01 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] 看图猜语言实现</title>
<link>http://zhuanlan.zhihu.com/hllvm/20416295</link>
<description>&lt;p&gt;结合这个专栏的主题以及我在知乎最近的动态，看下面的几张图猜一个&lt;b&gt;编程语言平台的实现的名字&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;所有图结合起来都是指同一个实现（可能指其中的某个部分），不是每组图对应一个语言/实现啥的。&lt;/b&gt;把图片分组是因为同一组的图隐含的是同一个单词。&lt;/p&gt;&lt;p&gt;&lt;b&gt;猜的是语言的实现的名字，不是编程语言的名字。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实应该很简单…相信评论里很快就会有人放答案了。有兴趣猜的话就先别看评论区嗯。&lt;/p&gt;（其实我以前一直想画张包含这些元素的图，但一直坑着…有大大有兴趣帮忙画一张不？）&lt;br&gt;&lt;br&gt;&lt;p&gt;1. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/92e222372976f4ba30f1fe71bc6064c8_b.jpg&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;999&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;999&quot; data-original=&quot;https://pic1.zhimg.com/92e222372976f4ba30f1fe71bc6064c8_r.jpg&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/7e428368fd6ac7eb57527ecd19e9230d_b.jpg&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;445&quot; class=&quot;content_image&quot; width=&quot;346&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;2. &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/1659d6008c54dc48e8e05fcde34abbc6_b.jpg&quot; data-rawwidth=&quot;2883&quot; data-rawheight=&quot;1365&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2883&quot; data-original=&quot;https://pic3.zhimg.com/1659d6008c54dc48e8e05fcde34abbc6_r.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/949f7fb0a7800cf3285e80e1ed5c0151_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;1464&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic2.zhimg.com/949f7fb0a7800cf3285e80e1ed5c0151_r.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/4be876f664b62583b66407e7139ea859_b.jpg&quot; data-rawwidth=&quot;696&quot; data-rawheight=&quot;696&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;696&quot; data-original=&quot;https://pic2.zhimg.com/4be876f664b62583b66407e7139ea859_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;3. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/ffc0bfe7ec5f13fe1493c2d2ac41785c_b.jpg&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;764&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/ffc0bfe7ec5f13fe1493c2d2ac41785c_r.jpg&quot;&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20416295</guid>
<pubDate>Mon, 14 Dec 2015 16:22:11 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>学习编程语言与编译优化的一个书单</title>
<link>http://zhuanlan.zhihu.com/hllvm/20130808</link>
<description>其实是想放张图：&lt;img src=&quot;https://pic3.zhimg.com/21e2e4bb3586ece2078fd6c3c65d4cbe_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;1228&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/21e2e4bb3586ece2078fd6c3c65d4cbe_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;（这个书单帖居然有那么多点赞，完全没料到。我这帖说的应该是很小众的内容才对？压力好大…）&lt;/p&gt;&lt;p&gt;要学习编程语言原理与编译/优化原理，有许多书可读。我的生活乐趣之一就是不断的读这个领域的各种书 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;但毕竟很多书覆盖的知识点或者说切入点都是类似的，只是为了学习知识而不是纯为了生活乐趣的话，倒没必要全都读了。每个方面挑些&lt;b&gt;适合自己偏好&lt;/b&gt;的好书读读就好。&lt;/p&gt;&lt;p&gt;这里挑了我放在办公室里的书的其中几本，供大家参考一下从入门到深入学习&lt;b&gt;偏编译优化方向的编程语言知识的路线图&lt;/b&gt;。编程语言原理涉及的知识面相当广，也有许多不同的细分方向，这里就只针对编译优化这个比较窄的方向做些推荐。&lt;/p&gt;&lt;p&gt;上图的书的阅读顺序是从上到下。欢迎大家评论和推荐更好的书 ^_^&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;书单&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这些书从上到下分别是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3743526/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Third Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/10802357/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第三版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5407246/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（英文版·第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（原版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3023631/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Computer Systems: A Programmer&#39;s Perspective, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5333562/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（原书第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/4117971/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版即将上市，译者是想能的信息科技的严圣逸和支付宝的前端架构专家绝云）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5288601/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Engineering a Compiler, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/20436488/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《编译器设计》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1821532/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Advanced Compiler Design and Implementation》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1400374/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《高级编译器设计与实现》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2359859/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《High-Performance Compilers for Parallel Computing》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（尚无中译版）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2126867/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Optimizing Compilers for Modern Architectures》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1171448/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《现代体系结构的优化编译器》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;学习路线图&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这份书单中，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;头两本书用于了解大背景的。To get the big picture；&lt;br&gt;&lt;/li&gt;&lt;li&gt;中间两本是用来做编译原理入门的；&lt;br&gt;&lt;/li&gt;&lt;li&gt;最后三本用于深入学习编译与优化的知识。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这三个阶段里，每个阶段都可以有其它书可以替代。这些只是&lt;b&gt;适合我的偏好&lt;/b&gt;的选择而已。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;1. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3743526/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Third Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/10802357/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第三版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;2009年出版。简称PLP。这本书主要用于掌握编程语言方面的大背景——编程语言是什么、有哪些种类，实现编程语言的大体流程是怎样，在编程语言的设计与实现里都会用到些什么术语等。它的Part I和Part II不但讲解了编程语言常见的结构，也顺带提到了它们背后涉及的一些实现，其实比专门的编译原理书更适用于最初的入门。&lt;br&gt;&lt;/p&gt;&lt;p&gt;第三版目录在此：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cs.rochester.edu/u/scott/pragmatics/3e/toc.shtml&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PLP 3e Table of Contents&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;书中对许多概念的讲解在编程语言中有普适意义。例如说书中提到了“display”的概念，在讲stack frame的static link/static chain时提到可以使用display来减少需要的递归搜索的次数——对递归深度有固定上限的问题，可以把递归搜索的结果事先放在一个小数组里，这个数组就是“display”（裘老师译为“区头向量”）。这个“display”的概念其实可以引伸到各种递归问题，例如基于类的面向对象语言里的快速子类型检查就可以用上display；相关的，像是面向对象语言所用的虚函数表（vtable）其实也是一个变种display。&lt;/p&gt;&lt;p&gt;这本书顺带充当了我学习许多语言的入门书，拓宽了我的知识面。Scheme、Ada、Prolog之类的好些语言我都是从这本书开始真的接触并写代码来学习的。&lt;/p&gt;&lt;p&gt;我最初读的是裘宗燕老师翻译的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2152385/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第二版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。这是我喜欢的中译版技术书之一。虽然里面的术语译法跟我所喜欢的不完全一致，但完全没影响阅读。&lt;/p&gt;&lt;p&gt;评论里&lt;a href=&quot;https://www.zhihu.com/people/6f8a5a4cb5218434cf962c835b21afde&quot; data-hash=&quot;6f8a5a4cb5218434cf962c835b21afde&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@Snow Liang&quot; data-tip=&quot;p$b$6f8a5a4cb5218434cf962c835b21afde&quot;&gt;@Snow Liang&lt;/a&gt;提醒说这本书今年11月就要出第四版了：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/26424018/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Fourth Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。真好！&lt;/p&gt;&lt;p&gt;作者&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rochester.edu/u/scott/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Michael L. Scott&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;是&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.rochester.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rochester大学&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的教授，虽然本职教学并不主要是编程语言相关，而是诸如事物内存（transactional memory）之类，但是他对这本书颇为投入而且也对成果感到很满意。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;2. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5407246/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（英文版·第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（原版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3023631/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Computer Systems: A Programmer&#39;s Perspective, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5333562/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（原书第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;原书2008年出版。大名鼎鼎的CS:APP，是从软件角度学习系统知识必备的一本入门书，不用多说。这本书刚新出了第三版不过我还没舍得买，所以书单上只能先放着第二版。&lt;/p&gt;&lt;p&gt;前一本书PLP主要从上层介绍编程语言上的概念，而这本书主要介绍编程语言的概念会映射到怎样的系统层概念上。从编译器的角度看，PLP主要覆盖的是编程语言的词法、语法、语义的部分，是编译器前端的知识；而CS:APP则更关注把编程语言的概念映射到实际的CPU、内存、操作系统层面上，是编译器后端的知识。两者结合起来就完美的覆盖了学习编译器所需的知识面，对编译原理的全貌有一个把握。&lt;/p&gt;&lt;p&gt;国内的同学们是幸福的，这本书的影印版质量非常非常好，纸张、印刷都极其高质量，不能再多赞了！买本影印版感觉赚大了。中译版我没读过不过据说质量也不错。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;3. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/4117971/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;（书名可以直译为：《写个普通的编译器——通过编写语言处理器来学习编译与运行时环境的原理》。呃真引进的话肯定不会这么译…）&lt;/p&gt;&lt;p&gt;2009年出版。这是本日文书。有那么多入门级编译器书，为啥我要选它来推荐？&lt;/p&gt;&lt;p&gt;因为我觉得这本书写得很实在，适合入门学习时形象地掌握整个编译流程，其中都有哪些环节，每个环节间又是如何互动的。在&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/people/RednaxelaFX/all%3Fsort%3Dtime%26tags_sort%3Dcount%26filter%3Dall%26tag%3D%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%26mode%3Dgrid&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我读过或接触过的编译器书&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;里，它算是我最推荐的用于指导实际写第一个编译器的入门书。&lt;/p&gt;&lt;p&gt;这本书的知识点和难度大致都跟斯坦福的编译原理入门课CS143相近，结合两者来学习也是不错的选择。请参考另一帖：&lt;a href=&quot;http://www.zhihu.com/question/28679215/answer/43883727&quot; class=&quot;internal&quot;&gt;斯坦福大学编译原理课程质量怎么样？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这本书吸引我的特点有两个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从头到尾围绕一个完整可运行的简易编译器来讲解；完整配套源码在Github就有：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/aamine/cbc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;aamine/cbc · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;覆盖了从词法/语法分析 -&amp;gt; 语义分析 -&amp;gt; 中间代码生成 -&amp;gt; 目标代码生成 -&amp;gt; 链接 -&amp;gt; 运行时环境的完整流程。并没有过于纠缠于其中的任一环节（特别是没有过于纠缠于前端部分），而是更关注整体流程，注重大局观。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这本书描述的是一个名为&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/aamine/cbc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;C♭&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（读作C-flat）语言的编译器cbc，使用Java实现，目标运行环境是Linux/x86。&lt;/p&gt;&lt;p&gt;C♭是一个C的简化版，简化的主要是宏相关的部分以及早期C一直延续下来的许多小细节；保留下来的部分覆盖了C的绝大部分功能，例如基本类型、函数、指针，struct/union等等，作为入门级编译器的源语言功能上正好适中。&lt;/p&gt;&lt;p&gt;cbc编译器的整体工作流程是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Cb源码
=&amp;gt; [ 词法分析 + 语法分析 ] =&amp;gt; // 由JavaCC生成
抽象语法树（AST）
=&amp;gt; [ Visitor模式的语义分析 ] =&amp;gt;
标注的抽象语法树（Annotated AST）
=&amp;gt; [ 中间代码生成 ] =&amp;gt; // 跟虎书的C版本非常相似，但代码风格比虎书好
树形中间代码（Tree IR）
=&amp;gt; [ 简单优化 ] =&amp;gt;
优化过的中间代码
=&amp;gt; [ 代码生成 ] =&amp;gt;    // 使用Java写的内部DSL来生成GNU as格式的汇编
                     // 支持可重定位与不可重定位两种版本的代码生成
GNU as格式的汇编
=&amp;gt; [[ GNU as ]] =&amp;gt;   // 汇编器
目标代码
=&amp;gt; [[ GNU ld ]] =&amp;gt;   // 链接器
ELF可执行文件 / 动态链接库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中用单中括号标注的环节是cbc自己实现的，而双中括号标注的部分则是依赖现成的工具实现。cbc生成的代码符合Linux/x86的C ABI，可以跟libc或者其它导出C ABI的库链接起来。&lt;/p&gt;&lt;p&gt;以此，C♭程序从源码到可执行文件到运行时环境的整个流程都在本书中有所体现。&lt;br&gt;&lt;/p&gt;&lt;p&gt;细心的读者可能会问：cbc不用分配寄存器么？答案是它用了非常非常简易的分配方式——“栈顶缓存”——直接融合在代码生成环节中。详细请见另一帖：&lt;a href=&quot;http://www.zhihu.com/question/29355187/answer/51935409&quot; class=&quot;internal&quot;&gt;寄存器分配问题？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;p&gt;要在中文社区推广这本书，光靠日文原版还是太困难。就等有爱人士到图灵社区去接下翻译任务啦：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ituring.com.cn/book/1308&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;图灵社区 : 图书 : 自制编译器&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，我可以提供充分的技术支持 :-)&lt;/p&gt;&lt;p&gt;更新：这本书已经有译者接下了，是想能的信息科技的严圣逸和支付宝的前端架构专家绝云。太好了！据说2016年4月底可以上市。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;4. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5288601/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Engineering a Compiler, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/20436488/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《编译器设计》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;2011年出版。简称EAC2。据说有人把这本书称为“橡书”但我不知道这种叫法的来源是啥。书的封面图是“The Landing of the Ark”。&lt;/p&gt;&lt;p&gt;这本书是编译原理教材里我最喜欢的一本，没有之一。它用作入门时的第一本书也行，放在『ふつうのコンパイラをつくろう』之类的简易入门书之后作为正式学习编译原理的教材也很合适。它覆盖的知识面足以应付初级到中级编译原理的学习，内容夯实，脉络清晰，语言既干练又不失形象。&lt;/p&gt;&lt;p&gt;而且它选择讲解的知识点都是相当实用且与时俱进的——可能就除了寄存器分配的地方没有专门的小节讲线性扫描寄存器分配算法（Linear-scan register allocation）不够与时俱进——其它讲的都是当代编译器里常见而实用的内容。&lt;/p&gt;&lt;p&gt;例如说第9章讲数据流分析的部分，主要结合SSA形式来展开，比起特别传统的非要从非SSA形式讲起、最后在进阶部分提一下SSA形式的做法要现代多了。&lt;/p&gt;&lt;p&gt;EAC2目录在此：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.elsevier.com/wps/find/bookdescription.cws_home/724559/description%23description&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Elsevier&#39;s site for Engineering a Compiler&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本书作者&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/%7Ekeith/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Keith D. Cooper&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/%7Elinda/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Linda Torczon&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;都是&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.rice.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice大学&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的名教授，而且两人同为&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/%7Eken/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ken Kennedy&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的学生。后面会再提到他们的关系。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;5. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1821532/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Advanced Compiler Design and Implementation》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1400374/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《高级编译器设计与实现》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;1997年出版。大名鼎鼎的“鲸书”，在编译原理的经典动物书“龙虎鲸”中排得上号的进阶读物。从这本书开始就要深入学习编译优化了。&lt;/p&gt;&lt;p&gt;这本书只关心优化编译器的中、后端涉及优化的部分，而完全不涉及前端的词法/语法分析或语言相关的语义分析。因而它虽然不适合作为初学教材，但在进阶学习时非常好用——完全没废话，直达痛点。&lt;/p&gt;&lt;p&gt;本书作者Steven Stanley Muchnick不但在学术界很有影响，在业界也参与了一些重量级项目，例如HP的PA-RISC的设计及其优化编译器的实现，然后是Sun的SPARC的设计及其优化编译器的实现。鲸书里介绍的编译器优化技术都是实打实的，理论结合实际，边读边实践很痛快。&lt;/p&gt;&lt;p&gt;要是还能再来个新版本就好了…&lt;/p&gt;&lt;br&gt;&lt;p&gt;接下来要介绍的两本其实只是在鲸书的基础上拓展一下视野用的，免得受单一作者的偏好而限制了自己的选择范围。这两本都是相对偏老的书，以Fortran编译器中的优化为主要介绍对象，重点介绍数据依赖分析、循环优化、自动向量化之类的话题，在现在各种主流CPU都强力推出SIMD指令的潮流下并不过时，反而相当值得参考。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;6. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2359859/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《High-Performance Compilers for Parallel Computing》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;1995年出版的老书。尚未有中译版，以后也不太可能会有吧。&lt;/p&gt;&lt;p&gt;作者Michael Wolfe。我现在就职的Azul Systems有位元老员工叫做Michael Wolf，是我们的pauseless GC算法的设计者之一，非常牛。一开始我是因为把名字看错了才买的这本书，却有意想不到的收获。&lt;/p&gt;&lt;p&gt;因为这本书很奇葩！&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;7. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2126867/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Optimizing Compilers for Modern Architectures》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1171448/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《现代体系结构的优化编译器》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;br&gt;&lt;p&gt;（待补充）&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;8. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//ssabook.gforge.inria.fr/latest/book.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Static Single Assignment Book》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Bonus：这是一本还在写作中的书，因此没有纸质版，暂时只有电子版。不过对许多本来就不想买书的同学们来说或许是个福音吧（逃&lt;/p&gt;&lt;p&gt;静态单赋值形式（SSA Form）是现代主流编译器都会采用的IR形式，而且越来越多编译器开始以SSA形式的IR为主。&lt;/p&gt;&lt;p&gt;最极致的是像LLVM那样采用单层IR，而且这个IR必须是SSA形式的。许多人觉得LLVM IR操作起来方便的原因之一就是许多算法在SSA形式下表达起来很简洁直观。说来，因为LLVM IR本身不是Memory-SSA或Heap-SSA形式，并不显式跟踪内存中的赋值，所以前端在生成LLVM IR时倒不必总是自己构建SSA形式，而可以用alloca分配局部变量然后让LLVM自带的mem2reg去构建SSA形式，所以这种SSA形式的IR也没有给前端增加负担，是个双赢。&lt;/p&gt;&lt;p&gt;既然SSA形式这么重要这么流行，应该有本书专门以它为线索来介绍编译原理的知识对不对？这本书就是如此。它是许多作者合写的，每一章都像是一篇相对独立的论文一样，围绕SSA形式介绍了编译器中后端的方方面面。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;还缺什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实我还很希望能在书单里有几本介绍对JIT编译器或者说运行时编译做重点讲解的书，以及对动态类型语言的编译优化做重点讲解的书。可惜这些方面的论文虽然不少，但却没有现成的书对其做系统性的讲解。&lt;/p&gt;&lt;p&gt;好在万变不离其宗，JIT编译器与动态语言优化其实都还是在传统的编译原理基础上的进化，掌握好基础的话这些话题都会变得更易于理解。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;一些背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;“&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.rice.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;系”的编译器大牛们：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/CS/compilers/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice Compiler Group&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;“&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.stanford.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Stanford&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;系”的编译器大牛们：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//suif.stanford.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The SUIF Group&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;==========================================================&lt;/p&gt;&lt;p&gt;顺带给想八卦的同学们，这是我办公室书架的全景：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/a25fcec4cae70aaa039802eaa94a9a4e_b.jpg&quot; data-rawwidth=&quot;2048&quot; data-rawheight=&quot;1085&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2048&quot; data-original=&quot;https://pic3.zhimg.com/a25fcec4cae70aaa039802eaa94a9a4e_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;有不少眼熟的书对不对？^_^&lt;/p&gt;&lt;p&gt;还有更多书放在家里的书架上。家里的书架已经快溢出了所以不得不把越来越多书搬到办公室来…&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20130808</guid>
<pubDate>Mon, 27 Jul 2015 12:53:52 +0800</pubDate>
<media:thumbnail url="https://pic3.zhimg.com/b806999aa557e5e839cf51bccbd4d8e2_b.jpg" />
</item>
<item>
<title>Lambda 表达式无法定义的一个算符</title>
<link>http://zhuanlan.zhihu.com/hllvm/20049022</link>
<description>很多人都问我如何理解 yield 云云，事实上 yield 以及其他的类似物包括 call/cc 都是用 Lambda 演算&lt;b&gt;无法定义&lt;/b&gt;的东西。&lt;p&gt;就比如 call/cc 吧，如果我们规定 Continuation 永不返回，或者说它是&lt;b&gt;发散&lt;/b&gt;的，那么它的类型可以唯一指定成&lt;img src=&quot;https://zhihu.com/equation?tex=%5Calpha%5Crightarrow%5Cbot&quot; alt=&quot;\alpha\rightarrow\bot&quot; eeimg=&quot;1&quot;&gt;，或者说&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cneg%5Calpha&quot; alt=&quot;\neg\alpha&quot; eeimg=&quot;1&quot;&gt;。那么考虑 call/cc 算子，它的类型首先肯定得满足&lt;img src=&quot;https://zhihu.com/equation?tex=%28%28%5Calpha%5Crightarrow%5Cbot%29%5Crightarrow%5Cbeta%29%5Crightarrow%5Cgamma&quot; alt=&quot;((\alpha\rightarrow\bot)\rightarrow\beta)\rightarrow\gamma&quot; eeimg=&quot;1&quot;&gt;，而考察 call/cc(&lt;i&gt;f&lt;/i&gt;) 两种可能的返回情况——通过（丢给 &lt;i&gt;f&lt;/i&gt; 的） continuation 返回或者 &lt;i&gt;f&lt;/i&gt; 正常返回——那么可以得到等式&lt;img src=&quot;https://zhihu.com/equation?tex=%5Calpha%3D%5Cbeta%3D%5Cgamma&quot; alt=&quot;\alpha=\beta=\gamma&quot; eeimg=&quot;1&quot;&gt;，即：&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7Bcall%2Fcc%7D%3A%28%5Cneg%5Calpha%5Crightarrow%5Calpha%29%5Crightarrow%5Calpha&quot; alt=&quot;\mathrm{call/cc}:(\neg\alpha\rightarrow\alpha)\rightarrow\alpha&quot; eeimg=&quot;1&quot;&gt;。若允许 Continuation 返回，则 call/cc 的类型可定为&lt;img src=&quot;https://zhihu.com/equation?tex=%28%28%5Calpha%5Crightarrow%5Cbeta%29%5Crightarrow%5Calpha%29%5Crightarrow%5Calpha&quot; alt=&quot;((\alpha\rightarrow\beta)\rightarrow\alpha)\rightarrow\alpha&quot; eeimg=&quot;1&quot;&gt;。接下来将证明这条定律可以推出排中律（使用 LJ 推理系统）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;α ⊢ &lt;/b&gt;&lt;b&gt;α&lt;/b&gt; [I]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α ⊢ α ∨ &lt;/b&gt;&lt;b&gt;¬α&lt;/b&gt; [∨R](1);&lt;/li&gt;&lt;li&gt;&lt;b&gt;⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [I]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [WL](2);&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, (α ∨ ¬α) → ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [→L, (1), (2)](3);&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [→L, (1), (3)]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, ((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ ⊥&lt;/b&gt; [WL]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ α → ⊥&lt;/b&gt; [→R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ α ∨ &lt;/b&gt;&lt;b&gt;¬α&lt;/b&gt; [∨R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ ⊢&lt;/b&gt;&lt;b&gt; ((α ∨ ¬α) → ¬(α ∨ ¬α)) → &lt;/b&gt;&lt;b&gt;(α ∨ ¬α)&lt;/b&gt; [→R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ ⊢ α ∨ ¬&lt;/b&gt;&lt;b&gt;α&lt;/b&gt; [MP，代换律]&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;换言之，如果 call/cc 是 Lambda 可表的，则意味着直觉自然演绎可以证明排中律——这显然不可能，于是 call/cc 必然是 Lambda 不可表，它必须作为单独的算符扩充到 Lambda 演算的体系里来。</description>
<author>Belleve</author>
<guid isPermaLink="false">20049022</guid>
<pubDate>Fri, 29 May 2015 05:15:41 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
