<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 03 Mar 2016 10:44:20 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>[八卦] 据说Dropbox要试着在内部推广PyPy</title>
<link>http://zhuanlan.zhihu.com/hllvm/20616374</link>
<description>去年年底的消息。就跟Pyston talk差不多时间吧。&lt;p&gt;- &quot;What about Pyston?&quot;&lt;/p&gt;&lt;p&gt;- &quot;At least one of them works.&quot;&lt;/p&gt;&lt;p&gt;还挺好玩。不过看着&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dropbox/pyston/commits/master&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pyston还不断在开发中&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，大概Pyston也不会就此挂掉吧…&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20616374</guid>
<pubDate>Thu, 03 Mar 2016 09:43:19 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Azul Systems正式宣布32位ARM上的Zulu Embedded</title>
<link>http://zhuanlan.zhihu.com/hllvm/20595654</link>
<description>新闻稿：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.azul.com/press_release/azul-systems-enhances-zulu-embedded-to-support-32-bit-arm-processors/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Azul Systems enhances Zulu Embedded to support 32-bit ARM processors&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;p&gt;这是Azul Systems在OpenJDK的基础上做的ARMv7 / AArch32 port。目前已经有解释器以及完整的Client Compiler（C1）实现。&lt;/p&gt;&lt;p&gt;贯彻Zulu产品线的一贯作风，这个ARM port的所有代码都会在&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//openjdk.java.net/projects/aarch32-port/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;OpenJDK AArch32项目&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;下完全开源。同事最近发的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mail.openjdk.java.net/pipermail/aarch32-port-dev/2016-February/000094.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;一个大patch&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;就是为接下来提交C1代码而做的铺垫。&lt;/p&gt;&lt;p&gt;欢迎关注ARM上的Zulu Embedded！&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595654</guid>
<pubDate>Wed, 24 Feb 2016 08:15:57 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] Cliff Click大神也看上给Python加JIT了</title>
<link>http://zhuanlan.zhihu.com/hllvm/20595643</link>
<description>&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cliffc.org/blog/2016/02/19/winds-of-change&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Winds of Change - Cliff Click&#39;s Blog&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Python Go Fast:&lt;/strong&gt; Do Unto Python as Thou hast Done Unto Java. I hack the guts of Python; add a high power JIT, a full-fledged low-pause GC, true multi-threading support, i.e. make Python as fast and as parallel as Java (about the same speed as C).  This blog is really a request for an open discussion on this topic.  Is the Python community interested?  How does this get funded?  (uber Kickstarter?)  I’ll only go here with the full support of the core Python committers, and general “feel goods” from the general python community – and I’m hoping to start a discussion.  At this point I’m a premier language implementer, and making Python Go Fast is well within my abilities and past experiences. Take about 2 years &amp;amp; $2M for this effort to be self-sustaining (build all the core new tech and hand it off to other contributors).&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;困难啊…Cliff大神可能还没体会过CPython社区对“改变”的抗拒orz&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595643</guid>
<pubDate>Wed, 24 Feb 2016 08:09:04 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Pyjion的代码质量一例 [20160221]</title>
<link>http://zhuanlan.zhihu.com/hllvm/20591139</link>
<description>&lt;p&gt;&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20581695&quot; class=&quot;internal&quot;&gt;上一篇文章&lt;/a&gt;简单介绍了一下&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pyjion项目&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的目标与概况。相信很多同学都很好奇，目前的Pyjion到底效果如何对不对？&lt;/p&gt;&lt;p&gt;那我们就从一个再简单不过的例子来一探究竟。非常感谢&lt;a href=&quot;https://www.zhihu.com/people/f12d62dfdf1236e961460798455b1718&quot; data-hash=&quot;f12d62dfdf1236e961460798455b1718&quot; class=&quot;member_mention&quot; data-tip=&quot;p$b$f12d62dfdf1236e961460798455b1718&quot;&gt;@Thomson&lt;/a&gt;大大帮忙做实验，下面的实验结果都是拜托他帮忙获得的。&lt;/p&gt;&lt;p&gt;考虑下面的Python代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它由CPython编译得到的字节码如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;0 LOAD_FAST                0 (a)
3 LOAD_FAST                1 (b)
6 BINARY_ADD          
7 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（Pyjion目前是基于CPython 3.6.0 alpha 1，不过这里用CPython 2.x系列和3.x系列得到的字节码一样，不影响例子）&lt;/p&gt;&lt;p&gt;经过上一篇文章提到的编译流程，Pyjion会生成下面这样的MSIL来表达foo()函数的内容：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// function prologue
    ldarg.1
    ldc.i4       0x88                // offsetof(PyFrameObject, f_lasti)
    conv.i
    add
    stloc.0
    ldarg.1
    call         METHOD_PY_PUSHFRAME // PyJit_PushFrame
// 0: LOAD_FAST 0 (a)
    ldloc.0
    ldc.i4       0x0
    conv.i
    stind.i4
    ldarg.1
    ldc.i4       0x188               // offsetof(PyFrameObject, f_localsplus) + 0 * sizeof(size_t)
    conv.i
    add
    ldind.i
    dup
    ldc.i4       0x10                // offsetof(PyObject, ob_refcnt)
    conv.i
    add
    dup
    ldind.i4
    ldc.i4.1
    add
    stind.i4
// 3: LOAD_FAST 1 (b)
    ldloc.0
    ldc.i4       0x3
    conv.i
    stind.i4
    ldarg.1
    ldc.i4       0x190               // offsetof(PyFrameObject, f_localsplus) + 1 * sizeof(size_t)
    conv.i
    add
    ldind.i
    dup
    ldc.i4       0x10                // offsetof(PyObject, ob_refcnt)
    conv.i
    add
    dup
    ldind.i4
    ldc.i4.1
    add
    stind.i4
// 6: BINARY_ADD
    ldloc.0
    ldc.i4       0x6
    conv.i
    stind.i4
    call         METHOD_ADD_TOKEN    // PyJit_Add
    dup
    stloc.2
    ldc.i4.0
    conv.i
    bne.un       L_success
    br           L_Raise
L_success:
    ldloc.2
// 7: RETURN_VALUE
    ldloc.0
    ldc.i4       0x7
    conv.i
    stind.i4
    stloc.1
    leave        L_ret

// default exception handler
L_Raise:
    ldarg.1
    call         METHOD_EH_TRACE     // PyJit_EhTrace
L_Reraise:
    ldc.i4.0
    conv.i
    br           L_finalRet

// function epilogue
L_ret:
    ldloc.1
L_finalRet:
    ldarg.1
    call         METHOD_PY_POPFRAME  // PyJit_PopFrame
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起来好像很夸张有没有？&lt;/p&gt;&lt;p&gt;其实完全没有。上面的MSIL，如果用类似C的伪代码表达，会是这个样子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// emulate generated code in pseudo C&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo_compiled_code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unused&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyFrameObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// function prologue&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lasti&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_lasti&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// updates are needed to keep the frame state available for inspection&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;PyJit_PushFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PyThreadState_Get()-&amp;gt;frame = frame;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorCheckLocal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;__try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;// conceptual. Not a protected region in MSIL.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 0: LOAD_FAST 0 (a)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lasti&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_localsplus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ob_refcnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 3: LOAD_FAST 1 (b)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lasti&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_localsplus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ob_refcnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 6: BINARY_ADD&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lasti&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyJit_Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;errorCheckLocal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L_Raise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorCheckLocal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 7: RETURN_VALUE&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lasti&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L_ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// MSIL leave.s instruction, for clearing evaluation stack&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__finally&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// conceptual. Not a fault handler in MSIL.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// default exception handler&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// for error handling when we have no EH handlers, return NULL.&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;L_Raise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyJit_EhTrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;L_Reraise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;retValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// function epilogue&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;L_ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;PyJit_PopFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PyThreadState_Get()-&amp;gt;frame = frame-&amp;gt;f_back;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;稍微解释一下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;上面的伪代码里，局部变量名有下划线（&#39;_&#39;）开头的实际上并不在MSIL层面的局部变量，而是在求值栈（evaluation stack）上，而没有下划线开头的则是真正的MSIL层面的局部变量。&lt;br&gt;&lt;/li&gt;&lt;li&gt;伪代码里的 __try { ... } __finally { ... } 并不是MSIL层面上的异常处理，而是逻辑上它是用来实现Python代码的异常处理语义用的。实际涉及的跳转我都在伪代码里用goto来表达了。CPython解释器自身经常通过返回值为NULL来表达要抛异常，Pyjion也完全继承了这个设计。要说有啥不同，那就是Pyjion会在编译时把CPython特别偷懒的“block stack”给展开来，于是就不用到运行时还每次跳出循环或者抛异常都去慢慢展开block stack了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以看到，Pyjion生成的MSIL所代表的逻辑，其实就是把CPython解释器中每个字节码的逻辑展开来粘合到一起。这样就消除了解释器循环自身带来的开销，所以肯定是要比CPython原本的解释执行要快。不过在此基础上它并没有做多少优化，而是为了兼容性而尽可能的去模仿CPython解释器原本的行为。例如说所有Python代码里的局部变量都还是跟CPython解释器一样从PyFrameObject的f_localsplus数组访问，最大限度的保证任何想inspect CPython执行状态的功能都还能正常运行。&lt;/p&gt;&lt;p&gt;在伪代码里还可以看到每条CPython字节码处理的开头都有一个对 frame-&amp;gt;f_lasti 的赋值。这同样是为了保证严格的兼容性而做的——CPython有许多地方在泄漏解释器的内部状态，例如&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.python.org/3/library/traceback.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;traceback模块&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，例如&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.python.org/3/library/inspect.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;inspect模块&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，又例如&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.python.org/3/c-api/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;毫无保护的C API&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，它们都可以去查看Python解释器栈的状态，而这个由 PyFrameObject 构成的栈中很重要的内容就是“当前执行到哪里了”，也就是这个 f_lasti 字段。要想百分百兼容依赖了这些抽象泄漏的众多现有的Python库，要么就得这样死板的实现，否则就得实现得非常非常非常麻烦。&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外可以发现，生成的MSIL里还嵌入着一些native函数调用。Pyjion把这些函数叫做intrinsics，也可以叫做runtime helper function。Pyjion通过这种方式来支持Python字节码里隐含的“复杂操作”，例如那个&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp%23L87&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PyJit_Add()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。它的实现长啥样呢？&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PyJit_Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// TODO: Verify ref counting...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyUnicode_CheckExact&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyUnicode_CheckExact&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PyUnicode_Append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyNumber_Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Py_DECREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Py_DECREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这其实就跟CPython解释器里的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/python/cpython/blob/efe0e11c78f890146375f1d4cbed4b513cdffa3c/Python/ceval.c%23L1559&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;BINARY_ADD字节码&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的内部实现几乎是一样的，只是把求值栈的操作映射到了MSIL层面上。&lt;/p&gt;&lt;p&gt;而面对这样的runtime helper函数，RyuJIT只能当它们是黑盒子而无法进一步分析与优化，也就无从內联这些函数的调用。&lt;/p&gt;&lt;p&gt;在Windows x86-64上的RyuJIT，最终会把上面的foo()函数例子编译为这样的机器码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// function prologue
    push    rdi
    push    rsi
    sub     rsp,28h
    mov     rsi,rdx
    lea     rdi,[rsi+88h]
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_PY_PUSHFRAME+0x38
    call    qword ptr [rax]
// 0: LOAD_FAST 0 (a)
    xor     ecx,ecx
    mov     dword ptr [rdi],ecx
    mov     rcx,qword ptr [rsi+188h]
    lea     rdx,[rcx+10h]
    add     dword ptr [rdx],1
// 3: LOAD_FAST 1 (b)
    mov     dword ptr [rdi],3
    mov     rdx,qword ptr [rsi+190h]
    lea     rax,[rdx+10h]
    add     dword ptr [rax],1
// 6: BINARY_ADD
    mov     dword ptr [rdi],6
    mov     rax,offset pyjit!gMETHOD_ADD_TOKEN+0x38
    call    qword ptr [rax]
    test    rax,rax
    je      L_Raise
// 7: RETURN_VALUE
    mov     dword ptr [rdi],7
    jmp     L_ret
// default exception handler
L_Raise:
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_EH_TRACE+0x38
    call    qword ptr [rax]
L_Reraise:
    xor     edi,edi
    jmp     L_finalRet
// function epilogue
L_ret:
    mov     rdi,rax
L_finalRet:
    mov     rcx,rsi
    mov     rax,offset pyjit!gMETHOD_PY_POPFRAME+0x38
    call    qword ptr [rax]
    mov     rax,rdi
    add     rsp,28h
    pop     rsi
    pop     rdi
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;嗯…跟上面的MSIL层面的逻辑几乎完全一样，只是MSIL层面的求值栈和局部变量都被优化到x86-64指令集的寄存器上了，其它就跟伪代码里写的一模一样。&lt;/p&gt;&lt;p&gt;Pyjion要真的让CPython的性能有突飞猛进的发展，还有很长的路要走。&lt;/p&gt;&lt;p&gt;就这个例子来说，其实它的 *lasti = 0 和 *lasti = 3 都是完全冗余的，因为可以假设CPython不会有机会观察到这俩状态——直到下次Pyjion要通过periodic_work进入CPython runtime，或者下次调用可能暴露实现细节的CPython函数 (*)。诸如这样的冗余可以通过更彻底的静态分析来消除掉，只是要实现它就得堆人力和时间了。&lt;/p&gt;&lt;p&gt;而许多能有效提升动态语言性能的技巧，在当前的CPython上都行不通，因为它对自己的内部状态实在没有啥封装可言，内部实现细节泄漏得到处都是。如果能堵上那些抽象泄漏，就可以把隐藏类（hidden class）、多态內联（polymorphic inline caching）、类型推导以及进一步优化一股脑的堆上去了。不幸的是CPython社区就喜欢这些泄漏的抽象，怕是难说服社区接受这种程度的改变——不然大家现在都该在用Pyston或者PyPy了。&lt;/p&gt;&lt;p&gt;另外，Pyjion未来要想进一步提升性能，需要在“哪些东西暴露在MSIL / IR层面“与”哪些东西封装在intrinsics / runtime helper function“之间找到一个更好的平衡。现在因为Pyjion把很多操作都放在了intrinsics里，RyuJIT无法理解也无法优化它们，失去了优化的机会；但如果把太多细节暴露给RyuJIT的话，方法体可能又会太大，让RyuJIT工作得太吃力。如何在两者间找到个好的平衡是门艺术。做得好的话，一些冗余的引用技术更新也应该可以消除掉，那就很爽。&lt;/p&gt;&lt;br&gt;&lt;p&gt;下次有机会再展示一下Pyjion目前已经做了的一种优化——带标记的指针（tagged pointer）。&lt;/p&gt;&lt;p&gt;(*) 这个思路就跟JVM里某些优化可以在两个safepoint之间进行，但不能跨越safepoint边界一样。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20591139</guid>
<pubDate>Mon, 22 Feb 2016 17:50:07 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] CPython / 微软 Pyjion / IBM Python+OMR</title>
<link>http://zhuanlan.zhihu.com/hllvm/20581695</link>
<description>&lt;h2&gt;&lt;b&gt;大背景&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;在进入主题前，请先看看IBM Research以前做过的类似项目的经验：Fiorano项目。&lt;/p&gt;&lt;p&gt;Fiorano是IBM Research做的一次尝试，将IBM J9 JVM所使用的Testarossa（TR）编译器单独拿出来，插入到CPython运行时中为后者提供JIT编译服务。&lt;/p&gt;&lt;p&gt;传送门：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p169.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Adding Dynamically-Typed Language Support to a Statically-Typed Language Compiler: Performance Evaluation, Analysis, and Tradeoffs&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//researcher.watson.ibm.com/researcher/files/us-pengwu/oopsla12-final-dsl.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;On the Benefits and Pitfalls of Extending a Statically Typed Language JIT Compiler for Dynamic Scripting Languages&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;结果呢？当然Fiorano没有被整合到官方CPython里，不然现在大家就已经在用它了。但作为研究性项目它还是有点意思的——我觉得最重要的一点，是在一个原本没有打算与高性能JIT编译器搭配使用的runtime上，很难实现出特别有效的优化。在主流JVM上，JIT编译后的代码的速度可以轻易达到解释器速度的10x水平；而Fiorano带上了JIT却也就达到了纯解释执行的CPython的速度的1.2x～2.74x的水平范围，并没有给大家带来多少震撼…&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;Pyjion&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub - Microsoft/Pyjion: Pyjion&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;开源许可证：MIT&lt;/p&gt;&lt;p&gt;是的，微软近期也加入了给&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.python.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CPython&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;加JIT编译器的大混战。微软甚至还有一个寄身于Data Group in Azure组的Python研发组，最近&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blogs.msdn.microsoft.com/pythonengineering/2016/02/12/welcome/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;开始对外宣传&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;项目名是“Pyjion”，读作“pigeon”（鸽子），因为项目主力成员Dino大大想要有Python的Py音节、JIT的Ji音节的词…就找（sheng）到（zao）了这么个词出来。GJ！&lt;br&gt;&lt;/p&gt;&lt;p&gt;说起项目主要成员之一的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//blogs.msdn.com/b/dinoviehland/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dino Viehland&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;大大，他以前是IronPython与DLR的主力开发之一，后来也参与了&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//microsoft.github.io/PTVS/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Python Tools for Visual Studio（PTVS）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的开发。大家用Visual Studio / VS Express开发Python爽不？里面就有Dino大大的功劳。&lt;/p&gt;&lt;p&gt;可见他对Python那可是有深深的怨念…是真爱啊！&lt;/p&gt;&lt;p&gt;而Pyjion项目的另一个主要成员是Brett Cannon。他从2003年开始就是CPython的core commiter了。这也是真爱啊！&lt;/p&gt;&lt;p&gt;未来传送门：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PyCon US 2016：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//us.pycon.org/2016/schedule/presentation/1866/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Presentation: Pyjion: who doesn’t want faster for free?&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; - 2016-05-30&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;言归正传，这Pyjion到底是啥呢？它是Brett和Dino做的&lt;b&gt;实验产物&lt;/b&gt;，为了在保持完全兼容的前提下提升CPython的性能。目前基于的CPython版本是3.6 alpha 1。&lt;/p&gt;&lt;br&gt;&lt;p&gt;项目官网的一句话说明是：&quot;A JIT for Python based upon CoreCLR&quot;。它目前的项目目标有三个：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;Add a C API to CPython for plugging in a JIT&lt;/b&gt;（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/master/Patches/python.diff&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;代码&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;） &amp;lt;- 最主要的目标&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;ol&gt;&lt;li&gt;Develop a JIT module using CoreCLR utilizing the C API mentioned in goal #1（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/tree/master/Pyjion&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;代码&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;） &amp;lt;- 概念验证用&lt;br&gt;&lt;/li&gt;&lt;li&gt;Develop a C++ framework&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;目标1很简单，就是给CPython添加一组新的C API及其实现，来为外部的JIT编译器提供接入CPython运行时的钩子。这部分目前设计和实现都很直观，看看上面的代码链接的patch就知道它是啥了——在解释器入口处添加钩子，当有JIT编译器注册进来时，一个函数在即将开始被解释执行时会先尝试JIT编译，如果成功以后就执行JIT出来的机器码；如果不成功就会把该函数标记为不可JIT编译，以后就不再尝试了。&lt;/p&gt;&lt;p&gt;目前这C API并不太灵活，只允许以Python函数为单元来编译，编译必须对整个函数成功，否则就得整个函数留在解释器里跑。这个API没有考虑到在函数中间跳进JIT编译的代码（On-Stack Replacement，OSR）或从JIT编译的代码中途跳回到解释器（deoptimization）之类的需求。&lt;/p&gt;&lt;p&gt;目标2的描述方式挺有趣的：把&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dotnet/coreclr&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CoreCLR&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;当作JIT编译器插入CPython。啥？难道为了JIT还得把整个CoreCLR都拉进来么？太可怕了！&lt;/p&gt;&lt;p&gt;实际上当然没那么糟糕。这个描述方式感觉是故意说得模糊一些。其实Pyjion只是要使用CoreCLR里带着的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RyuJIT编译器&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;来为CPython服务。但是当前的RyuJIT的实现依赖了CLR / CoreCLR提供的JIT编译器接口，所以要单独使用RyuJIT的话，得要把原本由CLR / CoreCLR提供的一些服务/接口给模拟出来才行。这个模拟层在Pyjion代码里就是CExecutionEngine、CorJitInfo等类。&lt;/p&gt;&lt;p&gt;换言之，Pyjion自身在pyjit.dll中，而它并不真的需要依赖整个CoreCLR（主体位于coreclr.dll），而只需要其中的RyuJIT（位于clrjit.dll）及其必须依赖的库（例如gcinfo），然后提供CExecutionEngine、CorJitInfo等类的实现给RyuJIT模拟出它所依赖CoreCLR的一些功能。&lt;/p&gt;&lt;p&gt;据说RyuJIT其实是希望未来与CLR / CoreCLR分离开，变得更独立，便于在诸如Pyjion这样的场景单独使用。目前RyuJIT与CLR确实不是由同一个组负责开发的，要分家也很合理。但未来会如何发展，外界也只能拭目以待了。&lt;/p&gt;&lt;p&gt;那么Pyjion是如何使用RyuJIT的呢？&lt;/p&gt;&lt;p&gt;它并没有实现一个RyuJIT的前端，直接把CPython字节码转换为RyuJIT的IR；而是把CPython字节码先转换为CLR的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Common_Intermediate_Language&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MSIL&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;字节码，然后再让RyuJIT去把这MSIL编译成机器码，最后安装到CPython运行时里去运行。这种做法或许多少与项目组成员之前做IronPython的经历有关系，或者是与RyuJIT现在与CLR / CoreCLR的偶和有关系。&lt;/p&gt;&lt;p&gt;不过这里生成的MSIL只用了MSIL的指令集，而没有完全实现标准的Assembly格式；其元数据相关部分都是Pyjion用自己的数据结构模拟出来的，所以无法将生成的MSIL交给诸如ildasm之类的工具来查看。&lt;/p&gt;&lt;p&gt;具体的转换步骤是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;CPython的解释器入口&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Patches/python.diff%23L364&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PyEval_EvalFrameEx()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;调用JIT编译器JitCompile()函数，传入CPython字节码。&lt;br&gt;&lt;/li&gt;&lt;li&gt;JIT编译器入口&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pyjit.cpp%23L52&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JitCompile()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;创建AbstractInterpreter与PythonCompiler，调用&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp%23L2971&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AbstractInterpreter::compile()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;开始编译流程。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.h%23L157&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AbstractInterpreter&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;类充当CPython字节码的解析器（parser），一边抽象解释CPython字节码一边调用PythonCompiler来生成MSIL。&lt;br&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp%23L59&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AbstractInterpreter::preprocess()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;先把CPython字节码里偷懒而设计的&quot;Block&quot;给预处理掉，把循环的跳转目标、异常处理块的边界给找出来并扁平化。可能有同学不理解“偷懒”是什么意思：Python的字节码编译器在处理循环和异常相关的控制流时，没有在编译器里处理嵌套关系，而是把“作用域栈”留到了解释器里。而正确的做法是&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.h%23L185&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在编译器里处理掉它&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，例如这样：&lt;a href=&quot;https://www.zhihu.com/question/28992261/answer/43400987&quot; class=&quot;internal&quot;&gt;如何对C语言的FOR语句给出一个生成中间代码的语法制导定义？ - RednaxelaFX 的回答&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp%23L190&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AbstractInterpreter::interpret()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;遍历一遍整个CPython函数的字节码，找出基本块边界、异常处理块的边界，以及收集一些后续优化可能用到的信息。例如说它会做个很保守的逃逸分析来判断哪些值没有逃逸，后面就可以选择对它们做进一步特殊优化，例如下文提到的tagged pointer。&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp%23L1796&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AbstractInterpreter::compile_worker()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;一个个基本块遍历CPython字节码并生成MSIL字节码。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.h%23L221&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PythonCompiler&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;会把每种CPython字节码的操作映射为合适的MSIL字节码序列。简单的CPython字节码可以直接映射为一条或多条MSIL字节码，而复杂的字节码则映射为Pyjion的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.h&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;intrinsic函数&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的调用。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;例如两个Python对象相加，会映射为对Pyjion提供的“&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp%23L87&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PyJit_Add()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;”函数的调用，而这个函数会调用回到CPython运行时里的实现。&lt;/li&gt;&lt;li&gt;具体生成MSIL的有一个&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/ilgen.h%23L66&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ILGenerator&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;类。它与.NET的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//msdn.microsoft.com/en-us/library/system.reflection.emit.ilgenerator.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;System.Reflection.Emit.ILGenerator&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;颇为神似。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.cpp%23L1084&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PythonCompiler::emit_compile()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; -&amp;gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/ilgen.h%23L470&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ILGenerator::compile()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; -&amp;gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dotnet/coreclr/blob/b16ff5935ff9df3211798f18f0c951666ae27774/src/jit/ee_il_dll.cpp%23L135&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CILJit::compileMethod()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; MSIL传入RyuJIT开始编译。&lt;br&gt;&lt;/li&gt;&lt;li&gt;接下来就交给RyuJIT编译，得到编译好的机器码以及一些相关的元数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;换句话说，Pyjion这种实现JIT编译的方式，实际的效果是把一个Python函数的字节码全部粘合到一起，去掉了解释器循环自身的开销，但是大部分复杂的操作还是调用回到CPython运行时去处理的。&lt;/p&gt;&lt;p&gt;要说在语义层面上的优化，Pyjion尝试了给CPython添加&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/taggedptr.h&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tagged pointer&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;来减少小整数的内存开销，顺带提高运行性能（因为实际数据就伪装在指针里，离运算更近了）。但为了保证兼容性，tagged pointer只在被JIT编译的函数内部使用，一到&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp%23L3051&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;return_value&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;之类的要暴露（escape）出去的地方就还是装箱（box）回到原本的对象形态。对应的intrinsic实现在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp%23L2291&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TAGGED_METHOD宏&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;里（例如&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.cpp%23L1277&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PyJit_Add_Int()&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;就是这样来的）。&lt;/p&gt;&lt;p&gt;原本CPython解释器在解释执行每N条字节码指令后都会做些周期性检查，例如是否应该释放GIL来给别的线程机会执行。Pyjion把Python代码JIT编译后，这些周期性检查就安放在用户代码里的循环回跳（backedge）的地方。这跟HotSpot VM的JIT编译代码选择的放置safepoint polling的位置一样。&lt;/p&gt;&lt;p&gt;总体来说，Pyjion采用了一种非常保守的实现方式，很容易保证正确性，但能带来的性能提升也会非常有限。保守是否就意味着容易被接受呢？难说…搞不好会给人太多想像空间结果很失望orz&lt;/p&gt;&lt;p&gt;希望当前的保守设计只是一个过渡阶段。毕竟这个设计比Fiorano的做法还要保守，能带来的性能提升就更有限了。&lt;/p&gt;&lt;p&gt;在JIT编译之外，Pyjion还有没有向CPython注入任何其它东西呢？一点也没有。GIL、GC、监控之类的额外功能一概没碰。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;IBM Python+OMR&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;回头一点点更新。先放个传送门讲解背景：&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; class=&quot;internal&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20581695</guid>
<pubDate>Thu, 18 Feb 2016 15:44:23 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻][JavaScript引擎] WebKit JavaScriptCore用新的B3编译器后端替代FTL JIT中的LLVM</title>
<link>http://zhuanlan.zhihu.com/hllvm/20577490</link>
<description>&lt;p&gt;传送门：&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//webkit.org/blog/5852/introducing-the-b3-jit-compiler/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Introducing the B3 JIT Compiler&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; &amp;lt;- 这篇介绍写得非常好，清晰的讲解了B3的设计目的、思路和效果。&lt;br&gt;&lt;/li&gt;&lt;li&gt;B3文档：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//webkit.org/docs/b3/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bare Bones Backend&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;B3 IR文档：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//webkit.org/docs/b3/intermediate-representation.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;B3 Intermediate Representation&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;Filip大大再次立功。苹果内部果然也开撕了嘛…&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这次更新后，JavaScriptCore仍旧会使用4层编译系统：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第1层：解释器 LLInt&lt;br&gt;&lt;/li&gt;&lt;li&gt;第2层：简易非优化JIT编译器 Baseline JIT&lt;/li&gt;&lt;li&gt;第3层：优化JIT编译器 DFG JIT&lt;/li&gt;&lt;li&gt;第4层：高度优化JIT编译器 FTL JIT&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;只不过，这个FTL的意思变了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;老：Fourth Tier LLVM = DFG++（高层优化） + LLVM（底层优化）&lt;br&gt;&lt;/li&gt;&lt;li&gt;新：Faster Than Light = DFG++（高层优化） + B3（底层优化）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;…名字的更新当然是故意的。以前就有人开玩笑说FTL是faster than light，现在把LLVM扔掉了这名字就干脆也改过来了。&lt;/p&gt;&lt;p&gt;可以看到其实这个新的B3后端并不是把整个FTL JIT给重写了，而只是替换掉了其中负责底层优化的LLVM部分而已。&lt;/p&gt;&lt;br&gt;&lt;p&gt;不得不说Filip大大带的JavaScriptCore团队还挺厉害的。去年10月开始写这个新的名为“B3”的后端，过了4个月就已经上了正轨了。&lt;/p&gt;&lt;p&gt;B3本质上是对LLVM的剪裁与特化，针对JavaScriptCore的需求而生。它与LLVM在相似的抽象层，B3 IR的构造API也与LLVM IR相似，这样FTL::Output就可以方便的从原本构造LLVM IR切换到构造B3 IR。换句话说，扔掉的是LLVM“&lt;i&gt;臃肿&lt;/i&gt;”的实现，而保留下的是LLVM的优化的精髓。当然“&lt;i&gt;臃肿&lt;/i&gt;”是相对FTL的应用场景而言的（？）。&lt;/p&gt;&lt;p&gt;这个B3后端最最核心的关注点就是减少内存开销。这再次展示了&lt;b&gt;编译器中IR在内存里的布局对编译速度的影响&lt;/b&gt;——但主要关注AOT编译场景的编译器（例如GCC和LLVM）大多不够注重这一点。在FTL JIT里，LLVM编译出来的代码质量虽然不错，但是编译速度在许多运行时间不够长的场景里就显得太慢了，用户程序都跑完了LLVM还没编译完。&lt;/p&gt;&lt;p&gt;以前跟JRockit的JIT编译器开发聊天的时候，他们也提到JRockit的JIT编译器IR有过一次重要的更新，大幅减少了内存开销而并没有做什么别的特别优化，光是这样就让编译速度提升了50%而编译出来的代码质量与以前一样。JRockit减少编译器IR的内存开销主要是通过几种思路：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;减少数据结构中指针的使用，改为用更紧凑的整数ID/下标来表示引用关系；&lt;/li&gt;&lt;li&gt;尽量用固定大小的结构表示常用信息，而把可变长并且不常用的信息挪到外部；&lt;/li&gt;&lt;li&gt;尽量把数据紧凑的放在数组/vector里。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;无独有偶，B3的思路和JRockit非常非常相似。这也是比较新的、干净的IR设计流行的做法。&lt;/p&gt;&lt;p&gt;B3为了减少内存开销，还把LLVM IR中的use-def/def-use双向链接中的def-use信息抛弃了。一个def无法直接找到自己的所有use，就无法直接完成“Replace All Uses With”操作；但要替换IR指令还是可以通过遍历一次IR图来做到。&lt;/p&gt;&lt;p&gt;不在IR里记录def-use信息是的有趣的取舍；HotSpot Client Compiler（C1）与Maxine C1X也采用了类似的设计，只为了SSA而记录use-def信息，但不记录def-use信息。这个设计在C1里却造成了一些很悲催的坑：C1 HIR的指令替换只能一条对一条的做——一条HIR指令可以被另外一条HIR指令所替代，但是一条新的指令却无法替代多条老的指令，因为不遍历一次整个IR就无法知道老指令有没有被其它地方用到（同时C1也无法让多条新指令替代一条老指令，不过那是另一个问题）。这设计导致&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/c1/c1_Canonicalizer.cpp%23l713&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;C1某些优化被“永久禁用”&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，导致C1X的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kenai.com/projects/maxine/sources/maxine/content/com.oracle.max.c1x/src/com/sun/c1x/opt/DiamondEliminator.java%3Frev%3D8812&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DiamondEliminator&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;如此难看、而&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kenai.com/projects/maxine/sources/maxine/content/com.oracle.max.c1x/src/com/sun/c1x/opt/SCCPropagator.java%3Frev%3D8812&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SCCPropagator&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;实现起来太麻烦以致没人去实现它。&lt;/p&gt;&lt;p&gt;但C1 / C1X的HIR还是用单向链表连在一起的，而B3 IR是用数组（vector）为容器，如果要实现批量插入新IR节点那肯定得仔细处理才能让效率高。B3的解决方案是在一个pass里把需要对IR做的修改放进&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/b3/B3InsertionSet.h&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;InsertionSet&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;里，等到下次遍历整个IR图时再去批量插入IR。这对JavaScriptCore倒不是什么新概念——DFG自己其实早就有&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/dfg/DFGInsertionSet.h&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;InsertionSet&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;了。可见Filip大大还是不禁觉得自己的设计比LLVM好哇。&lt;/p&gt;&lt;p&gt;B3 IR里还藏了些原本LLVM没有但DFG已经有的私货，例如&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/b3/B3UpsilonValue.h&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;UpsilonValue&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。这是DFG所采用的特殊的SSA形式的组成部分，既然要扔掉LLVM，就干脆把B3的SSA形式也向DFG靠拢。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;B3 IR里一些复合控制流的IR指令设计也是个有趣的点。用Graal的术语来说，这就是在IR层面上用更显式的方式来表达&lt;b&gt;Guard&lt;/b&gt;。在IR层面上保留Guard的语义，而不急于将其lower到普通的if + deoptimization，对干净的实现某些优化（例如guard的提升与合并）还挺重要的。&lt;/p&gt;&lt;br&gt;&lt;p&gt;B3目前采用的寄存器分配器是一个graph coloring算法的变种，叫做&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cs.princeton.edu/research/techreps/TR-498-95&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Iterated Register Coalescing&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（IRC）。LLVM默认的寄存器分配器则是一种linear scan算法的比较复杂的变种，叫做Greedy。Greedy虽然比原始的linear scan慢一些，但是总体来说还是比graph coloring系的算法快而效果相近。所以Filip大大也说会一边继续优化B3基于IRC的寄存器分配器，一边考虑&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//bugs.webkit.org/show_bug.cgi%3Fid%3D153797&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;把Greedy分配算法移植到JavaScriptCore里&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;LLVM的Greedy寄存器分配器近来还挺流行的。V8 TurboFan&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//codereview.chromium.org/1061923005/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;尝试过移植它&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（虽然目前被撤销了，但以后或许还会再放进来），&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//bugzilla.mozilla.org/show_bug.cgi%3Fid%3D814966&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;IonMonkey&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;也&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hg.mozilla.org/mozilla-central/file/tip/js/src/jit/BacktrackingAllocator.h&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;实现了它&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。Hmm。&lt;/p&gt;&lt;br&gt;&lt;p&gt;====================================================&lt;/p&gt;&lt;p&gt;同事Philip Reames也发表了对B3的看法：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.philipreames.com/Blog/2016/02/15/quick-thoughts-on-webkits-b3/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quick thoughts on WebKit’s B3&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;显然，作为我们这边的重度LLVM用户和开发，Philip大大对B3颇有微词 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;====================================================&lt;br&gt;&lt;/p&gt;&lt;p&gt;题图跟本文的主题有什么关系，大家知道不？^_^&lt;/p&gt;&lt;p&gt;（题图引用自&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//faf.jp/info_spe1.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;戦闘妖精雪風&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，（ｃ）２００２ 神林長平・早川書房／バンダイビジュアル・ビクターエンタテインメント・ＧＯＮＺＯ）&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20577490</guid>
<pubDate>Wed, 17 Feb 2016 04:05:15 +0800</pubDate>
<media:thumbnail url="https://pic2.zhimg.com/2f994cb65c4e8ddbeedccb101c97e689_b.jpg" />
</item>
<item>
<title>给类型求导</title>
<link>http://zhuanlan.zhihu.com/hllvm/20570808</link>
<description>熟识类型的用家可能都知道两个非常常见的类型构造：二元组和标签并，在代数类型（Algebraic type）中分别映射到乘法和加法，于是多项式&lt;img src=&quot;https://zhihu.com/equation?tex=1%2Bt%5E2&quot; alt=&quot;1+t^2&quot; eeimg=&quot;1&quot;&gt;可以用来表示&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BEither%7D%5C%3B%28%29%5C%3B%28t%2Ct%29&quot; alt=&quot;\mathrm{Either}\;()\;(t,t)&quot; eeimg=&quot;1&quot;&gt;这样的构造。继续扩展下去，比如把递归类型引入的话，就得到了许多递归类型的有理式表示，比如列表，它可以表示成&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D%5Cfrac%7B1%7D%7B1-a%7D&quot; alt=&quot;L(a)=\frac{1}{1-a}&quot; eeimg=&quot;1&quot;&gt;，因为它是方程&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D1%2BaL%28a%29&quot; alt=&quot;L(a)=1+aL(a)&quot; eeimg=&quot;1&quot;&gt;的解 [注 1]，而这个方程是列表的递归类型表示（在 Isorecursive 语义下，它表示&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29&quot; alt=&quot;L(a)&quot; eeimg=&quot;1&quot;&gt;和&lt;img src=&quot;https://zhihu.com/equation?tex=1%2BaL%28a%29&quot; alt=&quot;1+aL(a)&quot; eeimg=&quot;1&quot;&gt;之间存在一一映射，在实现时则用「指针」表示这种映射）。&lt;p&gt;上面的列表若是实现出来的话，是用链表实现的，对于双向遍历的话性能很差，于是我们发明一个 Zipper 类型，它同时存储一个焦点项目和它的左右两侧：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Zipper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;向左右两侧遍历的操作就可以写成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;left&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;反向遍历的复杂度也降低到了 O(1)，性能获得了很可观的提升。除了列表，其他更复杂的数据结构，如二叉树等，也可以定义出 Zipper。&lt;/p&gt;&lt;p&gt;从代数类型的角度看，Zipper 的方程可以写作&lt;img src=&quot;https://zhihu.com/equation?tex=Z%28a%29%3DL%28a%29%5Ccdot+a+%5Ccdot+L%28a%29%3DaL%28a%29%5E2&quot; alt=&quot;Z(a)=L(a)\cdot a \cdot L(a)=aL(a)^2&quot; eeimg=&quot;1&quot;&gt;，换言之，一个列表的 Zipper 可以看作一个「焦点」和两个列表的积，而后者则是原来列表类型敲掉一个空位。&lt;img src=&quot;https://pic1.zhimg.com/0ed4cd4fd0e3bae9483c9a58ae37461c_b.png&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;49&quot; class=&quot;content_image&quot; width=&quot;400&quot;&gt;&lt;/p&gt;&lt;p&gt;给数据结构挖个洞是个不太罕见的需求，我们已经知道&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C+%5Cfrac%7B1%7D%7B1-a%7D%3D%5Cleft%28%5Cfrac%7B1%7D%7B1-a%7D%5Cright%29%5E2&quot; alt=&quot;\mathrm{Hole}_a\ \frac{1}{1-a}=\left(\frac{1}{1-a}\right)^2&quot; eeimg=&quot;1&quot;&gt;。对于更简单的类型，我们也可以试试在上面挖洞，比如，类型 1 因为挖不出来洞，所以&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a+1%3D+0&quot; alt=&quot;\mathrm{Hole}_a 1= 0&quot; eeimg=&quot;1&quot;&gt;；「一元组」a 挖洞之后都变一样了，于是&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%3D1&quot; alt=&quot;\mathrm{Hole}_a\;a=1&quot; eeimg=&quot;1&quot;&gt;；而对于二元组&lt;img src=&quot;https://zhihu.com/equation?tex=a%5E2&quot; alt=&quot;a^2&quot; eeimg=&quot;1&quot;&gt;，因为存在两种可能的「挖」法（左或右），所以&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%5E2%3D%28%28%29%2Ca%29%2B%28a%2C%28%29%29%3D2a&quot; alt=&quot;\mathrm{Hole}_a\;a^2=((),a)+(a,())=2a&quot; eeimg=&quot;1&quot;&gt;。这可以推广到所有的简单元祖，我们总可以得到&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%5En%3Dna%5E%7Bn-1%7D&quot; alt=&quot;\mathrm{Hole}_a\;a^n=na^{n-1}&quot; eeimg=&quot;1&quot;&gt;。&lt;/p&gt;&lt;p&gt;看上去怎么那么眼熟。&lt;/p&gt;&lt;p&gt;…………………………&lt;/p&gt;&lt;p&gt;这不是求导么？&lt;/p&gt;&lt;p&gt;对，Conor McBride 的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//strictlypositive.org/diff.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;论文&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;中，就论述了类型上的导子（Derivation）&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a&quot; alt=&quot;\partial_a&quot; eeimg=&quot;1&quot;&gt;，并且证明了它和「挖洞」行为之间的联系。导子的三个基础法则——和法则、莱布尼兹法则和链式法则，都可以用挖洞的行为「证明」。&lt;img src=&quot;https://pic1.zhimg.com/40d585a0d6a2e0bf510df7b3a984e5b4_b.png&quot; data-rawwidth=&quot;1828&quot; data-rawheight=&quot;344&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1828&quot; data-original=&quot;https://pic1.zhimg.com/40d585a0d6a2e0bf510df7b3a984e5b4_r.png&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/a5830a07404680c707a5a911582d0902_b.png&quot; data-rawwidth=&quot;1875&quot; data-rawheight=&quot;688&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1875&quot; data-original=&quot;https://pic3.zhimg.com/a5830a07404680c707a5a911582d0902_r.png&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/7f40b2bfe902ccd0782cd2801579e807_b.png&quot; data-rawwidth=&quot;1774&quot; data-rawheight=&quot;556&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1774&quot; data-original=&quot;https://pic4.zhimg.com/7f40b2bfe902ccd0782cd2801579e807_r.png&quot;&gt;&lt;/p&gt;&lt;p&gt;除此之外隐函数的「微分」同样适用于数据类型。考虑将导子作用到二叉树&lt;img src=&quot;https://zhihu.com/equation?tex=T%28a%29%3D1%2BaT%28a%29%5E2&quot; alt=&quot;T(a)=1+aT(a)^2&quot; eeimg=&quot;1&quot;&gt;上：&lt;/p&gt;&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3DT%28a%29%5E2%2B2aT%28a%29%5Ccdot%5Cpartial_a+T%28a%29&quot; alt=&quot;\partial_a T(a)=T(a)^2+2aT(a)\cdot\partial_a T(a)&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;p&gt;可以解得&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3D%5Cfrac%7BT%28a%29%5E2%7D%7B1-2aT%28a%29%7D%3DT%28a%29%5E2%5Ccdot+L%282%5Ccdot+a%5Ccdot+T%28a%29%29&quot; alt=&quot;\partial_a T(a)=\frac{T(a)^2}{1-2aT(a)}=T(a)^2\cdot L(2\cdot a\cdot T(a))&quot; eeimg=&quot;1&quot;&gt; [注 2]&lt;/p&gt;&lt;p&gt;这个式子表明，带有空位的二叉树可以用两个子树和一个列表的二元组表示，这个列表的每项包含三个部分：一个布尔值，一个节点和一个子树。事实上，这个列表就表示了从树根到空位走过的路径：布尔值分辨每次是左转还是右转，节点值标记路过的节点，子树值标记另一侧的东西；而前面那两个树则是空位下面的子树。&lt;/p&gt;&lt;p&gt;——&lt;/p&gt;&lt;p&gt;最后，如果说数学家就是在寻找相似性的话，那么这个应该是一个非常好的案例了。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;————————&lt;/p&gt;&lt;p&gt;[注 1]：考虑到一般来说，类型的相反数和倒数并没有良好定义，此处&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D%5Cfrac%7B1%7D%7B1-a%7D&quot; alt=&quot;L(a)=\frac{1}{1-a}&quot; eeimg=&quot;1&quot;&gt;可以理解为泰勒展式&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D%5Csum_%7Bj%3D0%7D%5E%5Cinfty+a%5Ej&quot; alt=&quot;L(a)=\sum_{j=0}^\infty a^j&quot; eeimg=&quot;1&quot;&gt;。更严谨的表述需要使用&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmu&quot; alt=&quot;\mu&quot; eeimg=&quot;1&quot;&gt;符号。&lt;/p&gt;&lt;p&gt;[注 2]：用级数表示的话，&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3D%5Csum_%7Bk%3D0%7D%5E%7B%5Cinfty%7D+T%28a%29%5B2aT%28a%29%5D%5Ek&quot; alt=&quot;\partial_a T(a)=\sum_{k=0}^{\infty} T(a)[2aT(a)]^k&quot; eeimg=&quot;1&quot;&gt;。此外也可以解出，&lt;img src=&quot;https://zhihu.com/equation?tex=T%28a%29%3D%5Csum_k+%5Cfrac%7Ba%5Ek%7D%7Bk%2B1%7D%7B2k+%5Cchoose+k%7D&quot; alt=&quot;T(a)=\sum_k \frac{a^k}{k+1}{2k \choose k}&quot; eeimg=&quot;1&quot;&gt;&lt;/p&gt;</description>
<author>Belleve</author>
<guid isPermaLink="false">20570808</guid>
<pubDate>Sun, 14 Feb 2016 06:33:25 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻][小道消息] ART又要考虑用基于LLVM的编译器了…</title>
<link>http://zhuanlan.zhihu.com/hllvm/20569303</link>
<description>如题。真就跟国内修公路一样，修了拆拆了修…&amp;gt;_&amp;lt; 还不知道这个传闻的准确性就是了。&lt;br&gt;&lt;p&gt;另外一方面，ART在向着使用OpenJDK类库的方面倒是有扎实的进展。看这个 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/6c37e9adf7afc547a0fdf4db29249f6982845162/runtime/openjdkjvm/OpenjdkJvm.cc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;runtime/openjdkjvm/OpenjdkJvm.cc&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 就是HotSpot的hotspot/src/share/vm/prims/jvm.cpp的对应物。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20569303</guid>
<pubDate>Sat, 13 Feb 2016 03:10:49 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] ART有了新的汇编写的解释器</title>
<link>http://zhuanlan.zhihu.com/hllvm/20491978</link>
<description>&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/c3ba07ef76549129705af28173070b88a1c39531&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Merge &quot;Fast Art interpreter&quot;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;p&gt;觉得Android Runtime（ART）的解释器比不上Dalvik用汇编写的解释器的同学，你们得到了：汇编解释器卷土重来 ^_^&lt;/p&gt;&lt;p&gt;——显然，ART还是有相当部分的代码要在解释器里跑，不然解释器性能再差又如何呢。&lt;/p&gt;&lt;p&gt;而dex2oat对PGO的支持也如火如荼进行中：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/27e17fd81cc30e16e86c9c15498cae7f920c9dfe&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Enable profiled guided compilation in dex2oat&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20491978</guid>
<pubDate>Sat, 16 Jan 2016 15:39:30 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>新手上路学习JavaScript引擎实现——路线图</title>
<link>http://zhuanlan.zhihu.com/hllvm/20505562</link>
<description>&lt;p&gt;最近在知乎接连看到几个相关的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/39468189&quot; class=&quot;internal&quot;&gt;如何阅读 ChakraCore 的代码?&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/39014659&quot; class=&quot;internal&quot;&gt;新手应该如何读Google V8引擎源代码？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/38332604&quot; class=&quot;internal&quot;&gt;Kinoma XS6 是一款怎样的 JavaScript 引擎？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;这些问题都是试图从阅读源码着手去学习JavaScript引擎的实现的。然而，对新手而言，直接从一个复杂的实现的源码着手，不可避免的是事倍功半的做法。&lt;/p&gt;&lt;p&gt;要学习JavaScript引擎的实现，就跟学习其它东西一样，最好是循序渐进的来，先打好基础，再去结合现实学习主流实现。&lt;/p&gt;&lt;p&gt;我推荐的学习路线是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;临摹：先找个比较简单语言的简单解释器实现，以它为模子，自己抄一个解释器出来。这个过程中可以学习到编程语言的解释器的基本构造，特别是其组成部分的划分，以及这些组成部分在工作流程中各自处于什么位置。整个流程串起来之后，思路就会清晰许多，接下去学习就可以有针对性了。&lt;/li&gt;&lt;li&gt;巩固：临摹的时候必然只能一个解释器的各部分的一种特定的简单实现。然而其背后的原理是怎样的，同一个组件是否有别的更先进（或不同取舍）的做法，就需要进一步学习了。此时可以针对各部分去读不同的书，例如编译原理、GC、对象模型等方面。学习原理，巩固基础，拓展视野。&lt;/li&gt;&lt;li&gt;规范：到此有足够基础可以着手学习/实现真正的JavaScript引擎了。但在动手之前，应该熟读&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/6.0/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMAScript规范&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，了解到底JavaScript语言所要求的语义是怎样的，解决“是什么”的问题。觉得新的ECMAScript 2015太复杂的话，从&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/5.1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMAScript 5.1&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习是个不错的开始。有个带注解的ECMAScript 5.1规范特别适合学习：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//es5.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Annotated ECMAScript 5.1&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。另外，更喜欢阅读中文文档的同学可以看&lt;a href=&quot;https://www.zhihu.com/people/b2abeb901f0608346f2517bebcd224aa&quot; data-hash=&quot;b2abeb901f0608346f2517bebcd224aa&quot; class=&quot;member_mention&quot; data-tip=&quot;p$b$b2abeb901f0608346f2517bebcd224aa&quot;&gt;@呂康豪&lt;/a&gt;大大在评论区推荐的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.w3.org/html/ig/zh/wiki/ES5&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ES5 - HTML5 Chinese Interest Group Wiki&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，那是他的怨念喔。&lt;/li&gt;&lt;li&gt;接轨：把前面学习的知识都结合起来，按照规范实现自己的简单的JavaScript引擎；或者此时也可以去阅读现成的比较简单的JavaScript引擎的实现，但还是自己动手写过一次能有更深刻的理解。&lt;/li&gt;&lt;li&gt;进阶：到这个阶段，再去阅读现实中主流的、高性能的JavaScript引擎的源码，就可以做到有的放矢了。快速阅读一下官方文档，浏览一下代码组织结构，就应该能大概掌握一个实现的大致架构。然后再抓住JavaScript引擎实现可能存在的重要设计点去看看，就可以知道这个实现在每个部分都选择了哪些实现方式。其实就像搭积木一样，每个部分能有什么选择都了然于心，这样再去深入到细节读代码，就可以事半功倍的提取出自己想要知道的信息了。很多时候看目录结构和源码文件名就能大概猜到需要的信息在哪个文件里，进去确认一下就好。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;我推荐这个学习路线，是因为上面的阶段我全都走过一遍了，亲测有效。国内有不少从事JavaScript引擎研发的同行们，不知道大家的学习路线又是怎样的呢？&lt;/p&gt;&lt;p&gt;以&lt;a href=&quot;https://www.zhihu.com/question/38332604/answer/75904396&quot; class=&quot;internal&quot;&gt;Kinoma XS6的讨论&lt;/a&gt;为例，我从看到问题到开始阅读源码，到写完整个回答，总共只用了几分钟。这个回答就包含了我在阅读一个JavaScript引擎实现时会首先关注的设计点，抓住这些点去阅读源码就可以很快的了解这个实现的全貌、其大体的设计思路和取舍方向。换言之，我并不需要为了了解它的概况而需要去从细节开始学习很多新的知识，而只要在已有知识里印证这个实现在可能的实现方式里到底选择了哪些。&lt;/p&gt;&lt;p&gt;另外也想提一下Constellation大大的lv5 JavaScript引擎（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Constellation/iv&quot; class=&quot;internal&quot;&gt;Constellation/iv · GitHub&lt;/a&gt;）。它的发展历程见证了Constellation的成长，也跟上面的学习路线中“规范-接轨-进阶”的过程完全吻合——一开始lv5是作者边读ES5规范边用最直观的方式把规范实现出来的。整个流程走通之后，他就开始从开源的主流JavaScript引擎学习先进的做法，并逐步实现到lv5当中，渐渐将其发展成一个颇为实在的、现代的实现。&lt;/p&gt;&lt;p&gt;我在这里也提到过lv5：&lt;a href=&quot;https://www.zhihu.com/question/34589661/answer/79792354&quot; class=&quot;internal&quot;&gt;准大三，计算机专业如何确定工作方向？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;我从2012年开始其实也有断断续续积累一些文字，希望能规整到一个系统的知识体系下写成一本书，以便更好的把这些相关知识传播给大家。不过目前这个计划还在早期阶段，暂时不接受催稿谢谢…&lt;/p&gt;&lt;p&gt;虽然书离成形还尚远，但我曾经试过把积累的内容的一部分汇总起来发出来：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/37596&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;[链接帖] 各JavaScript引擎的简介，及相关资料/博客收集帖&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，欢迎大家参考和提建议。这系列帖子已好久没更新就是了…&lt;/p&gt;&lt;br&gt;&lt;p&gt;话说回来，万事开头难，按照上面的路线，得找个最初的临摹对象来学习。&lt;/p&gt;&lt;p&gt;可以选择的对象有很多，不过这里我还是想再次推荐&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/4118518/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『プログラミング言語を作る』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中文版&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/25735333/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《自制编程语言》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）一书。我在这里发过一个简介帖：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/39194&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《自制编程语言》集中讨论帖&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//kmaebashi.com/programmer/devlang/crowbar.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Crowbar&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;语言及其解释器实现，就是我想推荐作为入门临摹的对象。&lt;br&gt;&lt;/p&gt;&lt;p&gt;欲知它究竟是怎样设计与实现，且看下回分晓 ^_^&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20505562</guid>
<pubDate>Sat, 16 Jan 2016 15:33:20 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
