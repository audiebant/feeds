<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 06 Nov 2016 17:31:07 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>Clang Parser漫步——declaration-specifiers（二）</title>
<link>https://zhuanlan.zhihu.com/p/23368100</link>
<description>既上文&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23344499&quot; data-editable=&quot;true&quot; data-title=&quot;Clang Parser漫步——external-declaration（一） - XlousZeng的文章 - 知乎专栏&quot; class=&quot;&quot;&gt;Clang Parser漫步——external-declaration（一） - XlousZeng的文章 - 知乎专栏&lt;/a&gt;说到解析external-declaration之后，本文将会解释Clang是如何解析declaration-specifiers的。&lt;p&gt;首先，这里先给出C99中declaration-specifiers的EBNF语法：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;declaration-specifiers:: [C99 6.7]
    storage-class-specifier declaration-specifiers[opt]
    type-specifier declaration-specifiers[opt]
    [C99]   function-specifier declaration-specifiers[opt]

storage-class-specifier:: [C99 6.7.1]
       &#39;typedef&#39;
       &#39;extern&#39;
       &#39;static&#39;
       &#39;auto&#39;
       &#39;register&#39;

function-specifier: [C99 6.7.4]
[C99]  &#39;inline&#39;

type-specifier::
            &#39;char&#39;
            &#39;wchar_t&#39;
            &#39;bool&#39;
            &#39;short&#39;
            &#39;int&#39;
            &#39;long&#39;
            &#39;signed&#39;
            &#39;unsigned&#39;
            &#39;float&#39;
            &#39;double&#39;
            &#39;void&#39;
    [C99]   &#39;_Bool&#39;
    [C99]   &#39;_Complex&#39;
    [C99]   &#39;_Imaginary&#39;  // Removed in TC2?
        enum-specifier
        struct-specifier
        union-specifier
        cv-qualifier

cv-qualifier::
        &#39;const&#39;
        &#39;volatile&#39;
        &#39;restrict&#39;&lt;/code&gt;&lt;p&gt;&lt;b&gt;一、入口&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在可以按照上述的语法对declaration-specifiers进行解析了；入口函数在ParseDecl.cpp:1581行&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-50ecb590293726244d4e921c8271f74d.png&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;471&quot;&gt;接下来在一个while循环中使用switch语句去处理上述右递归文法。略过处理c++，objective-c语法的逻辑。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-e1299f35e6d0a5fcbdf3b17f65231d39.png&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;471&quot;&gt;上述的DoneWithDeclSpec是解析完成之时的出口，会调用DS对象的finish函数完成一个declaration-specifiers的解析，进行语义检查，如：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;unsigned double是非法的;
unsigned x = 4;　　//x的默认类型将会转换为unsigned int.
unsigned unsigned x = 4;  // 错误duplicate &#39;unsigned&#39; declaration specifier
&lt;/code&gt;&lt;p&gt;Clang将declaration-specifiers分为如下几类，不同的类别是可以同时存在一个声明中的，但同一组中只能有一个。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;TypeSpecifierType: char, wchar_t,  _Bool,  foat,  double,  void, enum, union, struct;&lt;/li&gt;&lt;li&gt;TypeSpecifierWidth: short, long, long long;&lt;/li&gt;&lt;li&gt;TypeSpecifierComplex: _Imaginary, _Complex;&lt;/li&gt;&lt;li&gt;TypeSpecifierSign: unsigned, signed;&lt;/li&gt;&lt;li&gt;TypeQualifier: const, restrict, volatile;&lt;/li&gt;&lt;li&gt;StorageClassSpecifier: typedef, extern, static, auto, register;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;处理identifier，这个地方会区分普通标识符还是typename：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-08fe3d5abf90a93c8fe3de8e552f7be8.png&quot; data-rawwidth=&quot;769&quot; data-rawheight=&quot;406&quot;&gt;将其作为typename，并进行名字查找：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b3613f92cc6baaed9e1e403b98935949.png&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;255&quot;&gt;处理storage-class-specifier:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-0aa42016ca27eeb24337a2f60292e25d.png&quot; data-rawwidth=&quot;787&quot; data-rawheight=&quot;455&quot;&gt;处理function-specifiers，这些都是在C99中才加入的，如果你不需要处理C99的语法，可以跳过此类。&lt;b&gt;[注意，virtual和explicit是C++的语法]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-41344eb85758bf52fc8db136112346f4.png&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;255&quot;&gt;处理type-specifiers，&lt;b&gt;[注意：__int64是Clang扩充的整数类型]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-4b3f64a1b0b1a8886792db9930b807a1.png&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;488&quot;&gt;其他基本上都是类似的，就不贴图了，下面处理的是type-qualifiers：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-3d019c68592f12ef9f9d3f2d7b1e3fef.png&quot; data-rawwidth=&quot;833&quot; data-rawheight=&quot;332&quot;&gt;然后就是重点，解析struct/union，enum类型的定义和声明。在Clang中，struct/union是作为一类来处理的，与C++中的class关键字同理。&lt;/p&gt;&lt;img src=&quot;v2-ae3d93f1232751f43a185772abfbdcce.png&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;332&quot;&gt;&lt;p&gt;&lt;b&gt;二、解析Struct/Union-specifier&lt;/b&gt;&lt;/p&gt;&lt;p&gt;ParseClassSpecifier函数在ParseDeclCXX.cpp:839行。&lt;/p&gt;&lt;img src=&quot;v2-b1bd03de1206c6ad924360845858f4b2.png&quot; data-rawwidth=&quot;833&quot; data-rawheight=&quot;332&quot;&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;产生式为：
struct-or-union-specifier: [C99 6.7.2.1]
        struct-or-union identifier[opt] &#39;{&#39; struct-contents &#39;}&#39;
        struct-or-union identifier
[GNU]   struct-or-union attributes[opt] identifier[opt] &#39;{&#39; struct-contents attributes[opt]

[GNU]   struct-or-union attributes[opt] identifier

        struct-or-union:
        &#39;struct&#39;
        &#39;union&#39;
&lt;/code&gt;&lt;p&gt;首先进行一个简单的区分是struct or union or class[c++语法]&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-cc56279114bd2a147e907c5e48aeee31.png&quot; data-rawwidth=&quot;684&quot; data-rawheight=&quot;203&quot;&gt;之后就是解析各种gnu和microsoft的扩展了，我们这时候可以跳过。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-ede1f129c69ffe576344bac1e4900c88.png&quot; data-rawwidth=&quot;684&quot; data-rawheight=&quot;297&quot;&gt;判断是否有tag名字或者简单的模板id，不考虑c++模板。因为struct/union有匿名语法。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b439713a0ae8922aaa5ca87033cbf320.png&quot; data-rawwidth=&quot;639&quot; data-rawheight=&quot;150&quot;&gt;判断该struct/union X...是reference ? definition ? declaration。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b254c425cd88d220b528c1193bdadb38.png&quot; data-rawwidth=&quot;790&quot; data-rawheight=&quot;505&quot;&gt;然后得到如果TUK表示定义，则会转入解析struct/union body的函数，我们略过对c++语法的解析逻辑。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-060e9e2fbee3efe4d3753256fb5b9add.png&quot; data-rawwidth=&quot;776&quot; data-rawheight=&quot;214&quot;&gt;后面的部分就是Clang的错误语法产生式，将某些常见的错误语法形式编码到Parser中，为了更好的进行错误提示，可以了解下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-6a4cf2d75b8434b44f2e867c36db5066.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;436&quot;&gt;&lt;b&gt;三、解析enum-specifier&lt;/b&gt;&lt;/p&gt;&lt;p&gt;解析函数依旧在ParseDecl.cpp中，处于2766行。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;产生式：
ParseEnumSpecifier
       enum-specifier: [C99 6.7.2.2]
         &#39;enum&#39; identifier[opt] &#39;{&#39; enumerator-list &#39;}&#39;
[C99/C++]&#39;enum&#39; identifier[opt] &#39;{&#39; enumerator-list &#39;,&#39; &#39;}&#39;

         &#39;enum&#39; identifier　[类型引用或者声明]
&lt;/code&gt;&lt;br&gt;&lt;p&gt;&lt;img src=&quot;v2-27fd8fa76072c3371a519cf2c7df4519.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;436&quot;&gt;对于C++11来说，一个enum定义了一个作用域，但是C语言中没有。所以此处可以跳过作用域的处理。&lt;/p&gt;&lt;p&gt;判断是否有tag名字，否则就是一个匿名enum。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-a351f778a1fd864aaa5255b0ec47d112.png&quot; data-rawwidth=&quot;609&quot; data-rawheight=&quot;176&quot;&gt;与之前解析struct-specifier类似，判断该语法为何种形式, 定义或声明或引用&lt;/p&gt;&lt;img src=&quot;v2-6b38e227f7fa859c3139d3f9952a3e12.png&quot; data-rawwidth=&quot;778&quot; data-rawheight=&quot;316&quot;&gt;&lt;p&gt;名字处理好了之后，调用语义动作生成一个EnumDecl。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-574e2fc8b6284e091c1ea44ad887eabf.png&quot; data-rawwidth=&quot;778&quot; data-rawheight=&quot;236&quot;&gt;然后就可以解析enum {....}了。&lt;/p&gt;&lt;p&gt;最后进行语义判断，是否有多个enum声明，有个话将进行错误提示。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-c412f2e5fa4b5ac5d2781ebb104ffe1b.png&quot; data-rawwidth=&quot;778&quot; data-rawheight=&quot;210&quot;&gt;&lt;b&gt;三、解析Enum声明成员&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先声明一个作用域，用于检查同名变量，注意对于C语言来说，enum中没有一个单独的作用域，enum体内所有的变量的作用域在该enum声明所在的作用域，比如在顶层声明一个enum，那么enum常量所属的作用域是最顶层作用域。&lt;/p&gt;&lt;img src=&quot;v2-3478e1f88d61e0e5a6da793a43cbec07.png&quot; data-rawwidth=&quot;761&quot; data-rawheight=&quot;65&quot;&gt;&lt;code lang=&quot;text&quot;&gt;//对于如下代码：
enum X
{
    XX = 0,
    XZ,
};

enum Y
{
   XX = 0;
};

// 将会提示redefinition of enumerator &#39;XX&#39;。
//　如果此处使用c++11 enum class语法，带来的效果将会如Java中enum声明一样。
// 单独形成一个作用域。

//　如下代码在Clang 3.9 中使用-std=c++11编译通过。
enum class X
{
    XX = 0,
    XZ,
};

enum class Y
{
   XX = 0,
};

&lt;/code&gt;&lt;p&gt;好了，回归正题，在一个死循环中以此解析每个enum-decelarator，将结果保存在一个SmallVector中。&lt;/p&gt;&lt;p&gt;得到一个标识符，判断是否有赋值表达式，有的话在3031行解析常量表达式。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-74113ecc7372b25047d27665a58eb4bc.png&quot; data-rawwidth=&quot;689&quot; data-rawheight=&quot;457&quot;&gt;每个enumerator-constant解析完成之后，调用语义动作生成一个EnumConstantDecl对象，并添加到集合中。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-4dc0c990a3333020a8daf04a2125edaf.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;190&quot;&gt;当所有的成员解析完成之后，退出while循环，调用语义动作生成一个EnumDecl对象，对进行语义检查。&lt;/p&gt;&lt;img src=&quot;v2-d094a17d89aaa6206d01f3d1d933f21e.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;190&quot;&gt;</description>
<author>XlousZeng</author>
<guid isPermaLink="false">23368100</guid>
<pubDate>Wed, 02 Nov 2016 14:18:14 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[HotSpot VM] 单独构建OpenJDK8u的HotSpot VM的脚本</title>
<link>https://zhuanlan.zhihu.com/p/23374517</link>
<description>时不时被问到这个问题，还是一并回答了吧。&lt;p&gt;假定从 &lt;a href=&quot;http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot&quot; data-editable=&quot;true&quot; data-title=&quot;jdk8u/jdk8u/hotspot: log&quot; class=&quot;&quot;&gt;http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot&lt;/a&gt; 签出了HotSpot VM的代码。那么在Mac OS X上，想单独build出HotSpot VM而不想build整个JDK8u的话，可以用我自用的这俩bash函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# HotSpot development on Mac
# Make just the HotSpot VM. Defaults to making a fastdebug variant.
makehs() {
        local JHOME
        JHOME=$JAVA_HOME
        local BNAME
        if [[ -n $1 ]]; then
                BNAME=$1;
        else
                BNAME=&#39;all_fastdebug&#39; # &#39;fastdebug_build&#39;
        fi
        # use an existing JDK7 for the buld
        JAVA_HOME=&#39;~/sdk/jdk7/Contents/Home&#39;
        # HS_CLANG_OPTS=&quot;CC=clang COMPILER_WARNINGS_FATAL=false LFLAGS=&#39;-Xlinker -lstdc++&#39; USE_CLANG=true&quot;
        make -C make CC=clang COMPILER_WARNINGS_FATAL=false LFLAGS=&#39;-Xlinker -lstdc++&#39; USE_CLANG=true LP64=1 LANG=C ALT_BOOTDIR=$JAVA_HOME ARCH_DATA_MODEL=64 HOTSPOT_BUILD_JOBS=8 $BNAME
        JAVA_HOME=$JHOME
}

# Export the HotSpot build to the specified export JDK
exporths_fastdebug() {
        EXPORT_JDK_PATH=~/sdk/jdk8u/Contents/Home/
        cp -r `pwd`/build/bsd/export-universal/fastdebug/* $EXPORT_JDK_PATH
}
&lt;/code&gt;&lt;p&gt;（注意：makehs()里JAVA_HOME请配置为任何一个Oracle JDK7或OpenJDK7的JDK安装路径；exporths_fastdebug()里EXPORT_JDK_PATH请配置为目标JDK的路径。我是把这俩函数放在我的.bash_profile里的，各位同学想怎么用都行。）&lt;/p&gt;&lt;p&gt;这俩都是很偷懒的脚本，就不多解释了。&lt;/p&gt;&lt;p&gt;在签出的hotspot目录里执行makehs可以默认构建出fastdebug版的HotSpot VM，其build结果在hotspot目录里的build/bsd/export-universal/fastdebug目录下。&lt;/p&gt;&lt;p&gt;然后，准备好一个事先build好的JDK8u的完整安装（例如说拿一个现成的Oracle JDK8u装好），并且把EXPORT_JDK_PATH变量配置到该JDK8u的安装路径上，然后在刚才build的hotspot目录里执行exporths_fastdebug()就会把刚build好的内容拷贝到目标JDK8u里，覆盖掉其中原本的HotSpot VM（主要是libjvm.dylib）。&lt;/p&gt;&lt;p&gt;完事之后那个目标JDK8u里的HotSpot VM就被狸猫换太子，变成我们自己build的版本了。然后就可以尽情实验啦。&lt;/p&gt;&lt;p&gt;以前我在Linux上做HotSpot VM的开发的时候，用的脚本也是类似的。根据Linux和Mac OS X的特点稍微调整一下就好了。&lt;/p&gt;&lt;p&gt;最后放俩我老blog的传送门：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/875957&quot; data-editable=&quot;true&quot; data-title=&quot;在XUbuntu 10.10上以JRL源码构建Oracle JDK 6 update 23&quot;&gt;在XUbuntu 10.10上以JRL源码构建Oracle JDK 6 update 23&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://hllvm.group.iteye.com/group/topic/39814#post-260210&quot; data-editable=&quot;true&quot; data-title=&quot;Mac OS X 10.9.2 build JDK8有谁build成功过么&quot;&gt;Mac OS X 10.9.2 build JDK8有谁build成功过么&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23374517</guid>
<pubDate>Wed, 02 Nov 2016 16:41:12 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Clang Parser漫步——external-declaration（一）</title>
<link>https://zhuanlan.zhihu.com/p/23344499</link>
<description>&lt;p&gt;之前一个回答&lt;a href=&quot;https://www.zhihu.com/question/51908169/answer/129019775?group_id=776373881685442560&quot; data-editable=&quot;true&quot; data-title=&quot;最近想分析的一下gcc的源代码，但不知从何出入手。请大神们指教指教，非常感谢。？ - 知乎用户的回答&quot; class=&quot;&quot;&gt;最近想分析的一下gcc的源代码，但不知从何出入手。请大神们指教指教，非常感谢。？ - 知乎用户的回答&lt;/a&gt;里面叙述了Clang+LLVM 3.0的整体框架，但是有点遗憾的是那篇回答只是一个梗概，并未对某些细节做出一些阐述。&lt;/p&gt;&lt;p&gt;第二篇：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23368100&quot; data-editable=&quot;true&quot; data-title=&quot;Clang Parser漫步——declaration-specifiers（二） - XlousZeng的文章 - 知乎专栏&quot;&gt;Clang Parser漫步——declaration-specifiers（二） - XlousZeng的文章 - 知乎专栏&lt;/a&gt;&lt;/p&gt;该篇文章是受R大鼓励，接着上述的问题对Clang3.0中Parser部分进行剖析，略过对C++、Objective-C语法的支持，暂时不考虑语义部分Sema，工作量太大了。&lt;p&gt;本文下所有的测试代码和环境都是在Debian8, GCC/G++ 4.9.2, Clang3.9下进行编译的。调试的Clang版本是3.0，源码从Clang官网下载。&lt;/p&gt;&lt;p&gt;在阅读Clang的Parser部分之前，需要准备一份C语言标准，由于Clang支持的C语言是C99，所以最好是对照C99的标准&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;open-std.org 的页面&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&lt;/a&gt;中语法的EBNF范式阅读，效果更好，当然也可以看C89。&lt;/p&gt;&lt;p&gt;Parser部分涉及到的目录有 tools/clang/lib/AST语法树定义，Sema语义分析，Lex词法分析器，Parse语法分析器。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;clang目录结构：
.
├── Analysis
├── ARCMigrate
├── AST
├── Basic
├── CMakeLists.txt
├── CodeGen
├── Driver
├── Frontend
├── FrontendTool
├── Headers
├── Index
├── Lex
├── Makefile
├── Parse
├── Rewrite
├── Sema
├── Serialization
└── StaticAnalyzer
&lt;/code&gt;&lt;p&gt;Clang工程的入口函数在Parse.cpp:463行的ParseTopLevelDecl()函数&lt;/p&gt;&lt;img src=&quot;v2-d715ea78583bd963f02f2269baeef6d1.png&quot; data-rawwidth=&quot;755&quot; data-rawheight=&quot;491&quot;&gt;&lt;p&gt;简单起见，我们不需要关注Attributes的解析，因此可以直接跳到483行的ParseExternalDeclaration函数。&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;产生式：
external-declaration: [C99 6.9]
    function-definition
    declaration&lt;/code&gt;&lt;p&gt;此处会根据function-definition或者declaration的First集的不同之处做一些特殊情况优化。我们现在只考虑普遍情况，此时会调用ParseDeclarationOrFunctionDefinition(attrs)函数。&lt;/p&gt;&lt;img src=&quot;v2-a4dea387813e54c187abd7fdf23d7e3d.png&quot; data-rawwidth=&quot;738&quot; data-rawheight=&quot;190&quot;&gt;&lt;p&gt;然后调用如下函数，先初始化一个ParsingDeclSpec对象，用于解析公共的declaration-specifiers&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-bb2138967c8b23dd9be4cec9234eacce.png&quot; data-rawwidth=&quot;726&quot; data-rawheight=&quot;255&quot;&gt;C99的语法为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function-definition: [C99 6.9.1]
    decl-specs declarator declaration-list[opt] compound-statement

function-definition: [C99 6.7.1] - implicit int result
    decl-specs[opt] declarator declaration-list[opt] compound-statement
    declaration: [C99 6.7]
    declaration-specifiers init-declarator-list[opt] &#39;;&#39;
&lt;/code&gt;&lt;p&gt;首先会解析变量定义和函数定义公共的declaration-specifiers。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-7d4d9a410f149bd1dd1c6aaa68483a22.png&quot; data-rawwidth=&quot;818&quot; data-rawheight=&quot;68&quot;&gt;然后调用ParseDeclGroup函数解析declarator，在C99中，每个declarator都表示普通变量声明器，数组变量声明器，函数声明器，指针声明器等。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-c3302dc7079b11cbc1e4d087764e9866.png&quot; data-rawwidth=&quot;818&quot; data-rawheight=&quot;68&quot;&gt;&lt;img src=&quot;v2-b88c352606c9ece48894ba24598d00b0.png&quot; data-rawwidth=&quot;827&quot; data-rawheight=&quot;258&quot;&gt;当每个declarator都解析完了之后，需要对得到的declarator进行判断其为普通变量声明，函数声明，抑或是数组声明。&lt;/p&gt;&lt;p&gt;１．处理函数：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b5d946c8ee5fdc45878ea913b4967de6.png&quot; data-rawwidth=&quot;777&quot; data-rawheight=&quot;380&quot;&gt;２．解析变量&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-51993a48090839da494001056ce99603.png&quot; data-rawwidth=&quot;777&quot; data-rawheight=&quot;380&quot;&gt;此处的while循环用于解析单行声明多个变量的语法形式：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;declarator-inits::
    declarator-init, declarator-inits;

declarator-init::
    declarator [=initiation-list]opt;&lt;/code&gt;&lt;p&gt;&lt;img src=&quot;v2-ea7eb10009e60b12eee562c187b634cc.png&quot; data-rawwidth=&quot;638&quot; data-rawheight=&quot;170&quot;&gt;最后当一个external-declaration结束的时候，会调用语义动作Sema。&lt;/p&gt;&lt;img src=&quot;v2-60a1f2bd60c87c5cda24f40f3dd7b5c1.png&quot; data-rawwidth=&quot;638&quot; data-rawheight=&quot;97&quot;&gt;</description>
<author>XlousZeng</author>
<guid isPermaLink="false">23344499</guid>
<pubDate>Tue, 01 Nov 2016 13:47:08 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[科普] 一个演示简单编译器循环优化的例子</title>
<link>https://zhuanlan.zhihu.com/p/23326776</link>
<description>是标题党了啦。这是应对&lt;a href=&quot;https://www.zhihu.com/question/51592012&quot; data-editable=&quot;true&quot; data-title=&quot;VS为什么会生成这样的C++反汇编代码？ - 程序员&quot;&gt;VS为什么会生成这样的C++反汇编代码？ - 程序员&lt;/a&gt;问题而写个一个小例子。并没有啥高深新奇的知识，纯科普而已。&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;演示用的代码例子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;先来看用于演示的C代码例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;                     // (1)
  for (uint32_t i = lo; i &amp;lt; hi; i++) {  // (2)
    uint32_t y = 2 * i;                 // (3)
    if ((hi &amp;amp; 1) == 0) {                // (4)
      sum += i;                         // (5)
      gLastI = i;                       // (6)
    } else {
      sum += y;                         // (7)
    }
  }
  return sum;                           // (8)
}
&lt;/code&gt;&lt;p&gt;挺简单的函数。有啥好优化的呢？——对于不熟悉编译原理的同学来说，最可能让他们意外的可能就是优化后代码的顺序与原程序的巨大差异。&lt;/p&gt;&lt;p&gt;ICC 17在Linux/x86-64上在-O3优化级别会把这个例子优化为等价于下面的形式：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  if (lo &amp;lt; hi) {
    uint32_t n = hi - lo;
    if ((hi &amp;amp; 1) != 0) {
      for (uint32_t i = 0; i &amp;lt; n; i++) {
        sum += lo * 2; // folded into lea
        sum += i * 2;  // folded into lea
      }
    } else {
      uint32_t last_i;
      for (uint32_t i = 0; i &amp;lt; n; i++) {
        sum += lo;
        last_i = lo;
        lo++;
      }
      gLastI = last_i;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;p&gt;实际生成的汇编长这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;foo:
        mov       edx, esi                                      #5.35
        xor       eax, eax                                      #6.11
        cmp       edi, edx                                      #7.29
        jae       ..B1.9        # Prob 50%                      #7.29
        mov       esi, edx                                      #5.35
        mov       ecx, eax                                      #7.3
        sub       esi, edi                                      #5.35
        test      dl, 1                                         #9.15
        je        ..B1.7        # Prob 50%                      #9.21
..B1.4:                         # Preds ..B1.2 ..B1.4
        lea       eax, DWORD PTR [rax+rdi*2]                    #7.3
        lea       eax, DWORD PTR [rax+rcx*2]                    #8.17
        inc       ecx                                           #7.3
        cmp       ecx, esi                                      #7.3
        jb        ..B1.4        # Prob 82%                      #7.3
        jmp       ..B1.9        # Prob 100%                     #7.3
..B1.7:                         # Preds ..B1.2 ..B1.7
        inc       ecx                                           #7.3
        add       eax, edi                                      #10.7
        mov       edx, edi                                      #11.7
        inc       edi                                           #7.3
        cmp       ecx, esi                                      #7.3
        jb        ..B1.7        # Prob 82%                      #7.3
        mov       DWORD PTR gLastI[rip], edx                    #11.7
..B1.9:                         # Preds ..B1.4 ..B1.8 ..B1.1
        ret                                                     #16.10
&lt;/code&gt;&lt;p&gt;它为什么可以这样做？下面就让我简单民科科普一下。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;先放个传送门：&lt;a href=&quot;https://www.zhihu.com/question/23261395/answer/42426957&quot; data-editable=&quot;true&quot; data-title=&quot;编译器生成的汇编语句执行顺序为什么与C代码顺序不同？ - RednaxelaFX 的回答&quot;&gt;编译器生成的汇编语句执行顺序为什么与C代码顺序不同？ - RednaxelaFX 的回答&lt;/a&gt;。这个传送门里我的回答提到了编译器在优化代码的时候，只要保证最终的结果满足程序中各种依赖关系就可以了，而不必总是维持跟输入的源码相同的顺序（“program order”）。不过这个传送门中涉及的例子非常简单，只有纯直线代码，没有跳转 / 条件跳转，也没有对内存的读写，所以只要用“数据依赖”（data dependence）就足以讲解了。&lt;/p&gt;&lt;p&gt;而本文所用的例子则稍微复杂一点，可以涉及稍微多一些的优化的讲解。&lt;/p&gt;&lt;p&gt;首先在(2)开始有一个典型的for循环，在(4)有一个条件分支；这两个都是控制流操作，使这个例子涉及“控制依赖”（control dependence）。然后在(6)有一个对全局变量gLastI的写操作，这是一个内存写操作，使这个例子涉及“内存依赖”（memory dependence）——或者说正好演示了冗余写操作的情况。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;副作用？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对编译器中的优化器来说，所谓“副作用”就是在当前编译单元中无法做足够分析的运算结果。这跟上层的源语言中所说的“副作用”并不总是一回事。所以当看到对程序中的副作用的讨论时，要注意清楚讨论的上下文是什么，免得误解了对方的意思。&lt;/p&gt;&lt;p&gt;例如说，对编译器中端的优化器来说，C语言的一个标量类型的局部变量，如果它在整个函数中都没有被取过地址，那么所有对它自身的读写运算都可以认为是“无副作用”的。这是因为这些变量是活动记录（activation record，或者说栈帧）的一部分，而一个函数被调用一次的活动记录里的内容都是这次调用独享访问的，除非程序主动通过取局部变量地址的方式来暴露出机会让别的代码能操作这些局部变量。这样编译器的优化器就可以对其做足够分析，将它们涉及的副作用都分析出来，并转换为没有副作用的形式。&lt;/p&gt;&lt;p&gt;而对原本的C语言来说，一般会把对局部变量的赋值（写）运算叫做“有副作用”的。&lt;/p&gt;&lt;p&gt;这个差异主要是来自编译器各部分的分工，以及优化器对程序的分析能力。&lt;/p&gt;&lt;p&gt;回顾一下一个典型的带优化的编译器的工作流程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    源代码
-&amp;gt; [ 词法分析 ]
-&amp;gt;  单词流
-&amp;gt; [ 语法分析 ]
-&amp;gt;  语法树 / 抽象语法树           编译器前端
-&amp;gt; [ 语义分析 ]
-&amp;gt;  带标注的语法树
-&amp;gt; [ 中间代码生成 ]
-&amp;gt;  中间代码              -------------------------
-&amp;gt; [ 平台无关优化 ]
-&amp;gt;  优化的中间代码                编译器中端
-&amp;gt; [ 平台相关lowering ]
-&amp;gt;  平台相关中间代码       --------------------------
-&amp;gt; [ 平台相关优化 ]
-&amp;gt;  优化的平台相关中间代码         编译器后端
-&amp;gt; [ 代码生成 ]
-&amp;gt; 目标代码&lt;/code&gt;&lt;p&gt;在这个流程中，编译器前端更关心源语言的语义，后端更关心目标平台的特性，而位于中间的中端则主要关心相对不那么语言相关、也不那么平台相关的优化。&lt;/p&gt;&lt;p&gt;当我们讨论源语言层面上的“副作用”，编译器前端的“语义分析”部分是必须要能正确理解这些副作用的含义（并在副作用不合理时给出警告）。然后在“中间代码生成”的部分，这些“副作用”会在中间表示中用更显式的方式表现出来，于是到编译器中端拿到中间表示的时候，就不用关心这些源语言层面的副作用了。&lt;/p&gt;&lt;p&gt;例如说，一个经典的不好的C代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo() {
  int i = 0;
  int j = i + i++;
  return j;
}&lt;/code&gt;&lt;p&gt;在 i + i++ 的地方有一个纯粹的对局部变量i的读操作，以及一个带有副作用（自增）的对局部变量i的读写操作，而这两个操作之间没有sequence point所以它们俩的求值顺序是未定义的。&lt;/p&gt;&lt;p&gt;在Clang中，语义分析的部分会对这个情况给出警告：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;foo.c:3:16: warning: unsequenced modification and access to &#39;i&#39; [-Wunsequenced]
  int j = i + i++;
          ~    ^
&lt;/code&gt;&lt;p&gt;然后Clang在生成中间代码（LLVM IR）时，会根据自己的理解选择一种求值顺序——后做i++，生成出每个操作都简单明确的中间代码，然后编译器中端（LLVM）在拿到LLVM IR之后就能根据代码的顺序准确地理解前端所做的选择：&lt;/p&gt;&lt;code lang=&quot;llvm&quot;&gt;; Function Attrs: nounwind
define i32 @foo() #0 {
  %i = alloca i32, align 4           ; int i
  %j = alloca i32, align 4           ; int j
  store i32 0, i32* %i, align 4      ; i = 0
  %3 = load i32, i32* %i, align 4    ; tmp3 = i
  %4 = load i32, i32* %i, align 4    ; tmp4 = i
  %5 = add nsw i32 %4, 1             ; tmp5 = tmp4 + 1
  store i32 %5, i32* %i, align 4     ; i = tmp5
  %6 = add nsw i32 %3, %4            ; tmp6 = tmp3 + tmp4
  store i32 %6, i32* %j, align 4     ; j = tmp6
  %7 = load i32, i32* %j, align 4    ; tmp7 = j
  ret i32 %7                         ; return tmp7
}
&lt;/code&gt;&lt;p&gt;也就是Clang选择拆解副作用的方式，对应这样的C代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo() {
  int i = 0;
  int j = i + i;
  i = i + 1;     // side-effect of i++
  return j;
}&lt;/code&gt;&lt;p&gt;可以看到这里生成的LLVM IR还是“有副作用”的——那3条store指令就是“副作用”。但是LLVM可以对所有没有被取地址的标量类型的局部变量都可以做完全的分析——可以找到所有对这些局部变量的读写操作并分析其中的副作用的效果——然后将IR转换到对这些局部变量来说没有副作用的形式。&lt;br&gt;&lt;/p&gt;&lt;p&gt;例如说对上述LLVM IR跑一次mem2reg pass（或者包含mem2reg的sroa pass），会得到：&lt;/p&gt;&lt;code lang=&quot;llvm&quot;&gt;; Function Attrs: nounwind
define i32 @foo() #0 {
  %1 = add nsw i32 0, 1              ; tmp1 = 0 + 1
  %2 = add nsw i32 0, 0              ; tmp2 = 0 + 0
  ret i32 %2                         ; return tmp2
}
&lt;/code&gt;&lt;p&gt;这里就没有任何副作用了，只有对局部值的简单运算。进一步做常量折叠和无用代码消除之后，就只剩下：&lt;/p&gt;&lt;code lang=&quot;llvm&quot;&gt;; Function Attrs: nounwind
define i32 @foo() #0 {
  ret i32 0                          ; return 0
}
&lt;/code&gt;&lt;p&gt;了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;同一个例子用GCC 4.9.2来看编译器前端的理解（生成的GIMPLE）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;foo ()
{
  int i.0;
  int D.1748;
  int i;
  int j;

  i = 0;
  i.0 = i;
  i = i.0 + 1;      // side-effect of i++
  j = i.0 + i;
  D.1748 = j;
  return D.1748;
}
&lt;/code&gt;&lt;p&gt;这GCC选择的求值顺序就跟Clang正好相反，先做了i++。&lt;/p&gt;&lt;p&gt;然后中端在分析完局部变量涉及的副作用之后，所生成的无副作用的中间代码（Tree SSA形式的GIMPLE）：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;foo ()
{
  int j;
  int i;
  int D.1748;
  int i.0;
  int i.0_2;
  int _5;

  &amp;lt;bb 2&amp;gt;:
  i_1 = 0;
  i.0_2 = i_1;
  i_3 = i.0_2 + 1;
  j_4 = i.0_2 + i_3;
  _5 = j_4;

&amp;lt;L0&amp;gt;:
  return _5;
}
&lt;/code&gt;&lt;p&gt;每个局部变量最多被赋值一次，从赋值到使用直接不用考虑别的副作用影响该变量的值，所以说“没有副作用”。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;副作用与控制依赖&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;先说结论：没有副作用的运算可以无视控制依赖，只要满足数据依赖即可执行。&lt;/p&gt;&lt;p&gt;什么是控制依赖？控制依赖是说，某个运算Y的执行与否，依赖于某个带有控制流语义的运算X的结果。&lt;/p&gt;&lt;p&gt;例如说，&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int x = 0;
  if (cond) {
    x = a + c;
  }
  return x;
}&lt;/code&gt;&lt;p&gt;这个例子里，&quot;x = a + c&quot;就控制依赖于&quot;if (cond)&quot;的运算结果，只有当cond为真值的时候，x = a + c才执行。&lt;/p&gt;&lt;p&gt;但是&quot;a + c&quot;是一个没有副作用的运算，它其实放在foo()中的什么位置执行都可以——只要它所依赖的数据输入a和c都已经求好值了即可——而不必依赖于&quot;if (cond)&quot;的结果。这跟本文开头提到的传送门里“数据依赖”的例子一样。&lt;/p&gt;&lt;p&gt;所以把上述代码的a + c提取到if外面，转换成下面这样也是一样的：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int x = 0;
  int tmp = a + c;
  if (cond) {
    x = tmp;
  }
  return x;
}
&lt;/code&gt;&lt;p&gt;又或者再向前挪一点：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int tmp = a + c;
  int x = 0;
  if (cond) {
    x = tmp;
  }
  return x;
}
&lt;/code&gt;&lt;p&gt;也可以。&lt;/p&gt;&lt;p&gt;那么&quot;x = &quot;的部分呢？这个赋值会根据&quot;if (cond)&quot;的结果而影响局部变量x的值，所以要先看作有控制依赖的有副作用的操作，分析清楚之后再转换到无副作用的形式。&lt;/p&gt;&lt;p&gt;但是所谓“无副作用”的形式要如何表达一个变量可能经由不同的分支执行后得到不同的值呢？一种办法是SSA形式的“phi”伪函数。让我们把这个例子转成SSA形式来看：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int x0 = 0;
  if (cond) goto condtrue; else goto condfalse;

condtrue:
  int x1 = a + c;
  goto aftercond;

condfalse:
  goto aftercond;

aftercond:
  int x2 = phi(condfalse x0, condtrue x1);
  return x2;
}
&lt;/code&gt;&lt;p&gt;这个“phi”伪函数会显式指明“如果控制来自某个分支，则选用某个值”。这就把副作用与控制依赖显式结合在一起表达出来了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;回到本文开头的例子，位于(3)的&quot;2 * i&quot;是一个无副作用的运算，所以它的运算位置可以被移动。例如说它可以被向下移动（sink），到真正使用它的地方，变成：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  for (uint32_t i = lo; i &amp;lt; hi; i++) {
    if ((hi &amp;amp; 1) == 0) {
      sum += i;
      gLastI = i;
    } else {
      uint32_t y = 2 * i;
      sum += y;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;循环不变量与循环不变量外提（LICM）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;就跟上一节提到的思路一样，如果通过分析可以发现在循环中有运算的值不受循环的影响，那么就可以把它提升到循环的外面。这种优化叫做循环不变量外提（LICM，loop-invariant code motion）。&lt;/p&gt;&lt;p&gt;以本文开头的例子来说，通过分析可以发现从(2)开始的for循环，在循环体中没有对变量hi赋过值，所以hi的值在循环内不会改变。递推出去，hi &amp;amp; 1 是一个无副作用的运算，它的值在循环中也不会改变。同理 (hi &amp;amp; 1) == 0 的值在循环中也不会改变。&lt;/p&gt;&lt;p&gt;所以这个例子就可以把(4)的条件运算提取到循环外面，变成（在上一节的基础上）:&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  _Bool tmpcond = (hi &amp;amp; 1) == 0;
  for (uint32_t i = lo; i &amp;lt; hi; i++) {
    if (tmpcond) {
      sum += i;
      gLastI = i;
    } else {
      uint32_t y = 2 * i;
      sum += y;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;循环判断外提（loop unswitching）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作为LICM的一种扩展，如果我们发现循环里有条件是对循环不变量来做判断的，那么就可以选择把这个判断提升到循环的外面 ，并且把原循环拆分为两个特化的版本，分别对应条件为真以及为假的情况。&lt;/p&gt;&lt;p&gt;这样每个版本的循环都会比原本的更简单，而假定循环是耗时的操作，是我们要有针对性优化的目标，把循环拆分成特化的版本后就可以减小循环的开销。&lt;/p&gt;&lt;p&gt;还是回到本文开头的例子，在上一节版本的基础上，可以进一步变换为：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  if ((hi &amp;amp; 1) == 0) {
    for (uint32_t i = lo; i &amp;lt; hi; i++) {
      sum += i;
      gLastI = i;
    }
  } else {
    for (uint32_t i = lo; i &amp;lt; hi; i++) {
      uint32_t y = 2 * i;
      sum += y;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;p&gt;跟开头演示的优化后的结果是不是越来越相似了？&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;内存写的下沉（store sinking）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;嗯这个读起来有点怪。简单来说就是如果有连续多次对同一个位置的内存写操作，那么只有最后一个才是有意义的，前面那些只要没被用到都是无意义的，可以消除。所以这种优化也叫做“冗余内存写消除”（redundant store elimination）。&lt;/p&gt;&lt;p&gt;应用到循环中，如果我们在循环体中不断对某个位于内存中的变量做赋值，但却没有在循环中使用过这个赋值的结果，那么这个赋值就没有意义，可以被消除。&lt;/p&gt;&lt;p&gt;例如说：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  for (int i = 0; i &amp;lt; 3; i++) {
    globalVariable = i;
  }&lt;/code&gt;&lt;p&gt;全局变量globalVariable的实体必须要被分配在内存中，所以对它的赋值是一个内存写操作（memory store）。如果我们分析一下循环的执行过程 ，就会发现这个例子实际上会执行3次对globalVariable的赋值：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;globalVariable = 0&lt;br&gt;&lt;/li&gt;&lt;li&gt;globalVariable = 1&lt;br&gt;&lt;/li&gt;&lt;li&gt;globalVariable = 2&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但在这个循环中其实并没有用到这些赋值的结果，而在循环结束时需要给外界留下的副作用只需要是globalVariable = 2。所以我们可以把这个内存写操作“下沉”（sink）到循环的后面去，变成：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  for (int i = 0; i &amp;lt; 3; i++) {
    /* empty loop body */
  }
  globalVariable = 2; // constant-folded condition: if (0 &amp;lt; 3)&lt;/code&gt;&lt;p&gt;或者稍微没那么优化的版本：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  int i;
  for (i = 0; i &amp;lt; 3; i++) {
    /* empty loop body */
  }
  globalVariable = i - 1; // constant-folded condition: if (0 &amp;lt; 3)
&lt;/code&gt;&lt;p&gt;但要注意的是：一个for循环其实是有可能一次也不执行的，所以在循环体里的赋值如果被下沉到循环后面的话，要保证该循环至少执行过一次才正确。&lt;/p&gt;&lt;br&gt;&lt;p&gt;回到本文开头的例子，在上一节版本的基础上，把(6)对全局变量gLastI的赋值下沉到循环后面，可以变换成：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  if (lo &amp;lt; hi) {
    if ((hi &amp;amp; 1) == 0) {
      for (uint32_t i = lo; i &amp;lt; hi; i++) {
        sum += i;
      }
      gLastI = hi - 1;
    } else {
      for (uint32_t i = lo; i &amp;lt; hi; i++) {
        uint32_t y = 2 * i;
        sum += y;
      }
    }
  }
  return sum;
}
&lt;/code&gt;&lt;p&gt;具体到ICC所选用的优化形式，它没能彻底优化掉循环中的运算，不过至少在循环中用一个局部变量来替代了全局变量作为赋值的目标，然后在循环之后才做最终的内存写操作：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;      uint32_t last_i;
      for (uint32_t i = lo; i &amp;lt; hi; i++) {
        sum += i;
        last_i = i;
      }
      gLastI = last_i;
&lt;/code&gt;&lt;p&gt;这仍然算是store sinking——局部变量可以被分配到寄存器里，对局部变量的赋值就不会内存写了，所以还是比对全局变量的赋值更快。&lt;/p&gt;&lt;p&gt;经过store sinking优化后，代码的形式已经跟ICC优化的结果非常相似了。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;循环归纳变量优化（loop induction variable optimizations）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文开头所给出的ICC优化后的版本，剩下的一些优化是跟循环归纳变量相关的。所谓“循环归纳变量”，就是值与循环轮次成线性关系的变量。&lt;/p&gt;&lt;p&gt;例如说最典型的for循环：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  for (int i = 0; i &amp;lt; max; i++) {
    int x = arr[i + 2];
    /* ... */
  }&lt;/code&gt;&lt;p&gt;局部变量i就是一个循环归纳变量，它的值跟循环轮次正好相等。我们可以分析出这个变量i的性质为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;init = 0&lt;/li&gt;&lt;li&gt;limit = max&lt;/li&gt;&lt;li&gt;cmp = &amp;lt;&lt;/li&gt;&lt;li&gt;step = 1&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而表达式 i + 2 的值也是跟循环轮次成线性关系的，关系为 1 * i + 2。于是这个表达式的性质就可以从变量i推算出来。&lt;/p&gt;&lt;p&gt;GCC与Clang对循环归纳变量的分析与优化叫做“&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gccint/Scalar-evolutions.html&quot; data-editable=&quot;true&quot; data-title=&quot;Scalar evolutions&quot;&gt;Scalar evolutions&lt;/a&gt;”（简称SCEV）。&lt;/p&gt;&lt;p&gt;这边就不专门说明ICC是如何通过循环归纳变量分析来把本文开头的例子从上一节的版本优化到最终版本了。同学们有兴趣的话可以自己动手推推看 ^_^&lt;/p&gt;&lt;p&gt;事实上，既然这是一个等差数列求和的例子，比例子中ICC编译结果更简短的形式应该是这样的：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  if (lo &amp;lt; hi) {
    uint32_t n = hi - lo;
    if ((hi &amp;amp; 1) == 0) {
      gLastI = hi - 1;
      return (lo &amp;amp; 1) == 0 ? (n &amp;gt;&amp;gt; 1) * (lo + hi - 1)
                           : ((lo + hi - 1) &amp;gt;&amp;gt; 1) * n;
    } else {
      return (lo + hi - 1) * n;
    }
  } else {
    return 0;
  }
}
&lt;/code&gt;&lt;p&gt;直接连循环都不要了。这个形式是否比ICC的编译结果更优化还是得看情况。应用怎样的编译分析与优化能得到这个形式，就留作课后习题吧。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;把非常量的循环加法变换为非循环的乘法形式是实际编译器实现中比较少见的做法。更常见的反过来的优化：“强度削减”（strength reduction），把本来是乘法的运算变成加法，之类。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;这次就先科普到这里。欢迎对本文的科普和分析拾遗补阙 ^_^&lt;/p&gt;&lt;p&gt;注：GCC与Clang与本文开头的例子编译出来的结果比ICC的更复杂一些，相关分析也留作课后作业啦。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23326776</guid>
<pubDate>Tue, 01 Nov 2016 08:17:35 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>观察ChakraCore JIT生成的native code</title>
<link>https://zhuanlan.zhihu.com/p/23314157</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20792855&quot; data-editable=&quot;true&quot; data-title=&quot;前面&quot;&gt;前面&lt;/a&gt;介绍了ChakraCore的各个dump开关，可以用来查看编译的中间阶段的结果。这里介绍一下一个简单的JavaScript函数被编译成的native code像什么样子。&lt;/p&gt;&lt;p&gt;为了查看JIT code，一个办法是使用之前介绍的 -dump 开关查看encode阶段的结果（-dump:encoder）。另外ChakraCore支持一个选项是 -DebugBreak:FunctionNumber。FunctionNumber可以通过查看其它dump获得，比如 -dump:irbuilder，在JavaScript源文件没改变的话，即使是多次运行同一个函数的FunctionNumber也是不变的。-DebugBreak会导致encode阶段在函数入口插入一条断点指令（默默给encoder点个赞），比如x86和x64下的“int 3”，这样运行到该方法就会自然中断到调试器。&lt;/p&gt;&lt;p&gt;代查看的JavaScript源代码如下，要看的是其中 &lt;b&gt;access()&lt;/b&gt; 的JIT code。 &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// ch.exe -mic:1 -off:simplejit -DebugBreak:3
function Point(x, y) {
    this.x = x;
    this.y = y;
}

function access(pt) {
    return pt.x;
}

var pt = new Point(1, 2);
access(pt);
access(pt);&lt;/code&gt;&lt;p&gt;以x64为例，以下是JIT给上面 &lt;b&gt;access()&lt;/b&gt; 生成native code的CFG（Control Flow Graph）, 因为比较大，分成2部分介绍。这个CFG是从WinDbg里面反汇编的代码生成的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn966108.aspx&quot; data-editable=&quot;true&quot; data-title=&quot;DGML&quot;&gt;DGML&lt;/a&gt;，能在Visual Studio中直接查看。下图中每一个节点代表了一个basic block, 黑色实箭头是fallthough到下一个follower block, 红色的虚线箭头表示一个跳转（包括条件跳转和无条件跳转）。最上面的绿色节点代表函数入口而最下面的黄色节点是函数的退出block（含有 ret 指令）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-aa2219e7fd629d34c5aed9a4a0c0d102.png&quot; data-rawheight=&quot;840&quot; data-rawwidth=&quot;1057&quot;&gt;Control Flow Graph - part 1&lt;/p&gt;&lt;img src=&quot;v2-08ee1601080e718807bb1d83dd871031.png&quot; data-rawheight=&quot;706&quot; data-rawwidth=&quot;1696&quot;&gt;&lt;p&gt;Control Flow graph - part 2 （注意顶上两条入边与part 1的底部相连）&lt;/p&gt;&lt;ol&gt;&lt;li&gt;函数入口。1，2，3属于stack probe (对栈顶位置做一些基本检查，实现在 &lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/release/1.3/lib/Backend/amd64/LowererMDArch.cpp#L1630&quot; data-editable=&quot;true&quot; data-title=&quot;LowererMDArch::GeneratePrologueStackProbe&quot;&gt;LowererMDArch::GeneratePrologueStackProbe&lt;/a&gt; ）。检查StackLimit+FrameSize是否溢出，如溢出则跳至3做stack probe。&lt;/li&gt;&lt;li&gt;检查栈顶（RSP）有没有超出StackLimit，超过了则需进入3做stack probe。 &lt;br&gt;&lt;/li&gt;&lt;li&gt;检查栈空间，如还有stack space则扩展StackLimit，否则抛出stack overflow（见&lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/Base/ThreadContext.cpp#L1700&quot; data-editable=&quot;true&quot; data-title=&quot;ThreadContext::ProbeStackNoDispose&quot;&gt;ThreadContext::ProbeStackNoDispose&lt;/a&gt;）。&lt;/li&gt;&lt;li&gt;把寄存器参数放进&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ew5tede7.aspx&quot; data-editable=&quot;true&quot; data-title=&quot;home space&quot;&gt;home space&lt;/a&gt;，加载后面需要用到的常量，检查函数执行计数器（FunctionEntryPointInfo里面&lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/release/1.3/lib/Runtime/Base/FunctionBody.h#L988&quot; data-editable=&quot;true&quot; data-title=&quot;callsCount&quot;&gt;callsCount&lt;/a&gt;）是否超过255，没有则进入5将计数器加1。另外注意到打头的两条nop指令，是为了随机化JIT生成的native code。&lt;/li&gt;&lt;li&gt;把函数计数器加1。&lt;/li&gt;&lt;li&gt;检查传入参数个数。由于this引用被隐式传入，所以参数个数是实参个数+1。这里使用了AND指令是由于这里的参数个数存在了32-bit的低24-bit，高8位作为flag。&lt;/li&gt;&lt;li&gt;如果没有传入参数（除了this），则把undefined放入rcx寄存器。&lt;/li&gt;&lt;li&gt;把第一个参数放入rcx寄存器。&lt;/li&gt;&lt;li&gt;判断上面存入rcx的是否是对象指针。ChakraCore使用了float tagging，打上tag的值的第48-bit为0则其内容为指针，否则为其他值，如double, int。&lt;/li&gt;&lt;li&gt;已经判定第一个参数（RCX）位对象指针。ChakraCore里面对应JavaScript的Object对象的是DynamicObject，其偏移8的位置（如下图）存储了Js::Type对象的指针。这里的Type对象类似于v8的hidden class。在JIT编译的时候已经有profile信息。这里rax指向的类型对象的地址作为常量存在JIT生成的代码里就是从profile推导出来的。&lt;/li&gt;&lt;li&gt;判断当前的inline cache里面的类型是否匹配。第10步里检查的类型已经是常量，意味着传入任何其他类型的对象检查都会失败，如果直接退回（BailOut）interpreter，再重新JIT代价还是很大的。其实只要传入的参数的对象类型保持基本稳定，JIT生成的大部分代码还是有效，而不需要类型和最初JIT时profile里的类型一致。所以有了了inline cache（前面的常量也可以说是一种inline cache）。简单来看，它对应一个callsite，保存了访问的类型对象的地址和要访问的属性偏移，如果当前对象类型和inline cache里的一致的话，则使用inline cache里的偏移访问属性（进入第17步）。&lt;/li&gt;&lt;li&gt;从对象地址给定的偏移（0x10）获取属性，存入rbx。&lt;/li&gt;&lt;li&gt;JIT假定的类型和inline cache里面的类型都不匹配，调用&lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/Language/JavascriptOperators.cpp#L7180&quot; data-editable=&quot;true&quot; data-title=&quot;PatchGetValue&quot;&gt;PatchGetValue&lt;/a&gt;, 从本对象以及原型链里查找属性，根据查找的结果更新inline cache（PatchGetValue里面的Patch就是patch这个）。&lt;/li&gt;&lt;li&gt;把取得的属性从rbx复制到rax。&lt;/li&gt;&lt;li&gt;在第9步获取的不是对象指针的情况下（比如传入了一个数值而不是对象），bailout回interpreter执行，重新获取profile。&lt;/li&gt;&lt;li&gt;返回。&lt;/li&gt;&lt;li&gt;从inline cache里面获取属性偏移，取得属性值。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;以上就是一个最简单的方法JIT后的native code的简单描述，其中有些步骤还比较复杂 ，以后再专门展开。&lt;/p&gt;</description>
<author>Thomson</author>
<guid isPermaLink="false">23314157</guid>
<pubDate>Mon, 31 Oct 2016 12:39:32 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Java] 动态生成类的场景的考察</title>
<link>https://zhuanlan.zhihu.com/p/23297569</link>
<description>开个坑慢慢填哈。&lt;p&gt;============================================&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Oracle/Sun JDK / OpenJDK的Java SE中的场景&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;在Oracle/Sun JDK及OpenJDK内，动态生成类（字节码）的场景有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java 1.4之后的反射实现。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/548536&quot; data-editable=&quot;true&quot; data-title=&quot;关于反射调用方法的一个log&quot;&gt;关于反射调用方法的一个log&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Java 1.3开始&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html&quot; data-editable=&quot;true&quot; data-title=&quot;Proxy (Java Platform SE 8 )&quot; class=&quot;&quot;&gt;java.lang.reflect.Proxy&lt;/a&gt;的实现，会动态根据给定的接口和handler来生成类&lt;/li&gt;&lt;li&gt;Java 5开始的annotation，其背后的类也是动态生成的Proxy。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/1148983&quot; data-editable=&quot;true&quot; data-title=&quot;Java annotation的实例是什么类的？&quot;&gt;Java annotation的实例是什么类的？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Java 7开始的JSR 292实现的MethodHandle / LambdaForm到Java字节码的编译&lt;/li&gt;&lt;li&gt;Java 8开始的Nashorn将JavaScript编译为Java字节码&lt;/li&gt;&lt;li&gt;Java 8开始的Nashorn里的joni正则表达式库，将正则表达式编译到Java字节码&lt;/li&gt;&lt;li&gt;Java 8开始的默认的Java lambda表达式背后的字节码生成，相当于自动生成了跟手写的匿名内部类相似的东西。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/51491241/answer/126232275&quot; data-editable=&quot;true&quot; data-title=&quot;Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX 的回答&quot;&gt;Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX 的回答&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Java 9开始的indify string concatenation，对使用Java中“+”运算符来拼接字符串的表达式做动态字节码生成。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/280&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 280: Indify String Concatenation&quot;&gt;JEP 280: Indify String Concatenation&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;其中MethodHandle的LambdaForm实现与Nashorn都是比较新的实现，它们里面有些思路是相当有趣的。回头再展开来说。例如它们会为了有效地存储数据而根据需要的数据类型/结构来生成存储数据的对象。例如说Nashorn里实现可以存8个字段的JavaScript对象的背后的Java类，是一个叫做“JO8”的类，而这个类就是根据需要动态生成出来的。同理，MethodHandle中有一系列叫做“BoundMethodHandle”的东西，可以捕获参数的值（读作“currying”），其存储参数的类也是动态生成出来的，例如说Species_LII表示能按顺序保存1个引用类型、2个int类型字段的类。&lt;/p&gt;&lt;p&gt;Java 7新加入的invokedynamic指令现在被广泛应用于“compact encoding of boilerplate code”（我得想想怎么组织语言来用中文说…）。上面提到的Java lambda表达式、indify string concat都是这样的例子。&lt;/p&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;其它场景&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;在需要动态访问Java对象属性但又需要规避反射开销的地方，动态字节码生成也是很常见的。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;在JVM上实现的动态语言，要性能好的话，生成Java字节码也是必经之路。有些语言可以静态编译出Java Class（例如Groovy），而更多还是在运行时生成Class（有些可能可以缓存生成的Class）。除了前面提到的Nashorn外，动态生成字节码的还例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;JRuby&lt;/li&gt;&lt;li&gt;Jython&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;比完整的编程语言更轻量级的“表达式语言”（expression language）也很流行用动态字节码生成。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;MVEL&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;有些本来是可以静态编译的、在JVM上实现的语言，为了减小发布的JAR包大小，也有可能会选择用动态类生成来仅在运行时需要某些类的时候才将它们生成出来。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Scala&lt;/li&gt;&lt;li&gt;Fortress&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;有些模版引擎为了提升渲染速度，也会选择做字节码生成。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;各种JSP实现。例如Tomcat会把JSP先生成为Java源码，然后用Eclipse JDT（或者叫ECJ）将其编译到Java字节码。&lt;/li&gt;&lt;li&gt;淘宝以前尝试过将原本是在AST上解释执行来实现渲染的Velocity模版引擎，改造为将Velocity模版编译为等价的Java源码然后再编译到Java字节码的编译版。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;在动态做bytecode instrumentation的地方（或者说Java类的redefine / retransform）的地方，显然也会用到动态字节码生成。例如说：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;BTrace&lt;/li&gt;&lt;li&gt;某些AOP实现&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;有些测试框架会做mock，这些mock类也常常是通过proxy来实现的，所以也会用到上述场景中的其中一些（例如JDK自带的Proxy类）。&lt;/p&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;p&gt;说到动态字节码生成，顺带考察一下一些常用的工具 / 库吧。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://asm.ow2.org/&quot; data-editable=&quot;true&quot; data-title=&quot;ASM&quot;&gt;ASM&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://bytebuddy.net/&quot; data-editable=&quot;true&quot; data-title=&quot;Byte Buddy&quot;&gt;Byte Buddy&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jboss-javassist.github.io/javassist/&quot; data-editable=&quot;true&quot; data-title=&quot;Javassist&quot;&gt;Javassist&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/cglib/cglib&quot; data-editable=&quot;true&quot; data-title=&quot;cglib&quot;&gt;cglib&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://commons.apache.org/proper/commons-bcel/&quot; data-editable=&quot;true&quot; data-title=&quot;BCEL&quot;&gt;BCEL&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;其它：&lt;a href=&quot;https://java-source.net/open-source/bytecode-libraries&quot; data-editable=&quot;true&quot; data-title=&quot;Open Source ByteCode Libraries in Java&quot;&gt;Open Source ByteCode Libraries in Java&lt;/a&gt;&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;还有啥有趣的大类别这里遗漏了的，或者是每个大类别下有哪些您觉得有趣的例子的，欢迎在评论中补充 ^_^ 我也会慢慢补充上我知道的一些，并且对某些点稍微展开来说说动态生成了怎样的类。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23297569</guid>
<pubDate>Sun, 30 Oct 2016 02:26:39 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Oracle开源了其Java AOT编译器</title>
<link>https://zhuanlan.zhihu.com/p/23247204</link>
<description>先放传送门：&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/hotspot-dev/2016-October/025033.html&quot; data-editable=&quot;true&quot; data-title=&quot;[9] RFR(L) 8166415: Integrate AOT tool JAOTC&quot; class=&quot;&quot;&gt;[9] RFR(L) 8166415: Integrate AOT tool JAOTC&lt;/a&gt;&lt;p&gt;这是一个基于Graal的AOT编译器，可以跟JDK9+的HotSpot VM搭配使用。这跟.NET的CLR一早就有的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6t9t5wcf.aspx&quot;&gt;NGen&lt;/a&gt;是同类，而跟&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn600165(v=vs.110).aspx&quot;&gt;.NET Native&lt;/a&gt; / &lt;a href=&quot;https://github.com/dotnet/corert&quot;&gt;CoreRT&lt;/a&gt;、&lt;a href=&quot;https://www.excelsiorjet.com/&quot;&gt;Excelsior JET&lt;/a&gt;之类并非同类。&lt;/p&gt;&lt;p&gt;这比我原本预期的要早得多。我原本以为会到明年甚至更之后才能看到这个项目开源出来。真是惊喜。&lt;/p&gt;&lt;p&gt;以后大家再也不能吐槽Java的默认实现没有AOT编译器了。只能吐槽这个AOT编译器如何不好用/不够用了（逃&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23247204</guid>
<pubDate>Thu, 27 Oct 2016 16:58:33 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[C++] GCC对C++虚函数调用的一个优化</title>
<link>https://zhuanlan.zhihu.com/p/23233548</link>
<description>这个专栏平时Java / JVM的内容偏多，今天混入一些新血液吧。来聊点C++的话题。&lt;p&gt;不过说起来还是跟JVM相关的内容。在JVM实现中，要达到高性能的一个重要方面就是要对虚方法调用做优化，要尽其所能将虚方法调用点去虚化（devirtualize），以便支持后续的优化。这是因为Java里非private的成员方法默认就是virtual的，大家愿意也好不愿意也好也很容易会写一大堆虚方法，再加上良好的面向对象风格的代码提倡要尽量写职责单一的小方法，一大堆小的虚方法如果不能好好优化，那性能是上不去的。&lt;/p&gt;&lt;p&gt;而在C++里，虚函数的开销则没Java那么引人关注，毕竟成员函数默认不是virtual的，而且还有&lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot; data-editable=&quot;true&quot; data-title=&quot;CRTP&quot;&gt;CRTP&lt;/a&gt;之类的奇技淫巧来向别的方向取舍开销。但始终，对虚函数有优化需求这点跟Java还是很相似的。&lt;/p&gt;&lt;p&gt;很多同学都会在学习了一些C++的基础知识之后就偏执地认为C++的虚函数分派总是通过对vtable（虚函数表）的间接调用来做的，并且虚函数调用无法被内联。事实上编译器优化发展了那么多年，这种事情又怎会没有进一步的优化呢。&lt;/p&gt;&lt;p&gt;今天要说的就是相对新一些的GCC（&lt;a href=&quot;https://gcc.gnu.org/gcc-4.9/changes.html&quot; data-editable=&quot;true&quot; data-title=&quot;GCC 4.9&quot;&gt;GCC 4.9&lt;/a&gt;或更高）里的一种优化，由-fdevirtualize-speculatively参数控制的“speculative devirtualization”，或者用JVM里更常用的叫法是“guarded devirtualization”。这个优化是Jan Hubicka大大在2013年添加到GCC中的：&lt;a href=&quot;https://gcc.gnu.org/ml/gcc-patches/2013-08/msg00551.html&quot; data-editable=&quot;true&quot; data-title=&quot;Speculative call support in the callgraph&quot;&gt;Speculative call support in the callgraph&lt;/a&gt;。正好这几天在调试我们的JVM的一个core dump，留意到我们的JVM的C++代码里有虚函数调用点被GCC应用上了这个优化，就顺手来写写。&lt;/p&gt;&lt;p&gt;让我们先来看个例子：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class Base {
  int value_;
public:
  virtual int foo() __attribute__ ((noinline)) {
    return 42 + this-&amp;gt;bar();
  }

  virtual int bar() {
    return value_;
  }
};

class Derived : public Base {
public:
  int bar() {
    return 256;
  }
};

int main() {
  Base* b = new Derived;
  return b-&amp;gt;foo();
}
&lt;/code&gt;&lt;p&gt;这个例子用GCC 4.9.2在-O2下编译，会发现Base::foo()里对bar()这个虚函数的调用就是普通的通过vtable分派的间接调用。用伪代码来说就是这样：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;// this-&amp;gt;bar()
bar_ptr = this-&amp;gt;_vptr[BAR_VTABLE_INDEX]; // load function entry point from vtable
tmp = bar_ptr();                         // indirect call&lt;/code&gt;&lt;p&gt;实际用GCC 4.9.2 -O2在Linux/x86-64上生成的Base::foo()函数的代码是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Base::foo():
        subq    $8, %rsp
        movq    (%rdi), %rax  # rax = this-&amp;gt;_vptr
        call    *8(%rax)      # call this-&amp;gt;_vptr[BAR_VTABLE_INDEX]
        addq    $8, %rsp
        addl    $42, %eax
        ret
&lt;/code&gt;&lt;p&gt;但是如果我们把上面代码例子中Derived::bar()的声明去掉，使得Derived类变成：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class Derived : public Base {
};&lt;/code&gt;&lt;p&gt;再重新编译这个实验代码，就会发现Base::foo()里对bar()的调用变成了这个样子：（继续伪代码）&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;// this-&amp;gt;bar()
bar_ptr = this-&amp;gt;_vptr[BAR_VTABLE_INDEX]; // load function entry point from vtable
if (bar_ptr == Base::bar) {
  // inlined Base::bar()
  tmp = this-&amp;gt;value_;
} else {
  tmp = bar_ptr();                       // normal indirect virtual call
}&lt;/code&gt;&lt;p&gt;实际用GCC 4.9.2 -O2在Linux/x86-64上生成的新版本Base::foo()函数的代码是这样的：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Base::foo():
        movq    (%rdi), %rax
        movq    8(%rax), %rax
        cmpq    Base::bar(), %rax
        jne     .L3
        movl    8(%rdi), %eax
        addl    $42, %eax
        ret
.L3:
        subq    $8, %rsp
        call    *%rax
        addq    $8, %rsp
        addl    $42, %eax
        ret
&lt;/code&gt;&lt;p&gt;这种先做条件检查，然后在检查通过的分支里把虚函数调用变为非虚调用（进而可以被内联）的做法，就叫做“speculative devirtualization”或者“guarded devirtualization”。&lt;/p&gt;&lt;p&gt;GCC具体采用的做法是“function-based guarded devirtualization”，正如上面例子所演示的，它的“guard”其实还是从vtable读出了函数指针，只是读出来之后不马上去调用该函数指针，而是检查一下它是否跟预期的函数指针一致，如果一致则认为检查通过。乍一看这挺傻的，访问vtable的内存访问开销一点都没少，而且还多了个条件分支；如果能内联目标函数的话那可能还值得，否则的话这么做的好处就没多少了。&lt;/p&gt;&lt;p&gt;正因为这个优化并非总是值得的，GCC采用了很保守的策略，只在应该能提升性能的地方采用这种做法。一种情况是通过静态的类层次分析（CHA），发现一个虚函数调用点可能调用的目标函数只有1个可能性，那就生成上面所演示的“speculative devirtualized”代码，这种情况不需要profiling信息的支持。如果在做了该优化后，后续优化没能把目标函数内联进来或者至少从目标函数获取某些有利于优化的信息的话，则会撤销该优化，恢复回到普通的vtable间接调用。&lt;/p&gt;&lt;p&gt;上面演示的例子，之所以最开始的版本bar()还是用普通vtable调用而去掉Derived::bar()之后则变为“speculative devirtualized”调用，就是因为要满足上述保守策略的“只有1个可能调用的目标”的条件。&lt;/p&gt;&lt;p&gt;既然“只有1个可能调用目标”了，为啥不干脆去掉检查变为纯粹的直接调用（进而可能被内联），而要保留一个检查并在检查失败的分支中还去做普通vtable间接调用呢？&lt;/p&gt;&lt;p&gt;这主要是因为对C++程序不一点总是能做真正完备的“全程序分析”——假如碰上共享库/动态链接库，这些库里的类层次状况只能当黑盒子看待，所以总得留下一条退路给类层次分析错误的时候还能正确执行程序。&lt;/p&gt;&lt;p&gt;==================================&lt;/p&gt;&lt;p&gt;GCC选择的guard形式并非唯一的可能性。这种形式的guard在JVM里也有研究和应用，例如说IBM的JVM就有过这种形式的devirtualization。&lt;/p&gt;&lt;p&gt;但HotSpot VM没有使用这种形式的guard。HotSpot VM如果选择做guarded devirtualization的话，只会用type-based guarded devirtualization，也就是说guard检查的是被调用对象的类型，而不是目标方法的地址。&lt;/p&gt;&lt;p&gt;Type-based与function-/method-based的guard各有取舍。前者开销更小，而后者可处理的情况更多。&lt;/p&gt;&lt;p&gt;还是用本文开头的例子，如果是type-based，就可能会生成这样的代码：（还是伪代码）&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;// this-&amp;gt;bar()
if (this-&amp;gt;_vptr == vtable_of(Derived)) {
  // inlined Derived::bar()
  tmp = 256;
} else {
  this-&amp;gt;_vptr[BAR_VTABLE_INDEX](); // normal indirect virtual call
}&lt;/code&gt;&lt;p&gt;这个guard的形式显然比function-based的更轻一些，只要做一次间接读（读出_vptr字段来），而不像function-based版额外再读出bar的vtable entry出来。&lt;/p&gt;&lt;p&gt;但假如我们要调用foo()，它也是一个虚方法，但在Base与Derived中只有一个版本的实现，用type-based guard就得写成：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;if (this-&amp;gt;_vptr == vtable_of(Base) || this-&amp;gt;_vptr == vtable_of(Derived))&lt;/code&gt;&lt;p&gt;这就未必比function-based版好了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;最后放个传送门：&lt;a href=&quot;https://www.zhihu.com/question/34846173/answer/60302017&quot; data-editable=&quot;true&quot; data-title=&quot;HotSpot VM有没有对invokeinterface指令的方法表搜索进行优化？ - RednaxelaFX 的回答&quot;&gt;HotSpot VM有没有对invokeinterface指令的方法表搜索进行优化？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23233548</guid>
<pubDate>Thu, 27 Oct 2016 16:54:38 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] IBM J9 JVM开源的消息正式宣布了——OpenJ9</title>
<link>https://zhuanlan.zhihu.com/p/22550958</link>
<description>昨天（2016-09-20 PDT）在旧金山举办的JavaOne上，IBM正式宣布了即将开源其J9 Java虚拟机的消息。开源版J9 VM的名字是：OpenJ9！&lt;p&gt;几天前这边才刚发&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22506697?refer=hllvm&quot;&gt;OMR/TR终于开源的消息&lt;/a&gt;，这不，J9开源说来就来。&lt;br&gt;&lt;/p&gt;&lt;p&gt;相关资料：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;JavaOne的演讲：J9: Under the Hood of the Next Open Source JVM [CON3014]&lt;/li&gt;&lt;ul&gt;&lt;li&gt;可惜这个演讲没有录像，只有演示稿：&lt;a href=&quot;http://www.slideshare.net/DanHeidinga/j9-under-the-hood-of-the-next-open-source-jvm&quot; data-title=&quot;J9: Under the Hood of the Next Open Source JVM - SlideShare&quot; class=&quot;&quot;&gt;J9: Under the Hood of the Next Open Source JVM - SlideShare&lt;/a&gt;。链接是好的，打不开的话请自备…&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;根据演示稿所述，IBM目前的计划是跟随IBM Java 9一同正式发布OpenJ9。掐指一算，这大概就是明年这个时候了吧…&lt;/p&gt;&lt;p&gt;以后可以看到更多关于J9内部工作原理的资料了。怎能不一颗赛艇！&lt;/p&gt;&lt;p&gt;引用上述演示稿中的一页：&lt;/p&gt;&lt;img src=&quot;v2-f311880185afab21c28ac3d804def914.png&quot; data-rawwidth=&quot;2494&quot; data-rawheight=&quot;1402&quot;&gt;&lt;p&gt;&amp;lt;- 清晰地表明了未来OMR、OpenJ9与IBM J9之间的关系：OMR将是最上游，OpenJ9基于OMR构建出一个完整的JVM，OpenJ9 + OpenJDK Java Class Library构成一个完整的Java运行时环境，然后在此基础上添加IBM的特化功能最终构成IBM发行版J9及其配套库。&lt;br&gt;&lt;/p&gt;&lt;p&gt;这跟OpenJDK与Oracle JDK之间的关系基本上是同一个模型。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">22550958</guid>
<pubDate>Wed, 21 Sep 2016 15:48:26 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[OMR/TR] Testarossa的IL设计（持续更新）</title>
<link>https://zhuanlan.zhihu.com/p/22508731</link>
<description>边读代码边更新的笔记。一开始肯定会有不准确的地方，慢慢逐步修正。欢迎吐槽和补充～&lt;p&gt;先写点我原本就知道的内容，后面再更新具体到OMR TR代码的知识点。本文涉及的OMR TR代码基于最初开源的版本：&lt;a href=&quot;https://github.com/eclipse/omr/commit/03874a48843df45292aa35086c5faf4fd83de264&quot; data-editable=&quot;true&quot; data-title=&quot;Initial contribution of compiler technology consisting of: · eclipse/omr@03874a4 · GitHub&quot; class=&quot;&quot;&gt;Initial contribution of compiler technology consisting of: · eclipse/omr@03874a4 · GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上一篇文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/22506697?refer=hllvm&quot; data-editable=&quot;true&quot; data-title=&quot;[新闻] IBM/Eclipse OMR的编译器部分也已开源，以及IBM即将开源J9 VM - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&quot; class=&quot;&quot;&gt;[新闻] IBM/Eclipse OMR的编译器部分也已开源，以及IBM即将开源J9 VM - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&lt;/a&gt; 提到了OMR中的编译器组件——Testarossa（以下简称OMR TR）——也终于开源的新闻。这里就来看看OMR TR的中间表现形式（Intermediate Representation，IR）的设计是怎样的。&lt;br&gt;&lt;/p&gt;&lt;p&gt;OMR中的相关文档：&lt;a href=&quot;https://github.com/eclipse/omr/blob/master/doc/compiler/il/IntroToTrees.md&quot; data-editable=&quot;true&quot; data-title=&quot;omr/IntroToTrees.md at master · eclipse/omr · GitHub&quot; class=&quot;&quot;&gt;omr/IntroToTrees.md at master · eclipse/omr · GitHub&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;单一IR贯穿编译流程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;OMR TR的IR叫做Testarossa IL（Intermediate Language），下面简称TR IL。&lt;br&gt;&lt;/p&gt;&lt;p&gt;Testarossa的整个编译流程中基本上都是使用同样结构的树形（DAG形）TR IL。包括从平台无关代码向平台相关代码lower，也是从平台无关TR IL转换为平台相关TR IL。大部分平台相关优化也在TR IL上做。有一个&lt;a href=&quot;https://github.com/eclipse/omr/blob/master/compiler/optimizer/GlobalRegisterAllocator.hpp&quot;&gt;全局寄存器分配器&lt;/a&gt;也是在TR IL上做的。&lt;/p&gt;&lt;p&gt;然后指令选择（instruction selection）会从TR IL生成出平台相关的Instruction对象，然后这层由Instruction对象构成的底层IR主要用于局部寄存器分配（local register allocation/assignment）、计算栈帧布局与最终的代码生成（codegen）；在z上还会做一次scheduling，而其它平台上基本上除了窥孔优化（peephole optimization）之外就不在Instruction层面上做什么别的优化了。&lt;/p&gt;&lt;p&gt;引用Testarossa编译器的创始人Kevin Stoodley大大以前&lt;a href=&quot;https://webdocs.cs.ualberta.ca/~amaral/IBM-Stoodley-talks/UofAKASWideAudience.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;一个演讲&quot;&gt;一个演讲&lt;/a&gt;里对TR编译流程的介绍：&lt;/p&gt;&lt;img src=&quot;v2-ad5512a72f4e803b246af2314c897864.png&quot; data-rawwidth=&quot;1796&quot; data-rawheight=&quot;1386&quot;&gt;&lt;p&gt;这张图里的“Trees &amp;amp; CFG”就是本文所说的TR IL。&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;树形IR（Tree IR） / DAG IR&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;TR IL是一种颇为传统的树形IR（Tree IR），比一般编译器前端用的抽象语法树（AST）底层一些，而比完全拉直的线性IR要高层一些。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;相信熟悉&lt;a href=&quot;https://book.douban.com/subject/1886911/&quot; data-title=&quot;虎书系列&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;虎书系列&lt;/a&gt;的同学会对这种IR比较熟悉（对应虎书第7、8两章内容）。&lt;/li&gt;&lt;li&gt;熟悉GCC IR的同学，TR IL跟GCC的GENERIC已经lower了控制流但尚未lower表达式树的GIMPLE比较相似。&lt;/li&gt;&lt;li&gt;熟悉LCC的同学，TR IL跟LCC中的DAG IR几乎是一样的东西。&lt;/li&gt;&lt;li&gt;熟悉HotSpot Client Compiler（C1）的同学，TR IL与早期的C1的IR设计相当相似。早期C1的设计可以参考2000年的论文：&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=674976&quot; data-editable=&quot;true&quot; data-title=&quot;A Compiler for the Java HotSpotTM Virtual Machine&quot;&gt;A Compiler for the Java HotSpotTM Virtual Machine&lt;/a&gt;&lt;/li&gt;&lt;li&gt;熟悉RyuJIT的同学，TR IL跟RyuJIT的Tree IR颇有相似之处。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;TR IL比AST底层的地方在于：一般的AST设计会比较贴近源语言的语法结构，所以如果源语言有结构化控制流结构（if-then-else、while/for-loop等）的话，在AST里也会有直接对应的节点。而在一个典型的编译器后端用的树形IR中，控制流会被拆解为条件跳转与无条件跳转，树的形状会更贴近于底层控制流，而不再维持原本AST那种贴近源语言语法的层次结构。&lt;/p&gt;&lt;p&gt;TR IL比线性代码高层的地方在于：一般的线性代码跟机器语言比较贴近，就是一串线性执行的代码，没有所谓“语句”与“表达式”之分了——所有复杂（嵌套）表达式都被lower为一串使用临时变量的简单表达式。线性IR中的表达式大都可以用三地址代码直观地表示：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;dest = src1 op src2&lt;/code&gt;&lt;p&gt;&lt;b&gt;TR IL所使用的树形IR则仍然保持“语句”与“表达式”的区别。&lt;/b&gt;其中“语句”指的是可能有副作用的操作（例如变量赋值、函数调用等）或者是控制流跳转。语句不能嵌套，只能按顺序线性执行；换句话说，语句用于确定程序的执行顺序。而“表达式”则是纯粹的运算，没有副作用，没有控制流，可以嵌套。&lt;/p&gt;&lt;p&gt;常见的树形IR中“表达式”的若干重要特征是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;由于没有副作用与控制流，嵌套表达式的求值顺序可以任意决定，这给优化留下了自由度；&lt;/li&gt;&lt;li&gt;一个语句中的嵌套表达式的中间结果不会被别的语句中的表达式所看到。也就是说，一个语句中的表达式中间结果的生命周期仅限于该语句内，不会“泄漏”到别的语句中。这个特征对于某些非常简易的局部优化挺有帮助，例如&lt;a href=&quot;https://www.zhihu.com/question/29355187/answer/51935409&quot; data-editable=&quot;true&quot; data-title=&quot;这里&quot;&gt;这里&lt;/a&gt;提到的超简易寄存器分配算法。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不过就跟很多叫做“树形IR”但实际上却用的是有向无环图（DAG）的IR一样，&lt;b&gt;TR IL的表达式树实际上也是DAG而不总是真的树&lt;/b&gt;——表达式的中间运算结果在一个语句内可以被多个子表达式共享。像&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/237822&quot; data-editable=&quot;true&quot; data-title=&quot;LINQ的Expression Tree虽然叫做树但骨子里也是DAG&quot;&gt;LINQ的Expression Tree虽然叫做树但骨子里也是DAG&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;TR IL的DAG节点共享并不仅限制在一个“语句”中，而是在一个基本块或者扩展块中的语句都可以共享。&lt;/b&gt;这是DAG IR一种比较典型的做法。注意这与上面说的一般树形IR的表达式的“中间结果不会泄漏到别的语句”不一样。&lt;/p&gt;&lt;p&gt;TR IL的“语句”由&lt;a href=&quot;https://github.com/eclipse/omr/blob/master/compiler/il/OMRTreeTop.hpp&quot; data-editable=&quot;true&quot; data-title=&quot;TreeTop&quot;&gt;TreeTop&lt;/a&gt;表示。TreeTop是一个三元组：(TreeTop* prev, TreeTop* next, Node* node)，基本块里的一串TreeTop构成了指定程序执行顺序语义的双向链表。一个TreeTop节点下面挂的Node是这个语句里唯一一个可以有副作用的节点。这跟虎书第8章提到的canonical tree的设计非常相似。&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;每个节点只能生成一个值&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;TR IL的DAG节点，每个节点只能生成一个值。这对于大多数场景都够用。但有些特殊的平台支持，例如说一条div机器指令可能可以同时计算出商与余两个值，又比如说一条加法指令我们可能不但需要它的和，还想要它的进位（carry）值。要针对这些平台支持做优化，有些编译器会选择让IR支持某些节点生成多个值（或者说生成一个tuple然后用projection节点来提取tuple里的各个值）。&lt;/p&gt;&lt;p&gt;TR IL的设计则是坚守每个节点只生成一个值的设计。在遇到divmod、addwithcarry这样的需求时也还是用多个节点来分别表示那些原始操作，只是让优化器想办法识别出这些模式而把它们打包安排在相邻位置上。这个设计取舍是为了更容易保证构造IR时的正确性，而让优化器去解决性能问题。&lt;/p&gt;&lt;p&gt;参考文档：&lt;a href=&quot;https://github.com/eclipse/omr/blob/master/doc/compiler/il/ExtendingTrees.md#simplicity-&quot; data-editable=&quot;true&quot; data-title=&quot;Extending Trees - Simplicity&quot;&gt;Extending Trees - Simplicity&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;双层IR——控制流图与数据操作&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;TR IL是一种典型的双层IR，有单独一层控制流图（CFG）结构，由基本块（basic block）与控制流边构成；每个基本块代表一个最长的可线性执行的代码。基本块里是数据操作，也就是上一节提到的由“语句”和“表达式”构成的树形IR。&lt;/p&gt;&lt;p&gt;OMR TR所使用的基本块是“扩展基本块”（extended basic block）——函数调用以及其它潜在会抛出异常（有异常控制流）的IL指令并不结束一个基本块。&lt;/p&gt;&lt;p&gt;不仅如此，OMR TR在优化过程中还会进一步尝试把多个基本块粘合在一起，构成所谓的“扩展块”（extended block）——由多个原始基本块构成的单入口多出口（single-entry, multiple-exit）结构。这种扩展块结构也叫做&lt;a href=&quot;http://web.eecs.umich.edu/~mahlke/papers/1993/hwu_jsuper93.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;superblock&quot;&gt;superblock&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;参考文档：&lt;a href=&quot;https://github.com/eclipse/omr/blob/master/doc/compiler/il/IntroToTrees.md#basic-blocks&quot; data-editable=&quot;true&quot; data-title=&quot;Intro To Trees - Basic Block&quot;&gt;Intro To Trees - Basic Block&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;传统的IR——没有显式使用SSA形式&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;TR IL相对于现代流行的编译器IR，有一个很有趣的“特点”，就是虽然它支持各种控制流/数据流分析和优化，但却没有使用直接嵌入在IR中的&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot; data-editable=&quot;true&quot; data-title=&quot;SSA形式&quot;&gt;SSA形式&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;“取而代之”的是，TR IL里有TR_UseDefInfo这个辅助数据结构，用于记录IR中变量的use-def与def-use信息。本质上说它足以实现SSA形式所能实现的功能，只是没有把这个信息嵌入到IR里而已。&lt;/p&gt;&lt;p&gt;这个设计与Testarossa的血缘或许有很深的关系。正如前文所述，Testarossa最初的正式用途是作为J9 JVM配套的JIT编译器。而当时J9主要是针对嵌入式市场（Java ME）而开发的，配套的J9/TR自然必须严格考虑编译成本，不能做太重量级的分析与优化。后来J9逐步发展成熟，替代了IBM原本的桌面/服务器端JVM——Sovereign JVM——成为IBM JDK的唯一JVM，配套的J9/TR的功能也比以前大大丰富，单个编译器可进行不同优化级别的编译，以便支持J9的多层编译系统。&lt;/p&gt;&lt;p&gt;在最低优化级别的编译模式下，TR最主要的任务就是以最快速度从Java字节码生成出机器码，要构造SSA形式显然是太重量级了。而如果在高优化级别中为了深入做数据流分析而把IR转进一个单独的SSA形式版的TR IL，又会让IR的设计变得复杂：要么要支持两套IR，一套传统形式，一套SSA形式；要么要在同一套IR里支持传统模式与SSA模式。这两种用SSA形式的做法都有别的编译器使用，但TR选择了第三种也算常见的取舍：主IR里不直接携带use-def / def-use信息，而是在主IR之外用辅助数据结构来记录并跟踪这个信息。&lt;/p&gt;&lt;p&gt;TR IL里，TR_UseDefInfo是可选的辅助数据结构，只在需要做数据流分析/优化时才计算，可以很好地应对不同优化级别的不同需求。对应地，TR在做数据流分析时主要用的是传统的bitvector形式的分析。&lt;/p&gt;&lt;p&gt;说来，&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2359859/&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;《High-Performance Compilers for Parallel Computing》&quot;&gt;《High-Performance Compilers for Parallel Computing》&lt;/a&gt;一书的第6章，&quot;Scalar Analysis with Factored Use-Def Chains&quot;，把带有Factored Use-Def (FUD) Chain的IR与SSA形式的等价性介绍了一遍。此书作者Michael Wolfe对“SSA形式”这个叫法似乎没啥特别大的好感 &amp;gt;_&amp;lt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;（未完待续）&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">22508731</guid>
<pubDate>Mon, 19 Sep 2016 16:10:23 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
