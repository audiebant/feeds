<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Tue, 08 Nov 2016 18:15:14 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>[八卦] Phoenix Compiler Infrastructure或有望开源？</title>
<link>https://zhuanlan.zhihu.com/p/23515899</link>
<description>上周的就在家附近开的LLVM dev meeting俺可耻地缺席了。都是为了能有足够时间在家照顾好小叶子 ToT&lt;p&gt;好在还是有好几位同事去了。“Hallway session”万岁！&lt;/p&gt;&lt;p&gt;于是听到一个让我很感兴趣的、跟LLVM没关系的小道消息：微软研究院（MSR）或许有机会未来会把他们以前做的Phoenix Compiler Infrastructure给开源了。简直兴奋啊！&lt;/p&gt;&lt;p&gt;完全没听说过Phoenix的同学，请看Andy Ayers大大以前做的一个演讲：&lt;a href=&quot;http://slideplayer.com/slide/3602411/&quot; data-title=&quot;The Phoenix Compiler and Tools Framework&quot; class=&quot;&quot;&gt;The Phoenix Compiler and Tools Framework&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Phoenix是一个可以说定位跟LLVM颇为相似的编译器及分析工具框架，主要工作在语言中立的中端/后端。它完全使用C++/CLI编写，有native和CLI版binary，可分别供native C++与任意.NET语言调用。它有一套定义良好的IR以及操作该IR的API，IR有几个不同的抽象层，适用于编译流程中的各阶段（而不像LLVM的主IR主要只适合中端使用，到后端则是相当不同的MachineInstr IR）。它最初的目标是作为一个编译器框架（工具箱）要可以支持多种场景以及多种目标平台。例如说，基于它可以实现替代Visual C++编译器后端的c2.dll；最初也计划用它来替代CLR中的JIT64作为新的server JIT compiler…后来这部分目标被放弃了；同时还要可以支持对C/C++以及.NET程序的各种分析与优化，提供插件化API让用户可以轻松自定义编译pipeline并插入自己的插件。&lt;/p&gt;&lt;p&gt;2008年6月，Phoenix发布了最后一个CTP SDK之后，就从外界的视野中销声匿迹了。然而当时参与了这个项目的大大们都很不甘心吧。当时它还在活跃开发中的时候是由MSR和VC产品组共同管理的；后来产品组不要管它了，它就变成MSR自己的项目了。作为一个MSR项目，或许开源的阻力会稍微小一点点吧…&lt;/p&gt;&lt;p&gt;拭目以待！&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23515899</guid>
<pubDate>Tue, 08 Nov 2016 17:30:08 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Clang Parser漫步——declaration-specifiers（二）</title>
<link>https://zhuanlan.zhihu.com/p/23368100</link>
<description>既上文&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23344499&quot; data-editable=&quot;true&quot; data-title=&quot;Clang Parser漫步——external-declaration（一） - XlousZeng的文章 - 知乎专栏&quot; class=&quot;&quot;&gt;Clang Parser漫步——external-declaration（一） - XlousZeng的文章 - 知乎专栏&lt;/a&gt;说到解析external-declaration之后，本文将会解释Clang是如何解析declaration-specifiers的。&lt;p&gt;首先，这里先给出C99中declaration-specifiers的EBNF语法：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;declaration-specifiers:: [C99 6.7]
    storage-class-specifier declaration-specifiers[opt]
    type-specifier declaration-specifiers[opt]
    [C99]   function-specifier declaration-specifiers[opt]

storage-class-specifier:: [C99 6.7.1]
       &#39;typedef&#39;
       &#39;extern&#39;
       &#39;static&#39;
       &#39;auto&#39;
       &#39;register&#39;

function-specifier: [C99 6.7.4]
[C99]  &#39;inline&#39;

type-specifier::
            &#39;char&#39;
            &#39;wchar_t&#39;
            &#39;bool&#39;
            &#39;short&#39;
            &#39;int&#39;
            &#39;long&#39;
            &#39;signed&#39;
            &#39;unsigned&#39;
            &#39;float&#39;
            &#39;double&#39;
            &#39;void&#39;
    [C99]   &#39;_Bool&#39;
    [C99]   &#39;_Complex&#39;
    [C99]   &#39;_Imaginary&#39;  // Removed in TC2?
        enum-specifier
        struct-specifier
        union-specifier
        cv-qualifier

cv-qualifier::
        &#39;const&#39;
        &#39;volatile&#39;
        &#39;restrict&#39;&lt;/code&gt;&lt;p&gt;&lt;b&gt;一、入口&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在可以按照上述的语法对declaration-specifiers进行解析了；入口函数在ParseDecl.cpp:1581行&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-50ecb590293726244d4e921c8271f74d.png&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;471&quot;&gt;接下来在一个while循环中使用switch语句去处理上述右递归文法。略过处理c++，objective-c语法的逻辑。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-e1299f35e6d0a5fcbdf3b17f65231d39.png&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;471&quot;&gt;上述的DoneWithDeclSpec是解析完成之时的出口，会调用DS对象的finish函数完成一个declaration-specifiers的解析，进行语义检查，如：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;unsigned double是非法的;
unsigned x = 4;　　//x的默认类型将会转换为unsigned int.
unsigned unsigned x = 4;  // 错误duplicate &#39;unsigned&#39; declaration specifier
&lt;/code&gt;&lt;p&gt;Clang将declaration-specifiers分为如下几类，不同的类别是可以同时存在一个声明中的，但同一组中只能有一个。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;TypeSpecifierType: char, wchar_t,  _Bool,  foat,  double,  void, enum, union, struct;&lt;/li&gt;&lt;li&gt;TypeSpecifierWidth: short, long, long long;&lt;/li&gt;&lt;li&gt;TypeSpecifierComplex: _Imaginary, _Complex;&lt;/li&gt;&lt;li&gt;TypeSpecifierSign: unsigned, signed;&lt;/li&gt;&lt;li&gt;TypeQualifier: const, restrict, volatile;&lt;/li&gt;&lt;li&gt;StorageClassSpecifier: typedef, extern, static, auto, register;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;处理identifier，这个地方会区分普通标识符还是typename：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-08fe3d5abf90a93c8fe3de8e552f7be8.png&quot; data-rawwidth=&quot;769&quot; data-rawheight=&quot;406&quot;&gt;将其作为typename，并进行名字查找：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b3613f92cc6baaed9e1e403b98935949.png&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;255&quot;&gt;处理storage-class-specifier:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-0aa42016ca27eeb24337a2f60292e25d.png&quot; data-rawwidth=&quot;787&quot; data-rawheight=&quot;455&quot;&gt;处理function-specifiers，这些都是在C99中才加入的，如果你不需要处理C99的语法，可以跳过此类。&lt;b&gt;[注意，virtual和explicit是C++的语法]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-41344eb85758bf52fc8db136112346f4.png&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;255&quot;&gt;处理type-specifiers，&lt;b&gt;[注意：__int64是Clang扩充的整数类型]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-4b3f64a1b0b1a8886792db9930b807a1.png&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;488&quot;&gt;其他基本上都是类似的，就不贴图了，下面处理的是type-qualifiers：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-3d019c68592f12ef9f9d3f2d7b1e3fef.png&quot; data-rawwidth=&quot;833&quot; data-rawheight=&quot;332&quot;&gt;然后就是重点，解析struct/union，enum类型的定义和声明。在Clang中，struct/union是作为一类来处理的，与C++中的class关键字同理。&lt;/p&gt;&lt;img src=&quot;v2-ae3d93f1232751f43a185772abfbdcce.png&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;332&quot;&gt;&lt;p&gt;&lt;b&gt;二、解析Struct/Union-specifier&lt;/b&gt;&lt;/p&gt;&lt;p&gt;ParseClassSpecifier函数在ParseDeclCXX.cpp:839行。&lt;/p&gt;&lt;img src=&quot;v2-b1bd03de1206c6ad924360845858f4b2.png&quot; data-rawwidth=&quot;833&quot; data-rawheight=&quot;332&quot;&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;产生式为：
struct-or-union-specifier: [C99 6.7.2.1]
        struct-or-union identifier[opt] &#39;{&#39; struct-contents &#39;}&#39;
        struct-or-union identifier
[GNU]   struct-or-union attributes[opt] identifier[opt] &#39;{&#39; struct-contents attributes[opt]

[GNU]   struct-or-union attributes[opt] identifier

        struct-or-union:
        &#39;struct&#39;
        &#39;union&#39;
&lt;/code&gt;&lt;p&gt;首先进行一个简单的区分是struct or union or class[c++语法]&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-cc56279114bd2a147e907c5e48aeee31.png&quot; data-rawwidth=&quot;684&quot; data-rawheight=&quot;203&quot;&gt;之后就是解析各种gnu和microsoft的扩展了，我们这时候可以跳过。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-ede1f129c69ffe576344bac1e4900c88.png&quot; data-rawwidth=&quot;684&quot; data-rawheight=&quot;297&quot;&gt;判断是否有tag名字或者简单的模板id，不考虑c++模板。因为struct/union有匿名语法。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b439713a0ae8922aaa5ca87033cbf320.png&quot; data-rawwidth=&quot;639&quot; data-rawheight=&quot;150&quot;&gt;判断该struct/union X...是reference ? definition ? declaration。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b254c425cd88d220b528c1193bdadb38.png&quot; data-rawwidth=&quot;790&quot; data-rawheight=&quot;505&quot;&gt;然后得到如果TUK表示定义，则会转入解析struct/union body的函数，我们略过对c++语法的解析逻辑。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-060e9e2fbee3efe4d3753256fb5b9add.png&quot; data-rawwidth=&quot;776&quot; data-rawheight=&quot;214&quot;&gt;后面的部分就是Clang的错误语法产生式，将某些常见的错误语法形式编码到Parser中，为了更好的进行错误提示，可以了解下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-6a4cf2d75b8434b44f2e867c36db5066.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;436&quot;&gt;&lt;b&gt;三、解析enum-specifier&lt;/b&gt;&lt;/p&gt;&lt;p&gt;解析函数依旧在ParseDecl.cpp中，处于2766行。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;产生式：
ParseEnumSpecifier
       enum-specifier: [C99 6.7.2.2]
         &#39;enum&#39; identifier[opt] &#39;{&#39; enumerator-list &#39;}&#39;
[C99/C++]&#39;enum&#39; identifier[opt] &#39;{&#39; enumerator-list &#39;,&#39; &#39;}&#39;

         &#39;enum&#39; identifier　[类型引用或者声明]
&lt;/code&gt;&lt;br&gt;&lt;p&gt;&lt;img src=&quot;v2-27fd8fa76072c3371a519cf2c7df4519.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;436&quot;&gt;对于C++11来说，一个enum定义了一个作用域，但是C语言中没有。所以此处可以跳过作用域的处理。&lt;/p&gt;&lt;p&gt;判断是否有tag名字，否则就是一个匿名enum。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-a351f778a1fd864aaa5255b0ec47d112.png&quot; data-rawwidth=&quot;609&quot; data-rawheight=&quot;176&quot;&gt;与之前解析struct-specifier类似，判断该语法为何种形式, 定义或声明或引用&lt;/p&gt;&lt;img src=&quot;v2-6b38e227f7fa859c3139d3f9952a3e12.png&quot; data-rawwidth=&quot;778&quot; data-rawheight=&quot;316&quot;&gt;&lt;p&gt;名字处理好了之后，调用语义动作生成一个EnumDecl。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-574e2fc8b6284e091c1ea44ad887eabf.png&quot; data-rawwidth=&quot;778&quot; data-rawheight=&quot;236&quot;&gt;然后就可以解析enum {....}了。&lt;/p&gt;&lt;p&gt;最后进行语义判断，是否有多个enum声明，有个话将进行错误提示。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-c412f2e5fa4b5ac5d2781ebb104ffe1b.png&quot; data-rawwidth=&quot;778&quot; data-rawheight=&quot;210&quot;&gt;&lt;b&gt;三、解析Enum声明成员&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先声明一个作用域，用于检查同名变量，注意对于C语言来说，enum中没有一个单独的作用域，enum体内所有的变量的作用域在该enum声明所在的作用域，比如在顶层声明一个enum，那么enum常量所属的作用域是最顶层作用域。&lt;/p&gt;&lt;img src=&quot;v2-3478e1f88d61e0e5a6da793a43cbec07.png&quot; data-rawwidth=&quot;761&quot; data-rawheight=&quot;65&quot;&gt;&lt;code lang=&quot;text&quot;&gt;//对于如下代码：
enum X
{
    XX = 0,
    XZ,
};

enum Y
{
   XX = 0;
};

// 将会提示redefinition of enumerator &#39;XX&#39;。
//　如果此处使用c++11 enum class语法，带来的效果将会如Java中enum声明一样。
// 单独形成一个作用域。

//　如下代码在Clang 3.9 中使用-std=c++11编译通过。
enum class X
{
    XX = 0,
    XZ,
};

enum class Y
{
   XX = 0,
};

&lt;/code&gt;&lt;p&gt;好了，回归正题，在一个死循环中以此解析每个enum-decelarator，将结果保存在一个SmallVector中。&lt;/p&gt;&lt;p&gt;得到一个标识符，判断是否有赋值表达式，有的话在3031行解析常量表达式。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-74113ecc7372b25047d27665a58eb4bc.png&quot; data-rawwidth=&quot;689&quot; data-rawheight=&quot;457&quot;&gt;每个enumerator-constant解析完成之后，调用语义动作生成一个EnumConstantDecl对象，并添加到集合中。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-4dc0c990a3333020a8daf04a2125edaf.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;190&quot;&gt;当所有的成员解析完成之后，退出while循环，调用语义动作生成一个EnumDecl对象，对进行语义检查。&lt;/p&gt;&lt;img src=&quot;v2-d094a17d89aaa6206d01f3d1d933f21e.png&quot; data-rawwidth=&quot;847&quot; data-rawheight=&quot;190&quot;&gt;</description>
<author>XlousZeng</author>
<guid isPermaLink="false">23368100</guid>
<pubDate>Wed, 02 Nov 2016 14:18:14 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[HotSpot VM] 单独构建OpenJDK8u的HotSpot VM的脚本</title>
<link>https://zhuanlan.zhihu.com/p/23374517</link>
<description>时不时被问到这个问题，还是一并回答了吧。&lt;p&gt;假定从 &lt;a href=&quot;http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot&quot; data-editable=&quot;true&quot; data-title=&quot;jdk8u/jdk8u/hotspot: log&quot; class=&quot;&quot;&gt;http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot&lt;/a&gt; 签出了HotSpot VM的代码。那么在Mac OS X上，想单独build出HotSpot VM而不想build整个JDK8u的话，可以用我自用的这俩bash函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# HotSpot development on Mac
# Make just the HotSpot VM. Defaults to making a fastdebug variant.
makehs() {
        local JHOME
        JHOME=$JAVA_HOME
        local BNAME
        if [[ -n $1 ]]; then
                BNAME=$1;
        else
                BNAME=&#39;all_fastdebug&#39; # &#39;fastdebug_build&#39;
        fi
        # use an existing JDK7 for the buld
        JAVA_HOME=&#39;~/sdk/jdk7/Contents/Home&#39;
        # HS_CLANG_OPTS=&quot;CC=clang COMPILER_WARNINGS_FATAL=false LFLAGS=&#39;-Xlinker -lstdc++&#39; USE_CLANG=true&quot;
        make -C make CC=clang COMPILER_WARNINGS_FATAL=false LFLAGS=&#39;-Xlinker -lstdc++&#39; USE_CLANG=true LP64=1 LANG=C ALT_BOOTDIR=$JAVA_HOME ARCH_DATA_MODEL=64 HOTSPOT_BUILD_JOBS=8 $BNAME
        JAVA_HOME=$JHOME
}

# Export the HotSpot build to the specified export JDK
exporths_fastdebug() {
        EXPORT_JDK_PATH=~/sdk/jdk8u/Contents/Home/
        cp -r `pwd`/build/bsd/export-universal/fastdebug/* $EXPORT_JDK_PATH
}
&lt;/code&gt;&lt;p&gt;（注意：makehs()里JAVA_HOME请配置为任何一个Oracle JDK7或OpenJDK7的JDK安装路径；exporths_fastdebug()里EXPORT_JDK_PATH请配置为目标JDK的路径。我是把这俩函数放在我的.bash_profile里的，各位同学想怎么用都行。）&lt;/p&gt;&lt;p&gt;这俩都是很偷懒的脚本，就不多解释了。&lt;/p&gt;&lt;p&gt;在签出的hotspot目录里执行makehs可以默认构建出fastdebug版的HotSpot VM，其build结果在hotspot目录里的build/bsd/export-universal/fastdebug目录下。&lt;/p&gt;&lt;p&gt;然后，准备好一个事先build好的JDK8u的完整安装（例如说拿一个现成的Oracle JDK8u装好），并且把EXPORT_JDK_PATH变量配置到该JDK8u的安装路径上，然后在刚才build的hotspot目录里执行exporths_fastdebug()就会把刚build好的内容拷贝到目标JDK8u里，覆盖掉其中原本的HotSpot VM（主要是libjvm.dylib）。&lt;/p&gt;&lt;p&gt;完事之后那个目标JDK8u里的HotSpot VM就被狸猫换太子，变成我们自己build的版本了。然后就可以尽情实验啦。&lt;/p&gt;&lt;p&gt;以前我在Linux上做HotSpot VM的开发的时候，用的脚本也是类似的。根据Linux和Mac OS X的特点稍微调整一下就好了。&lt;/p&gt;&lt;p&gt;最后放俩我老blog的传送门：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/875957&quot; data-editable=&quot;true&quot; data-title=&quot;在XUbuntu 10.10上以JRL源码构建Oracle JDK 6 update 23&quot;&gt;在XUbuntu 10.10上以JRL源码构建Oracle JDK 6 update 23&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://hllvm.group.iteye.com/group/topic/39814#post-260210&quot; data-editable=&quot;true&quot; data-title=&quot;Mac OS X 10.9.2 build JDK8有谁build成功过么&quot;&gt;Mac OS X 10.9.2 build JDK8有谁build成功过么&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23374517</guid>
<pubDate>Wed, 02 Nov 2016 16:41:12 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Clang Parser漫步——external-declaration（一）</title>
<link>https://zhuanlan.zhihu.com/p/23344499</link>
<description>&lt;p&gt;之前一个回答&lt;a href=&quot;https://www.zhihu.com/question/51908169/answer/129019775?group_id=776373881685442560&quot; data-editable=&quot;true&quot; data-title=&quot;最近想分析的一下gcc的源代码，但不知从何出入手。请大神们指教指教，非常感谢。？ - 知乎用户的回答&quot; class=&quot;&quot;&gt;最近想分析的一下gcc的源代码，但不知从何出入手。请大神们指教指教，非常感谢。？ - 知乎用户的回答&lt;/a&gt;里面叙述了Clang+LLVM 3.0的整体框架，但是有点遗憾的是那篇回答只是一个梗概，并未对某些细节做出一些阐述。&lt;/p&gt;&lt;p&gt;第二篇：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23368100&quot; data-editable=&quot;true&quot; data-title=&quot;Clang Parser漫步——declaration-specifiers（二） - XlousZeng的文章 - 知乎专栏&quot;&gt;Clang Parser漫步——declaration-specifiers（二） - XlousZeng的文章 - 知乎专栏&lt;/a&gt;&lt;/p&gt;该篇文章是受R大鼓励，接着上述的问题对Clang3.0中Parser部分进行剖析，略过对C++、Objective-C语法的支持，暂时不考虑语义部分Sema，工作量太大了。&lt;p&gt;本文下所有的测试代码和环境都是在Debian8, GCC/G++ 4.9.2, Clang3.9下进行编译的。调试的Clang版本是3.0，源码从Clang官网下载。&lt;/p&gt;&lt;p&gt;在阅读Clang的Parser部分之前，需要准备一份C语言标准，由于Clang支持的C语言是C99，所以最好是对照C99的标准&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;open-std.org 的页面&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&lt;/a&gt;中语法的EBNF范式阅读，效果更好，当然也可以看C89。&lt;/p&gt;&lt;p&gt;Parser部分涉及到的目录有 tools/clang/lib/AST语法树定义，Sema语义分析，Lex词法分析器，Parse语法分析器。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;clang目录结构：
.
├── Analysis
├── ARCMigrate
├── AST
├── Basic
├── CMakeLists.txt
├── CodeGen
├── Driver
├── Frontend
├── FrontendTool
├── Headers
├── Index
├── Lex
├── Makefile
├── Parse
├── Rewrite
├── Sema
├── Serialization
└── StaticAnalyzer
&lt;/code&gt;&lt;p&gt;Clang工程的入口函数在Parse.cpp:463行的ParseTopLevelDecl()函数&lt;/p&gt;&lt;img src=&quot;v2-d715ea78583bd963f02f2269baeef6d1.png&quot; data-rawwidth=&quot;755&quot; data-rawheight=&quot;491&quot;&gt;&lt;p&gt;简单起见，我们不需要关注Attributes的解析，因此可以直接跳到483行的ParseExternalDeclaration函数。&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;产生式：
external-declaration: [C99 6.9]
    function-definition
    declaration&lt;/code&gt;&lt;p&gt;此处会根据function-definition或者declaration的First集的不同之处做一些特殊情况优化。我们现在只考虑普遍情况，此时会调用ParseDeclarationOrFunctionDefinition(attrs)函数。&lt;/p&gt;&lt;img src=&quot;v2-a4dea387813e54c187abd7fdf23d7e3d.png&quot; data-rawwidth=&quot;738&quot; data-rawheight=&quot;190&quot;&gt;&lt;p&gt;然后调用如下函数，先初始化一个ParsingDeclSpec对象，用于解析公共的declaration-specifiers&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-bb2138967c8b23dd9be4cec9234eacce.png&quot; data-rawwidth=&quot;726&quot; data-rawheight=&quot;255&quot;&gt;C99的语法为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function-definition: [C99 6.9.1]
    decl-specs declarator declaration-list[opt] compound-statement

function-definition: [C99 6.7.1] - implicit int result
    decl-specs[opt] declarator declaration-list[opt] compound-statement
    declaration: [C99 6.7]
    declaration-specifiers init-declarator-list[opt] &#39;;&#39;
&lt;/code&gt;&lt;p&gt;首先会解析变量定义和函数定义公共的declaration-specifiers。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-7d4d9a410f149bd1dd1c6aaa68483a22.png&quot; data-rawwidth=&quot;818&quot; data-rawheight=&quot;68&quot;&gt;然后调用ParseDeclGroup函数解析declarator，在C99中，每个declarator都表示普通变量声明器，数组变量声明器，函数声明器，指针声明器等。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-c3302dc7079b11cbc1e4d087764e9866.png&quot; data-rawwidth=&quot;818&quot; data-rawheight=&quot;68&quot;&gt;&lt;img src=&quot;v2-b88c352606c9ece48894ba24598d00b0.png&quot; data-rawwidth=&quot;827&quot; data-rawheight=&quot;258&quot;&gt;当每个declarator都解析完了之后，需要对得到的declarator进行判断其为普通变量声明，函数声明，抑或是数组声明。&lt;/p&gt;&lt;p&gt;１．处理函数：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-b5d946c8ee5fdc45878ea913b4967de6.png&quot; data-rawwidth=&quot;777&quot; data-rawheight=&quot;380&quot;&gt;２．解析变量&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-51993a48090839da494001056ce99603.png&quot; data-rawwidth=&quot;777&quot; data-rawheight=&quot;380&quot;&gt;此处的while循环用于解析单行声明多个变量的语法形式：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;declarator-inits::
    declarator-init, declarator-inits;

declarator-init::
    declarator [=initiation-list]opt;&lt;/code&gt;&lt;p&gt;&lt;img src=&quot;v2-ea7eb10009e60b12eee562c187b634cc.png&quot; data-rawwidth=&quot;638&quot; data-rawheight=&quot;170&quot;&gt;最后当一个external-declaration结束的时候，会调用语义动作Sema。&lt;/p&gt;&lt;img src=&quot;v2-60a1f2bd60c87c5cda24f40f3dd7b5c1.png&quot; data-rawwidth=&quot;638&quot; data-rawheight=&quot;97&quot;&gt;</description>
<author>XlousZeng</author>
<guid isPermaLink="false">23344499</guid>
<pubDate>Tue, 01 Nov 2016 13:47:08 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[科普] 一个演示简单编译器循环优化的例子</title>
<link>https://zhuanlan.zhihu.com/p/23326776</link>
<description>是标题党了啦。这是应对&lt;a href=&quot;https://www.zhihu.com/question/51592012&quot; data-editable=&quot;true&quot; data-title=&quot;VS为什么会生成这样的C++反汇编代码？ - 程序员&quot;&gt;VS为什么会生成这样的C++反汇编代码？ - 程序员&lt;/a&gt;问题而写个一个小例子。并没有啥高深新奇的知识，纯科普而已。&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;演示用的代码例子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;先来看用于演示的C代码例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;                     // (1)
  for (uint32_t i = lo; i &amp;lt; hi; i++) {  // (2)
    uint32_t y = 2 * i;                 // (3)
    if ((hi &amp;amp; 1) == 0) {                // (4)
      sum += i;                         // (5)
      gLastI = i;                       // (6)
    } else {
      sum += y;                         // (7)
    }
  }
  return sum;                           // (8)
}
&lt;/code&gt;&lt;p&gt;挺简单的函数。有啥好优化的呢？——对于不熟悉编译原理的同学来说，最可能让他们意外的可能就是优化后代码的顺序与原程序的巨大差异。&lt;/p&gt;&lt;p&gt;ICC 17在Linux/x86-64上在-O3优化级别会把这个例子优化为等价于下面的形式：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  if (lo &amp;lt; hi) {
    uint32_t n = hi - lo;
    if ((hi &amp;amp; 1) != 0) {
      for (uint32_t i = 0; i &amp;lt; n; i++) {
        sum += lo * 2; // folded into lea
        sum += i * 2;  // folded into lea
      }
    } else {
      uint32_t last_i;
      for (uint32_t i = 0; i &amp;lt; n; i++) {
        sum += lo;
        last_i = lo;
        lo++;
      }
      gLastI = last_i;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;p&gt;实际生成的汇编长这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;foo:
        mov       edx, esi                                      #5.35
        xor       eax, eax                                      #6.11
        cmp       edi, edx                                      #7.29
        jae       ..B1.9        # Prob 50%                      #7.29
        mov       esi, edx                                      #5.35
        mov       ecx, eax                                      #7.3
        sub       esi, edi                                      #5.35
        test      dl, 1                                         #9.15
        je        ..B1.7        # Prob 50%                      #9.21
..B1.4:                         # Preds ..B1.2 ..B1.4
        lea       eax, DWORD PTR [rax+rdi*2]                    #7.3
        lea       eax, DWORD PTR [rax+rcx*2]                    #8.17
        inc       ecx                                           #7.3
        cmp       ecx, esi                                      #7.3
        jb        ..B1.4        # Prob 82%                      #7.3
        jmp       ..B1.9        # Prob 100%                     #7.3
..B1.7:                         # Preds ..B1.2 ..B1.7
        inc       ecx                                           #7.3
        add       eax, edi                                      #10.7
        mov       edx, edi                                      #11.7
        inc       edi                                           #7.3
        cmp       ecx, esi                                      #7.3
        jb        ..B1.7        # Prob 82%                      #7.3
        mov       DWORD PTR gLastI[rip], edx                    #11.7
..B1.9:                         # Preds ..B1.4 ..B1.8 ..B1.1
        ret                                                     #16.10
&lt;/code&gt;&lt;p&gt;它为什么可以这样做？下面就让我简单民科科普一下。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;先放个传送门：&lt;a href=&quot;https://www.zhihu.com/question/23261395/answer/42426957&quot; data-editable=&quot;true&quot; data-title=&quot;编译器生成的汇编语句执行顺序为什么与C代码顺序不同？ - RednaxelaFX 的回答&quot;&gt;编译器生成的汇编语句执行顺序为什么与C代码顺序不同？ - RednaxelaFX 的回答&lt;/a&gt;。这个传送门里我的回答提到了编译器在优化代码的时候，只要保证最终的结果满足程序中各种依赖关系就可以了，而不必总是维持跟输入的源码相同的顺序（“program order”）。不过这个传送门中涉及的例子非常简单，只有纯直线代码，没有跳转 / 条件跳转，也没有对内存的读写，所以只要用“数据依赖”（data dependence）就足以讲解了。&lt;/p&gt;&lt;p&gt;而本文所用的例子则稍微复杂一点，可以涉及稍微多一些的优化的讲解。&lt;/p&gt;&lt;p&gt;首先在(2)开始有一个典型的for循环，在(4)有一个条件分支；这两个都是控制流操作，使这个例子涉及“控制依赖”（control dependence）。然后在(6)有一个对全局变量gLastI的写操作，这是一个内存写操作，使这个例子涉及“内存依赖”（memory dependence）——或者说正好演示了冗余写操作的情况。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;副作用？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对编译器中的优化器来说，所谓“副作用”就是在当前编译单元中无法做足够分析的运算结果。这跟上层的源语言中所说的“副作用”并不总是一回事。所以当看到对程序中的副作用的讨论时，要注意清楚讨论的上下文是什么，免得误解了对方的意思。&lt;/p&gt;&lt;p&gt;例如说，对编译器中端的优化器来说，C语言的一个标量类型的局部变量，如果它在整个函数中都没有被取过地址，那么所有对它自身的读写运算都可以认为是“无副作用”的。这是因为这些变量是活动记录（activation record，或者说栈帧）的一部分，而一个函数被调用一次的活动记录里的内容都是这次调用独享访问的，除非程序主动通过取局部变量地址的方式来暴露出机会让别的代码能操作这些局部变量。这样编译器的优化器就可以对其做足够分析，将它们涉及的副作用都分析出来，并转换为没有副作用的形式。&lt;/p&gt;&lt;p&gt;而对原本的C语言来说，一般会把对局部变量的赋值（写）运算叫做“有副作用”的。&lt;/p&gt;&lt;p&gt;这个差异主要是来自编译器各部分的分工，以及优化器对程序的分析能力。&lt;/p&gt;&lt;p&gt;回顾一下一个典型的带优化的编译器的工作流程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    源代码
-&amp;gt; [ 词法分析 ]
-&amp;gt;  单词流
-&amp;gt; [ 语法分析 ]
-&amp;gt;  语法树 / 抽象语法树           编译器前端
-&amp;gt; [ 语义分析 ]
-&amp;gt;  带标注的语法树
-&amp;gt; [ 中间代码生成 ]
-&amp;gt;  中间代码              -------------------------
-&amp;gt; [ 平台无关优化 ]
-&amp;gt;  优化的中间代码                编译器中端
-&amp;gt; [ 平台相关lowering ]
-&amp;gt;  平台相关中间代码       --------------------------
-&amp;gt; [ 平台相关优化 ]
-&amp;gt;  优化的平台相关中间代码         编译器后端
-&amp;gt; [ 代码生成 ]
-&amp;gt; 目标代码&lt;/code&gt;&lt;p&gt;在这个流程中，编译器前端更关心源语言的语义，后端更关心目标平台的特性，而位于中间的中端则主要关心相对不那么语言相关、也不那么平台相关的优化。&lt;/p&gt;&lt;p&gt;当我们讨论源语言层面上的“副作用”，编译器前端的“语义分析”部分是必须要能正确理解这些副作用的含义（并在副作用不合理时给出警告）。然后在“中间代码生成”的部分，这些“副作用”会在中间表示中用更显式的方式表现出来，于是到编译器中端拿到中间表示的时候，就不用关心这些源语言层面的副作用了。&lt;/p&gt;&lt;p&gt;例如说，一个经典的不好的C代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo() {
  int i = 0;
  int j = i + i++;
  return j;
}&lt;/code&gt;&lt;p&gt;在 i + i++ 的地方有一个纯粹的对局部变量i的读操作，以及一个带有副作用（自增）的对局部变量i的读写操作，而这两个操作之间没有sequence point所以它们俩的求值顺序是未定义的。&lt;/p&gt;&lt;p&gt;在Clang中，语义分析的部分会对这个情况给出警告：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;foo.c:3:16: warning: unsequenced modification and access to &#39;i&#39; [-Wunsequenced]
  int j = i + i++;
          ~    ^
&lt;/code&gt;&lt;p&gt;然后Clang在生成中间代码（LLVM IR）时，会根据自己的理解选择一种求值顺序——后做i++，生成出每个操作都简单明确的中间代码，然后编译器中端（LLVM）在拿到LLVM IR之后就能根据代码的顺序准确地理解前端所做的选择：&lt;/p&gt;&lt;code lang=&quot;llvm&quot;&gt;; Function Attrs: nounwind
define i32 @foo() #0 {
  %i = alloca i32, align 4           ; int i
  %j = alloca i32, align 4           ; int j
  store i32 0, i32* %i, align 4      ; i = 0
  %3 = load i32, i32* %i, align 4    ; tmp3 = i
  %4 = load i32, i32* %i, align 4    ; tmp4 = i
  %5 = add nsw i32 %4, 1             ; tmp5 = tmp4 + 1
  store i32 %5, i32* %i, align 4     ; i = tmp5
  %6 = add nsw i32 %3, %4            ; tmp6 = tmp3 + tmp4
  store i32 %6, i32* %j, align 4     ; j = tmp6
  %7 = load i32, i32* %j, align 4    ; tmp7 = j
  ret i32 %7                         ; return tmp7
}
&lt;/code&gt;&lt;p&gt;也就是Clang选择拆解副作用的方式，对应这样的C代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo() {
  int i = 0;
  int j = i + i;
  i = i + 1;     // side-effect of i++
  return j;
}&lt;/code&gt;&lt;p&gt;可以看到这里生成的LLVM IR还是“有副作用”的——那3条store指令就是“副作用”。但是LLVM可以对所有没有被取地址的标量类型的局部变量都可以做完全的分析——可以找到所有对这些局部变量的读写操作并分析其中的副作用的效果——然后将IR转换到对这些局部变量来说没有副作用的形式。&lt;br&gt;&lt;/p&gt;&lt;p&gt;例如说对上述LLVM IR跑一次mem2reg pass（或者包含mem2reg的sroa pass），会得到：&lt;/p&gt;&lt;code lang=&quot;llvm&quot;&gt;; Function Attrs: nounwind
define i32 @foo() #0 {
  %1 = add nsw i32 0, 1              ; tmp1 = 0 + 1
  %2 = add nsw i32 0, 0              ; tmp2 = 0 + 0
  ret i32 %2                         ; return tmp2
}
&lt;/code&gt;&lt;p&gt;这里就没有任何副作用了，只有对局部值的简单运算。进一步做常量折叠和无用代码消除之后，就只剩下：&lt;/p&gt;&lt;code lang=&quot;llvm&quot;&gt;; Function Attrs: nounwind
define i32 @foo() #0 {
  ret i32 0                          ; return 0
}
&lt;/code&gt;&lt;p&gt;了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;同一个例子用GCC 4.9.2来看编译器前端的理解（生成的GIMPLE）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;foo ()
{
  int i.0;
  int D.1748;
  int i;
  int j;

  i = 0;
  i.0 = i;
  i = i.0 + 1;      // side-effect of i++
  j = i.0 + i;
  D.1748 = j;
  return D.1748;
}
&lt;/code&gt;&lt;p&gt;这GCC选择的求值顺序就跟Clang正好相反，先做了i++。&lt;/p&gt;&lt;p&gt;然后中端在分析完局部变量涉及的副作用之后，所生成的无副作用的中间代码（Tree SSA形式的GIMPLE）：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;foo ()
{
  int j;
  int i;
  int D.1748;
  int i.0;
  int i.0_2;
  int _5;

  &amp;lt;bb 2&amp;gt;:
  i_1 = 0;
  i.0_2 = i_1;
  i_3 = i.0_2 + 1;
  j_4 = i.0_2 + i_3;
  _5 = j_4;

&amp;lt;L0&amp;gt;:
  return _5;
}
&lt;/code&gt;&lt;p&gt;每个局部变量最多被赋值一次，从赋值到使用直接不用考虑别的副作用影响该变量的值，所以说“没有副作用”。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;副作用与控制依赖&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;先说结论：没有副作用的运算可以无视控制依赖，只要满足数据依赖即可执行。&lt;/p&gt;&lt;p&gt;什么是控制依赖？控制依赖是说，某个运算Y的执行与否，依赖于某个带有控制流语义的运算X的结果。&lt;/p&gt;&lt;p&gt;例如说，&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int x = 0;
  if (cond) {
    x = a + c;
  }
  return x;
}&lt;/code&gt;&lt;p&gt;这个例子里，&quot;x = a + c&quot;就控制依赖于&quot;if (cond)&quot;的运算结果，只有当cond为真值的时候，x = a + c才执行。&lt;/p&gt;&lt;p&gt;但是&quot;a + c&quot;是一个没有副作用的运算，它其实放在foo()中的什么位置执行都可以——只要它所依赖的数据输入a和c都已经求好值了即可——而不必依赖于&quot;if (cond)&quot;的结果。这跟本文开头提到的传送门里“数据依赖”的例子一样。&lt;/p&gt;&lt;p&gt;所以把上述代码的a + c提取到if外面，转换成下面这样也是一样的：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int x = 0;
  int tmp = a + c;
  if (cond) {
    x = tmp;
  }
  return x;
}
&lt;/code&gt;&lt;p&gt;又或者再向前挪一点：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int tmp = a + c;
  int x = 0;
  if (cond) {
    x = tmp;
  }
  return x;
}
&lt;/code&gt;&lt;p&gt;也可以。&lt;/p&gt;&lt;p&gt;那么&quot;x = &quot;的部分呢？这个赋值会根据&quot;if (cond)&quot;的结果而影响局部变量x的值，所以要先看作有控制依赖的有副作用的操作，分析清楚之后再转换到无副作用的形式。&lt;/p&gt;&lt;p&gt;但是所谓“无副作用”的形式要如何表达一个变量可能经由不同的分支执行后得到不同的值呢？一种办法是SSA形式的“phi”伪函数。让我们把这个例子转成SSA形式来看：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int foo(int a, int b, int cond) {
  int c = b + 1;
  int x0 = 0;
  if (cond) goto condtrue; else goto condfalse;

condtrue:
  int x1 = a + c;
  goto aftercond;

condfalse:
  goto aftercond;

aftercond:
  int x2 = phi(condfalse x0, condtrue x1);
  return x2;
}
&lt;/code&gt;&lt;p&gt;这个“phi”伪函数会显式指明“如果控制来自某个分支，则选用某个值”。这就把副作用与控制依赖显式结合在一起表达出来了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;回到本文开头的例子，位于(3)的&quot;2 * i&quot;是一个无副作用的运算，所以它的运算位置可以被移动。例如说它可以被向下移动（sink），到真正使用它的地方，变成：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  for (uint32_t i = lo; i &amp;lt; hi; i++) {
    if ((hi &amp;amp; 1) == 0) {
      sum += i;
      gLastI = i;
    } else {
      uint32_t y = 2 * i;
      sum += y;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;循环不变量与循环不变量外提（LICM）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;就跟上一节提到的思路一样，如果通过分析可以发现在循环中有运算的值不受循环的影响，那么就可以把它提升到循环的外面。这种优化叫做循环不变量外提（LICM，loop-invariant code motion）。&lt;/p&gt;&lt;p&gt;以本文开头的例子来说，通过分析可以发现从(2)开始的for循环，在循环体中没有对变量hi赋过值，所以hi的值在循环内不会改变。递推出去，hi &amp;amp; 1 是一个无副作用的运算，它的值在循环中也不会改变。同理 (hi &amp;amp; 1) == 0 的值在循环中也不会改变。&lt;/p&gt;&lt;p&gt;所以这个例子就可以把(4)的条件运算提取到循环外面，变成（在上一节的基础上）:&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  _Bool tmpcond = (hi &amp;amp; 1) == 0;
  for (uint32_t i = lo; i &amp;lt; hi; i++) {
    if (tmpcond) {
      sum += i;
      gLastI = i;
    } else {
      uint32_t y = 2 * i;
      sum += y;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;循环判断外提（loop unswitching）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作为LICM的一种扩展，如果我们发现循环里有条件是对循环不变量来做判断的，那么就可以选择把这个判断提升到循环的外面 ，并且把原循环拆分为两个特化的版本，分别对应条件为真以及为假的情况。&lt;/p&gt;&lt;p&gt;这样每个版本的循环都会比原本的更简单，而假定循环是耗时的操作，是我们要有针对性优化的目标，把循环拆分成特化的版本后就可以减小循环的开销。&lt;/p&gt;&lt;p&gt;还是回到本文开头的例子，在上一节版本的基础上，可以进一步变换为：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  if ((hi &amp;amp; 1) == 0) {
    for (uint32_t i = lo; i &amp;lt; hi; i++) {
      sum += i;
      gLastI = i;
    }
  } else {
    for (uint32_t i = lo; i &amp;lt; hi; i++) {
      uint32_t y = 2 * i;
      sum += y;
    }
  }
  return sum;
}
&lt;/code&gt;&lt;p&gt;跟开头演示的优化后的结果是不是越来越相似了？&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;内存写的下沉（store sinking）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;嗯这个读起来有点怪。简单来说就是如果有连续多次对同一个位置的内存写操作，那么只有最后一个才是有意义的，前面那些只要没被用到都是无意义的，可以消除。所以这种优化也叫做“冗余内存写消除”（redundant store elimination）。&lt;/p&gt;&lt;p&gt;应用到循环中，如果我们在循环体中不断对某个位于内存中的变量做赋值，但却没有在循环中使用过这个赋值的结果，那么这个赋值就没有意义，可以被消除。&lt;/p&gt;&lt;p&gt;例如说：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  for (int i = 0; i &amp;lt; 3; i++) {
    globalVariable = i;
  }&lt;/code&gt;&lt;p&gt;全局变量globalVariable的实体必须要被分配在内存中，所以对它的赋值是一个内存写操作（memory store）。如果我们分析一下循环的执行过程 ，就会发现这个例子实际上会执行3次对globalVariable的赋值：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;globalVariable = 0&lt;br&gt;&lt;/li&gt;&lt;li&gt;globalVariable = 1&lt;br&gt;&lt;/li&gt;&lt;li&gt;globalVariable = 2&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但在这个循环中其实并没有用到这些赋值的结果，而在循环结束时需要给外界留下的副作用只需要是globalVariable = 2。所以我们可以把这个内存写操作“下沉”（sink）到循环的后面去，变成：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  for (int i = 0; i &amp;lt; 3; i++) {
    /* empty loop body */
  }
  globalVariable = 2; // constant-folded condition: if (0 &amp;lt; 3)&lt;/code&gt;&lt;p&gt;或者稍微没那么优化的版本：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  int i;
  for (i = 0; i &amp;lt; 3; i++) {
    /* empty loop body */
  }
  globalVariable = i - 1; // constant-folded condition: if (0 &amp;lt; 3)
&lt;/code&gt;&lt;p&gt;但要注意的是：一个for循环其实是有可能一次也不执行的，所以在循环体里的赋值如果被下沉到循环后面的话，要保证该循环至少执行过一次才正确。&lt;/p&gt;&lt;br&gt;&lt;p&gt;回到本文开头的例子，在上一节版本的基础上，把(6)对全局变量gLastI的赋值下沉到循环后面，可以变换成：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  uint32_t sum = 0;
  if (lo &amp;lt; hi) {
    if ((hi &amp;amp; 1) == 0) {
      for (uint32_t i = lo; i &amp;lt; hi; i++) {
        sum += i;
      }
      gLastI = hi - 1;
    } else {
      for (uint32_t i = lo; i &amp;lt; hi; i++) {
        uint32_t y = 2 * i;
        sum += y;
      }
    }
  }
  return sum;
}
&lt;/code&gt;&lt;p&gt;具体到ICC所选用的优化形式，它没能彻底优化掉循环中的运算，不过至少在循环中用一个局部变量来替代了全局变量作为赋值的目标，然后在循环之后才做最终的内存写操作：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;      uint32_t last_i;
      for (uint32_t i = lo; i &amp;lt; hi; i++) {
        sum += i;
        last_i = i;
      }
      gLastI = last_i;
&lt;/code&gt;&lt;p&gt;这仍然算是store sinking——局部变量可以被分配到寄存器里，对局部变量的赋值就不会内存写了，所以还是比对全局变量的赋值更快。&lt;/p&gt;&lt;p&gt;经过store sinking优化后，代码的形式已经跟ICC优化的结果非常相似了。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;循环归纳变量优化（loop induction variable optimizations）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文开头所给出的ICC优化后的版本，剩下的一些优化是跟循环归纳变量相关的。所谓“循环归纳变量”，就是值与循环轮次成线性关系的变量。&lt;/p&gt;&lt;p&gt;例如说最典型的for循环：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;  for (int i = 0; i &amp;lt; max; i++) {
    int x = arr[i + 2];
    /* ... */
  }&lt;/code&gt;&lt;p&gt;局部变量i就是一个循环归纳变量，它的值跟循环轮次正好相等。我们可以分析出这个变量i的性质为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;init = 0&lt;/li&gt;&lt;li&gt;limit = max&lt;/li&gt;&lt;li&gt;cmp = &amp;lt;&lt;/li&gt;&lt;li&gt;step = 1&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而表达式 i + 2 的值也是跟循环轮次成线性关系的，关系为 1 * i + 2。于是这个表达式的性质就可以从变量i推算出来。&lt;/p&gt;&lt;p&gt;GCC与Clang对循环归纳变量的分析与优化叫做“&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gccint/Scalar-evolutions.html&quot; data-editable=&quot;true&quot; data-title=&quot;Scalar evolutions&quot;&gt;Scalar evolutions&lt;/a&gt;”（简称SCEV）。&lt;/p&gt;&lt;p&gt;这边就不专门说明ICC是如何通过循环归纳变量分析来把本文开头的例子从上一节的版本优化到最终版本了。同学们有兴趣的话可以自己动手推推看 ^_^&lt;/p&gt;&lt;p&gt;事实上，既然这是一个等差数列求和的例子，比例子中ICC编译结果更简短的形式应该是这样的：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

uint32_t gLastI;

uint32_t foo(uint32_t lo, uint32_t hi) {
  if (lo &amp;lt; hi) {
    uint32_t n = hi - lo;
    if ((hi &amp;amp; 1) == 0) {
      gLastI = hi - 1;
      return (lo &amp;amp; 1) == 0 ? (n &amp;gt;&amp;gt; 1) * (lo + hi - 1)
                           : ((lo + hi - 1) &amp;gt;&amp;gt; 1) * n;
    } else {
      return (lo + hi - 1) * n;
    }
  } else {
    return 0;
  }
}
&lt;/code&gt;&lt;p&gt;直接连循环都不要了。这个形式是否比ICC的编译结果更优化还是得看情况。应用怎样的编译分析与优化能得到这个形式，就留作课后习题吧。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;把非常量的循环加法变换为非循环的乘法形式是实际编译器实现中比较少见的做法。更常见的反过来的优化：“强度削减”（strength reduction），把本来是乘法的运算变成加法，之类。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;这次就先科普到这里。欢迎对本文的科普和分析拾遗补阙 ^_^&lt;/p&gt;&lt;p&gt;注：GCC与Clang与本文开头的例子编译出来的结果比ICC的更复杂一些，相关分析也留作课后作业啦。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23326776</guid>
<pubDate>Tue, 01 Nov 2016 08:17:35 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>观察ChakraCore JIT生成的native code</title>
<link>https://zhuanlan.zhihu.com/p/23314157</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20792855&quot; data-editable=&quot;true&quot; data-title=&quot;前面&quot;&gt;前面&lt;/a&gt;介绍了ChakraCore的各个dump开关，可以用来查看编译的中间阶段的结果。这里介绍一下一个简单的JavaScript函数被编译成的native code像什么样子。&lt;/p&gt;&lt;p&gt;为了查看JIT code，一个办法是使用之前介绍的 -dump 开关查看encode阶段的结果（-dump:encoder）。另外ChakraCore支持一个选项是 -DebugBreak:FunctionNumber。FunctionNumber可以通过查看其它dump获得，比如 -dump:irbuilder，在JavaScript源文件没改变的话，即使是多次运行同一个函数的FunctionNumber也是不变的。-DebugBreak会导致encode阶段在函数入口插入一条断点指令（默默给encoder点个赞），比如x86和x64下的“int 3”，这样运行到该方法就会自然中断到调试器。&lt;/p&gt;&lt;p&gt;代查看的JavaScript源代码如下，要看的是其中 &lt;b&gt;access()&lt;/b&gt; 的JIT code。 &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// ch.exe -mic:1 -off:simplejit -DebugBreak:3
function Point(x, y) {
    this.x = x;
    this.y = y;
}

function access(pt) {
    return pt.x;
}

var pt = new Point(1, 2);
access(pt);
access(pt);&lt;/code&gt;&lt;p&gt;以x64为例，以下是JIT给上面 &lt;b&gt;access()&lt;/b&gt; 生成native code的CFG（Control Flow Graph）, 因为比较大，分成2部分介绍。这个CFG是从WinDbg里面反汇编的代码生成的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn966108.aspx&quot; data-editable=&quot;true&quot; data-title=&quot;DGML&quot;&gt;DGML&lt;/a&gt;，能在Visual Studio中直接查看。下图中每一个节点代表了一个basic block, 黑色实箭头是fallthough到下一个follower block, 红色的虚线箭头表示一个跳转（包括条件跳转和无条件跳转）。最上面的绿色节点代表函数入口而最下面的黄色节点是函数的退出block（含有 ret 指令）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;v2-aa2219e7fd629d34c5aed9a4a0c0d102.png&quot; data-rawheight=&quot;840&quot; data-rawwidth=&quot;1057&quot;&gt;Control Flow Graph - part 1&lt;/p&gt;&lt;img src=&quot;v2-08ee1601080e718807bb1d83dd871031.png&quot; data-rawheight=&quot;706&quot; data-rawwidth=&quot;1696&quot;&gt;&lt;p&gt;Control Flow graph - part 2 （注意顶上两条入边与part 1的底部相连）&lt;/p&gt;&lt;ol&gt;&lt;li&gt;函数入口。1，2，3属于stack probe (对栈顶位置做一些基本检查，实现在 &lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/release/1.3/lib/Backend/amd64/LowererMDArch.cpp#L1630&quot; data-editable=&quot;true&quot; data-title=&quot;LowererMDArch::GeneratePrologueStackProbe&quot;&gt;LowererMDArch::GeneratePrologueStackProbe&lt;/a&gt; ）。检查StackLimit+FrameSize是否溢出，如溢出则跳至3做stack probe。&lt;/li&gt;&lt;li&gt;检查栈顶（RSP）有没有超出StackLimit，超过了则需进入3做stack probe。 &lt;br&gt;&lt;/li&gt;&lt;li&gt;检查栈空间，如还有stack space则扩展StackLimit，否则抛出stack overflow（见&lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/Base/ThreadContext.cpp#L1700&quot; data-editable=&quot;true&quot; data-title=&quot;ThreadContext::ProbeStackNoDispose&quot;&gt;ThreadContext::ProbeStackNoDispose&lt;/a&gt;）。&lt;/li&gt;&lt;li&gt;把寄存器参数放进&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ew5tede7.aspx&quot; data-editable=&quot;true&quot; data-title=&quot;home space&quot;&gt;home space&lt;/a&gt;，加载后面需要用到的常量，检查函数执行计数器（FunctionEntryPointInfo里面&lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/release/1.3/lib/Runtime/Base/FunctionBody.h#L988&quot; data-editable=&quot;true&quot; data-title=&quot;callsCount&quot;&gt;callsCount&lt;/a&gt;）是否超过255，没有则进入5将计数器加1。另外注意到打头的两条nop指令，是为了随机化JIT生成的native code。&lt;/li&gt;&lt;li&gt;把函数计数器加1。&lt;/li&gt;&lt;li&gt;检查传入参数个数。由于this引用被隐式传入，所以参数个数是实参个数+1。这里使用了AND指令是由于这里的参数个数存在了32-bit的低24-bit，高8位作为flag。&lt;/li&gt;&lt;li&gt;如果没有传入参数（除了this），则把undefined放入rcx寄存器。&lt;/li&gt;&lt;li&gt;把第一个参数放入rcx寄存器。&lt;/li&gt;&lt;li&gt;判断上面存入rcx的是否是对象指针。ChakraCore使用了float tagging，打上tag的值的第48-bit为0则其内容为指针，否则为其他值，如double, int。&lt;/li&gt;&lt;li&gt;已经判定第一个参数（RCX）位对象指针。ChakraCore里面对应JavaScript的Object对象的是DynamicObject，其偏移8的位置（如下图）存储了Js::Type对象的指针。这里的Type对象类似于v8的hidden class。在JIT编译的时候已经有profile信息。这里rax指向的类型对象的地址作为常量存在JIT生成的代码里就是从profile推导出来的。&lt;/li&gt;&lt;li&gt;判断当前的inline cache里面的类型是否匹配。第10步里检查的类型已经是常量，意味着传入任何其他类型的对象检查都会失败，如果直接退回（BailOut）interpreter，再重新JIT代价还是很大的。其实只要传入的参数的对象类型保持基本稳定，JIT生成的大部分代码还是有效，而不需要类型和最初JIT时profile里的类型一致。所以有了了inline cache（前面的常量也可以说是一种inline cache）。简单来看，它对应一个callsite，保存了访问的类型对象的地址和要访问的属性偏移，如果当前对象类型和inline cache里的一致的话，则使用inline cache里的偏移访问属性（进入第17步）。&lt;/li&gt;&lt;li&gt;从对象地址给定的偏移（0x10）获取属性，存入rbx。&lt;/li&gt;&lt;li&gt;JIT假定的类型和inline cache里面的类型都不匹配，调用&lt;a href=&quot;https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/Language/JavascriptOperators.cpp#L7180&quot; data-editable=&quot;true&quot; data-title=&quot;PatchGetValue&quot;&gt;PatchGetValue&lt;/a&gt;, 从本对象以及原型链里查找属性，根据查找的结果更新inline cache（PatchGetValue里面的Patch就是patch这个）。&lt;/li&gt;&lt;li&gt;把取得的属性从rbx复制到rax。&lt;/li&gt;&lt;li&gt;在第9步获取的不是对象指针的情况下（比如传入了一个数值而不是对象），bailout回interpreter执行，重新获取profile。&lt;/li&gt;&lt;li&gt;返回。&lt;/li&gt;&lt;li&gt;从inline cache里面获取属性偏移，取得属性值。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;以上就是一个最简单的方法JIT后的native code的简单描述，其中有些步骤还比较复杂 ，以后再专门展开。&lt;/p&gt;</description>
<author>Thomson</author>
<guid isPermaLink="false">23314157</guid>
<pubDate>Mon, 31 Oct 2016 12:39:32 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Java] 动态生成类的场景的考察</title>
<link>https://zhuanlan.zhihu.com/p/23297569</link>
<description>开个坑慢慢填哈。&lt;p&gt;============================================&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Oracle/Sun JDK / OpenJDK的Java SE中的场景&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;在Oracle/Sun JDK及OpenJDK内，动态生成类（字节码）的场景有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java 1.4之后的反射实现。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/548536&quot; data-editable=&quot;true&quot; data-title=&quot;关于反射调用方法的一个log&quot;&gt;关于反射调用方法的一个log&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Java 1.3开始&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html&quot; data-editable=&quot;true&quot; data-title=&quot;Proxy (Java Platform SE 8 )&quot; class=&quot;&quot;&gt;java.lang.reflect.Proxy&lt;/a&gt;的实现，会动态根据给定的接口和handler来生成类&lt;/li&gt;&lt;li&gt;Java 5开始的annotation，其背后的类也是动态生成的Proxy。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/1148983&quot; data-editable=&quot;true&quot; data-title=&quot;Java annotation的实例是什么类的？&quot;&gt;Java annotation的实例是什么类的？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Java 7开始的JSR 292实现的MethodHandle / LambdaForm到Java字节码的编译&lt;/li&gt;&lt;li&gt;Java 8开始的Nashorn将JavaScript编译为Java字节码&lt;/li&gt;&lt;li&gt;Java 8开始的Nashorn里的joni正则表达式库，将正则表达式编译到Java字节码&lt;/li&gt;&lt;li&gt;Java 8开始的默认的Java lambda表达式背后的字节码生成，相当于自动生成了跟手写的匿名内部类相似的东西。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/51491241/answer/126232275&quot; data-editable=&quot;true&quot; data-title=&quot;Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX 的回答&quot;&gt;Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX 的回答&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Java 9开始的indify string concatenation，对使用Java中“+”运算符来拼接字符串的表达式做动态字节码生成。传送门：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/280&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 280: Indify String Concatenation&quot;&gt;JEP 280: Indify String Concatenation&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;其中MethodHandle的LambdaForm实现与Nashorn都是比较新的实现，它们里面有些思路是相当有趣的。回头再展开来说。例如它们会为了有效地存储数据而根据需要的数据类型/结构来生成存储数据的对象。例如说Nashorn里实现可以存8个字段的JavaScript对象的背后的Java类，是一个叫做“JO8”的类，而这个类就是根据需要动态生成出来的。同理，MethodHandle中有一系列叫做“BoundMethodHandle”的东西，可以捕获参数的值（读作“currying”），其存储参数的类也是动态生成出来的，例如说Species_LII表示能按顺序保存1个引用类型、2个int类型字段的类。&lt;/p&gt;&lt;p&gt;Java 7新加入的invokedynamic指令现在被广泛应用于“compact encoding of boilerplate code”（我得想想怎么组织语言来用中文说…）。上面提到的Java lambda表达式、indify string concat都是这样的例子。&lt;/p&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;其它场景&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;在需要动态访问Java对象属性但又需要规避反射开销的地方，动态字节码生成也是很常见的。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;在JVM上实现的动态语言，要性能好的话，生成Java字节码也是必经之路。有些语言可以静态编译出Java Class（例如Groovy），而更多还是在运行时生成Class（有些可能可以缓存生成的Class）。除了前面提到的Nashorn外，动态生成字节码的还例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;JRuby&lt;/li&gt;&lt;li&gt;Jython&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;比完整的编程语言更轻量级的“表达式语言”（expression language）也很流行用动态字节码生成。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;MVEL&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;有些本来是可以静态编译的、在JVM上实现的语言，为了减小发布的JAR包大小，也有可能会选择用动态类生成来仅在运行时需要某些类的时候才将它们生成出来。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Scala&lt;/li&gt;&lt;li&gt;Fortress&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;有些模版引擎为了提升渲染速度，也会选择做字节码生成。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;各种JSP实现。例如Tomcat会把JSP先生成为Java源码，然后用Eclipse JDT（或者叫ECJ）将其编译到Java字节码。&lt;/li&gt;&lt;li&gt;淘宝以前尝试过将原本是在AST上解释执行来实现渲染的Velocity模版引擎，改造为将Velocity模版编译为等价的Java源码然后再编译到Java字节码的编译版。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;在动态做bytecode instrumentation的地方（或者说Java类的redefine / retransform）的地方，显然也会用到动态字节码生成。例如说：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;BTrace&lt;/li&gt;&lt;li&gt;某些AOP实现&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;有些测试框架会做mock，这些mock类也常常是通过proxy来实现的，所以也会用到上述场景中的其中一些（例如JDK自带的Proxy类）。&lt;/p&gt;&lt;br&gt;&lt;p&gt;============================================&lt;/p&gt;&lt;br&gt;&lt;p&gt;说到动态字节码生成，顺带考察一下一些常用的工具 / 库吧。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://asm.ow2.org/&quot; data-editable=&quot;true&quot; data-title=&quot;ASM&quot;&gt;ASM&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://bytebuddy.net/&quot; data-editable=&quot;true&quot; data-title=&quot;Byte Buddy&quot;&gt;Byte Buddy&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jboss-javassist.github.io/javassist/&quot; data-editable=&quot;true&quot; data-title=&quot;Javassist&quot;&gt;Javassist&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/cglib/cglib&quot; data-editable=&quot;true&quot; data-title=&quot;cglib&quot;&gt;cglib&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://commons.apache.org/proper/commons-bcel/&quot; data-editable=&quot;true&quot; data-title=&quot;BCEL&quot;&gt;BCEL&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;其它：&lt;a href=&quot;https://java-source.net/open-source/bytecode-libraries&quot; data-editable=&quot;true&quot; data-title=&quot;Open Source ByteCode Libraries in Java&quot;&gt;Open Source ByteCode Libraries in Java&lt;/a&gt;&lt;/li&gt;&lt;li&gt;（待补充）&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;============================================&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;还有啥有趣的大类别这里遗漏了的，或者是每个大类别下有哪些您觉得有趣的例子的，欢迎在评论中补充 ^_^ 我也会慢慢补充上我知道的一些，并且对某些点稍微展开来说说动态生成了怎样的类。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23297569</guid>
<pubDate>Sun, 30 Oct 2016 02:26:39 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Oracle开源了其Java AOT编译器</title>
<link>https://zhuanlan.zhihu.com/p/23247204</link>
<description>先放传送门：&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/hotspot-dev/2016-October/025033.html&quot; data-editable=&quot;true&quot; data-title=&quot;[9] RFR(L) 8166415: Integrate AOT tool JAOTC&quot; class=&quot;&quot;&gt;[9] RFR(L) 8166415: Integrate AOT tool JAOTC&lt;/a&gt;&lt;p&gt;这是一个基于Graal的AOT编译器，可以跟JDK9+的HotSpot VM搭配使用。这跟.NET的CLR一早就有的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6t9t5wcf.aspx&quot;&gt;NGen&lt;/a&gt;是同类，而跟&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn600165(v=vs.110).aspx&quot;&gt;.NET Native&lt;/a&gt; / &lt;a href=&quot;https://github.com/dotnet/corert&quot;&gt;CoreRT&lt;/a&gt;、&lt;a href=&quot;https://www.excelsiorjet.com/&quot;&gt;Excelsior JET&lt;/a&gt;之类并非同类。&lt;/p&gt;&lt;p&gt;这比我原本预期的要早得多。我原本以为会到明年甚至更之后才能看到这个项目开源出来。真是惊喜。&lt;/p&gt;&lt;p&gt;以后大家再也不能吐槽Java的默认实现没有AOT编译器了。只能吐槽这个AOT编译器如何不好用/不够用了（逃&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23247204</guid>
<pubDate>Thu, 27 Oct 2016 16:58:33 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[C++] GCC对C++虚函数调用的一个优化</title>
<link>https://zhuanlan.zhihu.com/p/23233548</link>
<description>这个专栏平时Java / JVM的内容偏多，今天混入一些新血液吧。来聊点C++的话题。&lt;p&gt;不过说起来还是跟JVM相关的内容。在JVM实现中，要达到高性能的一个重要方面就是要对虚方法调用做优化，要尽其所能将虚方法调用点去虚化（devirtualize），以便支持后续的优化。这是因为Java里非private的成员方法默认就是virtual的，大家愿意也好不愿意也好也很容易会写一大堆虚方法，再加上良好的面向对象风格的代码提倡要尽量写职责单一的小方法，一大堆小的虚方法如果不能好好优化，那性能是上不去的。&lt;/p&gt;&lt;p&gt;而在C++里，虚函数的开销则没Java那么引人关注，毕竟成员函数默认不是virtual的，而且还有&lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot; data-editable=&quot;true&quot; data-title=&quot;CRTP&quot;&gt;CRTP&lt;/a&gt;之类的奇技淫巧来向别的方向取舍开销。但始终，对虚函数有优化需求这点跟Java还是很相似的。&lt;/p&gt;&lt;p&gt;很多同学都会在学习了一些C++的基础知识之后就偏执地认为C++的虚函数分派总是通过对vtable（虚函数表）的间接调用来做的，并且虚函数调用无法被内联。事实上编译器优化发展了那么多年，这种事情又怎会没有进一步的优化呢。&lt;/p&gt;&lt;p&gt;今天要说的就是相对新一些的GCC（&lt;a href=&quot;https://gcc.gnu.org/gcc-4.9/changes.html&quot; data-editable=&quot;true&quot; data-title=&quot;GCC 4.9&quot;&gt;GCC 4.9&lt;/a&gt;或更高）里的一种优化，由-fdevirtualize-speculatively参数控制的“speculative devirtualization”，或者用JVM里更常用的叫法是“guarded devirtualization”。这个优化是Jan Hubicka大大在2013年添加到GCC中的：&lt;a href=&quot;https://gcc.gnu.org/ml/gcc-patches/2013-08/msg00551.html&quot; data-editable=&quot;true&quot; data-title=&quot;Speculative call support in the callgraph&quot;&gt;Speculative call support in the callgraph&lt;/a&gt;。正好这几天在调试我们的JVM的一个core dump，留意到我们的JVM的C++代码里有虚函数调用点被GCC应用上了这个优化，就顺手来写写。&lt;/p&gt;&lt;p&gt;让我们先来看个例子：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class Base {
  int value_;
public:
  virtual int foo() __attribute__ ((noinline)) {
    return 42 + this-&amp;gt;bar();
  }

  virtual int bar() {
    return value_;
  }
};

class Derived : public Base {
public:
  int bar() {
    return 256;
  }
};

int main() {
  Base* b = new Derived;
  return b-&amp;gt;foo();
}
&lt;/code&gt;&lt;p&gt;这个例子用GCC 4.9.2在-O2下编译，会发现Base::foo()里对bar()这个虚函数的调用就是普通的通过vtable分派的间接调用。用伪代码来说就是这样：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;// this-&amp;gt;bar()
bar_ptr = this-&amp;gt;_vptr[BAR_VTABLE_INDEX]; // load function entry point from vtable
tmp = bar_ptr();                         // indirect call&lt;/code&gt;&lt;p&gt;实际用GCC 4.9.2 -O2在Linux/x86-64上生成的Base::foo()函数的代码是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Base::foo():
        subq    $8, %rsp
        movq    (%rdi), %rax  # rax = this-&amp;gt;_vptr
        call    *8(%rax)      # call this-&amp;gt;_vptr[BAR_VTABLE_INDEX]
        addq    $8, %rsp
        addl    $42, %eax
        ret
&lt;/code&gt;&lt;p&gt;但是如果我们把上面代码例子中Derived::bar()的声明去掉，使得Derived类变成：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class Derived : public Base {
};&lt;/code&gt;&lt;p&gt;再重新编译这个实验代码，就会发现Base::foo()里对bar()的调用变成了这个样子：（继续伪代码）&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;// this-&amp;gt;bar()
bar_ptr = this-&amp;gt;_vptr[BAR_VTABLE_INDEX]; // load function entry point from vtable
if (bar_ptr == Base::bar) {
  // inlined Base::bar()
  tmp = this-&amp;gt;value_;
} else {
  tmp = bar_ptr();                       // normal indirect virtual call
}&lt;/code&gt;&lt;p&gt;实际用GCC 4.9.2 -O2在Linux/x86-64上生成的新版本Base::foo()函数的代码是这样的：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Base::foo():
        movq    (%rdi), %rax
        movq    8(%rax), %rax
        cmpq    Base::bar(), %rax
        jne     .L3
        movl    8(%rdi), %eax
        addl    $42, %eax
        ret
.L3:
        subq    $8, %rsp
        call    *%rax
        addq    $8, %rsp
        addl    $42, %eax
        ret
&lt;/code&gt;&lt;p&gt;这种先做条件检查，然后在检查通过的分支里把虚函数调用变为非虚调用（进而可以被内联）的做法，就叫做“speculative devirtualization”或者“guarded devirtualization”。&lt;/p&gt;&lt;p&gt;GCC具体采用的做法是“function-based guarded devirtualization”，正如上面例子所演示的，它的“guard”其实还是从vtable读出了函数指针，只是读出来之后不马上去调用该函数指针，而是检查一下它是否跟预期的函数指针一致，如果一致则认为检查通过。乍一看这挺傻的，访问vtable的内存访问开销一点都没少，而且还多了个条件分支；如果能内联目标函数的话那可能还值得，否则的话这么做的好处就没多少了。&lt;/p&gt;&lt;p&gt;正因为这个优化并非总是值得的，GCC采用了很保守的策略，只在应该能提升性能的地方采用这种做法。一种情况是通过静态的类层次分析（CHA），发现一个虚函数调用点可能调用的目标函数只有1个可能性，那就生成上面所演示的“speculative devirtualized”代码，这种情况不需要profiling信息的支持。如果在做了该优化后，后续优化没能把目标函数内联进来或者至少从目标函数获取某些有利于优化的信息的话，则会撤销该优化，恢复回到普通的vtable间接调用。&lt;/p&gt;&lt;p&gt;上面演示的例子，之所以最开始的版本bar()还是用普通vtable调用而去掉Derived::bar()之后则变为“speculative devirtualized”调用，就是因为要满足上述保守策略的“只有1个可能调用的目标”的条件。&lt;/p&gt;&lt;p&gt;既然“只有1个可能调用目标”了，为啥不干脆去掉检查变为纯粹的直接调用（进而可能被内联），而要保留一个检查并在检查失败的分支中还去做普通vtable间接调用呢？&lt;/p&gt;&lt;p&gt;这主要是因为对C++程序不一点总是能做真正完备的“全程序分析”——假如碰上共享库/动态链接库，这些库里的类层次状况只能当黑盒子看待，所以总得留下一条退路给类层次分析错误的时候还能正确执行程序。&lt;/p&gt;&lt;p&gt;==================================&lt;/p&gt;&lt;p&gt;GCC选择的guard形式并非唯一的可能性。这种形式的guard在JVM里也有研究和应用，例如说IBM的JVM就有过这种形式的devirtualization。&lt;/p&gt;&lt;p&gt;但HotSpot VM没有使用这种形式的guard。HotSpot VM如果选择做guarded devirtualization的话，只会用type-based guarded devirtualization，也就是说guard检查的是被调用对象的类型，而不是目标方法的地址。&lt;/p&gt;&lt;p&gt;Type-based与function-/method-based的guard各有取舍。前者开销更小，而后者可处理的情况更多。&lt;/p&gt;&lt;p&gt;还是用本文开头的例子，如果是type-based，就可能会生成这样的代码：（还是伪代码）&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;// this-&amp;gt;bar()
if (this-&amp;gt;_vptr == vtable_of(Derived)) {
  // inlined Derived::bar()
  tmp = 256;
} else {
  this-&amp;gt;_vptr[BAR_VTABLE_INDEX](); // normal indirect virtual call
}&lt;/code&gt;&lt;p&gt;这个guard的形式显然比function-based的更轻一些，只要做一次间接读（读出_vptr字段来），而不像function-based版额外再读出bar的vtable entry出来。&lt;/p&gt;&lt;p&gt;但假如我们要调用foo()，它也是一个虚方法，但在Base与Derived中只有一个版本的实现，用type-based guard就得写成：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;if (this-&amp;gt;_vptr == vtable_of(Base) || this-&amp;gt;_vptr == vtable_of(Derived))&lt;/code&gt;&lt;p&gt;这就未必比function-based版好了。&lt;/p&gt;&lt;br&gt;&lt;p&gt;最后放个传送门：&lt;a href=&quot;https://www.zhihu.com/question/34846173/answer/60302017&quot; data-editable=&quot;true&quot; data-title=&quot;HotSpot VM有没有对invokeinterface指令的方法表搜索进行优化？ - RednaxelaFX 的回答&quot;&gt;HotSpot VM有没有对invokeinterface指令的方法表搜索进行优化？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">23233548</guid>
<pubDate>Thu, 27 Oct 2016 16:54:38 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] IBM J9 JVM开源的消息正式宣布了——OpenJ9</title>
<link>https://zhuanlan.zhihu.com/p/22550958</link>
<description>昨天（2016-09-20 PDT）在旧金山举办的JavaOne上，IBM正式宣布了即将开源其J9 Java虚拟机的消息。开源版J9 VM的名字是：OpenJ9！&lt;p&gt;几天前这边才刚发&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22506697?refer=hllvm&quot;&gt;OMR/TR终于开源的消息&lt;/a&gt;，这不，J9开源说来就来。&lt;br&gt;&lt;/p&gt;&lt;p&gt;相关资料：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;JavaOne的演讲：J9: Under the Hood of the Next Open Source JVM [CON3014]&lt;/li&gt;&lt;ul&gt;&lt;li&gt;可惜这个演讲没有录像，只有演示稿：&lt;a href=&quot;http://www.slideshare.net/DanHeidinga/j9-under-the-hood-of-the-next-open-source-jvm&quot; data-title=&quot;J9: Under the Hood of the Next Open Source JVM - SlideShare&quot; class=&quot;&quot;&gt;J9: Under the Hood of the Next Open Source JVM - SlideShare&lt;/a&gt;。链接是好的，打不开的话请自备…&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;根据演示稿所述，IBM目前的计划是跟随IBM Java 9一同正式发布OpenJ9。掐指一算，这大概就是明年这个时候了吧…&lt;/p&gt;&lt;p&gt;以后可以看到更多关于J9内部工作原理的资料了。怎能不一颗赛艇！&lt;/p&gt;&lt;p&gt;引用上述演示稿中的一页：&lt;/p&gt;&lt;img src=&quot;v2-f311880185afab21c28ac3d804def914.png&quot; data-rawwidth=&quot;2494&quot; data-rawheight=&quot;1402&quot;&gt;&lt;p&gt;&amp;lt;- 清晰地表明了未来OMR、OpenJ9与IBM J9之间的关系：OMR将是最上游，OpenJ9基于OMR构建出一个完整的JVM，OpenJ9 + OpenJDK Java Class Library构成一个完整的Java运行时环境，然后在此基础上添加IBM的特化功能最终构成IBM发行版J9及其配套库。&lt;br&gt;&lt;/p&gt;&lt;p&gt;这跟OpenJDK与Oracle JDK之间的关系基本上是同一个模型。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">22550958</guid>
<pubDate>Wed, 21 Sep 2016 15:48:26 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
