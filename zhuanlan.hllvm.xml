<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 25 Dec 2015 08:49:37 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>[号外] 看图猜语言实现——答案</title>
<link>http://zhuanlan.zhihu.com/hllvm/20445566</link>
<description>&lt;p&gt;之前发的&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20416295&quot; class=&quot;internal&quot;&gt;[号外] 看图猜语言实现&lt;/a&gt;帖大概也不会有新的跟帖回答，是时候放答案了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实答案就在这个回答里：&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; class=&quot;internal&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一组图的关键字：J9&lt;br&gt;&lt;/li&gt;&lt;li&gt;第二组图的关键字：Testarossa&lt;br&gt;&lt;/li&gt;&lt;li&gt;第三组图的关键字：Modron&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;结合起来就是：&lt;/p&gt;&lt;p&gt;IBM J9 Java虚拟机，以及其使用的JIT编译器Testarossa，以及其GC框架Modron。&lt;/p&gt;&lt;p&gt;之前看到J9的开源项目——OMR的技术预览版——发布的消息实在是兴奋，手痒就发了这么个猜谜。&lt;/p&gt;&lt;p&gt;您猜对了么？&lt;/p&gt;&lt;br&gt;&lt;p&gt;祝大家圣诞快乐——如果您过这个节的话 &amp;gt;_&amp;lt; 只是应景说说&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20445566</guid>
<pubDate>Fri, 25 Dec 2015 07:59:01 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] 看图猜语言实现</title>
<link>http://zhuanlan.zhihu.com/hllvm/20416295</link>
<description>&lt;p&gt;结合这个专栏的主题以及我在知乎最近的动态，看下面的几张图猜一个&lt;b&gt;编程语言平台的实现的名字&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;所有图结合起来都是指同一个实现（可能指其中的某个部分），不是每组图对应一个语言/实现啥的。&lt;/b&gt;把图片分组是因为同一组的图隐含的是同一个单词。&lt;/p&gt;&lt;p&gt;&lt;b&gt;猜的是语言的实现的名字，不是编程语言的名字。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实应该很简单…相信评论里很快就会有人放答案了。有兴趣猜的话就先别看评论区嗯。&lt;/p&gt;（其实我以前一直想画张包含这些元素的图，但一直坑着…有大大有兴趣帮忙画一张不？）&lt;br&gt;&lt;br&gt;&lt;p&gt;1. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/92e222372976f4ba30f1fe71bc6064c8_b.jpg&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;999&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;999&quot; data-original=&quot;https://pic1.zhimg.com/92e222372976f4ba30f1fe71bc6064c8_r.jpg&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/7e428368fd6ac7eb57527ecd19e9230d_b.jpg&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;445&quot; class=&quot;content_image&quot; width=&quot;346&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;2. &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/1659d6008c54dc48e8e05fcde34abbc6_b.jpg&quot; data-rawwidth=&quot;2883&quot; data-rawheight=&quot;1365&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2883&quot; data-original=&quot;https://pic3.zhimg.com/1659d6008c54dc48e8e05fcde34abbc6_r.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/949f7fb0a7800cf3285e80e1ed5c0151_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;1464&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic2.zhimg.com/949f7fb0a7800cf3285e80e1ed5c0151_r.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/4be876f664b62583b66407e7139ea859_b.jpg&quot; data-rawwidth=&quot;696&quot; data-rawheight=&quot;696&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;696&quot; data-original=&quot;https://pic2.zhimg.com/4be876f664b62583b66407e7139ea859_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;3. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/ffc0bfe7ec5f13fe1493c2d2ac41785c_b.jpg&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;764&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/ffc0bfe7ec5f13fe1493c2d2ac41785c_r.jpg&quot;&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20416295</guid>
<pubDate>Mon, 14 Dec 2015 16:22:11 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>学习编程语言与编译优化的一个书单</title>
<link>http://zhuanlan.zhihu.com/hllvm/20130808</link>
<description>其实是想放张图：&lt;img src=&quot;https://pic3.zhimg.com/21e2e4bb3586ece2078fd6c3c65d4cbe_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;1228&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/21e2e4bb3586ece2078fd6c3c65d4cbe_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;（这个书单帖居然有那么多点赞，完全没料到。我这帖说的应该是很小众的内容才对？压力好大…）&lt;/p&gt;&lt;p&gt;要学习编程语言原理与编译/优化原理，有许多书可读。我的生活乐趣之一就是不断的读这个领域的各种书 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;但毕竟很多书覆盖的知识点或者说切入点都是类似的，只是为了学习知识而不是纯为了生活乐趣的话，倒没必要全都读了。每个方面挑些&lt;b&gt;适合自己偏好&lt;/b&gt;的好书读读就好。&lt;/p&gt;&lt;p&gt;这里挑了我放在办公室里的书的其中几本，供大家参考一下从入门到深入学习&lt;b&gt;偏编译优化方向的编程语言知识的路线图&lt;/b&gt;。编程语言原理涉及的知识面相当广，也有许多不同的细分方向，这里就只针对编译优化这个比较窄的方向做些推荐。&lt;/p&gt;&lt;p&gt;上图的书的阅读顺序是从上到下。欢迎大家评论和推荐更好的书 ^_^&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;书单&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这些书从上到下分别是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/3743526/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Third Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/10802357/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第三版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/5407246/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（英文版·第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（原版：&lt;a href=&quot;http://book.douban.com/subject/3023631/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Computer Systems: A Programmer&#39;s Perspective, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，中译版：&lt;a href=&quot;http://book.douban.com/subject/5333562/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（原书第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4117971/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（尚无中译版，图灵正在招译者：&lt;a href=&quot;http://www.ituring.com.cn/book/1308&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;图灵社区 : 图书  : 自制编译器&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/5288601/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Engineering a Compiler, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/20436488/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《编译器设计》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/1821532/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Advanced Compiler Design and Implementation》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/1400374/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《高级编译器设计与实现》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2359859/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《High-Performance Compilers for Parallel Computing》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（尚无中译版）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2126867/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Optimizing Compilers for Modern Architectures》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/1171448/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《现代体系结构的优化编译器》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;学习路线图&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这份书单中，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;头两本书用于了解大背景的。To get the big picture；&lt;br&gt;&lt;/li&gt;&lt;li&gt;中间两本是用来做编译原理入门的；&lt;br&gt;&lt;/li&gt;&lt;li&gt;最后三本用于深入学习编译与优化的知识。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这三个阶段里，每个阶段都可以有其它书可以替代。这些只是&lt;b&gt;适合我的偏好&lt;/b&gt;的选择而已。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;1. &lt;a href=&quot;http://book.douban.com/subject/3743526/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Third Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/10802357/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第三版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;2009年出版。简称PLP。这本书主要用于掌握编程语言方面的大背景——编程语言是什么、有哪些种类，实现编程语言的大体流程是怎样，在编程语言的设计与实现里都会用到些什么术语等。它的Part I和Part II不但讲解了编程语言常见的结构，也顺带提到了它们背后涉及的一些实现，其实比专门的编译原理书更适用于最初的入门。&lt;br&gt;&lt;/p&gt;&lt;p&gt;第三版目录在此：&lt;a href=&quot;https://www.cs.rochester.edu/u/scott/pragmatics/3e/toc.shtml&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PLP 3e Table of Contents&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;书中对许多概念的讲解在编程语言中有普适意义。例如说书中提到了“display”的概念，在讲stack frame的static link/static chain时提到可以使用display来减少需要的递归搜索的次数——对递归深度有固定上限的问题，可以把递归搜索的结果事先放在一个小数组里，这个数组就是“display”（裘老师译为“区头向量”）。这个“display”的概念其实可以引伸到各种递归问题，例如基于类的面向对象语言里的快速子类型检查就可以用上display；相关的，像是面向对象语言所用的虚函数表（vtable）其实也是一个变种display。&lt;/p&gt;&lt;p&gt;这本书顺带充当了我学习许多语言的入门书，拓宽了我的知识面。Scheme、Ada、Prolog之类的好些语言我都是从这本书开始真的接触并写代码来学习的。&lt;/p&gt;&lt;p&gt;我最初读的是裘宗燕老师翻译的&lt;a href=&quot;http://book.douban.com/subject/2152385/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第二版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。这是我喜欢的中译版技术书之一。虽然里面的术语译法跟我所喜欢的不完全一致，但完全没影响阅读。&lt;/p&gt;&lt;p&gt;评论里&lt;a href=&quot;https://www.zhihu.com/people/6f8a5a4cb5218434cf962c835b21afde&quot; data-hash=&quot;6f8a5a4cb5218434cf962c835b21afde&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@Snow Liang&quot; data-tip=&quot;p$b$6f8a5a4cb5218434cf962c835b21afde&quot;&gt;@Snow Liang&lt;/a&gt;提醒说这本书今年11月就要出第四版了：&lt;a href=&quot;http://book.douban.com/subject/26424018/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Fourth Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。真好！&lt;/p&gt;&lt;p&gt;作者&lt;a href=&quot;http://www.cs.rochester.edu/u/scott/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Michael L. Scott&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;是&lt;a href=&quot;http://www.rochester.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rochester大学&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的教授，虽然本职教学并不主要是编程语言相关，而是诸如事物内存（transactional memory）之类，但是他对这本书颇为投入而且也对成果感到很满意。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;2. &lt;a href=&quot;http://book.douban.com/subject/5407246/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（英文版·第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（原版：&lt;a href=&quot;http://book.douban.com/subject/3023631/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Computer Systems: A Programmer&#39;s Perspective, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，中译版：&lt;a href=&quot;http://book.douban.com/subject/5333562/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（原书第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;原书2008年出版。大名鼎鼎的CS:APP，是从软件角度学习系统知识必备的一本入门书，不用多说。这本书刚新出了第三版不过我还没舍得买，所以书单上只能先放着第二版。&lt;/p&gt;&lt;p&gt;前一本书PLP主要从上层介绍编程语言上的概念，而这本书主要介绍编程语言的概念会映射到怎样的系统层概念上。从编译器的角度看，PLP主要覆盖的是编程语言的词法、语法、语义的部分，是编译器前端的知识；而CS:APP则更关注把编程语言的概念映射到实际的CPU、内存、操作系统层面上，是编译器后端的知识。两者结合起来就完美的覆盖了学习编译器所需的知识面，对编译原理的全貌有一个把握。&lt;/p&gt;&lt;p&gt;国内的同学们是幸福的，这本书的影印版质量非常非常好，纸张、印刷都极其高质量，不能再多赞了！买本影印版感觉赚大了。中译版我没读过不过据说质量也不错。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;3. &lt;a href=&quot;http://book.douban.com/subject/4117971/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;（书名可以直译为：《写个普通的编译器——通过编写语言处理器来学习编译与运行时环境的原理》。呃真引进的话肯定不会这么译…）&lt;/p&gt;&lt;p&gt;2009年出版。这是本日文书。有那么多入门级编译器书，为啥我要选它来推荐？&lt;/p&gt;&lt;p&gt;因为我觉得这本书写得很实在，适合入门学习时形象地掌握整个编译流程，其中都有哪些环节，每个环节间又是如何互动的。在&lt;a href=&quot;http://book.douban.com/people/RednaxelaFX/all?sort=time&amp;amp;tags_sort=count&amp;amp;filter=all&amp;amp;tag=%E7%BC%96%E8%AF%91%E5%99%A8&amp;amp;mode=grid&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我读过或接触过的编译器书&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;里，它算是我最推荐的用于指导实际写第一个编译器的入门书。&lt;/p&gt;&lt;p&gt;这本书的知识点和难度大致都跟斯坦福的编译原理入门课CS143相近，结合两者来学习也是不错的选择。请参考另一帖：&lt;a href=&quot;http://www.zhihu.com/question/28679215/answer/43883727&quot; class=&quot;internal&quot;&gt;斯坦福大学编译原理课程质量怎么样？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这本书吸引我的特点有两个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从头到尾围绕一个完整可运行的简易编译器来讲解；完整配套源码在Github就有：&lt;a href=&quot;https://github.com/aamine/cbc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;aamine/cbc · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;覆盖了从词法/语法分析 -&amp;gt; 语义分析 -&amp;gt; 中间代码生成 -&amp;gt; 目标代码生成 -&amp;gt; 链接 -&amp;gt; 运行时环境的完整流程。并没有过于纠缠于其中的任一环节（特别是没有过于纠缠于前端部分），而是更关注整体流程，注重大局观。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这本书描述的是一个名为&lt;a href=&quot;https://github.com/aamine/cbc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;C♭&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（读作C-flat）语言的编译器cbc，使用Java实现，目标运行环境是Linux/x86。&lt;/p&gt;&lt;p&gt;C♭是一个C的简化版，简化的主要是宏相关的部分以及早期C一直延续下来的许多小细节；保留下来的部分覆盖了C的绝大部分功能，例如基本类型、函数、指针，struct/union等等，作为入门级编译器的源语言功能上正好适中。&lt;/p&gt;&lt;p&gt;cbc编译器的整体工作流程是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Cb源码
=&amp;gt; [ 词法分析 + 语法分析 ] =&amp;gt; // 由JavaCC生成
抽象语法树（AST）
=&amp;gt; [ Visitor模式的语义分析 ] =&amp;gt;
标注的抽象语法树（Annotated AST）
=&amp;gt; [ 中间代码生成 ] =&amp;gt; // 跟虎书的C版本非常相似，但代码风格比虎书好
树形中间代码（Tree IR）
=&amp;gt; [ 简单优化 ] =&amp;gt;
优化过的中间代码
=&amp;gt; [ 代码生成 ] =&amp;gt;    // 使用Java写的内部DSL来生成GNU as格式的汇编
                     // 支持可重定位与不可重定位两种版本的代码生成
GNU as格式的汇编
=&amp;gt; [[ GNU as ]] =&amp;gt;   // 汇编器
目标代码
=&amp;gt; [[ GNU ld ]] =&amp;gt;   // 链接器
ELF可执行文件 / 动态链接库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中用单中括号标注的环节是cbc自己实现的，而双中括号标注的部分则是依赖现成的工具实现。cbc生成的代码符合Linux/x86的C ABI，可以跟libc或者其它导出C ABI的库链接起来。&lt;/p&gt;&lt;p&gt;以此，C♭程序从源码到可执行文件到运行时环境的整个流程都在本书中有所体现。&lt;br&gt;&lt;/p&gt;&lt;p&gt;细心的读者可能会问：cbc不用分配寄存器么？答案是它用了非常非常简易的分配方式——“栈顶缓存”——直接融合在代码生成环节中。详细请见另一帖：&lt;a href=&quot;http://www.zhihu.com/question/29355187/answer/51935409&quot; class=&quot;internal&quot;&gt;寄存器分配问题？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;p&gt;要在中文社区推广这本书，光靠日文原版还是太困难。就等有爱人士到图灵社区去接下翻译任务啦：&lt;a href=&quot;http://www.ituring.com.cn/book/1308&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;图灵社区 : 图书 : 自制编译器&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，我可以提供充分的技术支持 :-)&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;4. &lt;a href=&quot;http://book.douban.com/subject/5288601/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Engineering a Compiler, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/20436488/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《编译器设计》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;2011年出版。简称EAC2。据说有人把这本书称为“橡书”但我不知道这种叫法的来源是啥。书的封面图是“The Landing of the Ark”。&lt;/p&gt;&lt;p&gt;这本书是编译原理教材里我最喜欢的一本，没有之一。它用作入门时的第一本书也行，放在『ふつうのコンパイラをつくろう』之类的简易入门书之后作为正式学习编译原理的教材也很合适。它覆盖的知识面足以应付初级到中级编译原理的学习，内容夯实，脉络清晰，语言既干练又不失形象。&lt;/p&gt;&lt;p&gt;而且它选择讲解的知识点都是相当实用且与时俱进的——可能就除了寄存器分配的地方没有专门的小节讲线性扫描寄存器分配算法（Linear-scan register allocation）不够与时俱进——其它讲的都是当代编译器里常见而实用的内容。&lt;/p&gt;&lt;p&gt;例如说第9章讲数据流分析的部分，主要结合SSA形式来展开，比起特别传统的非要从非SSA形式讲起、最后在进阶部分提一下SSA形式的做法要现代多了。&lt;/p&gt;&lt;p&gt;EAC2目录在此：&lt;a href=&quot;http://www.elsevier.com/wps/find/bookdescription.cws_home/724559/description#description&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Elsevier&#39;s site for Engineering a Compiler&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本书作者&lt;a href=&quot;http://www.cs.rice.edu/~keith/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Keith D. Cooper&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;http://www.cs.rice.edu/~linda/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Linda Torczon&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;都是&lt;a href=&quot;http://www.rice.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice大学&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的名教授，而且两人同为&lt;a href=&quot;http://www.cs.rice.edu/~ken/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ken Kennedy&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的学生。后面会再提到他们的关系。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;5. &lt;a href=&quot;http://book.douban.com/subject/1821532/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Advanced Compiler Design and Implementation》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/1400374/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《高级编译器设计与实现》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;1997年出版。大名鼎鼎的“鲸书”，在编译原理的经典动物书“龙虎鲸”中排得上号的进阶读物。从这本书开始就要深入学习编译优化了。&lt;/p&gt;&lt;p&gt;这本书只关心优化编译器的中、后端涉及优化的部分，而完全不涉及前端的词法/语法分析或语言相关的语义分析。因而它虽然不适合作为初学教材，但在进阶学习时非常好用——完全没废话，直达痛点。&lt;/p&gt;&lt;p&gt;本书作者Steven Stanley Muchnick不但在学术界很有影响，在业界也参与了一些重量级项目，例如HP的PA-RISC的设计及其优化编译器的实现，然后是Sun的SPARC的设计及其优化编译器的实现。鲸书里介绍的编译器优化技术都是实打实的，理论结合实际，边读边实践很痛快。&lt;/p&gt;&lt;p&gt;要是还能再来个新版本就好了…&lt;/p&gt;&lt;br&gt;&lt;p&gt;接下来要介绍的两本其实只是在鲸书的基础上拓展一下视野用的，免得受单一作者的偏好而限制了自己的选择范围。这两本都是相对偏老的书，以Fortran编译器中的优化为主要介绍对象，重点介绍数据依赖分析、循环优化、自动向量化之类的话题，在现在各种主流CPU都强力推出SIMD指令的潮流下并不过时，反而相当值得参考。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;6. &lt;a href=&quot;http://book.douban.com/subject/2359859/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《High-Performance Compilers for Parallel Computing》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;1995年出版的老书。尚未有中译版，以后也不太可能会有吧。&lt;/p&gt;&lt;p&gt;作者Michael Wolfe。我现在就职的Azul Systems有位元老员工叫做Michael Wolf，是我们的pauseless GC算法的设计者之一，非常牛。一开始我是因为把名字看错了才买的这本书，却有意想不到的收获。&lt;/p&gt;&lt;p&gt;因为这本书很奇葩！&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;7. &lt;a href=&quot;http://book.douban.com/subject/2126867/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Optimizing Compilers for Modern Architectures》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;http://book.douban.com/subject/1171448/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《现代体系结构的优化编译器》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;br&gt;&lt;p&gt;（待补充）&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;8. &lt;a href=&quot;http://ssabook.gforge.inria.fr/latest/book.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Static Single Assignment Book》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Bonus：这是一本还在写作中的书，因此没有纸质版，暂时只有电子版。不过对许多本来就不想买书的同学们来说或许是个福音吧（逃&lt;/p&gt;&lt;p&gt;静态单赋值形式（SSA Form）是现代主流编译器都会采用的IR形式，而且越来越多编译器开始以SSA形式的IR为主。&lt;/p&gt;&lt;p&gt;最极致的是像LLVM那样采用单层IR，而且这个IR必须是SSA形式的。许多人觉得LLVM IR操作起来方便的原因之一就是许多算法在SSA形式下表达起来很简洁直观。说来，因为LLVM IR本身不是Memory-SSA或Heap-SSA形式，并不显式跟踪内存中的赋值，所以前端在生成LLVM IR时倒不必总是自己构建SSA形式，而可以用alloca分配局部变量然后让LLVM自带的mem2reg去构建SSA形式，所以这种SSA形式的IR也没有给前端增加负担，是个双赢。&lt;/p&gt;&lt;p&gt;既然SSA形式这么重要这么流行，应该有本书专门以它为线索来介绍编译原理的知识对不对？这本书就是如此。它是许多作者合写的，每一章都像是一篇相对独立的论文一样，围绕SSA形式介绍了编译器中后端的方方面面。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;还缺什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实我还很希望能在书单里有几本介绍对JIT编译器或者说运行时编译做重点讲解的书，以及对动态类型语言的编译优化做重点讲解的书。可惜这些方面的论文虽然不少，但却没有现成的书对其做系统性的讲解。&lt;/p&gt;&lt;p&gt;好在万变不离其宗，JIT编译器与动态语言优化其实都还是在传统的编译原理基础上的进化，掌握好基础的话这些话题都会变得更易于理解。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;一些背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;“&lt;a href=&quot;http://www.rice.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;系”的编译器大牛们：&lt;a href=&quot;http://www.cs.rice.edu/CS/compilers/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice Compiler Group&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;“&lt;a href=&quot;http://www.stanford.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Stanford&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;系”的编译器大牛们：&lt;a href=&quot;http://suif.stanford.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The SUIF Group&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;==========================================================&lt;/p&gt;&lt;p&gt;顺带给想八卦的同学们，这是我办公室书架的全景：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/a25fcec4cae70aaa039802eaa94a9a4e_b.jpg&quot; data-rawwidth=&quot;2048&quot; data-rawheight=&quot;1085&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2048&quot; data-original=&quot;https://pic3.zhimg.com/a25fcec4cae70aaa039802eaa94a9a4e_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;有不少眼熟的书对不对？^_^&lt;/p&gt;&lt;p&gt;还有更多书放在家里的书架上。家里的书架已经快溢出了所以不得不把越来越多书搬到办公室来…&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20130808</guid>
<pubDate>Mon, 27 Jul 2015 12:53:52 +0800</pubDate>
<media:thumbnail url="https://pic3.zhimg.com/b806999aa557e5e839cf51bccbd4d8e2_b.jpg" />
</item>
<item>
<title>Lambda 表达式无法定义的一个算符</title>
<link>http://zhuanlan.zhihu.com/hllvm/20049022</link>
<description>很多人都问我如何理解 yield 云云，事实上 yield 以及其他的类似物包括 call/cc 都是用 Lambda 演算&lt;b&gt;无法定义&lt;/b&gt;的东西。&lt;p&gt;就比如 call/cc 吧，如果我们规定 Continuation 永不返回，或者说它是&lt;b&gt;发散&lt;/b&gt;的，那么它的类型可以唯一指定成&lt;img src=&quot;https://zhihu.com/equation?tex=%5Calpha%5Crightarrow%5Cbot&quot; alt=&quot;\alpha\rightarrow\bot&quot; eeimg=&quot;1&quot;&gt;，或者说&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cneg%5Calpha&quot; alt=&quot;\neg\alpha&quot; eeimg=&quot;1&quot;&gt;。那么考虑 call/cc 算子，它的类型首先肯定得满足&lt;img src=&quot;https://zhihu.com/equation?tex=%28%28%5Calpha%5Crightarrow%5Cbot%29%5Crightarrow%5Cbeta%29%5Crightarrow%5Cgamma&quot; alt=&quot;((\alpha\rightarrow\bot)\rightarrow\beta)\rightarrow\gamma&quot; eeimg=&quot;1&quot;&gt;，而考察 call/cc(&lt;i&gt;f&lt;/i&gt;) 两种可能的返回情况——通过（丢给 &lt;i&gt;f&lt;/i&gt; 的） continuation 返回或者 &lt;i&gt;f&lt;/i&gt; 正常返回——那么可以得到等式&lt;img src=&quot;https://zhihu.com/equation?tex=%5Calpha%3D%5Cbeta%3D%5Cgamma&quot; alt=&quot;\alpha=\beta=\gamma&quot; eeimg=&quot;1&quot;&gt;，即：&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7Bcall%2Fcc%7D%3A%28%5Cneg%5Calpha%5Crightarrow%5Calpha%29%5Crightarrow%5Calpha&quot; alt=&quot;\mathrm{call/cc}:(\neg\alpha\rightarrow\alpha)\rightarrow\alpha&quot; eeimg=&quot;1&quot;&gt;。若允许 Continuation 返回，则 call/cc 的类型可定为&lt;img src=&quot;https://zhihu.com/equation?tex=%28%28%5Calpha%5Crightarrow%5Cbeta%29%5Crightarrow%5Calpha%29%5Crightarrow%5Calpha&quot; alt=&quot;((\alpha\rightarrow\beta)\rightarrow\alpha)\rightarrow\alpha&quot; eeimg=&quot;1&quot;&gt;。接下来将证明这条定律可以推出排中律（使用 LJ 推理系统）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;α ⊢ &lt;/b&gt;&lt;b&gt;α&lt;/b&gt; [I]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α ⊢ α ∨ &lt;/b&gt;&lt;b&gt;¬α&lt;/b&gt; [∨R](1);&lt;/li&gt;&lt;li&gt;&lt;b&gt;⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [I]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [WL](2);&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, (α ∨ ¬α) → ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [→L, (1), (2)](3);&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [→L, (1), (3)]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, ((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ ⊥&lt;/b&gt; [WL]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ α → ⊥&lt;/b&gt; [→R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ α ∨ &lt;/b&gt;&lt;b&gt;¬α&lt;/b&gt; [∨R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ ⊢&lt;/b&gt;&lt;b&gt; ((α ∨ ¬α) → ¬(α ∨ ¬α)) → &lt;/b&gt;&lt;b&gt;(α ∨ ¬α)&lt;/b&gt; [→R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ ⊢ α ∨ ¬&lt;/b&gt;&lt;b&gt;α&lt;/b&gt; [MP，代换律]&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;换言之，如果 call/cc 是 Lambda 可表的，则意味着直觉自然演绎可以证明排中律——这显然不可能，于是 call/cc 必然是 Lambda 不可表，它必须作为单独的算符扩充到 Lambda 演算的体系里来。</description>
<author>Belleve</author>
<guid isPermaLink="false">20049022</guid>
<pubDate>Fri, 29 May 2015 05:15:41 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>六离合释：指针的 Hoare Logic——Separation Logic</title>
<link>http://zhuanlan.zhihu.com/hllvm/20030603</link>
<description>Hoare Logic 是证明程序正确性的法宝，具体而言，它给出了逐步推理程序正确性的方法。Hoare Logic 使用符号 {&lt;i&gt;P&lt;/i&gt;} &lt;b&gt;e&lt;/b&gt; {&lt;i&gt;R&lt;/i&gt;} 表示程序步骤 &lt;b&gt;e&lt;/b&gt; 执行前后的行为：若断言 &lt;i&gt;P&lt;/i&gt; 在执行前成立，则 &lt;b&gt;e&lt;/b&gt; 执行后断言 &lt;i&gt;R&lt;/i&gt; 成立。一些推理规则是很显而易见的：比如&lt;p&gt;&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cfrac+%7B%5C%7BP%5C%7D%5C+%5Cmathbf%7Be%7D%5C+%5C%7BQ%5C%7D%5C+%2C+%5C+%5C%7BQ%5C%7D%5C+%5Cmathbf%7Bf%7D%5C+%5C%7BR%5C%7D+%7D+%7B%5C%7BP%5C%7D%5C+%5Cmathbf%7Be%3Bf%7D%5C+%5C%7BR%5C%7D%7D&quot; alt=&quot;\frac {\{P\}\ \mathbf{e}\ \{Q\}\ , \ \{Q\}\ \mathbf{f}\ \{R\} } {\{P\}\ \mathbf{e;f}\ \{R\}}&quot; eeimg=&quot;1&quot;&gt;(sequent)&lt;br&gt;&lt;/p&gt;&lt;p&gt;Hoare Logic 推出后在程序正确性证明方面成为了利器，然而它有一点没有包含，就是没有处理指针，于是 John C. Reynolds 等扩展的 Separation Logic 很好地处理了指针相关的内容。&lt;/p&gt;&lt;p&gt;Separation Logic 中的程序状态分为两个部分：栈区 &lt;i&gt;s&lt;/i&gt; 和堆区 &lt;i&gt;h&lt;/i&gt;，堆 &lt;i&gt;h&lt;/i&gt; 定义为地址到值的函数。两个堆&lt;b&gt;正交&lt;/b&gt;若且唯若其定义域不交，记作&lt;img src=&quot;https://zhihu.com/equation?tex=h_1+%5Cbot+h_2&quot; alt=&quot;h_1 \bot h_2&quot; eeimg=&quot;1&quot;&gt;。Separation Logic 定义了四个附加的断言符号来声明堆的性质：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;断言 &lt;b&gt;emp &lt;/b&gt;表示堆的定义域是空的&lt;/li&gt;&lt;li&gt;算符&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmapsto&quot; alt=&quot;\mapsto&quot; eeimg=&quot;1&quot;&gt;表示指针指向，即若&lt;img src=&quot;https://zhihu.com/equation?tex=s%2Ch+%5Cmodels+e%5Cmapsto+f&quot; alt=&quot;s,h \models e\mapsto f&quot; eeimg=&quot;1&quot;&gt;当且仅当&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7Bdom%7D%5C+h%3D%5C%7Be%5C%7D&quot; alt=&quot;\mathrm{dom}\ h=\{e\}&quot; eeimg=&quot;1&quot;&gt;且&lt;img src=&quot;https://zhihu.com/equation?tex=h%28e%29%3Df&quot; alt=&quot;h(e)=f&quot; eeimg=&quot;1&quot;&gt;&lt;/li&gt;&lt;li&gt;算符 * 叫做&lt;b&gt;分离合取&lt;/b&gt;，若状态 (&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;h&lt;/i&gt;) 满足 &lt;i&gt;P&lt;/i&gt; * &lt;i&gt;Q&lt;/i&gt;，则 &lt;i&gt;h&lt;/i&gt; 一定可以拆分成正交的两个部分 &lt;i&gt;j&lt;/i&gt;&lt;i&gt;k&lt;/i&gt; 使得 (&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;j&lt;/i&gt;) 满足 &lt;i&gt;P&lt;/i&gt;，(&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;k&lt;/i&gt;) 满足 &lt;i&gt;Q&lt;/i&gt;&lt;/li&gt;&lt;li&gt;算符 &lt;img src=&quot;https://zhihu.com/equation?tex=-%5C%21%5C%21%5Cast&quot; alt=&quot;-\!\!\ast&quot; eeimg=&quot;1&quot;&gt; 称为「法杖」或者&lt;b&gt;分离蕴含&lt;/b&gt;，若状态&lt;img src=&quot;https://zhihu.com/equation?tex=s%2Ch%5Cmodels+P-%5C%21%5C%21%5Cast+Q&quot; alt=&quot;s,h\models P-\!\!\ast Q&quot; eeimg=&quot;1&quot;&gt;，那么就表示对所有和 &lt;i&gt;h&lt;/i&gt; 正交且满足 &lt;i&gt;P&lt;/i&gt; 的堆 &lt;i&gt;j&lt;/i&gt;，有&lt;img src=&quot;https://zhihu.com/equation?tex=s%2C%28h%5Ccup+j%29%5Cmodels++Q&quot; alt=&quot;s,(h\cup j)\models  Q&quot; eeimg=&quot;1&quot;&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;分离合取和分离蕴含与逻辑学中的合取蕴含极其相似（例如，分离蕴含的前件为假时也成立），Separation Logic 也可以定义一条肯定前件：&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cfrac%7Bs%2C+h+%5Cmodels+P+%5Cast+%28P+-%5C%21%5C%21%5Cast%5C%2C+Q%29%7D%7Bs%2C+h+%5Cmodels+Q%7D&quot; alt=&quot;\frac{s, h \models P \ast (P -\!\!\ast\, Q)}{s, h \models Q}&quot; eeimg=&quot;1&quot;&gt;。&lt;p&gt;在这四个算符的基础上 Reynolds 等还定义了其他的符号，如对定义域没有要求的箭头&lt;img src=&quot;https://zhihu.com/equation?tex=%5Chookrightarrow&quot; alt=&quot;\hookrightarrow&quot; eeimg=&quot;1&quot;&gt;（表示「内存中有一项……」而非「只有一项」）和指向连续内存的记号&lt;img src=&quot;https://zhihu.com/equation?tex=e%5Cmapsto+f_1%2C+f_2%2C+...%2C+f_n&quot; alt=&quot;e\mapsto f_1, f_2, ..., f_n&quot; eeimg=&quot;1&quot;&gt;等。下图表示了&lt;img src=&quot;https://zhihu.com/equation?tex=x%5Cmapsto+3%2Cy%5Cast+y%5Cmapsto+3%2Cx&quot; alt=&quot;x\mapsto 3,y\ast y\mapsto 3,x&quot; eeimg=&quot;1&quot;&gt;对应的内存情形：&lt;img src=&quot;https://pic1.zhimg.com/4ac79f5c3e5318d9422fe2c336b7cbe0_b.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;261&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;592&quot; data-original=&quot;https://pic1.zhimg.com/4ac79f5c3e5318d9422fe2c336b7cbe0_r.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;而 &lt;img src=&quot;https://zhihu.com/equation?tex=x%5Cmapsto+3%2Cy%5Cwedge+y%5Cmapsto+3%2Cx&quot; alt=&quot;x\mapsto 3,y\wedge y\mapsto 3,x&quot; eeimg=&quot;1&quot;&gt;则是：&lt;img src=&quot;https://pic4.zhimg.com/7f0e84fb98b6e876ac909a360cf1540f_b.jpg&quot; data-rawwidth=&quot;299&quot; data-rawheight=&quot;254&quot; class=&quot;content_image&quot; width=&quot;299&quot;&gt;因为被&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cwedge&quot; alt=&quot;\wedge&quot; eeimg=&quot;1&quot;&gt;连接的两条子断言描述的是同一片内存。&lt;/p&gt;&lt;p&gt;Separation Logic 用于证明程序正确性的方式和 Hoare Logic 相似，但是有额外的 5 条推理规则。&lt;/p&gt;&lt;p&gt;首先是「框法则」，一个「好」程序不应该干涉和它不相关的内容，换言之如果程序满足 {&lt;i&gt;P&lt;/i&gt;} &lt;b&gt;e&lt;/b&gt; {&lt;i&gt;Q&lt;/i&gt;}，那么对于任意的内存断言 &lt;i&gt;R&lt;/i&gt;，若 &lt;i&gt;R&lt;/i&gt; 中没有被 &lt;b&gt;e&lt;/b&gt; 指向的目标，则一定有 {&lt;i&gt;P&lt;/i&gt; * &lt;i&gt;R&lt;/i&gt;} &lt;b&gt;e&lt;/b&gt; {&lt;i&gt;Q&lt;/i&gt; * &lt;i&gt;R&lt;/i&gt;}。&lt;/p&gt;&lt;p&gt;对指针赋值 &lt;b&gt;*e = f&lt;/b&gt; 而言，Separation Logic 定义了公理&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be%5Cmapsto+x%5C%7D%5C+%5Cmathbf%7B%2Ae%3Df%7D%5C+%5C%7Be%5Cmapsto+f%5C%7D&quot; alt=&quot;\{e\mapsto x\}\ \mathbf{*e=f}\ \{e\mapsto f\}&quot; eeimg=&quot;1&quot;&gt;，这个公理实际上明确了很多东西：除了被指向的目标外，还要求指针 &lt;b&gt;e&lt;/b&gt; 已经被分配了内存，野指针就是被这么消灭的。&lt;/p&gt;&lt;p&gt;解分配 &lt;b&gt;dispose e&lt;/b&gt; 的规则也很明确：&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be%5Cmapsto+x%5C%7D%5C+%5Cmathbf%7Bdispose%5C+e%7D%5C+%5C%7B%5Cmathbf%7Bemp%7D%5C%7D&quot; alt=&quot;\{e\mapsto x\}\ \mathbf{dispose\ e}\ \{\mathbf{emp}\}&quot; eeimg=&quot;1&quot;&gt;，一个（只有 e 的）堆被释放内存之后，它就空啦！&lt;/p&gt;&lt;p&gt;分配内存 &lt;b&gt;e = new(v)&lt;/b&gt; 的规则稍有些复杂：&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be+%3D+v%27+%5Cwedge%5Cmathbf%7Bemp%7D+%5C%7D%5C+%5Cmathbf%7Be%3Dnew%28v%29+%7D+%5C+%5C%7Be%5Cmapsto+v%5C%7D&quot; alt=&quot;\{e = v&#39; \wedge\mathbf{emp} \}\ \mathbf{e=new(v) } \ \{e\mapsto v\}&quot; eeimg=&quot;1&quot;&gt;（&lt;i&gt;v&#39;&lt;/i&gt; 和 &lt;i&gt;e&lt;/i&gt; 彼此不同），Separation Logic 不允许分配内存后不初始化，所以 &lt;b&gt;new&lt;/b&gt; 都是带初始值的。&lt;/p&gt;&lt;p&gt;最后一条推理规则是针对解引用 &lt;b&gt;e = *f&lt;/b&gt; 的：&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be%3Dv%27%5Cwedge+f%5Cmapsto+v%5C%7D%5C+%5Cmathbf%7Be%3D%2Af%7D%5C+%5C%7Be%3Dv%5Cwedge+f%5Cmapsto+v%5C%7D&quot; alt=&quot;\{e=v&#39;\wedge f\mapsto v\}\ \mathbf{e=*f}\ \{e=v\wedge f\mapsto v\}&quot; eeimg=&quot;1&quot;&gt;（&lt;i&gt;v&lt;/i&gt;, &lt;i&gt;v&#39;&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt; 彼此不同）&lt;/p&gt;&lt;p&gt;在 Separation Logic 推出之后许多人（包括发明者 Reynolds 等在内）都对其进行了各种扩展，比如针对并行的（各位可想想互相独立的并行进程&lt;img src=&quot;https://zhihu.com/equation?tex=p%5C+%7C%7C%5C+q&quot; alt=&quot;p\ ||\ q&quot; eeimg=&quot;1&quot;&gt;的推理规则怎么写），处理垃圾收集的，等等。&lt;/p&gt;</description>
<author>Belleve</author>
<guid isPermaLink="false">20030603</guid>
<pubDate>Thu, 14 May 2015 16:27:07 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>JIT编译，动态编译与自适应动态编译</title>
<link>http://zhuanlan.zhihu.com/hllvm/19977592</link>
<description>&lt;p&gt;在微博上看到有人在推广这篇介绍Visual C++与RyuJIT的文章：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/84712/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;每个程序员都应当知道的编译器优化知识&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;（原文：&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/dn904673.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Compilers - What Every Programmer Should Know About Compiler Optimizations&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;, MSDN Magazine 2015-02）&lt;/p&gt;&lt;p&gt;这篇文章总体来说写得还不错。不过在描述RyuJIT的功能时略微夸大了一些：&lt;/p&gt;&lt;blockquote&gt;What’s the difference between RyuJIT and Visual C++ in terms of optimization capabilities? Because it does its work at run time, RyuJIT can perform optimizations that Visual C++ can’t. &lt;b&gt;For example, at run time, RyuJIT might be able to determine that the condition of an if statement is never true in this particular run of the application and, therefore, it can be optimized away.&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;这说的主要是一种&lt;a href=&quot;http://en.wikipedia.org/wiki/Profile-guided_optimization&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PGO优化（profile-guided optimization）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的效果（注1）。虽然“理论上说”这是可能的，但CLR使用JIT编译器的方式使得RyuJIT实际上无法在JIT编译时做到这种优化。就像评论里&lt;a href=&quot;https://www.zhihu.com/people/d073f194bcabc1cec5ef69d0b534de99&quot; data-hash=&quot;d073f194bcabc1cec5ef69d0b534de99&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@空明流转&quot; data-tip=&quot;p$b$d073f194bcabc1cec5ef69d0b534de99&quot;&gt;@空明流转&lt;/a&gt;大大说的：&lt;/p&gt;&lt;blockquote&gt;我是觉得，“对JIT编译器抱有过高期望”一直都是非编译器行业的一种长期偏见。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;我完全同意。所以才要来解剖一下。&lt;/p&gt;想起之前回答过的一个问题：&lt;a href=&quot;http://www.zhihu.com/question/26913901/answer/35303563&quot; class=&quot;internal&quot;&gt;HotSpot是较新的Java虚拟机技术，用来代替JIT技术,那么HotSpot和JIT是共存的吗？ - RednaxelaFX 的回答&lt;/a&gt;&lt;p&gt;本文想写的东西有一半在上面的链接里，请先读完它在继续向后阅读后文。重点是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;动态编译（dynamic compilation）&lt;/b&gt;指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation）。&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;JIT编译（just-in-time compilation）&lt;/b&gt;狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。&lt;/li&gt;&lt;li&gt;JIT编译一词后来被泛化，时常与动态编译等价；但要注意宽泛与狭义的JIT编译所指的区别。&lt;/li&gt;&lt;li&gt;&lt;b&gt;自适应动态编译（adaptive dynamic compilation）&lt;/b&gt;也是一种动态编译，但它通常执行的时机比JIT编译迟，先让程序“以某种形式”先运行起来，收集一些信息之后再做动态编译。这样的编译可以更加优化，可以很自然的融入PGO优化。这个“某种形式”可以称为“baseline execution“，可以由解释器或简单的JIT编译器承担。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;CLR，JIT编译与PGO&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;针对CLR / RyuJIT的场景稍微展开一下。&lt;/p&gt;&lt;p&gt;CLR的执行引擎的模型是“纯编译的单层JIT编译器“。所有被执行的有MSIL方法体的方法，要么被NGen事先编译成机器码了（PreJIT），要么在方法第一次被调用前进行JIT编译到机器码；总之就是MSIL要编译成机器码之后才被执行。&lt;/p&gt;&lt;p&gt;在正常执行时，每个有MSIL方法体的方法只有一次被编译的机会；一旦被编译过了就雷打不动了。对单次执行来说，CLR这种“单层JIT编译、只编译一次“的模型意味着代码被编译的时候还一次都没被执行过，也就无从借助运行时收集的profile信息来做有针对性的优化。&lt;/p&gt;&lt;p&gt;与之相对，自适应动态编译由于可以等程序执行了一段时间之后才做编译，所以有充分时间收集profile并利用profile来优化，经典例子就是收集分支跳转的次数，看taken分支还是not-taken分支的次数多。这样才可以做到本文开头引用的那段文字所描述的优化。&lt;/p&gt;&lt;p&gt;从.NET 4.5开始，CLR支持一个新功能叫做&lt;a href=&quot;http://blogs.msdn.com/b/davbr/archive/2011/10/12/rejit-a-how-to-guide.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ReJIT&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，用于支持managed profiler通过动态插桩（instrument）来收集性能数据（profile）。动态插桩意味着修改某个已有方法的MSIL方法体，所以在修改过后需要重新JIT编译才可以执行，因而得名ReJIT。注意ReJIT功能自身并不用于收集profile；收集profile的是CLR外部的managed profiler。所以收集到的profile也无法供给CLR的JIT编译器使用。&lt;/p&gt;&lt;p&gt;这与CLR正常执行时的模型其实仍然一致：每个MSIL方法体仍然只有一次被编译的机会；所谓“重新JIT编译“编译的是新的MSIL方法体。&lt;/p&gt;&lt;p&gt;.NET 4.5还引入了&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/10/18/an-easy-solution-for-improving-app-launch-performance.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;“Multicore JIT”&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;：在第一次运行程序时，用recording mode记录下哪些方法被JIT编译过，写入profile文件；以后执行可以用playback mode在后台线程先JIT编译这个列表里的方法，这样等到应用真的第一次调用某个方法时它可能已经被JIT编译好了。这是JIT编译的一种特殊做法，虽然没有脱离JIT编译的范畴但增加了一个自由度。&lt;br&gt;&lt;/p&gt;&lt;p&gt;当前这个Multicore JIT的设计只针对程序启动速度优化，它只观察和记录JIT编译活动，生成的profile粒度太粗，仅是“被JIT编译过的方法的列表“，而不包含任何细粒度的profiling信息（例如说条件分支、虚方法的被调用对象的实际类型等）。所以仍然做不到本文开头所说的PGO优化。&lt;/p&gt;&lt;p&gt;但基于这个架构，后续开发完全可以添加更多功能，例如在recording mode中让JIT编译器生成收集profile的代码，收集细粒度profile（例如类型信息、分支跳转情况等），并将收集到的profile写入文件；后续执行就可以根据细粒度profile来做高度优化的编译。&lt;/p&gt;&lt;p&gt;其实.NET 4.5已经有了类似的PGO功能，但不用于JIT编译场景而用于NGen（AOT编译）场景。这就是&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/hh873180(v=vs.110).aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MPGO（managed profile-guided optimization）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。当使用MPGO来NGen时，要分三步来生成最终的NGen二进制映像：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用MPGO，NGen生成带有收集profile功能的代码；&lt;/li&gt;&lt;li&gt;使用(1)生成的代码运行若干次该程序的“典型场景”，以便收集profile。这叫做training run；&lt;/li&gt;&lt;li&gt;结合(2)收集到的profile，再次运行MPGO来完成最终的NGen。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个过程跟一般的native PGO优化一样，都是要运行多次，依赖training run收集到的profile来引导后续运行的优化。在这种模式下运行的RyuJIT就可以做到类似本文开头所说的优化——但&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/e7k32f4k.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Visual C++的编译器同样支持PGO&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，同样可以做这种优化（而且可能做得更好）。相信未来的.NET Native在逐渐成熟起来之后也会考虑支持PGO。&lt;/p&gt;&lt;p&gt;自适应动态编译的思路就是把这种多次运行才能得到的好处压缩在一次运行中完成：执行引擎自动在开始的时候生成收集profile的代码，然后自动收集profile，最后自动利用profile来做优化编译。这样不但用起来方便，而且可以保证收集到的profile能够反映本次运行的特征。Native PGO的多次运行模型非常依赖于training run的代表性，如果其特征与后来实际运行的特征不匹配，那PGO“优化”反而会带来性能损失。&lt;/p&gt;&lt;p&gt;HotSpot VM是一个典型的自适应动态编译系统，使用解释器或Client Compiler（C1）来实现初始执行和profile的收集，然后把profile信息交给Server Compiler（C2）做优化编译。&lt;/p&gt;&lt;p&gt;对HotSpot VM的执行模型感兴趣的同学可以参考同事Doug Hawkins做的演讲来了解更多细节：&lt;a href=&quot;https://vimeo.com/120533011&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JVM Mechanics by Douglas Hawkins as Presented at Silicon Valley Java User Group by Azul Systems on Vimeo&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;传统PGO与自适应动态编译的结合&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;有没有办法结合传统的PGO与自适应动态编译呢？&lt;a href=&quot;http://www.azulsystems.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Azul Systems&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的&lt;a href=&quot;http://www.azulsystems.com/products/zing/whatisit&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Zing VM&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;所实现的&lt;a href=&quot;http://www.azulsystems.com/solutions/zing/readynow&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ReadyNow!&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;功能是一个思路。&lt;/p&gt;&lt;p&gt;Zing VM基于HotSpot VM开发，与HotSpot VM的执行模式相似，都是解释器+C1+C2的多层混合模式执行引擎，使用了自适应动态编译。&lt;/p&gt;&lt;p&gt;能在程序运行一次的过程中就自动进行PGO当然是方便，但收集profile时总有额外开销，不一定适用于所有场景。特别是，收集profile通常发生在程序启动阶段，也就是说启动时会比较慢；如果特别在意程序启动的速度的话，这种做法就不合适了。&lt;/p&gt;&lt;p&gt;ReadyNow!的思路是让传统PGO与自适应动态编译结合起来：一个程序可以先跑些training run把细粒度profile信息记录下来，后续执行的时候可以跳过原本收集profile的阶段，直接利用之前记录的profile信息来做优化编译。这样就减少了程序启动时收集profile的开销，让程序快速达到稳定的高性能状态。&lt;/p&gt;&lt;p&gt;在Zing VM中，ReadyNow!不但能通过profile信息来指导优化，还可以指导&lt;b&gt;不做&lt;/b&gt;某些过于激进的优化，减少因过度优化而导致的“去优化”（deoptimization）。这样也有利于程序快速达到稳定的性能水平，而不必在过度优化—去优化－再优化－再去优化－⋯的震荡多次后才达到稳定。&lt;/p&gt;&lt;br&gt;&lt;br&gt;==========================================================&lt;br&gt;&lt;br&gt;&lt;p&gt;* 注1：也有一些场景RyuJIT确实可以做到文中所说优化，例如在JIT编译时把已经初始化好的readonly变量看作编译时常量来做常量传播和折叠的优化。用代码举例的话，可以是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyConfig&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_debug&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IsDebug&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsDebug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此例中 if (MyConfig.IsDebug) 可以先内联IsDebug属性得知它就是_debug，然后发现它是readonly静态变量，直接用它的值来做优化；假如其值是false，那代码就变成 if (false) ，整个if块就可以被优化消除掉了。&lt;/p&gt;&lt;p&gt;具体逻辑从CoreCLR源码可以看到，在&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/93e7d209dc19ddeff0f5ea5e3686b3ec0efef447/src/jit/importer.cpp#L11612&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Compiler::impImportBlockCode(BasicBlock * block)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;CORINFO_FIELD_STATIC_ADDRESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Replace static read-only fields with constant if possible&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aflags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CORINFO_ACCESS_GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
                    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fieldInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fieldFlags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CORINFO_FLG_FIELD_FINAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fieldInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fieldFlags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CORINFO_FLG_FIELD_STATIC_IN_HEAP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;varTypeIsIntegral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lclTyp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varTypeIsFloating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lclTyp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;     
                    &lt;span class=&quot;n&quot;&gt;CorInfoInitClassResult&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initClassResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compCompHnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resolvedToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compMethodHnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;impTokenLookupContextHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initClassResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CORINFO_INITCLASS_INITIALIZED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;     
                        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;pFldAddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
                        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fldAddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compCompHnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getFieldAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resolvedToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pFldAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

                        &lt;span class=&quot;c1&quot;&gt;// We should always be able to access this static&#39;s address directly&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pFldAddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

                        &lt;span class=&quot;n&quot;&gt;op1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;impImportStaticReadOnlyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fldAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclTyp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIELD_DONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;     
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过这是比较特殊的场景，而PGO能覆盖的是更一般的场景。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">19977592</guid>
<pubDate>Mon, 16 Mar 2015 06:28:34 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Hack Tech Talk 2015/03/05</title>
<link>http://zhuanlan.zhihu.com/hllvm/19969441</link>
<description>今晚去&lt;a href=&quot;https://www.facebook.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Facebook&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的&lt;a href=&quot;https://www.google.com/maps/place/1+Hacker+Way,+Menlo+Park,+CA+94025/@37.4838448,-122.1489573,19z/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Menlo Park主园区&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;听了个&lt;a href=&quot;http://facebooktechtalkhack.splashthat.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;关于Hack Type System的tech talk&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。挺有趣的，稍微写点啥发出来吧。新鲜滚热辣 &amp;gt;_&amp;lt;&lt;p&gt;第一次去，进到Facebook园区觉得里面就像一个小型城市一样。有点回到了阿里西厂园区的感觉——只是占地面积更大的感觉。&lt;/p&gt;&lt;p&gt;本文不关心Zend PHP、HHVM、Hack之间的爱恨恩怨。那些话题留给language zealot们慢慢咬。&lt;/p&gt;&lt;p&gt;内容慢慢更新嗯。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Hack项目与Hack类型系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;今晚的活动由manager（Damien Sereni）开场，然后由Josh Watzman主讲。演讲有录像，日后会放出。等出来之后我会把链接更新过来。&lt;/p&gt;&lt;p&gt;更新（2015-03-27）：录像总算放出来了：&lt;a href=&quot;https://www.youtube.com/watch?v=aN22-V-b8RM&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Heresy! Combining type systems with PHP&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（请自备梯子）&lt;/p&gt;&lt;p&gt;演讲内容主要是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Hack项目概要、与PHP的关系&lt;br&gt;&lt;/li&gt;&lt;li&gt;Hack的类型系统的功能和当前实现的局限&lt;/li&gt;&lt;li&gt;Hack的类型检查器（type checker）的实现细节&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;首先Hack项目是什么。&lt;/p&gt;&lt;p&gt;官网：&lt;a href=&quot;http://hacklang.org/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;hacklang.org/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub代码仓库：&lt;a href=&quot;https://github.com/facebook/hhvm/tree/master/hphp/hack&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/facebook/hhv&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;m/tree/master/hphp/hack&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Hack项目包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一门编程语言语言：Hack Programming Language。&lt;/li&gt;&lt;li&gt;一个类型系统，及其对应的类型检查器&lt;/li&gt;&lt;li&gt;与HHVM衔接的前端编译器&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Hack编程语言是&lt;a href=&quot;http://php.net/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PHP&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的方言，在PHP 5的基础上添加了一套类型系统和与其配套的类型标注语法，另外还添加了一套集合库和一些方便的语言特性，例如比PHP的闭包更简洁的lambda语法、async语法之类。最重要的是它仍然可以完全兼容原本的PHP 5，所以可以从现有的PHP代码平滑过渡到使用越来越多的Hack特性。当前的facebook.com就跑在Hack上——当然，既然原本的PHP也可以算作Hack，那⋯ &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;Hack非常非常强调“实用主义”（pragmatism），不玩纯学术，不做高大全。一切皆为Facebook的具体使用环境而设计。Facebook已经有非常大量的PHP，完全替换掉它们迁移到一种新语言不现实而且也没必要。PHP的开发效率确实还不错，（只要知道它的坑在哪里之后别掉坑里）开发－调试－发布循环可以很块。但程序的错误一定要到调试运行时才有机会看到也时普遍让开发者头疼的问题。&lt;/p&gt;&lt;br&gt;&lt;p&gt;Hack语言的设计目的主要是为了相对PHP提高开发效率，而并非提高运行效率——后者还是交给HHVM自己解决。Hack给PHP添加了类型标注主要也是为了给开发者提供友善、有用但不碍事的类型检查提示信息，把程序里潜在的类型错误报告出来，让开发者能尽早发现和修复bug，而不必等到运行时。因此Hack的类型系统不是为了赶时髦，而是尽可能的适应原本PHP的语义，让原本PHP就存在的类型变得更明显、更容易检查。就这个意义上说，Hack与PHP的关系跟TypeScript与JavaScript（&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMAScript 5&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; / &lt;a href=&quot;https://people.mozilla.org/~jorendorff/es6-draft.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;6&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）的关系相似。&lt;/p&gt;&lt;p&gt;Hack的类型系统使用了渐进式类型系统（gradual typing）的设计，也就是说类型系统能接受从完全没写类型标注到完全标注好的程序。它从&lt;a href=&quot;https://github.com/edwinsmith&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Edwin Smith&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;得到了大量影响。Edwin以前在&lt;a href=&quot;http://www.adobe.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Adobe&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的&lt;a href=&quot;https://github.com/adobe-research/ActionScript4&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ActionScript 4&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的主要成员之一；Hack的gradual typing受ActionScript 4的影响非常深。之前我以为&lt;a href=&quot;http://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Erik Meijer&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;在Hack的设计上有更大的影响，但去参加这个活动都没怎么听大家提起梅姐，略失落。&lt;/p&gt;&lt;p&gt;当下有不少较新的语言都采用了gradual typing设计，例如&lt;a href=&quot;https://www.dartlang.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dart&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.typescriptlang.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TypeScript&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;、&lt;a href=&quot;http://perl6.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Perl 6&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;等。&lt;/p&gt;&lt;p&gt;关于ActionScript 4的gradual typing设计，可以参考这篇论文：&lt;a href=&quot;http://www.cs.umd.edu/~avik/projects/iogti/paper.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Ins and Outs of Gradual Type Inference&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。论文和实验虽然都是在ActionScript 3上做的，但其实它是为ActionScript 4做的铺垫。 &lt;/p&gt;&lt;p&gt;关于gradual typing的更多资料，可以参考这里：&lt;a href=&quot;https://github.com/samth/gradual-typing-bib&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;samth/gradual-typing-bib · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，还有&lt;a href=&quot;http://siek.blogspot.com/2012/10/is-typescript-gradually-typed-part-1.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这个&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;除了gradual typing外，Hack的类型系统还包含别的当下流行的特性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.generics.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;泛型（generics）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。支持协变/逆变（covariance / contravariance）。支持&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.generics.constraints.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;类型约束（type constraints）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.nullable.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;可空类型（nullable types）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。Hack里的类型默认不可空（不可以为null），要允许null的话必须显式声明为可空类型。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.collections.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;集合类型（collections）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。为了更明确表明意图，也便于类型检查，Hack把&lt;a href=&quot;http://php.net/manual/en/language.types.array.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PHP的数组&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;用法细分为若干集合类型，例如&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.collections.vector.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Vector&amp;lt;Tv&amp;gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;、&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.collections.set.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Set&amp;lt;Tv&amp;gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;、&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.collections.map.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Map&amp;lt;Tk, Tv&amp;gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;、&lt;a href=&quot;http://docs.hhvm.com/manual/en/hack.collections.pair.php&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pair&amp;lt;Tv1, Tv2&amp;gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;目前能运行Hack编程语言的主要就是&lt;a href=&quot;http://hhvm.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HHVM&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。虽然也有&lt;a href=&quot;http://hhvm.com/blog/6863/announcing-the-hack-transpiler&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hack Transpiler&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;可以把Hack转换为PHP以便在普通PHP环境里运行（就像TypeScript编译为JavaScript那样），但始终不咋受关注。&lt;/p&gt;&lt;p&gt;Hack的实际代码分为两部分：&lt;a href=&quot;https://github.com/facebook/hhvm/tree/master/hphp/hack&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;类型检查器&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;与&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/parser/hphp.y#L2900&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HHVM的前端&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。类型检查器的任务是分析Hack源码，做类型检查并报告错误。它并不做任何代码生成；而HHVM一侧，在原本的PHP语言的前端编译器之外另外专门写了一个Hack语言的前端，将Hack语言编译为&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/doc/bytecode.specification&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HHBC（HipHop Bytecode）&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;然后交给HHVM的后端去执行。&lt;/p&gt;&lt;p&gt;历史原因使得这两部分没有任何交互而且存在大量重复代码。Josh表示&lt;a href=&quot;http://hhvm.com/blog/8405/coming-soon-in-hhvm&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;今年内有望把类型检查器改造得与HHVM更紧密的整合起来&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，让它成能够直接生成HHBC，届时就不必维护两个有大量重复代码的项目了。但要让HHVM有效使用Hack的类型标注的好处，必须略为改造HHBC让它能记录更多类型信息才行。&lt;br&gt;&lt;/p&gt;&lt;p&gt;Hack类型检查器和HHVM的JIT编译器都要做类型检查，但两者的出发点和取舍还是有所不同。前者的目标是“prove the negative”，找出肯定有类型错误的地方，并相应报错；后者是“prove the positive”，找出某个变量在某处肯定是某个特定类型而不是其它类型的情况，并相应优化。这使得Hack类型检查器报告的类型信息比HHVM的JIT编译器做优化所需的类型信息弱，因而也不能直接用于优化。&lt;/p&gt;&lt;br&gt;&lt;p&gt;这次演讲的主角就是Hack的类型检查器。它大部分用&lt;a href=&quot;https://ocaml.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;OCaml&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;实现，并有少量C代码实现些特殊功能。&lt;/p&gt;&lt;p&gt;Hack类型检查器主要由&lt;a href=&quot;https://github.com/pikatchu&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Julien Verlaguet&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;https://github.com/jwatzman&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Josh Watzman&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;实现。Julien来自法国&lt;a href=&quot;http://www.upmc.fr/en/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paris VI University&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，所以很自然的选择了用OCaml。&lt;/p&gt;&lt;p&gt;Hack官网上有个&lt;a href=&quot;http://hacklang.org/tutorial/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tutorial&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，里面可以直接在页面上对用户输入的Hack代码做类型检查。这是通过把OCaml编写的类型检查器编译成JavaScript来在浏览器里运行的。&lt;br&gt;&lt;/p&gt;&lt;p&gt;类型检查器的工作流程分为5个步骤（phase）。每个步骤都只依赖之前的步骤计算所得数据而不需要同步骤内别的部分的计算数据，便于并行化，以便应对Facebook庞大的PHP/Hack代码量。&lt;/p&gt;&lt;p&gt;这5个步骤是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/7127f2b0d6104d6040f08a80a308b407ee6ac043/hphp/hack/src/parsing/parsing_service.ml#L87&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Parsing&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;：将Hack源码解析为&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/hack/src/parsing/ast.ml&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AST&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/7127f2b0d6104d6040f08a80a308b407ee6ac043/hphp/hack/src/naming/naming.ml#L700&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Global Environment&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;：扫描AST，把所有类和函数声明记录到一个全局符号表&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/7127f2b0d6104d6040f08a80a308b407ee6ac043/hphp/hack/src/typing/typing_decl.ml#L344-L346&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Naming&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;：&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/7127f2b0d6104d6040f08a80a308b407ee6ac043/hphp/hack/src/typing/typing_decl.ml#L894&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Declaration&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;：&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/7127f2b0d6104d6040f08a80a308b407ee6ac043/hphp/hack/src/typing/typing_check_service.ml#L40&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Typing&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;：真正去做类型检查，以函数为单位。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;这个流程的大入口（之一）可以在这里找到：&lt;a href=&quot;https://github.com/facebook/hhvm/blob/7127f2b0d6104d6040f08a80a308b407ee6ac043/hphp/hack/src/server/serverTypeCheck.ml#L193&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;type_check&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Josh很热心的回答了我的问题，把5个步骤在代码中的入口位置都指出来了：&lt;a href=&quot;http://pastebin.com/6rVfpY3f&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;pastebin.com/6rVfpY3f&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;实际代码的结构并不直接反映出上述的5个步骤。Josh解释说&lt;a href=&quot;https://twitter.com/jvwatzman/status/574030103501389824&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;“The actual code is pretty messy and poorly factored.”&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;（未完待续）&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;TypeScript, AtScript与Flow&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;TypeScript: &lt;a href=&quot;http://www.typescriptlang.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Welcome to TypeScript&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;AtScript: &lt;a href=&quot;https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/edit&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AtScript Primer&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Flow: &lt;a href=&quot;http://flowtype.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Flow: A Static Typechecker for JavaScript&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Damien Sereni提到在Facebook，用JavaScript写前端的开发工程师跟用PHP写数据部分的开发工程师的风格不太一样。这使得他们对工具的需求也不同。所以Flow虽然跟Hack是同一个团队开发的，但设计却非常不一样。&lt;/p&gt;&lt;p&gt;Facebook尝试过用TypeScript，但发现TypeScript无法满足他们的需要，然后才觉得自己开发Flow。TypeScript的类型检查边界是函数级别的，函数的参数和返回值类型都要声明才能有效的做类型检查；而Flow的类型检查边界是文件级别的——只要在文件层面上声明类型即可。&lt;/p&gt;&lt;p&gt;Flow同样用OCaml实现，然后也有少量C。它与Hack类型检查器有一些共享代码。&lt;/p&gt;&lt;p&gt;Flow团队有跟微软的TypeScript团队和Google的AtScript团队协调，让这三种JavaScript方言可以尽可能兼容。Flow能够&lt;a href=&quot;https://github.com/facebook/flow/tree/master/src/dts&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;直接读取和使用TypeScript的.d.ts Definition File&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;八卦部分&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;聊天的时候听说了各种以前没咋关心的八卦。其实有些想想似乎更早之前也听说过，然后就忘记了。&lt;/p&gt;&lt;p&gt;一个是Hack语言的名字的八卦。这门语言的名字似乎是公认的糟糕，Josh的说法是“跟Go共为最糟糕命名” &amp;gt;_&amp;lt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个是HHVM的开发团队的八卦。HHVM Open Source、Hack、Flow这几个项目都是同一个manager——前面提到的Damien Sereni——带的。而HHVM内部开发团队在Facebook叫做“HHVM JIT team”。&lt;/p&gt;&lt;p&gt;这“HHVM JIT team”与“HHVM Open Source team”的关系是：前者是原本的HHVM团队，继续肩负着开发HHVM核心的任务；后者主要是为了支持外部的HHVM用户，修补外部用户遇到的bug、从PHP移植外部用户需要（但Facebook自己没用到）的扩展，例如MongoDB扩展啥的。两个团队是在同一份代码上工作，但任务和受众不同。&lt;/p&gt;&lt;p&gt;HHVM Open Source team主要服务的对象是像百度、Etsy之类的HHVM外部客户。Facebook能养着一个组专门服务外部客户真好⋯&lt;/p&gt;&lt;p&gt;一个是&lt;a href=&quot;http://www.playstation.com/en-us/explore/ps4/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PS4&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的&lt;a href=&quot;https://www.freebsdnews.com/2013/06/24/freebsd-based-orbis-os-powering-sony-ps4/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Orbit OS是基于FreeBSD裁剪和定制的&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。内核裁剪和写死了一些东西，例如semaphore的数量有个写死的上限之类的；然后新写了些驱动程序。然后PS4的主菜单界面程序VShell，整个是用C#写的，基于&lt;a href=&quot;http://www.mono-project.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mono&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;运行在PS4上。这个Mono实例只用于运行VShell，而不用于运行任何其它东西（例如游戏）。Sony最近还试着给Mono提交了写patch来修PS4平台上遇到的问题。&lt;/p&gt;&lt;p&gt;看到&lt;a href=&quot;https://github.com/dotnet/coreclr/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CoreCLR&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;开源他们似乎也很激动⋯咳咳。搞不好以后PS4上就流淌着微软代码的血液了（扭头看向XBox One⋯&lt;/p&gt;&lt;p&gt;一个是&lt;a href=&quot;http://www.windriver.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wind River&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;重启了GCC小组，重新开始大搞编译器。真好。被Intel大财主收购之后的Wind River仍然有自由做自己的项目，只是Intel点名要做的项目无法忽略了而已。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">19969441</guid>
<pubDate>Fri, 06 Mar 2015 16:57:35 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>六离合释：健康宏展开的故事</title>
<link>http://zhuanlan.zhihu.com/hllvm/19957610</link>
<description>今受 &lt;a href=&quot;https://www.zhihu.com/people/a06cfb38e37dac1658e6457df4d7f032&quot; data-hash=&quot;a06cfb38e37dac1658e6457df4d7f032&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@RednaxelaFX&quot; data-tip=&quot;p$b$a06cfb38e37dac1658e6457df4d7f032&quot;&gt;@RednaxelaFX&lt;/a&gt; 的邀请，到此地方来，本打算像写书那样，写个长的系列，唤作《六离合释》，借个 Panini 文法里的词来说语言理论，不过写书我实在是坚持不下来，所以还是东一榔头西一棒子地讲一些小的细节好了。&lt;p&gt;给程序语言设计宏系统实际上是挺麻烦的事。C/C++ 的宏实际上就是 token 层面的查找替换，早期的 lisp 要更好些，是在 AST 层面的查找替换，由于 lisp 的节点可以随意组合、文法统一，所以在人们眼里 lisp 宏一直是强大的象征。&lt;/p&gt;&lt;p&gt;但是，最好的宏系统实际上是在 Scheme 里。无论是 C/C++，还是 Common Lisp，它的宏都是使用动态作用域的，也就是说，考虑你想实现个类似 javascript 里的 “||” 算符：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-common-lisp&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;defmarco&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;gensym&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;falsy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们使用临时变量 t 避免 x 被重复计算，同时满足 javascript “||” 里的短路特性。falsy 是一个用来判断 x 是否为「假」值的自定义函数。这个宏看上去十分完美。&lt;/p&gt;&lt;p&gt;但他仍然有问题：因为用户很可能会覆写掉 falsy 的定义：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-common-lisp&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;falsy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你应该看出来问题所在了：&lt;b&gt;传统的宏展开中，被宏引入的新语法节点中的所有名称使用的是宏调用处的作用域，这往往和用户的意图不一致：他们希望使用宏定义处的作用域，就像嵌套函数里的变量名一样。&lt;/b&gt;这就是著名的「宏健康性」问题。&lt;/p&gt;&lt;p&gt;1986 年，Kohlbecker 等发明了 KFFD 算法第一次实现了健康的宏展开，基于此方法的宏系统成为了 R5RS 的标准。1988 年，Bawden 等提出的文法闭包（Syntactic closure）允许进行细粒度的作用域指派控制，借以实现一些「不健康的」特殊宏。1992 年，Dybvig（嗯，就是王某人说的那位）的 syntax-case 系统完善了 KFFD 体系，并成为了新的标准。&lt;/p&gt;&lt;p&gt;实现健康宏展开的思路并不算复杂：我们只需要在展开宏的步骤里同时维护每个名字的作用域绑定就可以了。考虑一个 expand 函数，它的参数是语法树 c 和作用域 e。&lt;/p&gt;&lt;p&gt;对于变量，我们把它绑定到 e 上。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;expand(Variable c, e) = binding(c, e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于宏定义，我们解析宏定义得到一个宏「函数」，它是将若干个语法树变换成一个语法树的过程。所有的宏函数都会记录其定义时所在的作用域。&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;expand(MacroDefinition c, e) = MacroFunction(c, e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于宏调用，有趣的地方就来了：我们事先将参数进行包装，然后直接丢给宏函数。宏函数返回的结果则在一个新创建的，宏函数定义作用域的子作用域中展开。&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;expand(MacroCall(name, args), e) = 
    let(mfn = ResolveMacro(name, e))
        let(wrapped = map(args, lambda(a) SyntacticClosure(a, e))
            expand(ApplyMacro(mfn, wrapped),
                derive(DefiningScopeOf(mfn)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而对于文法闭包的处理，哼哼，我们不是记录了它的作用域 e1 吗？直接展开便是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;expand(SyntacticClosure(c, e1), e) = expand(c, e1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而为什么我们可以这么做呢？因为宏函数实际上不会去「触碰」文法闭包，如上面的 or，x 和 y 都是整体进，整体出的，它们会直接无损地从宏函数里出来；而宏函数中新加入的变量——比如 t——则没有闭包加持，会落到我们布置好的「陷阱」作用域——derive(DefiningScopeOf(mfn)) 里，实现了健康的宏展开。&lt;/p&gt;&lt;p&gt;而且，由于宏函数的多样性，如果用户需要，他完全可以拆掉文法闭包来实现特殊的宏：如一些 DSL 需要修改宏参数所在的作用域，单纯的健康宏展开就做不到了。&lt;/p&gt;</description>
<author>Belleve</author>
<guid isPermaLink="false">19957610</guid>
<pubDate>Mon, 16 Feb 2015 09:10:12 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>JIT编译器杂谈#1：JIT编译器的血缘（一）</title>
<link>http://zhuanlan.zhihu.com/hllvm/19954031</link>
<description>&lt;p&gt;这年头啥都得讲个娱乐性。专栏第一篇杂谈，先来点八卦轻松一下。&lt;/p&gt;&lt;p&gt;对我来说，有没有人最近用&lt;a href=&quot;http://www.dji.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DJI&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;无人机求婚成功啥的如同耳边一阵风；上周&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2015/02/03/coreclr-is-now-open-source.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CoreCLR在GitHub上以MIT许可证开源了&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;才是激动人心的娱乐新闻啊！&lt;/p&gt;&lt;p&gt;趁着这个娱乐热点，从&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/8bs2ecf4.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CLR&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的JIT编译器引伸出去，我想在这篇杂谈写一些JIT编译器的血缘。正好可以从一个侧面解答：有那么多讲编译原理的书，为什么没有专门讲JIT编译器的？——因为JIT编译器用的也是“编译原理”啊（好吧还是有许多JIT的专有知识的，没多少专门的书确实可惜）。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;从现成的编译器到JIT编译器&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;如果有个项目急需为某个语言实现一个优化的JIT编译器，怎样能在有限的时间内快速做出优化程度足够好的实现呢？&lt;/p&gt;&lt;p&gt;一个思路：如果有现成的静态编译器后端的话，针对输入的语言写个编译器前端，让它生成现成的后端能接受的&lt;a href=&quot;http://en.wikipedia.org/wiki/Intermediate_language#Intermediate_representation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;IR&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，直接插到现成的后端上。&lt;/p&gt;&lt;p&gt;“有现成的静态编译器后端”门槛挺高，直到&lt;a href=&quot;http://llvm.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;LLVM&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;普及之前；不过土豪大厂们早已跨过这门槛，自然会想走这条路。&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;Microsoft CLR / JIT64&lt;/b&gt;&lt;/p&gt;&lt;p&gt;微软的桌面/服务器版CLR在&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RyuJIT&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;之前有若干JIT编译器：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;JIT32（mscorjit.dll）：CLR一直以来的“Standard JIT”，或者叫“Normal JIT”，或者就叫“JIT”。最初主要针对32位客户端机器，所以这个编译器就定位在“Client Compiler”上，目标是快速编译，做少量开销低收益高的优化。运行32位CLR时用的是这个编译器（包括&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa384249.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WOW64&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的场景）。&lt;br&gt;&lt;/li&gt;&lt;li&gt;JIT64（mscorpjt.dll）：今天的主角。从.NET Framework 2.0开始引入到64位版CLR。主要用于支持x64和Itanium（IA-64）平台。当初认为这样的64位平台肯定都是“服务器”，所以这个编译器定位在“Server Compiler”上，目标是尽可能编译出优化的代码，而编译速度是次要目标。运行64位CLR时用的时这个编译器。&lt;br&gt;&lt;/li&gt;&lt;li&gt;EconoJIT（mscorejt.dll）：只存在于.NET Framework 1.0时代的CLR。这是个编译速度非常快的编译器，完全不做优化，甚至连代码校验（&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ht8ecch6.aspx#sectionToggle2&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;verification&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）都不做，尽可能快速把MSIL转换为机器码。它还支持“抛弃代码”（code pitching）——把当前没有正在被调用的方法的JIT编译代码从code cache删除掉并回收相应的空间（“正在被调用”指的是当前在调用栈上有栈帧的方法）。这个功能在桌面CLR的其它JIT编译器都没有支持；在.NET Compact Framework的CLR里倒是有支持。在早期.NET Framework SDK里有一个JIT Compiler Manager（jitman.exe）可以配置CLR是用Standard JIT还是EconoJIT。&lt;/li&gt;&lt;li&gt;OptJIT（mscorojt.dll）：与OptIL搭配使用，实现快速且高质量的JIT编译。似乎从来没正式在产品里发布？（有误请回复指正，谢谢！手上没老Windows机器不方便验证）OptIL是MSIL的一个子集，外加额外的元数据来引导JIT编译器做优化。应用场景是：先在静态编译的时候做大量耗时的优化，并把优化结果以元数据的形式嵌入OptIL里；JIT编译时可以借助元数据提供的“优化提示”来快速生成高质量的代码。&lt;/li&gt;&lt;li&gt;FJIT（mscorejit.dll）：严格说不是桌面/服务器版CLR的JIT编译器，而是&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=4917&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shared Source Common Language Infrastructure (SSCLI) &quot;Rotor&quot;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;带的JIT编译器。不过SSCLI 2.0带的FJIT完全可以插入桌面版CLRv2使用，所以这里也算上它。从外部无法得到CLR的源码所以我无法确定，不过看起来FJIT其实就是以前的EconoJIT，外加少量更新（例如添加verification功能）；连DLL文件的名字都一样，而且也支持&lt;a href=&quot;http://www.jot.fm/issues/issue_2006_04/article5/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;“抛弃代码”&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。不然光为了向学术研究社区开放代码专门新写一个JIT编译器也…好吧其实也花不了多少功夫，这个编译器实在太简单了。FJIT没有自己的IR，每条MSIL指令对应一小块汇编模版，一趟遍历就直接从MSIL翻译到机器码。&lt;/li&gt;&lt;li&gt;MSILC JIT：嗯？这个是啥来的？等CoreCLR放出它的代码之后再看看。&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/253&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Add info about MSILC JIT to docs · Issue #253 · dotnet/coreclr · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;可以看到JIT64是上述几个编译器里唯一一个以生成高质量代码为主要目标，而同时又可以不那么在乎编译速度的；而微软已经有一个出名的静态编译器了：Visual C++！正好符合这段的主题：把静态编译器的后端安到JIT编译器里。&lt;/p&gt;&lt;p&gt;JIT64基于UTC（Universal Tuple Compiler）。UTC同时也是Visual C++编译器的后端。VC++有明确的前端（c1xx.dll）、后端（c2.dll）和链接器（link.exe）的边界。前后端之间传递数据的格式是“CIL”（或CxxIL），是“C Intermediate Language”（或C++ Intermediate Language）；不要跟.NET的Common Intermediate Language弄混。请参考&lt;a href=&quot;http://blogs.msdn.com/b/vcblog/archive/2013/06/12/optimizing-c-code-new-title.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimizing C++ Code : Overview&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;JIT64并不直接使用VC++的c2.dll，而多半是引入了UTC的代码在自己的项目里单独维护。毕竟还是JIT编译，JIT64不能直接“暴力”的把UTC的所有优化都用上，而必须精心挑选一些效果好的优化按照一定的顺序执行。&lt;/p&gt;&lt;p&gt;JIT64自己要做的事情就是把输入的MSIL和类型信息转换为UTC所使用的线性IR，然后到代码生成的时候再帮忙生成一下调试符号信息和GC所需的元数据就好了，其它都交给现成的UTC去解决，消除冗余、循环优化、基于图着色的寄存器分配，生成x64、Itanium的代码生成器，应有尽有。&lt;/p&gt;&lt;p&gt;听起来很美好对不对？但因为不是直接用VC++组的c2.dll而是引入了UTC的源码，这块代码变成JIT64要自己维护的负担；而且一开始没有考虑要在JIT编译器里使用的编译器后端在架构和实现上通常不太在乎编译速度和内存开销，很难后天补救，要用只能忍。&lt;br&gt;&lt;/p&gt;&lt;p&gt;而且据说JIT64在做Itanium支持的时候还是坑了很久…hmm。&lt;/p&gt;&lt;p&gt;随着64位电脑的普及，现在随便找个x86的笔记本都是64位的，甚至连手机也开始用64位了，把64位机器都看作“服务器”的观点显然过时了。JIT64越来越多被吐槽编译速度太慢，于是终于在.NET Framework 4.6里被RyuJIT所替代。它还没彻底消失，在.NET 4.6还以compatjit.dll的名字作为备用JIT编译器待机——配置useLegacyJit=1的话还能继续用它。配置方法在&lt;a href=&quot;http://support.microsoft.com/kb/2967191&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;有提到（Visual Studio &quot;14&quot; CTP 4 (version 14.0.22129.1.DP) -&amp;gt; Known Issues -&amp;gt; CLR下面。这是VS2015的技术支持说明，但&lt;a href=&quot;https://github.com/jeffhung/.net/blob/master/docs/testing-with-ryujit.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;同样的配置在.NET 4.6上应该也可以用&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;Sun ExactVM / JBE&lt;/b&gt;&lt;/p&gt;&lt;p&gt;无独有偶，相近时期Sun开发的JVM之一——ExactVM（EVM）——也借助了Sun当时已有的静态编译器后端来实现优化的JIT编译器。这个我知道的稍微多一些，可以多写点；从这个例子可以反过来猜测JIT64研发时的历程。&lt;/p&gt;&lt;p&gt;（好吧ExactVM的JBE应该是在CLR的JIT64之前开发的。JBE大概是从1997年开始研发，并在Sun JDK 1.2.2时期（1999年7月）发布在Solaris版JDK产品中；JIT64随CLRv2发布，.NET Framework 2.0于2006年1月发布，1.1于2003年4月，1.0于2002年2月，即便JIT64是1999-2000年开始研发的那也还是在JBE之后。）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://web.archive.org/web/20011220184556/http://research.sun.com/jtech/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ExactVM&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;是Sun的“正统”JVM继承者。它的代码源于Sun JDK 1.0/1.1时代的JVM（后来叫做“Classic VM”），由Sun Labs的Java Topics Group负责研发。这组人本来想研究如何提高JVM的GC性能，结果拿到Classic VM之后发现执行引擎自身实在太慢，GC的性能问题根本体现不出来！一帮人只好先去解决执行引擎的效率问题，所以就开始研发新的优化JIT编译器。&lt;br&gt;&lt;/p&gt;&lt;p&gt;Classic VM在Sun JDK 1.1时代有一个用汇编写的解释器，效率还不错；还有一个性能和稳定性都一般的JIT编译器，“sunwjit“（Sun Workshop JIT）。ExactVM想要尽快得到一个高度优化的JIT编译器来填补高端部分的空缺，但是Labs哪儿来的人力物力去做这件事呢？他们就跟产品组合作，专门针对Solaris开发新的优化JIT编译器，并且找隔壁的&lt;a href=&quot;https://blogs.oracle.com/tatkar/entry/studio_release_names_from_the&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Sun Workshop&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;编译器组弄来他们的代码和开发参与进来。这就是JBE（Java Back End）。更加“根正苗红”了，全套Sun的自家装备。&lt;/p&gt;&lt;p&gt;在ExactVM里，JBE与解释器、sunwjit组成一个“多层编译系统”：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java方法刚开始都由解释器执行；&lt;/li&gt;&lt;li&gt;足够热之后会由充当初级编译器的sunwjit编译。这个是前台编译，也就是说触发编译的Java线程会暂停下来等编译；&lt;/li&gt;&lt;li&gt;再继续执行足够热之后会再由JBE优化编译。这个是后台编译，在一个单独的编译器线程上运行，也就是说触发编译的Java线程在触发后可以继续执行，同时编译任务会在后台的编译器线程执行，什么时候编译好就什么时候开始用新编译的代码。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;觉得眼熟不？没错，现在的HotSpot VM的多层编译系统大体上看也是这样设计的。不过当时ExactVM的实现还是没有现在HotSpot VM的实现干练，而且也没有实现&lt;a href=&quot;http://www.azulsystems.com/blog/cliff/2011-11-22-what-the-heck-is-osr-and-why-is-it-bad-or-good&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;OSR&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，跑小型性能测试程序会略吃亏。&lt;/p&gt;&lt;p&gt;ExactVM对这个系统的编译器非常有信心，觉得大部分时间都应该在执行JIT编译后的代码，所以解释器性能就不那么重要了。为了便于维护，ExactVM没有从Sun JDK 1.1的Classic VM继承用汇编写的解释器，反而退回到更早版本的用C写的简单解释器实现。&lt;/p&gt;&lt;p&gt;Sun Labs的论文提到JBE的历史：&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.86.2536&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mixed-mode bytecode execution&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;Our optimizing compiler traces its heritage back to a vectorizing and parallelizing compiler for Fortran and C developed at Supercomputer Systems Inc. (SSI) during the years 1987-93. Later, a Chaitin-Briggs-style global register allocator was added at Sun Microsystems. Later still, a front-end for Java class file bytecode (henceforth, Java bytecode) was developed and the compiler was integrated into our JVM.&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这里的SSI指的是Steve Chen的Supercomputer Systems, Inc，源自&lt;a href=&quot;http://en.wikipedia.org/wiki/Cray&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cray&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。SSI公司在IBM的资助下只活了几年——1987-1993——然后因产品研发进度太慢失去了资助而倒闭。期间SSI不但积极研发新的超级计算机，也开发了高度优化的Fortran和C编译器，主攻自动向量优化和并行优化。同一时期Sun也在积极开发C和Fortran编译器，而且似乎有跟SSI合作（Supercomputer Systems Limited Partnership？）。后者倒闭后，前者吸收了不少后者的编译器工程师，并将SSI的编译器技术整合到了Sun的C、C++、Fortran、Pascal和Ada编译器中。这些编译器有各自的前端，但都共用同一个后端；前端生成出后端的IR，“Sun IR”，剩下的优化、代码生成的活都交给后端解决。“鲸书”（&lt;a href=&quot;http://book.douban.com/subject/1821532/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Advanced Compiler Design and Implementation》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）有简短提到Sun IR的设计。这个IR是双向链表构成的线性IR，结合了一些高层IR和底层IR的特性，所以其抽象程度被归类为“中层IR“（MIR）。&lt;br&gt;&lt;/p&gt;&lt;p&gt;JBE把当时Sun编译器的公共后端的代码拿进来，稍做裁剪，并且新写了一个Java字节码的前端，搞定！原本这个公共后端里就有许多牛逼的优化，包括当时还比较新潮的基于SSA的优化和优化编译器标配的图着色寄存器分配器，要啥优化随便挑啊。&lt;/p&gt;&lt;p&gt;&amp;lt;- 不不，没那么快。由于Java要支持GC，一些相关功能必须在JIT编译器的IR层面得到体现，例如说&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一条对写内存的IR指令，如果是用于实现Java的putfield并且类型是引用类型，那么为了支持分代式GC或者并发GC就需要放write barrier；&lt;/li&gt;&lt;li&gt;在某些位置的IR要记录为检查是否要进入GC的“安全点”（safepoint）；&lt;/li&gt;&lt;li&gt;某个位置的IR是否要假设可能会遇到异常。Java的异常处理模型跟C++有点相似但又不一样，原本Sun compiler的IR应该得调整过才能应用于Java。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些功能在C、C++、Fortran的编译器上不会有，所以JBE把它们得新加进IR里。然后还可以借助一些Java语义做些特定优化，例如说Java不允许指向对象内部的指针；Java里两个数组引用如果不相等，那么它们所指向的数组实例一定不会有部分重叠（overlap），这些特性利用好有助于编译器的别名分析。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;然后，JBE毕竟是动态编译器，即便在后台编译比在前台的JIT编译可以容忍更长的编译时间，能忍受的程度还是远不如静态编译器。所以原本在静态编译器里的优化还是得做一些裁剪。&lt;/p&gt;&lt;p&gt;这么一来，JBE的编译器后端就跟原来其它Sun编译器的公共后端越来越不一样，也无法一起维护；JBE只能fork了公共后端的源码然后自己维护…维护过一大坨“别人的代码”而且还是“不断在变的别人的代码”的人都知道这是什么状况。:-( 所幸JBE项目组里的几位主要开发就来自SSI，对这块代码非常熟悉，想必比别人维护要轻松些吧。&lt;/p&gt;&lt;p&gt;更悲剧的是，整个ExactVM项目很快陷入了Sun的内部政治斗争——对手是“外来”的HotSpot VM项目。一山不容二虎，ExactVM与HotSpot VM的技术特性实在太相似，Sun无力支持两个效果几乎一样的Java SE JVM项目，必须砍掉一个。于是两组人斗得个人仰马翻昏天黑地，最终HotSpot VM胜出，顺带从ExactVM那边吸收一些优秀的功能，例如GC接口与CMS GC实现等。&lt;/p&gt;&lt;p&gt;竞争失败后，ExactVM被扔回到labs那边，改名为“Sun Microsystems Laboratories Virtual Machine for Research”（ResearchVM）。名字长到爆，但剩下的生命却甚短…没过多久它的职能就被新的&lt;a href=&quot;https://wikis.oracle.com/display/MaxineVM/Home&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Maxine VM&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;所替代。烧香。&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;HP JVM / JIT2.0 / ARC&lt;/b&gt;&lt;/p&gt;&lt;p&gt;继续盘点大公司。接下来看个&lt;a href=&quot;http://www.hp.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HP&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的故事。&lt;/p&gt;&lt;p&gt;ARIES是Automatic Re-translation and Integrated Environment Simulation的缩写，也有文档说是Automatic Recompilation and Integrated Environment Simulation。后来大家更多就直接叫它Aries而不管原本是啥的缩写了，所以有文档有岔子大概也不奇怪…&lt;/p&gt;&lt;br&gt;&lt;p&gt;关于ARIES的介绍，请参考：&lt;a href=&quot;http://h21007.www2.hp.com/portal/download/files/unprot/hpux/aries/hp-aries-external.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ARIES Technical Overview&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.openmpe.com/cslproceed/HPW01CD/4455/4455.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Aries: Transparent Execution of PA-RISC/HP-UX Applications on IPF/HP-UX&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;简单说，ARIES是一个把HP的&lt;a href=&quot;http://en.wikipedia.org/wiki/PA-RISC&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PA-RISC&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;机器码动态翻译为Itanium机器码的&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_translation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;动态二进制翻译器&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。“二进制翻译器”是从虚拟机的角度的叫法；其实它底下的技术有许多与编译原理共通的地方。现代trace-based编译器的鼻祖就是这些二进制翻译器。&lt;/p&gt;&lt;p&gt;说了半天，JVM呢？JIT编译器呢？&lt;/p&gt;&lt;p&gt;HP从Sun购买了Java的授权，以Sun Classic VM为基础开发能运行在&lt;a href=&quot;http://en.wikipedia.org/wiki/HP-UX&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HP-UX&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;系统上的JVM。一开始主要工作就是移植，把Classic VM平台相关的部分移植到新操作系统和新硬件上。但是当时Sun提供的sunwjit性能实在差，有几个HP工程师看不下去了，提议开发一个新的、trace-based JIT编译器，名为“JIT2.0”。我不太清楚这里的时间顺序是怎样，JIT2.0项目使用了ARIES二进制翻译器的技术，后来进一步成为“ARC”（Adaptive Run-time Compiler）。可以从其相关专利一窥究竟：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.google.com/patents/US7725885&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Patent US7725885&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;: Method and apparatus for trace based adaptive run time compiler&lt;/p&gt;&lt;p&gt;（以前我一直以为近年来流行的trace-based编译技术是&lt;a href=&quot;http://andreasgal.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Andreas Gal&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;从以前的动态二进制翻译技术得到灵感应用在JIT编译器上，然后才带起潮流；知道了HP早在90年代末2000年代初就在产品里应用上了trace-based编译技术我还真是吃了一惊。）&lt;/p&gt;&lt;p&gt;可惜，JIT2.0/ARC又是死在HotSpot VM的手上。&lt;/p&gt;&lt;p&gt;HP开发JIT2.0/ARC大概在Sun JDK 1.1.x-1.2.x时代，而Sun当时紧接着就准备推出高性能的HotSpot VM取代Classic VM作为新的默认JVM实现。HP拿到HotSpot VM的早期版本评估其性能时，发现它比Classic VM快了很多；即便Classic VM搭载上JIT2.0/ARC性能还是远不如HotSpot。此时HP既可以选择继续优化Classic VM，找出性能问题点并逐一修补，也可以选择抛弃之前的工作改用Sun的新JVM。权衡一番，HP决定结束一切在Classic VM上的开发，赶紧转向基于HotSpot VM继续开发。基于Classic VM的JIT2.0/ARC项目就此被终止。顺带一提，微软和IBM都是选择了走“魔改Classic VM“的路，效果也不差。&lt;/p&gt;&lt;p&gt;更可悲的是，后来人们看回这段历史，发现当时HP做性能评测没有意识到其实在那些测试里Classic VM是败在GC性能比HotSpot VM差太远，而不是败在JIT编译器太差。本来很有潜力的trace-based JIT编译器先驱就这么埋没了。诶。&lt;/p&gt;&lt;br&gt;&lt;p&gt;今天先写到这里，下一篇继续看看各个JIT编译器的血缘的故事。敬请期待 :-)&lt;/p&gt;&lt;p&gt;（题图引用自&lt;a href=&quot;http://blogs.msdn.com/b/vcblog/archive/2013/06/12/optimizing-c-code-new-title.aspx&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimizing C++ Code : Overview&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">19954031</guid>
<pubDate>Thu, 12 Feb 2015 17:04:31 +0800</pubDate>
<media:thumbnail url="https://pic3.zhimg.com/886d26a250c523df6c227ac68575d136_b.jpg" />
</item>
<item>
<title>开启新坑</title>
<link>http://zhuanlan.zhihu.com/hllvm/19953755</link>
<description>托大家的福开通了知乎专栏，在这边重拾旧业开个新坑。&lt;p&gt;（感觉这里会像是我的新中文博客…）&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;我的博客：&lt;a href=&quot;http://rednaxelafx.iteye.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Script Ahead, Code Behind - ItEye&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;高级语言虚拟机（HLLVM）讨论组：&lt;a href=&quot;http://hllvm.group.iteye.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;高级语言虚拟机 - ItEye&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;我的博客的虚拟机相关话题的索引帖：&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/362738&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;自己关于VM的帖的目录&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;想在这个专栏发的内容或许大多是来自我的博客和HLLVM讨论组的旧坑的延续。主要是关于编程语言的设计与实现，特别是在“高级语言虚拟机”方面的话题，JVM、CLR、JavaScript引擎之类的。&lt;/p&gt;&lt;p&gt;有好多坑待填啊呵呵呵～&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;首先先把在知乎上发过的一些回答整理、索引在这边吧。之前被吐槽说在知乎上发的许多回答分散在不同问题下面比较难找；有索引应该会好些吧。&lt;/p&gt;&lt;br&gt;&lt;p&gt;然后&lt;a href=&quot;https://www.zhihu.com/people/b6d28ac2b88b7f230552bab4a0aceaca&quot; data-hash=&quot;b6d28ac2b88b7f230552bab4a0aceaca&quot; class=&quot;member_mention&quot; data-tip=&quot;p$b$b6d28ac2b88b7f230552bab4a0aceaca&quot;&gt;@Belleve&lt;/a&gt;大大说他也会在这个专栏写点东西。敬请期待 ^_^&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;P.S. 其实知乎能不能让回答也带有标签呢？&lt;/p&gt;&lt;p&gt;P.P.S. 专栏的样式为啥似乎没有回答的样式好看？换行好难控制。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">19953755</guid>
<pubDate>Tue, 10 Feb 2015 09:04:44 +0800</pubDate>
<media:thumbnail url="https://pic4.zhimg.com/25534aafb871fbc9bfce041c996dd507_b.jpg" />
</item>
</channel>
</rss>
