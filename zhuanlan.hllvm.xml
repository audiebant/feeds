<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 14 Feb 2016 07:30:15 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>http://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>给类型求导</title>
<link>http://zhuanlan.zhihu.com/hllvm/20570808</link>
<description>熟识类型的用家可能都知道两个非常常见的类型构造：二元组和标签并，在代数类型（Algebraic type）中分别映射到乘法和加法，于是多项式&lt;img src=&quot;https://zhihu.com/equation?tex=1%2Bt%5E2&quot; alt=&quot;1+t^2&quot; eeimg=&quot;1&quot;&gt;可以用来表示&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BEither%7D%5C%3B%28%29%5C%3B%28t%2Ct%29&quot; alt=&quot;\mathrm{Either}\;()\;(t,t)&quot; eeimg=&quot;1&quot;&gt;这样的构造。继续扩展下去，比如把递归类型引入的话，就得到了许多递归类型的有理式表示，比如列表，它可以表示成&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D%5Cfrac%7B1%7D%7B1-a%7D&quot; alt=&quot;L(a)=\frac{1}{1-a}&quot; eeimg=&quot;1&quot;&gt;，因为它是方程&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29%3D1%2BaL%28a%29&quot; alt=&quot;L(a)=1+aL(a)&quot; eeimg=&quot;1&quot;&gt;的解，而这个方程是列表的递归类型表示（在 Isorecursive 语义下，它表示&lt;img src=&quot;https://zhihu.com/equation?tex=L%28a%29&quot; alt=&quot;L(a)&quot; eeimg=&quot;1&quot;&gt;和&lt;img src=&quot;https://zhihu.com/equation?tex=1%2BaL%28a%29&quot; alt=&quot;1+aL(a)&quot; eeimg=&quot;1&quot;&gt;之间存在一一映射，在实现时则用「指针」表示这种映射）。&lt;p&gt;上面的列表若是实现出来的话，是用链表实现的，对于双向遍历的话性能很差，于是我们发明一个 Zipper 类型，它同时存储一个焦点项目和它的左右两侧：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Zipper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;向左右两侧遍历的操作就可以写成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;left&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;反向遍历的复杂度也降低到了 O(1)，性能获得了很可观的提升。除了列表，其他更复杂的数据结构，如二叉树等，也可以定义出 Zipper。&lt;/p&gt;&lt;p&gt;从代数类型的角度看，Zipper 的方程可以写作&lt;img src=&quot;https://zhihu.com/equation?tex=Z%28a%29%3DL%28a%29%5Ccdot+a+%5Ccdot+L%28a%29%3DaL%28a%29%5E2&quot; alt=&quot;Z(a)=L(a)\cdot a \cdot L(a)=aL(a)^2&quot; eeimg=&quot;1&quot;&gt;，换言之，一个列表的 Zipper 可以看作一个「焦点」和两个列表的积，而后者则是原来列表类型敲掉一个空位。&lt;br&gt;&lt;/p&gt;&lt;p&gt;给数据结构挖个洞是个不太罕见的需求，我们已经知道&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C+%5Cfrac%7B1%7D%7B1-a%7D%3D%5Cleft%28%5Cfrac%7B1%7D%7B1-a%7D%5Cright%29%5E2&quot; alt=&quot;\mathrm{Hole}_a\ \frac{1}{1-a}=\left(\frac{1}{1-a}\right)^2&quot; eeimg=&quot;1&quot;&gt;。对于更简单的类型，我们也可以试试在上面挖洞，比如，类型 1 因为挖不出来洞，所以&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a+%3D+0&quot; alt=&quot;\mathrm{Hole}_a = 0&quot; eeimg=&quot;1&quot;&gt;；「一元组」a 挖洞之后都变一样了，于是&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%3D1&quot; alt=&quot;\mathrm{Hole}_a\;a=1&quot; eeimg=&quot;1&quot;&gt;；而对于二元组&lt;img src=&quot;https://zhihu.com/equation?tex=a%5E2&quot; alt=&quot;a^2&quot; eeimg=&quot;1&quot;&gt;，因为存在两种可能的「挖」法（左或右），所以&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%5E2%3D%28%28%29%2Ca%29%2B%28a%2C%28%29%29%3D2a&quot; alt=&quot;\mathrm{Hole}_a\;a^2=((),a)+(a,())=2a&quot; eeimg=&quot;1&quot;&gt;。这可以推广到所有的简单元祖，我们总可以得到&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7BHole%7D_a%5C%3Ba%5En%3Dna%5E%7Bn-1%7D&quot; alt=&quot;\mathrm{Hole}_a\;a^n=na^{n-1}&quot; eeimg=&quot;1&quot;&gt;。&lt;/p&gt;&lt;p&gt;看上去怎么那么眼熟。&lt;/p&gt;&lt;p&gt;…………………………&lt;/p&gt;&lt;p&gt;这不是求导么？&lt;/p&gt;&lt;p&gt;对，Conor McBride 的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//strictlypositive.org/diff.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;论文&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;中，就论述了类型上的微分算子&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a&quot; alt=&quot;\partial_a&quot; eeimg=&quot;1&quot;&gt;，并且证明了它和「挖洞」行为之间的联系。微分算子的三个基础法则——和、积和链式法则，都可以用挖洞的行为「证明」。&lt;/p&gt;&lt;p&gt;除此之外隐函数的微分法则同样适用于数据类型。考虑二叉树&lt;img src=&quot;https://zhihu.com/equation?tex=T%28a%29%3D1%2BaT%28a%29%5E2&quot; alt=&quot;T(a)=1+aT(a)^2&quot; eeimg=&quot;1&quot;&gt;的微分：&lt;/p&gt;&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3DT%28a%29%5E2%2B2aT%28a%29%5Ccdot%5Cpartial_a+T%28a%29&quot; alt=&quot;\partial_a T(a)=T(a)^2+2aT(a)\cdot\partial_a T(a)&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;p&gt;可以解得&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cpartial_a+T%28a%29%3D%5Cfrac%7BT%28a%29%5E2%7D%7B1-2aT%28a%29%7D%3DT%28a%29%5E2%5Ccdot+L%282%5Ccdot+a%5Ccdot+T%28a%29%29&quot; alt=&quot;\partial_a T(a)=\frac{T(a)^2}{1-2aT(a)}=T(a)^2\cdot L(2\cdot a\cdot T(a))&quot; eeimg=&quot;1&quot;&gt;&lt;/p&gt;&lt;p&gt;这个式子表明，带有空位的二叉树可以用两个列表和一个列表的二元组表示，这个列表的每项包含三个部分：一个布尔值，一个节点和一个子树。事实上，这个列表就表示了从树根到空位走过的路径：布尔值分辨每次是左转还是右转，节点值标记路过的节点，子树值标记另一侧的东西；而前面那两个树则是空位下面的子树。&lt;/p&gt;&lt;p&gt;——&lt;/p&gt;&lt;p&gt;最后，如果说数学家就是在寻找相似性的话，那么这个应该是一个非常好的案例了。&lt;/p&gt;</description>
<author>Belleve</author>
<guid isPermaLink="false">20570808</guid>
<pubDate>Sun, 14 Feb 2016 06:33:25 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻][小道消息] ART又要考虑用基于LLVM的编译器了…</title>
<link>http://zhuanlan.zhihu.com/hllvm/20569303</link>
<description>如题。真就跟国内修公路一样，修了拆拆了修…&amp;gt;_&amp;lt;&lt;br&gt;&lt;p&gt;另外一方面，ART在向着使用OpenJDK类库的方面倒是有扎实的进展。看这个 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/6c37e9adf7afc547a0fdf4db29249f6982845162/runtime/openjdkjvm/OpenjdkJvm.cc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;runtime/openjdkjvm/OpenjdkJvm.cc&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 就是HotSpot的hotspot/src/share/vm/prims/jvm.cpp的对应物。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20569303</guid>
<pubDate>Sat, 13 Feb 2016 03:10:49 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] ART有了新的汇编写的解释器</title>
<link>http://zhuanlan.zhihu.com/hllvm/20491978</link>
<description>&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/c3ba07ef76549129705af28173070b88a1c39531&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Merge &quot;Fast Art interpreter&quot;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;p&gt;觉得Android Runtime（ART）的解释器比不上Dalvik用汇编写的解释器的同学，你们得到了：汇编解释器卷土重来 ^_^&lt;/p&gt;&lt;p&gt;——显然，ART还是有相当部分的代码要在解释器里跑，不然解释器性能再差又如何呢。&lt;/p&gt;&lt;p&gt;而dex2oat对PGO的支持也如火如荼进行中：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/art/%2B/27e17fd81cc30e16e86c9c15498cae7f920c9dfe&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Enable profiled guided compilation in dex2oat&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20491978</guid>
<pubDate>Sat, 16 Jan 2016 15:39:30 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>新手上路学习JavaScript引擎实现——路线图</title>
<link>http://zhuanlan.zhihu.com/hllvm/20505562</link>
<description>&lt;p&gt;最近在知乎接连看到几个相关的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/39468189&quot; class=&quot;internal&quot;&gt;如何阅读 ChakraCore 的代码?&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/39014659&quot; class=&quot;internal&quot;&gt;新手应该如何读Google V8引擎源代码？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/38332604&quot; class=&quot;internal&quot;&gt;Kinoma XS6 是一款怎样的 JavaScript 引擎？&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;这些问题都是试图从阅读源码着手去学习JavaScript引擎的实现的。然而，对新手而言，直接从一个复杂的实现的源码着手，不可避免的是事倍功半的做法。&lt;/p&gt;&lt;p&gt;要学习JavaScript引擎的实现，就跟学习其它东西一样，最好是循序渐进的来，先打好基础，再去结合现实学习主流实现。&lt;/p&gt;&lt;p&gt;我推荐的学习路线是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;临摹：先找个比较简单语言的简单解释器实现，以它为模子，自己抄一个解释器出来。这个过程中可以学习到编程语言的解释器的基本构造，特别是其组成部分的划分，以及这些组成部分在工作流程中各自处于什么位置。整个流程串起来之后，思路就会清晰许多，接下去学习就可以有针对性了。&lt;/li&gt;&lt;li&gt;巩固：临摹的时候必然只能一个解释器的各部分的一种特定的简单实现。然而其背后的原理是怎样的，同一个组件是否有别的更先进（或不同取舍）的做法，就需要进一步学习了。此时可以针对各部分去读不同的书，例如编译原理、GC、对象模型等方面。学习原理，巩固基础，拓展视野。&lt;/li&gt;&lt;li&gt;规范：到此有足够基础可以着手学习/实现真正的JavaScript引擎了。但在动手之前，应该熟读&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/6.0/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMAScript规范&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，了解到底JavaScript语言所要求的语义是怎样的，解决“是什么”的问题。觉得新的ECMAScript 2015太复杂的话，从&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/5.1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMAScript 5.1&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习是个不错的开始。有个带注解的ECMAScript 5.1规范特别适合学习：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//es5.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Annotated ECMAScript 5.1&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。另外，更喜欢阅读中文文档的同学可以看&lt;a href=&quot;https://www.zhihu.com/people/b2abeb901f0608346f2517bebcd224aa&quot; data-hash=&quot;b2abeb901f0608346f2517bebcd224aa&quot; class=&quot;member_mention&quot; data-tip=&quot;p$b$b2abeb901f0608346f2517bebcd224aa&quot;&gt;@呂康豪&lt;/a&gt;大大在评论区推荐的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.w3.org/html/ig/zh/wiki/ES5&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ES5 - HTML5 Chinese Interest Group Wiki&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，那是他的怨念喔。&lt;/li&gt;&lt;li&gt;接轨：把前面学习的知识都结合起来，按照规范实现自己的简单的JavaScript引擎；或者此时也可以去阅读现成的比较简单的JavaScript引擎的实现，但还是自己动手写过一次能有更深刻的理解。&lt;/li&gt;&lt;li&gt;进阶：到这个阶段，再去阅读现实中主流的、高性能的JavaScript引擎的源码，就可以做到有的放矢了。快速阅读一下官方文档，浏览一下代码组织结构，就应该能大概掌握一个实现的大致架构。然后再抓住JavaScript引擎实现可能存在的重要设计点去看看，就可以知道这个实现在每个部分都选择了哪些实现方式。其实就像搭积木一样，每个部分能有什么选择都了然于心，这样再去深入到细节读代码，就可以事半功倍的提取出自己想要知道的信息了。很多时候看目录结构和源码文件名就能大概猜到需要的信息在哪个文件里，进去确认一下就好。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;我推荐这个学习路线，是因为上面的阶段我全都走过一遍了，亲测有效。国内有不少从事JavaScript引擎研发的同行们，不知道大家的学习路线又是怎样的呢？&lt;/p&gt;&lt;p&gt;以&lt;a href=&quot;https://www.zhihu.com/question/38332604/answer/75904396&quot; class=&quot;internal&quot;&gt;Kinoma XS6的讨论&lt;/a&gt;为例，我从看到问题到开始阅读源码，到写完整个回答，总共只用了几分钟。这个回答就包含了我在阅读一个JavaScript引擎实现时会首先关注的设计点，抓住这些点去阅读源码就可以很快的了解这个实现的全貌、其大体的设计思路和取舍方向。换言之，我并不需要为了了解它的概况而需要去从细节开始学习很多新的知识，而只要在已有知识里印证这个实现在可能的实现方式里到底选择了哪些。&lt;/p&gt;&lt;p&gt;另外也想提一下Constellation大大的lv5 JavaScript引擎（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Constellation/iv&quot; class=&quot;internal&quot;&gt;Constellation/iv · GitHub&lt;/a&gt;）。它的发展历程见证了Constellation的成长，也跟上面的学习路线中“规范-接轨-进阶”的过程完全吻合——一开始lv5是作者边读ES5规范边用最直观的方式把规范实现出来的。整个流程走通之后，他就开始从开源的主流JavaScript引擎学习先进的做法，并逐步实现到lv5当中，渐渐将其发展成一个颇为实在的、现代的实现。&lt;/p&gt;&lt;p&gt;我在这里也提到过lv5：&lt;a href=&quot;https://www.zhihu.com/question/34589661/answer/79792354&quot; class=&quot;internal&quot;&gt;准大三，计算机专业如何确定工作方向？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;我从2012年开始其实也有断断续续积累一些文字，希望能规整到一个系统的知识体系下写成一本书，以便更好的把这些相关知识传播给大家。不过目前这个计划还在早期阶段，暂时不接受催稿谢谢…&lt;/p&gt;&lt;p&gt;虽然书离成形还尚远，但我曾经试过把积累的内容的一部分汇总起来发出来：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/37596&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;[链接帖] 各JavaScript引擎的简介，及相关资料/博客收集帖&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，欢迎大家参考和提建议。这系列帖子已好久没更新就是了…&lt;/p&gt;&lt;br&gt;&lt;p&gt;话说回来，万事开头难，按照上面的路线，得找个最初的临摹对象来学习。&lt;/p&gt;&lt;p&gt;可以选择的对象有很多，不过这里我还是想再次推荐&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/4118518/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『プログラミング言語を作る』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中文版&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/25735333/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《自制编程语言》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）一书。我在这里发过一个简介帖：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/39194&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《自制编程语言》集中讨论帖&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//kmaebashi.com/programmer/devlang/crowbar.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Crowbar&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;语言及其解释器实现，就是我想推荐作为入门临摹的对象。&lt;br&gt;&lt;/p&gt;&lt;p&gt;欲知它究竟是怎样设计与实现，且看下回分晓 ^_^&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20505562</guid>
<pubDate>Sat, 16 Jan 2016 15:33:20 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] 微软如期开源ChakraCore JavaScript引擎</title>
<link>http://zhuanlan.zhihu.com/hllvm/20498427</link>
<description>&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blogs.windows.com/msedgedev/2016/01/13/chakracore-now-open/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ChakraCore GitHub repository is now open&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft/ChakraCore · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/Chakra-Samples&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft/Chakra-Samples · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;官方推账号：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/ChakraCore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@ChakraCore&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;开发路线图：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore/wiki/Roadmap&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Roadmap · Microsoft/ChakraCore Wiki · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ChakraCore架构文档：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore/wiki/Architecture-Overview&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Architecture Overview · Microsoft/ChakraCore Wiki · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 。&lt;a href=&quot;https://www.zhihu.com/people/f34d97ee3caf7250348b566a89025c31&quot; data-hash=&quot;f34d97ee3caf7250348b566a89025c31&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@彭飞&quot; data-tip=&quot;p$b$f34d97ee3caf7250348b566a89025c31&quot;&gt;@彭飞&lt;/a&gt; 翻译了一份&lt;a href=&quot;http://zhuanlan.zhihu.com/fiigii/20501758&quot; class=&quot;internal&quot;&gt;中文版&lt;/a&gt;。基本上跟之前在IE Blog / Windows Blog上有的信息一样，还没有啥新的信息。开源后能获取的新信息看来都得从源码里挖掘了。&lt;/p&gt;&lt;p&gt;ChakraCore源码目录结构：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ChakraCore/wiki/ChakraCore-Code-Structure&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ChakraCore Code Structure · Microsoft/ChakraCore Wiki · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//azure.microsoft.com/en-us/blog/the-road-ahead-for-azure-documentdb-with-chakracore/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Running JavaScript in Azure DocumentDB with Chakra&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;h3&gt;Bytecode serialization&lt;/h3&gt;&lt;p&gt;Upon registering a server-side script, DocumentDB uses Chakra to pre-compile and serialize the script to bytecode. In a normal JavaScript execution pipeline, the engine needs to parse the code, produce syntax trees and generate bytecode prior to execution. Chakra’s bytecode serialization allows DocumentDB to pre-process scripts up until (and including) bytecode generation and save a cached copy of the bytecode for re-use. This allows users to avoid the cost of re-parsing the script each time it is executed, which leads to substantial performance savings over time.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;基于寄存器的字节码设计。有一套扩展的字节码专门用于表达asm.js的语义。&lt;/p&gt;&lt;p&gt;等俺有空读读代码再补充点内容上来。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/38238351/answer/75496276&quot; class=&quot;internal&quot;&gt;如何看待微软 12 月 5 日宣布准备开源其 JavaScript 引擎 Chakra 的核心部分？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20498427</guid>
<pubDate>Thu, 14 Jan 2016 02:27:44 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] 看图猜语言实现——答案</title>
<link>http://zhuanlan.zhihu.com/hllvm/20445566</link>
<description>&lt;p&gt;之前发的&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20416295&quot; class=&quot;internal&quot;&gt;[号外] 看图猜语言实现&lt;/a&gt;帖大概也不会有新的跟帖回答，是时候放答案了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实答案就在这个回答里：&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; class=&quot;internal&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一组图的关键字：J9&lt;br&gt;&lt;/li&gt;&lt;li&gt;第二组图的关键字：Testarossa&lt;br&gt;&lt;/li&gt;&lt;li&gt;第三组图的关键字：Modron&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;结合起来就是：&lt;/p&gt;&lt;p&gt;IBM J9 Java虚拟机，以及其使用的JIT编译器Testarossa，以及其GC框架Modron。&lt;/p&gt;&lt;p&gt;之前看到J9的开源项目——OMR的技术预览版——发布的消息实在是兴奋，手痒就发了这么个猜谜。&lt;/p&gt;&lt;p&gt;您猜对了么？&lt;/p&gt;&lt;br&gt;&lt;p&gt;祝大家圣诞快乐——如果您过这个节的话 &amp;gt;_&amp;lt; 只是应景说说&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20445566</guid>
<pubDate>Fri, 25 Dec 2015 07:59:01 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] 看图猜语言实现</title>
<link>http://zhuanlan.zhihu.com/hllvm/20416295</link>
<description>&lt;p&gt;结合这个专栏的主题以及我在知乎最近的动态，看下面的几张图猜一个&lt;b&gt;编程语言平台的实现的名字&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;所有图结合起来都是指同一个实现（可能指其中的某个部分），不是每组图对应一个语言/实现啥的。&lt;/b&gt;把图片分组是因为同一组的图隐含的是同一个单词。&lt;/p&gt;&lt;p&gt;&lt;b&gt;猜的是语言的实现的名字，不是编程语言的名字。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实应该很简单…相信评论里很快就会有人放答案了。有兴趣猜的话就先别看评论区嗯。&lt;/p&gt;（其实我以前一直想画张包含这些元素的图，但一直坑着…有大大有兴趣帮忙画一张不？）&lt;br&gt;&lt;br&gt;&lt;p&gt;1. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/92e222372976f4ba30f1fe71bc6064c8_b.jpg&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;999&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;999&quot; data-original=&quot;https://pic1.zhimg.com/92e222372976f4ba30f1fe71bc6064c8_r.jpg&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/7e428368fd6ac7eb57527ecd19e9230d_b.jpg&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;445&quot; class=&quot;content_image&quot; width=&quot;346&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;2. &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/1659d6008c54dc48e8e05fcde34abbc6_b.jpg&quot; data-rawwidth=&quot;2883&quot; data-rawheight=&quot;1365&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2883&quot; data-original=&quot;https://pic3.zhimg.com/1659d6008c54dc48e8e05fcde34abbc6_r.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/949f7fb0a7800cf3285e80e1ed5c0151_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;1464&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic2.zhimg.com/949f7fb0a7800cf3285e80e1ed5c0151_r.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/4be876f664b62583b66407e7139ea859_b.jpg&quot; data-rawwidth=&quot;696&quot; data-rawheight=&quot;696&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;696&quot; data-original=&quot;https://pic2.zhimg.com/4be876f664b62583b66407e7139ea859_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;3. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/ffc0bfe7ec5f13fe1493c2d2ac41785c_b.jpg&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;764&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/ffc0bfe7ec5f13fe1493c2d2ac41785c_r.jpg&quot;&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20416295</guid>
<pubDate>Mon, 14 Dec 2015 16:22:11 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>学习编程语言与编译优化的一个书单</title>
<link>http://zhuanlan.zhihu.com/hllvm/20130808</link>
<description>其实是想放张图：&lt;img src=&quot;https://pic3.zhimg.com/21e2e4bb3586ece2078fd6c3c65d4cbe_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;1228&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/21e2e4bb3586ece2078fd6c3c65d4cbe_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;（这个书单帖居然有那么多点赞，完全没料到。我这帖说的应该是很小众的内容才对？压力好大…）&lt;/p&gt;&lt;p&gt;要学习编程语言原理与编译/优化原理，有许多书可读。我的生活乐趣之一就是不断的读这个领域的各种书 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;但毕竟很多书覆盖的知识点或者说切入点都是类似的，只是为了学习知识而不是纯为了生活乐趣的话，倒没必要全都读了。每个方面挑些&lt;b&gt;适合自己偏好&lt;/b&gt;的好书读读就好。&lt;/p&gt;&lt;p&gt;这里挑了我放在办公室里的书的其中几本，供大家参考一下从入门到深入学习&lt;b&gt;偏编译优化方向的编程语言知识的路线图&lt;/b&gt;。编程语言原理涉及的知识面相当广，也有许多不同的细分方向，这里就只针对编译优化这个比较窄的方向做些推荐。&lt;/p&gt;&lt;p&gt;上图的书的阅读顺序是从上到下。欢迎大家评论和推荐更好的书 ^_^&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;书单&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这些书从上到下分别是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3743526/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Third Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/10802357/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第三版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5407246/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（英文版·第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（原版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3023631/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Computer Systems: A Programmer&#39;s Perspective, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5333562/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（原书第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/4117971/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版即将上市，译者是想能的信息科技的严圣逸和支付宝的前端架构专家绝云）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5288601/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Engineering a Compiler, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/20436488/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《编译器设计》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1821532/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Advanced Compiler Design and Implementation》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1400374/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《高级编译器设计与实现》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2359859/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《High-Performance Compilers for Parallel Computing》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（尚无中译版）&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2126867/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Optimizing Compilers for Modern Architectures》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1171448/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《现代体系结构的优化编译器》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;学习路线图&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这份书单中，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;头两本书用于了解大背景的。To get the big picture；&lt;br&gt;&lt;/li&gt;&lt;li&gt;中间两本是用来做编译原理入门的；&lt;br&gt;&lt;/li&gt;&lt;li&gt;最后三本用于深入学习编译与优化的知识。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这三个阶段里，每个阶段都可以有其它书可以替代。这些只是&lt;b&gt;适合我的偏好&lt;/b&gt;的选择而已。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;1. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3743526/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Third Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/10802357/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第三版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;2009年出版。简称PLP。这本书主要用于掌握编程语言方面的大背景——编程语言是什么、有哪些种类，实现编程语言的大体流程是怎样，在编程语言的设计与实现里都会用到些什么术语等。它的Part I和Part II不但讲解了编程语言常见的结构，也顺带提到了它们背后涉及的一些实现，其实比专门的编译原理书更适用于最初的入门。&lt;br&gt;&lt;/p&gt;&lt;p&gt;第三版目录在此：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cs.rochester.edu/u/scott/pragmatics/3e/toc.shtml&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PLP 3e Table of Contents&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;书中对许多概念的讲解在编程语言中有普适意义。例如说书中提到了“display”的概念，在讲stack frame的static link/static chain时提到可以使用display来减少需要的递归搜索的次数——对递归深度有固定上限的问题，可以把递归搜索的结果事先放在一个小数组里，这个数组就是“display”（裘老师译为“区头向量”）。这个“display”的概念其实可以引伸到各种递归问题，例如基于类的面向对象语言里的快速子类型检查就可以用上display；相关的，像是面向对象语言所用的虚函数表（vtable）其实也是一个变种display。&lt;/p&gt;&lt;p&gt;这本书顺带充当了我学习许多语言的入门书，拓宽了我的知识面。Scheme、Ada、Prolog之类的好些语言我都是从这本书开始真的接触并写代码来学习的。&lt;/p&gt;&lt;p&gt;我最初读的是裘宗燕老师翻译的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2152385/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《程序设计语言——实践之路（第二版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。这是我喜欢的中译版技术书之一。虽然里面的术语译法跟我所喜欢的不完全一致，但完全没影响阅读。&lt;/p&gt;&lt;p&gt;评论里&lt;a href=&quot;https://www.zhihu.com/people/6f8a5a4cb5218434cf962c835b21afde&quot; data-hash=&quot;6f8a5a4cb5218434cf962c835b21afde&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@Snow Liang&quot; data-tip=&quot;p$b$6f8a5a4cb5218434cf962c835b21afde&quot;&gt;@Snow Liang&lt;/a&gt;提醒说这本书今年11月就要出第四版了：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/26424018/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Programming Language Pragmatics, Fourth Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。真好！&lt;/p&gt;&lt;p&gt;作者&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rochester.edu/u/scott/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Michael L. Scott&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;是&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.rochester.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rochester大学&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的教授，虽然本职教学并不主要是编程语言相关，而是诸如事物内存（transactional memory）之类，但是他对这本书颇为投入而且也对成果感到很满意。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;2. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5407246/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（英文版·第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（原版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3023631/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Computer Systems: A Programmer&#39;s Perspective, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5333562/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入理解计算机系统（原书第2版）》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;原书2008年出版。大名鼎鼎的CS:APP，是从软件角度学习系统知识必备的一本入门书，不用多说。这本书刚新出了第三版不过我还没舍得买，所以书单上只能先放着第二版。&lt;/p&gt;&lt;p&gt;前一本书PLP主要从上层介绍编程语言上的概念，而这本书主要介绍编程语言的概念会映射到怎样的系统层概念上。从编译器的角度看，PLP主要覆盖的是编程语言的词法、语法、语义的部分，是编译器前端的知识；而CS:APP则更关注把编程语言的概念映射到实际的CPU、内存、操作系统层面上，是编译器后端的知识。两者结合起来就完美的覆盖了学习编译器所需的知识面，对编译原理的全貌有一个把握。&lt;/p&gt;&lt;p&gt;国内的同学们是幸福的，这本书的影印版质量非常非常好，纸张、印刷都极其高质量，不能再多赞了！买本影印版感觉赚大了。中译版我没读过不过据说质量也不错。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;3. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/4117971/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;（书名可以直译为：《写个普通的编译器——通过编写语言处理器来学习编译与运行时环境的原理》。呃真引进的话肯定不会这么译…）&lt;/p&gt;&lt;p&gt;2009年出版。这是本日文书。有那么多入门级编译器书，为啥我要选它来推荐？&lt;/p&gt;&lt;p&gt;因为我觉得这本书写得很实在，适合入门学习时形象地掌握整个编译流程，其中都有哪些环节，每个环节间又是如何互动的。在&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/people/RednaxelaFX/all%3Fsort%3Dtime%26tags_sort%3Dcount%26filter%3Dall%26tag%3D%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%26mode%3Dgrid&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我读过或接触过的编译器书&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;里，它算是我最推荐的用于指导实际写第一个编译器的入门书。&lt;/p&gt;&lt;p&gt;这本书的知识点和难度大致都跟斯坦福的编译原理入门课CS143相近，结合两者来学习也是不错的选择。请参考另一帖：&lt;a href=&quot;http://www.zhihu.com/question/28679215/answer/43883727&quot; class=&quot;internal&quot;&gt;斯坦福大学编译原理课程质量怎么样？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这本书吸引我的特点有两个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从头到尾围绕一个完整可运行的简易编译器来讲解；完整配套源码在Github就有：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/aamine/cbc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;aamine/cbc · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;覆盖了从词法/语法分析 -&amp;gt; 语义分析 -&amp;gt; 中间代码生成 -&amp;gt; 目标代码生成 -&amp;gt; 链接 -&amp;gt; 运行时环境的完整流程。并没有过于纠缠于其中的任一环节（特别是没有过于纠缠于前端部分），而是更关注整体流程，注重大局观。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这本书描述的是一个名为&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/aamine/cbc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;C♭&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（读作C-flat）语言的编译器cbc，使用Java实现，目标运行环境是Linux/x86。&lt;/p&gt;&lt;p&gt;C♭是一个C的简化版，简化的主要是宏相关的部分以及早期C一直延续下来的许多小细节；保留下来的部分覆盖了C的绝大部分功能，例如基本类型、函数、指针，struct/union等等，作为入门级编译器的源语言功能上正好适中。&lt;/p&gt;&lt;p&gt;cbc编译器的整体工作流程是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Cb源码
=&amp;gt; [ 词法分析 + 语法分析 ] =&amp;gt; // 由JavaCC生成
抽象语法树（AST）
=&amp;gt; [ Visitor模式的语义分析 ] =&amp;gt;
标注的抽象语法树（Annotated AST）
=&amp;gt; [ 中间代码生成 ] =&amp;gt; // 跟虎书的C版本非常相似，但代码风格比虎书好
树形中间代码（Tree IR）
=&amp;gt; [ 简单优化 ] =&amp;gt;
优化过的中间代码
=&amp;gt; [ 代码生成 ] =&amp;gt;    // 使用Java写的内部DSL来生成GNU as格式的汇编
                     // 支持可重定位与不可重定位两种版本的代码生成
GNU as格式的汇编
=&amp;gt; [[ GNU as ]] =&amp;gt;   // 汇编器
目标代码
=&amp;gt; [[ GNU ld ]] =&amp;gt;   // 链接器
ELF可执行文件 / 动态链接库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中用单中括号标注的环节是cbc自己实现的，而双中括号标注的部分则是依赖现成的工具实现。cbc生成的代码符合Linux/x86的C ABI，可以跟libc或者其它导出C ABI的库链接起来。&lt;/p&gt;&lt;p&gt;以此，C♭程序从源码到可执行文件到运行时环境的整个流程都在本书中有所体现。&lt;br&gt;&lt;/p&gt;&lt;p&gt;细心的读者可能会问：cbc不用分配寄存器么？答案是它用了非常非常简易的分配方式——“栈顶缓存”——直接融合在代码生成环节中。详细请见另一帖：&lt;a href=&quot;http://www.zhihu.com/question/29355187/answer/51935409&quot; class=&quot;internal&quot;&gt;寄存器分配问题？ - RednaxelaFX 的回答&lt;/a&gt;&lt;/p&gt;&lt;p&gt;要在中文社区推广这本书，光靠日文原版还是太困难。就等有爱人士到图灵社区去接下翻译任务啦：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ituring.com.cn/book/1308&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;图灵社区 : 图书 : 自制编译器&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，我可以提供充分的技术支持 :-)&lt;/p&gt;&lt;p&gt;更新：这本书已经有译者接下了，是想能的信息科技的严圣逸和支付宝的前端架构专家绝云。太好了！据说2016年4月底可以上市。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;4. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/5288601/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Engineering a Compiler, Second Edition》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/20436488/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《编译器设计》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;2011年出版。简称EAC2。据说有人把这本书称为“橡书”但我不知道这种叫法的来源是啥。书的封面图是“The Landing of the Ark”。&lt;/p&gt;&lt;p&gt;这本书是编译原理教材里我最喜欢的一本，没有之一。它用作入门时的第一本书也行，放在『ふつうのコンパイラをつくろう』之类的简易入门书之后作为正式学习编译原理的教材也很合适。它覆盖的知识面足以应付初级到中级编译原理的学习，内容夯实，脉络清晰，语言既干练又不失形象。&lt;/p&gt;&lt;p&gt;而且它选择讲解的知识点都是相当实用且与时俱进的——可能就除了寄存器分配的地方没有专门的小节讲线性扫描寄存器分配算法（Linear-scan register allocation）不够与时俱进——其它讲的都是当代编译器里常见而实用的内容。&lt;/p&gt;&lt;p&gt;例如说第9章讲数据流分析的部分，主要结合SSA形式来展开，比起特别传统的非要从非SSA形式讲起、最后在进阶部分提一下SSA形式的做法要现代多了。&lt;/p&gt;&lt;p&gt;EAC2目录在此：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.elsevier.com/wps/find/bookdescription.cws_home/724559/description%23description&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Elsevier&#39;s site for Engineering a Compiler&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本书作者&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/%7Ekeith/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Keith D. Cooper&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/%7Elinda/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Linda Torczon&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;都是&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.rice.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice大学&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的名教授，而且两人同为&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/%7Eken/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ken Kennedy&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;的学生。后面会再提到他们的关系。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;5. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1821532/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Advanced Compiler Design and Implementation》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1400374/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《高级编译器设计与实现》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;1997年出版。大名鼎鼎的“鲸书”，在编译原理的经典动物书“龙虎鲸”中排得上号的进阶读物。从这本书开始就要深入学习编译优化了。&lt;/p&gt;&lt;p&gt;这本书只关心优化编译器的中、后端涉及优化的部分，而完全不涉及前端的词法/语法分析或语言相关的语义分析。因而它虽然不适合作为初学教材，但在进阶学习时非常好用——完全没废话，直达痛点。&lt;/p&gt;&lt;p&gt;本书作者Steven Stanley Muchnick不但在学术界很有影响，在业界也参与了一些重量级项目，例如HP的PA-RISC的设计及其优化编译器的实现，然后是Sun的SPARC的设计及其优化编译器的实现。鲸书里介绍的编译器优化技术都是实打实的，理论结合实际，边读边实践很痛快。&lt;/p&gt;&lt;p&gt;要是还能再来个新版本就好了…&lt;/p&gt;&lt;br&gt;&lt;p&gt;接下来要介绍的两本其实只是在鲸书的基础上拓展一下视野用的，免得受单一作者的偏好而限制了自己的选择范围。这两本都是相对偏老的书，以Fortran编译器中的优化为主要介绍对象，重点介绍数据依赖分析、循环优化、自动向量化之类的话题，在现在各种主流CPU都强力推出SIMD指令的潮流下并不过时，反而相当值得参考。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;6. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2359859/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《High-Performance Compilers for Parallel Computing》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;1995年出版的老书。尚未有中译版，以后也不太可能会有吧。&lt;/p&gt;&lt;p&gt;作者Michael Wolfe。我现在就职的Azul Systems有位元老员工叫做Michael Wolf，是我们的pauseless GC算法的设计者之一，非常牛。一开始我是因为把名字看错了才买的这本书，却有意想不到的收获。&lt;/p&gt;&lt;p&gt;因为这本书很奇葩！&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;7. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2126867/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Optimizing Compilers for Modern Architectures》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;（中译版：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1171448/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《现代体系结构的优化编译器》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;）&lt;/p&gt;&lt;br&gt;&lt;p&gt;（待补充）&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;8. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//ssabook.gforge.inria.fr/latest/book.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Static Single Assignment Book》&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Bonus：这是一本还在写作中的书，因此没有纸质版，暂时只有电子版。不过对许多本来就不想买书的同学们来说或许是个福音吧（逃&lt;/p&gt;&lt;p&gt;静态单赋值形式（SSA Form）是现代主流编译器都会采用的IR形式，而且越来越多编译器开始以SSA形式的IR为主。&lt;/p&gt;&lt;p&gt;最极致的是像LLVM那样采用单层IR，而且这个IR必须是SSA形式的。许多人觉得LLVM IR操作起来方便的原因之一就是许多算法在SSA形式下表达起来很简洁直观。说来，因为LLVM IR本身不是Memory-SSA或Heap-SSA形式，并不显式跟踪内存中的赋值，所以前端在生成LLVM IR时倒不必总是自己构建SSA形式，而可以用alloca分配局部变量然后让LLVM自带的mem2reg去构建SSA形式，所以这种SSA形式的IR也没有给前端增加负担，是个双赢。&lt;/p&gt;&lt;p&gt;既然SSA形式这么重要这么流行，应该有本书专门以它为线索来介绍编译原理的知识对不对？这本书就是如此。它是许多作者合写的，每一章都像是一篇相对独立的论文一样，围绕SSA形式介绍了编译器中后端的方方面面。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;还缺什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实我还很希望能在书单里有几本介绍对JIT编译器或者说运行时编译做重点讲解的书，以及对动态类型语言的编译优化做重点讲解的书。可惜这些方面的论文虽然不少，但却没有现成的书对其做系统性的讲解。&lt;/p&gt;&lt;p&gt;好在万变不离其宗，JIT编译器与动态语言优化其实都还是在传统的编译原理基础上的进化，掌握好基础的话这些话题都会变得更易于理解。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;一些背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;“&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.rice.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;系”的编译器大牛们：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.rice.edu/CS/compilers/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rice Compiler Group&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;“&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.stanford.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Stanford&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;系”的编译器大牛们：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//suif.stanford.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The SUIF Group&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;==========================================================&lt;/p&gt;&lt;p&gt;顺带给想八卦的同学们，这是我办公室书架的全景：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/a25fcec4cae70aaa039802eaa94a9a4e_b.jpg&quot; data-rawwidth=&quot;2048&quot; data-rawheight=&quot;1085&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2048&quot; data-original=&quot;https://pic3.zhimg.com/a25fcec4cae70aaa039802eaa94a9a4e_r.jpg&quot;&gt;&lt;br&gt;&lt;p&gt;有不少眼熟的书对不对？^_^&lt;/p&gt;&lt;p&gt;还有更多书放在家里的书架上。家里的书架已经快溢出了所以不得不把越来越多书搬到办公室来…&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20130808</guid>
<pubDate>Mon, 27 Jul 2015 12:53:52 +0800</pubDate>
<media:thumbnail url="https://pic3.zhimg.com/b806999aa557e5e839cf51bccbd4d8e2_b.jpg" />
</item>
<item>
<title>Lambda 表达式无法定义的一个算符</title>
<link>http://zhuanlan.zhihu.com/hllvm/20049022</link>
<description>很多人都问我如何理解 yield 云云，事实上 yield 以及其他的类似物包括 call/cc 都是用 Lambda 演算&lt;b&gt;无法定义&lt;/b&gt;的东西。&lt;p&gt;就比如 call/cc 吧，如果我们规定 Continuation 永不返回，或者说它是&lt;b&gt;发散&lt;/b&gt;的，那么它的类型可以唯一指定成&lt;img src=&quot;https://zhihu.com/equation?tex=%5Calpha%5Crightarrow%5Cbot&quot; alt=&quot;\alpha\rightarrow\bot&quot; eeimg=&quot;1&quot;&gt;，或者说&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cneg%5Calpha&quot; alt=&quot;\neg\alpha&quot; eeimg=&quot;1&quot;&gt;。那么考虑 call/cc 算子，它的类型首先肯定得满足&lt;img src=&quot;https://zhihu.com/equation?tex=%28%28%5Calpha%5Crightarrow%5Cbot%29%5Crightarrow%5Cbeta%29%5Crightarrow%5Cgamma&quot; alt=&quot;((\alpha\rightarrow\bot)\rightarrow\beta)\rightarrow\gamma&quot; eeimg=&quot;1&quot;&gt;，而考察 call/cc(&lt;i&gt;f&lt;/i&gt;) 两种可能的返回情况——通过（丢给 &lt;i&gt;f&lt;/i&gt; 的） continuation 返回或者 &lt;i&gt;f&lt;/i&gt; 正常返回——那么可以得到等式&lt;img src=&quot;https://zhihu.com/equation?tex=%5Calpha%3D%5Cbeta%3D%5Cgamma&quot; alt=&quot;\alpha=\beta=\gamma&quot; eeimg=&quot;1&quot;&gt;，即：&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7Bcall%2Fcc%7D%3A%28%5Cneg%5Calpha%5Crightarrow%5Calpha%29%5Crightarrow%5Calpha&quot; alt=&quot;\mathrm{call/cc}:(\neg\alpha\rightarrow\alpha)\rightarrow\alpha&quot; eeimg=&quot;1&quot;&gt;。若允许 Continuation 返回，则 call/cc 的类型可定为&lt;img src=&quot;https://zhihu.com/equation?tex=%28%28%5Calpha%5Crightarrow%5Cbeta%29%5Crightarrow%5Calpha%29%5Crightarrow%5Calpha&quot; alt=&quot;((\alpha\rightarrow\beta)\rightarrow\alpha)\rightarrow\alpha&quot; eeimg=&quot;1&quot;&gt;。接下来将证明这条定律可以推出排中律（使用 LJ 推理系统）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;α ⊢ &lt;/b&gt;&lt;b&gt;α&lt;/b&gt; [I]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α ⊢ α ∨ &lt;/b&gt;&lt;b&gt;¬α&lt;/b&gt; [∨R](1);&lt;/li&gt;&lt;li&gt;&lt;b&gt;⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [I]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [WL](2);&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, (α ∨ ¬α) → ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [→L, (1), (2)](3);&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ &lt;/b&gt;&lt;b&gt;⊥&lt;/b&gt; [→L, (1), (3)]&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;α, ((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ ⊥&lt;/b&gt; [WL]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ α → ⊥&lt;/b&gt; [→R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ, (α ∨ ¬α) → (α ∨ ¬α) → ⊥ ⊢ α ∨ &lt;/b&gt;&lt;b&gt;¬α&lt;/b&gt; [∨R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ ⊢&lt;/b&gt;&lt;b&gt; ((α ∨ ¬α) → ¬(α ∨ ¬α)) → &lt;/b&gt;&lt;b&gt;(α ∨ ¬α)&lt;/b&gt; [→R]&lt;/li&gt;&lt;li&gt;&lt;b&gt;((γ → β) → γ) → γ ⊢ α ∨ ¬&lt;/b&gt;&lt;b&gt;α&lt;/b&gt; [MP，代换律]&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;换言之，如果 call/cc 是 Lambda 可表的，则意味着直觉自然演绎可以证明排中律——这显然不可能，于是 call/cc 必然是 Lambda 不可表，它必须作为单独的算符扩充到 Lambda 演算的体系里来。</description>
<author>Belleve</author>
<guid isPermaLink="false">20049022</guid>
<pubDate>Fri, 29 May 2015 05:15:41 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>六离合释：指针的 Hoare Logic——Separation Logic</title>
<link>http://zhuanlan.zhihu.com/hllvm/20030603</link>
<description>Hoare Logic 是证明程序正确性的法宝，具体而言，它给出了逐步推理程序正确性的方法。Hoare Logic 使用符号 {&lt;i&gt;P&lt;/i&gt;} &lt;b&gt;e&lt;/b&gt; {&lt;i&gt;R&lt;/i&gt;} 表示程序步骤 &lt;b&gt;e&lt;/b&gt; 执行前后的行为：若断言 &lt;i&gt;P&lt;/i&gt; 在执行前成立，则 &lt;b&gt;e&lt;/b&gt; 执行后断言 &lt;i&gt;R&lt;/i&gt; 成立。一些推理规则是很显而易见的：比如&lt;p&gt;&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cfrac+%7B%5C%7BP%5C%7D%5C+%5Cmathbf%7Be%7D%5C+%5C%7BQ%5C%7D%5C+%2C+%5C+%5C%7BQ%5C%7D%5C+%5Cmathbf%7Bf%7D%5C+%5C%7BR%5C%7D+%7D+%7B%5C%7BP%5C%7D%5C+%5Cmathbf%7Be%3Bf%7D%5C+%5C%7BR%5C%7D%7D&quot; alt=&quot;\frac {\{P\}\ \mathbf{e}\ \{Q\}\ , \ \{Q\}\ \mathbf{f}\ \{R\} } {\{P\}\ \mathbf{e;f}\ \{R\}}&quot; eeimg=&quot;1&quot;&gt;(sequent)&lt;br&gt;&lt;/p&gt;&lt;p&gt;Hoare Logic 推出后在程序正确性证明方面成为了利器，然而它有一点没有包含，就是没有处理指针，于是 John C. Reynolds 等扩展的 Separation Logic 很好地处理了指针相关的内容。&lt;/p&gt;&lt;p&gt;Separation Logic 中的程序状态分为两个部分：栈区 &lt;i&gt;s&lt;/i&gt; 和堆区 &lt;i&gt;h&lt;/i&gt;，堆 &lt;i&gt;h&lt;/i&gt; 定义为地址到值的函数。两个堆&lt;b&gt;正交&lt;/b&gt;若且唯若其定义域不交，记作&lt;img src=&quot;https://zhihu.com/equation?tex=h_1+%5Cbot+h_2&quot; alt=&quot;h_1 \bot h_2&quot; eeimg=&quot;1&quot;&gt;。Separation Logic 定义了四个附加的断言符号来声明堆的性质：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;断言 &lt;b&gt;emp &lt;/b&gt;表示堆的定义域是空的&lt;/li&gt;&lt;li&gt;算符&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmapsto&quot; alt=&quot;\mapsto&quot; eeimg=&quot;1&quot;&gt;表示指针指向，即若&lt;img src=&quot;https://zhihu.com/equation?tex=s%2Ch+%5Cmodels+e%5Cmapsto+f&quot; alt=&quot;s,h \models e\mapsto f&quot; eeimg=&quot;1&quot;&gt;当且仅当&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cmathrm%7Bdom%7D%5C+h%3D%5C%7Be%5C%7D&quot; alt=&quot;\mathrm{dom}\ h=\{e\}&quot; eeimg=&quot;1&quot;&gt;且&lt;img src=&quot;https://zhihu.com/equation?tex=h%28e%29%3Df&quot; alt=&quot;h(e)=f&quot; eeimg=&quot;1&quot;&gt;&lt;/li&gt;&lt;li&gt;算符 * 叫做&lt;b&gt;分离合取&lt;/b&gt;，若状态 (&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;h&lt;/i&gt;) 满足 &lt;i&gt;P&lt;/i&gt; * &lt;i&gt;Q&lt;/i&gt;，则 &lt;i&gt;h&lt;/i&gt; 一定可以拆分成正交的两个部分 &lt;i&gt;j&lt;/i&gt;&lt;i&gt;k&lt;/i&gt; 使得 (&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;j&lt;/i&gt;) 满足 &lt;i&gt;P&lt;/i&gt;，(&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;k&lt;/i&gt;) 满足 &lt;i&gt;Q&lt;/i&gt;&lt;/li&gt;&lt;li&gt;算符 &lt;img src=&quot;https://zhihu.com/equation?tex=-%5C%21%5C%21%5Cast&quot; alt=&quot;-\!\!\ast&quot; eeimg=&quot;1&quot;&gt; 称为「法杖」或者&lt;b&gt;分离蕴含&lt;/b&gt;，若状态&lt;img src=&quot;https://zhihu.com/equation?tex=s%2Ch%5Cmodels+P-%5C%21%5C%21%5Cast+Q&quot; alt=&quot;s,h\models P-\!\!\ast Q&quot; eeimg=&quot;1&quot;&gt;，那么就表示对所有和 &lt;i&gt;h&lt;/i&gt; 正交且满足 &lt;i&gt;P&lt;/i&gt; 的堆 &lt;i&gt;j&lt;/i&gt;，有&lt;img src=&quot;https://zhihu.com/equation?tex=s%2C%28h%5Ccup+j%29%5Cmodels++Q&quot; alt=&quot;s,(h\cup j)\models  Q&quot; eeimg=&quot;1&quot;&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;分离合取和分离蕴含与逻辑学中的合取蕴含极其相似（例如，分离蕴含的前件为假时也成立），Separation Logic 也可以定义一条肯定前件：&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cfrac%7Bs%2C+h+%5Cmodels+P+%5Cast+%28P+-%5C%21%5C%21%5Cast%5C%2C+Q%29%7D%7Bs%2C+h+%5Cmodels+Q%7D&quot; alt=&quot;\frac{s, h \models P \ast (P -\!\!\ast\, Q)}{s, h \models Q}&quot; eeimg=&quot;1&quot;&gt;。&lt;p&gt;在这四个算符的基础上 Reynolds 等还定义了其他的符号，如对定义域没有要求的箭头&lt;img src=&quot;https://zhihu.com/equation?tex=%5Chookrightarrow&quot; alt=&quot;\hookrightarrow&quot; eeimg=&quot;1&quot;&gt;（表示「内存中有一项……」而非「只有一项」）和指向连续内存的记号&lt;img src=&quot;https://zhihu.com/equation?tex=e%5Cmapsto+f_1%2C+f_2%2C+...%2C+f_n&quot; alt=&quot;e\mapsto f_1, f_2, ..., f_n&quot; eeimg=&quot;1&quot;&gt;等。下图表示了&lt;img src=&quot;https://zhihu.com/equation?tex=x%5Cmapsto+3%2Cy%5Cast+y%5Cmapsto+3%2Cx&quot; alt=&quot;x\mapsto 3,y\ast y\mapsto 3,x&quot; eeimg=&quot;1&quot;&gt;对应的内存情形：&lt;img src=&quot;https://pic1.zhimg.com/4ac79f5c3e5318d9422fe2c336b7cbe0_b.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;261&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;592&quot; data-original=&quot;https://pic1.zhimg.com/4ac79f5c3e5318d9422fe2c336b7cbe0_r.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;而 &lt;img src=&quot;https://zhihu.com/equation?tex=x%5Cmapsto+3%2Cy%5Cwedge+y%5Cmapsto+3%2Cx&quot; alt=&quot;x\mapsto 3,y\wedge y\mapsto 3,x&quot; eeimg=&quot;1&quot;&gt;则是：&lt;img src=&quot;https://pic4.zhimg.com/7f0e84fb98b6e876ac909a360cf1540f_b.jpg&quot; data-rawwidth=&quot;299&quot; data-rawheight=&quot;254&quot; class=&quot;content_image&quot; width=&quot;299&quot;&gt;因为被&lt;img src=&quot;https://zhihu.com/equation?tex=%5Cwedge&quot; alt=&quot;\wedge&quot; eeimg=&quot;1&quot;&gt;连接的两条子断言描述的是同一片内存。&lt;/p&gt;&lt;p&gt;Separation Logic 用于证明程序正确性的方式和 Hoare Logic 相似，但是有额外的 5 条推理规则。&lt;/p&gt;&lt;p&gt;首先是「框法则」，一个「好」程序不应该干涉和它不相关的内容，换言之如果程序满足 {&lt;i&gt;P&lt;/i&gt;} &lt;b&gt;e&lt;/b&gt; {&lt;i&gt;Q&lt;/i&gt;}，那么对于任意的内存断言 &lt;i&gt;R&lt;/i&gt;，若 &lt;i&gt;R&lt;/i&gt; 中没有被 &lt;b&gt;e&lt;/b&gt; 指向的目标，则一定有 {&lt;i&gt;P&lt;/i&gt; * &lt;i&gt;R&lt;/i&gt;} &lt;b&gt;e&lt;/b&gt; {&lt;i&gt;Q&lt;/i&gt; * &lt;i&gt;R&lt;/i&gt;}。&lt;/p&gt;&lt;p&gt;对指针赋值 &lt;b&gt;*e = f&lt;/b&gt; 而言，Separation Logic 定义了公理&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be%5Cmapsto+x%5C%7D%5C+%5Cmathbf%7B%2Ae%3Df%7D%5C+%5C%7Be%5Cmapsto+f%5C%7D&quot; alt=&quot;\{e\mapsto x\}\ \mathbf{*e=f}\ \{e\mapsto f\}&quot; eeimg=&quot;1&quot;&gt;，这个公理实际上明确了很多东西：除了被指向的目标外，还要求指针 &lt;b&gt;e&lt;/b&gt; 已经被分配了内存，野指针就是被这么消灭的。&lt;/p&gt;&lt;p&gt;解分配 &lt;b&gt;dispose e&lt;/b&gt; 的规则也很明确：&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be%5Cmapsto+x%5C%7D%5C+%5Cmathbf%7Bdispose%5C+e%7D%5C+%5C%7B%5Cmathbf%7Bemp%7D%5C%7D&quot; alt=&quot;\{e\mapsto x\}\ \mathbf{dispose\ e}\ \{\mathbf{emp}\}&quot; eeimg=&quot;1&quot;&gt;，一个（只有 e 的）堆被释放内存之后，它就空啦！&lt;/p&gt;&lt;p&gt;分配内存 &lt;b&gt;e = new(v)&lt;/b&gt; 的规则稍有些复杂：&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be+%3D+v%27+%5Cwedge%5Cmathbf%7Bemp%7D+%5C%7D%5C+%5Cmathbf%7Be%3Dnew%28v%29+%7D+%5C+%5C%7Be%5Cmapsto+v%5C%7D&quot; alt=&quot;\{e = v&#39; \wedge\mathbf{emp} \}\ \mathbf{e=new(v) } \ \{e\mapsto v\}&quot; eeimg=&quot;1&quot;&gt;（&lt;i&gt;v&#39;&lt;/i&gt; 和 &lt;i&gt;e&lt;/i&gt; 彼此不同），Separation Logic 不允许分配内存后不初始化，所以 &lt;b&gt;new&lt;/b&gt; 都是带初始值的。&lt;/p&gt;&lt;p&gt;最后一条推理规则是针对解引用 &lt;b&gt;e = *f&lt;/b&gt; 的：&lt;img src=&quot;https://zhihu.com/equation?tex=%5C%7Be%3Dv%27%5Cwedge+f%5Cmapsto+v%5C%7D%5C+%5Cmathbf%7Be%3D%2Af%7D%5C+%5C%7Be%3Dv%5Cwedge+f%5Cmapsto+v%5C%7D&quot; alt=&quot;\{e=v&#39;\wedge f\mapsto v\}\ \mathbf{e=*f}\ \{e=v\wedge f\mapsto v\}&quot; eeimg=&quot;1&quot;&gt;（&lt;i&gt;v&lt;/i&gt;, &lt;i&gt;v&#39;&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt; 彼此不同）&lt;/p&gt;&lt;p&gt;在 Separation Logic 推出之后许多人（包括发明者 Reynolds 等在内）都对其进行了各种扩展，比如针对并行的（各位可想想互相独立的并行进程&lt;img src=&quot;https://zhihu.com/equation?tex=p%5C+%7C%7C%5C+q&quot; alt=&quot;p\ ||\ q&quot; eeimg=&quot;1&quot;&gt;的推理规则怎么写），处理垃圾收集的，等等。&lt;/p&gt;</description>
<author>Belleve</author>
<guid isPermaLink="false">20030603</guid>
<pubDate>Thu, 14 May 2015 16:27:07 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
