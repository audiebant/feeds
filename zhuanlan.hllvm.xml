<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 06 May 2016 09:21:55 +0800</lastBuildDate>
<image>
<url>https://pic4.zhimg.com/4b70deef7_xl.jpg</url>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://zhuanlan.zhihu.com/hllvm</link>
</image>
<item>
<title>[新闻] 龙芯开源了OpenJDK8的MIPS64 port</title>
<link>https://zhuanlan.zhihu.com/p/20853163</link>
<description>&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/porters-dev/2016-May/000544.html&quot; data-editable=&quot;true&quot; data-title=&quot;OpenJDK 8 port for MIPS has been open sourced by Loongson&quot;&gt;OpenJDK 8 port for MIPS has been open sourced by Loongson&lt;/a&gt;&lt;p&gt;太激动了！开源世界源源不断的好消息！&lt;/p&gt;&lt;p&gt;龙芯贡献出来的这个MIPS64 port可能是国内公司对OpenJDK做出的单个最大的贡献了。就为了这个规模也值得记录在册。&lt;/p&gt;&lt;p&gt;感谢所有参与了OpenJDK移植到龙芯以及将其开源的工作的大大们 ^_^&lt;br&gt;&lt;/p&gt;&lt;p&gt;除了龙芯之外，目前国内对OpenJDK贡献最活跃的公司是华为；阿里也有向OpenJDK贡献过代码。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20853163</guid>
<pubDate>Fri, 06 May 2016 08:32:28 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Chez Scheme开源了</title>
<link>https://zhuanlan.zhihu.com/p/20808925</link>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/cisco/ChezScheme&quot; data-editable=&quot;true&quot; data-title=&quot;GitHub - cisco/ChezScheme: Chez Scheme&quot;&gt;GitHub - cisco/ChezScheme: Chez Scheme&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有人说不就是开源了个Scheme编译器么有啥那么激动的。&lt;/p&gt;当然激动啦。这是Chez Scheme啊。&lt;p&gt;我大三开始学Scheme和啃SICP是从Petite Chez Scheme 7.4开始的。能一睹完整版Chez Scheme的芳容真是太爽了——即便是重写过的新Chez Scheme，不应该说重写过了更好哇哈哈。&lt;/p&gt;&lt;p&gt;近来各种原本根本无法想像会开源的项目居然都开源了，特别是在编译器和托管运行时这边，整个潮流就很让人激动。传闻6月份IBM J9配套的JIT编译器Testarossa的核心部分也会开源到OMR项目中，又是一重磅产品。&lt;/p&gt;&lt;p&gt;现在的小朋友要学习这方面，从入门级到高度优化的产品级项目都有众多开源项目可参考，多方便啊。我都恨不得想迟个十来年出生了，正好能在学校里赶上这浪潮 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;相关链接：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对Chez Scheme的过往历史感兴趣的同学，请先读读作者的论文：&lt;a href=&quot;http://www.cs.indiana.edu/~dyb/pubs/hocs.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;indiana.edu 的页面&quot; class=&quot;&quot;&gt;The Development of Chez Scheme&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Ikarus：&lt;a href=&quot;https://launchpad.net/ikarus&quot; data-editable=&quot;true&quot; data-title=&quot;Ikarus Scheme in Launchpad&quot;&gt;Ikarus Scheme in Launchpad&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Vicare：&lt;a href=&quot;http://marcomaggi.github.io/vicare.html&quot; data-editable=&quot;true&quot; data-title=&quot;Marco&#39;s GitHub Pages&quot;&gt;Marco&#39;s GitHub Pages&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;P.S. 请不要等我“评论”Chez Scheme，我自己还得好好学习一下它到底做了什么，都怎么做的，无力“评论”啊。我也想坐等大神来指条明路如何学习它嗯。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20808925</guid>
<pubDate>Wed, 27 Apr 2016 07:40:58 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>ChakraCore的dump开关</title>
<link>https://zhuanlan.zhihu.com/p/20792855</link>
<description>&lt;a href=&quot;https://github.com/Microsoft/ChakraCore&quot; data-editable=&quot;true&quot; data-title=&quot;ChakraCore&quot;&gt;ChakraCore&lt;/a&gt;开源也有一阵了，作为最后开源的一个主流JS引擎，在GitHub上已经有了5000+的star，说明有很多人关注。对于想要研究ChakraCore的童鞋，如果直接从代码入手，不太容易下手和实验。对此，ChakraCore已经自带了不少dump开关来输出整个编译过程的中间结果，可以据此一窥整个编译的过程。这里就介绍下ChakraCore里面的常用dump开关。&lt;p&gt;ChakraCore编译出来是chakracore.dll，如果不想自己写一个host，可以用ChakraCore自带的host CH.exe. CH.exe使用的是JSRT接口来访问ChakraCore的编译功能。比如用ChakraCore运行下面的JS文件。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function foo(a, b) {
    return a + b
}

print(foo(3, 4))

print(foo(5, 6))&lt;/code&gt;当CH.exe和chakracore.dll都编译好后（CH.exe依赖于后者，所以只要在Visual Studio编译CH.exe就可以），可以运行 “ch.exe foo.js -bgjit- -maxinterpretercount:1 -off:simplejit -dump:backend&quot;, 这样除了script运行的输出，编译的时候的中间结果也会输出到控制台。西面先解释下上面传入的各个参数。&lt;ul&gt;&lt;li&gt;-bgjit-，禁止JIT运行的background线程。ChakraCore里面JIT默认运行在专门的线程里面接收script线程发来的编译请求（CodeGenWorkItem), 这样的好处是不会阻塞script线程继续运行（interpret），但是也会给调试过程带来不确定性，所以不是调试相关的bug可以关掉。&lt;/li&gt;&lt;li&gt;-maxinterpretercount:1, 仅允许Javascript function被interpret一次。ChakraCore里面有Interpreter, SimpleJit, FullJit, 优化程度和耗时是依次递增，比较hot的函数也会一次进入这几个阶段。ChakraCore里面有heuristic机制来决定function何时进入下一个阶段。Debug的时候自然不能依赖这个来进入JIT，所以对interpret count设置固定值。一般这里推荐设置成1而不是0，因为需要运行一次interpreter来收集profile data供后面JIT使用。另外这个选项可以缩写成 &quot;-mic:1&quot;。&lt;/li&gt;&lt;li&gt;off:simplejit，关掉SimpleJIT。这个作为第二层优化，比FullJIT简单很多，作为interpreter和FullJIT之间的一个平衡，研究中可以关掉。&lt;/li&gt;&lt;li&gt;-dump:backend，输出JIT过程中的中间结果。Chakra的JIT分成了很多个phase（这个和UTC（VC++的c2.dll）很像，但是相比还是简单很多，其实phase dump也和UTC的很像，不得不说ChakraCore的JIT受了UTC的很大影响），第一个phase是IRBuilder把Parser生成的bytecode转成内部的IR结构（intermediate representation），后面典型的phase有Inline, GlobOpt, Lower, Encoder等。每个phase都会在IR上收集些信息供后面的phase使用，或者直接在IR上做变换。运行 ”ch.exe -?&quot;就可以看到phase列表。这里会列出相当多的phase，但实际上并不代表ChakraCore有这么多阶段来做优化，里面很多phase实际上代表了中比较具体的优化，这样可以通过 &quot;-off&quot; 选项来关闭相关的优化，比如CSE (common sub-expression elimination)，CopyProp都被列为一个phase，但是他们都是在GlobOpt里面做的。&quot;-dump&quot; 选项接收一个实际的phase做参数（比如IRBuilder, Lower)从而在相关phase结束后dump相应的中间结果。在研究JIT bug的是有经常需要把JIT的所有phase的结果都dump出来看看是哪个phase除了问题，全部都写上比较浪费时间，就有了一个“backend”来代表所有的phases。ChkaraCore的JIT主要是针对function的（另外一个是loop），这样dump一个有很多function的JS文件而已知问题出在某个function里面的时候，会很不方便，这里的dump选项还接受一个function Id来过滤，比如“-dump:backend:1” （function Id可以在不带function Id过滤的dump里面找到，如下面“#1.1”后面的1就是）。后续再介绍这里其他数字（从源代码也比较容易看出来）和每条IR的意思。最后需要注意的是所有的dump代码指编译在Debug版本的chakracore.dll里。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面的JS在ChakraCore里面的实际dump如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-----------------------------------------------------------------------------



************   IR after IRBuilder (FullJit)  ************
-----------------------------------------------------------------------------
Function foo ( (#1.1), #2)                        Instr Count:13

                       FunctionEntry                                          #
    s1[Object].var  =  Ld_A           0xXXXXXXXX (GlobalObject)[Object].var   #
    s2[LikelyCanBeTaggedValue_Int].var = ArgIn_A  prm2&amp;lt;40&amp;gt;.var                #
    s3[LikelyCanBeTaggedValue_Int].var = ArgIn_A  prm3&amp;lt;48&amp;gt;.var                #


  Line   2: return a + b
  Col    5: ^
                       StatementBoundary  #0                                  #0000
    s0.var          =  Add_A          s2.var, s3.var                          #0000
                       Br             $L1                                     #0004
    s0.var          =  Ld_A           0xXXXXXXXX (undefined)[Undefined].var   #0007
$L1:                                                                          #0009


  Line   3: }
  Col    1: ^
                       StatementBoundary  #1                                  #0009
                       StatementBoundary  #-1                                 #0009
                       Ret            s0.var                                  #0009

                       FunctionExit                                           #&lt;/code&gt;</description>
<author>Thomson</author>
<guid isPermaLink="false">20792855</guid>
<pubDate>Sat, 23 Apr 2016 14:51:47 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>lisp0</title>
<link>https://zhuanlan.zhihu.com/p/20689554</link>
<description>&lt;p&gt;代码没写完，广告先打起来&lt;a class=&quot;&quot; data-title=&quot;GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/bhuztez/lisp0&quot;&gt; GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;学习高级语言Runtime最好的办法，当然是自己动手写一个啦。毫无疑问假如你不是特别喜欢走弯路的轮子哥，肯定选从容易的开始。那么就选最最原始的LISP好了(Brainfuck之类的过于简单，这里先忽略他们的存在)。lisp0不会像Lisp Machine是一台单独的机器，lisp0就是一个普通的运行在Linux的程序。&lt;/p&gt;&lt;p&gt;既然是把Runtime实现一遍，那么在操作系统之上全都自己来实现，连CRT和libc也不要用。因为Lisp语言自己就又栈了，所以C程序没事别递归，用的栈是非常有限的，于是用bss段里的一段内存当C语言的栈，而操作系统在启动时，分配来的栈，给Lisp用。这样虽然奇葩了点，非常省事啊。&lt;/p&gt;&lt;p&gt;因为(假装)lisp0是immutable的，所以只要简单的引用计数就可以了。不过这写起来麻烦，用一次就要增减一次。还不如先用个简单的Mark sweep GC。因为immutable，所以新的不能被旧的引用，在allocate后把他们串成一个栈，只要从新往旧扫一遍，在扫到时还没被标记，那就一定不会被标记到，可以放心的free。至于memory allocator，就用简陋的TLSF算法就好了，这算法看上去就像个增强版的Buddy allocator。&lt;br&gt;&lt;/p&gt;&lt;p&gt;既然Lisp霸占了原本给C用的栈，使用方式也就和C保持一致好了。因为GCC支持Labels as Values，所以只要在CALL之后放一个label，那个label的值就是返回地址了。同时，因为symbol只接受[_0-9A-Za-z]+，所以长度小于等于8的symbol，经过base64解码之后长度就只有6字节了，而64位机器上去掉3位tag，还有61位，完全放的下。&lt;/p&gt;&lt;p&gt;接下来，lisp0应该改用HAMT来实现environment，换一个更好的GC。本文到此就结束了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20689554</guid>
<pubDate>Wed, 30 Mar 2016 23:01:05 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Java局部类型推导（var）的试玩版</title>
<link>https://zhuanlan.zhihu.com/p/20646039</link>
<description>&lt;p&gt;上一篇新闻提到了未来版本的Java（或许是Java 10）会有局部类型推导功能，也就是“var”隐式声明变量类型的功能。大家有兴趣现在就玩玩它的话，有好人build了当前的原型实现：&lt;/p&gt;&lt;a href=&quot;http://iteratrlearning.com/jep286.html&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 286: Type Inference for Java Builds&quot; class=&quot;&quot;&gt;JEP 286: Type Inference for Java Builds&lt;/a&gt;&lt;p&gt;目前该网站提供了Mac OS X和Linux版JDK build。Windows版“coming soon”。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20646039</guid>
<pubDate>Tue, 15 Mar 2016 06:54:55 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Java也要有局部类型推导（var）了</title>
<link>https://zhuanlan.zhihu.com/p/20635474</link>
<description>请跳传送门：&lt;a href=&quot;http://openjdk.java.net/jeps/286&quot; data-editable=&quot;true&quot; data-title=&quot;JEP 286: Local-Variable Type Inference&quot;&gt;JEP 286: Local-Variable Type Inference&lt;/a&gt;&lt;p&gt;看来有希望赶上Java 10。诶终于啊。&lt;/p&gt;&lt;p&gt;等JEP 286完成之后，Java的局部类型推导就比C#的还要神奇了…看：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;List&amp;lt;String&amp;gt; strs1 = new ArrayList&amp;lt;String&amp;gt;(); // Java 5 generics
List&amp;lt;String&amp;gt; strs2 = new ArrayList&amp;lt;&amp;gt;();       // Java 7 diamond syntax
var strs3 = new ArrayList&amp;lt;String&amp;gt;();          // JEP 286 var syntax&lt;/code&gt;&lt;p&gt;左边能推导到右边（Java 7 diamond），右边也能推导到左边（JEP 286 var），多欢乐 &amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;另外，C# 3.0里的var是个“&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/the35c6y.aspx&quot;&gt;上下文相关关键字&lt;/a&gt;”，也就是说只有在合适的地方写var才会被看作变量声明隐式声明类型的关键字，而其它地方（例如说作为变量名）则不算关键字而是普通标识符。JEP 286把这个设计基本找搬了，只是换了个名字叫做“reserved type name”。&lt;/p&gt;&lt;p&gt;========================================&lt;/p&gt;&lt;br&gt;&lt;p&gt;另外Java 10还有希望看到&lt;a href=&quot;http://openjdk.java.net/projects/valhalla/&quot; data-editable=&quot;true&quot; data-title=&quot;OpenJDK: Valhalla&quot;&gt;Project Valhalla&lt;/a&gt;的完成。到时候就可以写：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;var xs = new ArrayList&amp;lt;int&amp;gt;(); // Valhalla: generics over value types
&lt;/code&gt;&lt;p&gt;好棒好棒 &amp;gt;_&amp;lt;|||&lt;/p&gt;&lt;p&gt;但Valhalla当前到了第三版原型的设计，把彻底的类型特化给抛弃了，改为只对value type做特化。泪奔啊。这就意味着当前的原型设计不让这样写：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;  public static &amp;lt;T, U&amp;gt; T make(U arg0) {
    return new T(arg0);
  }&lt;/code&gt;&lt;p&gt;呜呜。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20635474</guid>
<pubDate>Thu, 10 Mar 2016 16:04:28 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] IBM OMR项目正式开源</title>
<link>https://zhuanlan.zhihu.com/p/20631665</link>
<description>代码在GitHub上：&lt;a href=&quot;https://github.com/eclipse/omr&quot; data-editable=&quot;true&quot; data-title=&quot;GitHub - eclipse/omr: OMR project&quot;&gt;GitHub - eclipse/omr: OMR project&lt;/a&gt;&lt;p&gt;项目负责人Mark Stoodley刚刚在EclipseCon上做了相关的演讲：&lt;a href=&quot;http://www.slideshare.net/MarkStoodley/omr-a-modern-toolkit-for-building-language-runtimes&quot; data-editable=&quot;true&quot; data-title=&quot;slideshare.net 的页面&quot; class=&quot;&quot;&gt;OMR: a modern toolkit for building language runtimes, EclipseCON 2016&lt;/a&gt;&lt;/p&gt;&lt;p&gt;IBM官方新闻稿：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/open/omr/&quot; data-editable=&quot;true&quot; data-title=&quot;OMR | developerWorks Open&quot; class=&quot;&quot;&gt;OMR | developerWorks Open&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/open/2016/03/08/introducing-omr-building-language-runtimes/&quot; data-editable=&quot;true&quot; data-title=&quot;Introducing OMR: Building language runtimes&quot;&gt;Introducing OMR: Building language runtimes&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;初始开源的组件有下面这些：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;port: platform porting library&lt;br&gt;&lt;/li&gt;&lt;li&gt;thread: a cross platform pthread-like threading library&lt;br&gt;&lt;/li&gt;&lt;li&gt;util: general utilities useful for building cross platform runtimes&lt;br&gt;&lt;/li&gt;&lt;li&gt;omrsigcompat: signal handling compatibility library&lt;br&gt;&lt;/li&gt;&lt;li&gt;omrtrace: tracing library for communication with IBM Health Center monitoring tools&lt;br&gt;&lt;/li&gt;&lt;li&gt;tool: code generation tools for the build system&lt;br&gt;&lt;/li&gt;&lt;li&gt;gc: garbage collection framework for managed heaps&lt;br&gt;&lt;/li&gt;&lt;li&gt;vm: APIs to manage per-interpreter and per-thread contexts&lt;br&gt;&lt;/li&gt;&lt;li&gt;example: demonstration code to show how a language runtime might consume some OMR components&lt;br&gt;&lt;/li&gt;&lt;li&gt;fvtest: a language-independent test framework so that OMR components can be tested outside of a language runtime&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;嗯最重磅的JIT部分还没出来，还在准备开源。&lt;/p&gt;&lt;br&gt;&lt;p&gt;知乎上之前的相关讨论：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/38480772/answer/76715935&quot; data-editable=&quot;true&quot; data-title=&quot;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&quot; class=&quot;&quot;&gt;如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://zhuanlan.zhihu.com/hllvm/20581695&quot; data-editable=&quot;true&quot; data-title=&quot;[新闻] CPython / 微软 Pyjion / IBM Python+OMR - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&quot;&gt;[新闻] CPython / 微软 Pyjion / IBM Python+OMR - 编程语言与高级语言虚拟机杂谈（仮） - 知乎专栏&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20631665</guid>
<pubDate>Wed, 09 Mar 2016 10:19:36 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[八卦] 据说Dropbox要试着在内部推广PyPy</title>
<link>https://zhuanlan.zhihu.com/p/20616374</link>
<description>去年年底的消息。就跟Pyston talk差不多时间吧。&lt;p&gt;- &quot;What about Pyston?&quot;&lt;/p&gt;&lt;p&gt;- &quot;At least one of them works.&quot;&lt;/p&gt;&lt;p&gt;还挺好玩。不过看着&lt;a href=&quot;https://github.com/dropbox/pyston/commits/master&quot;&gt;Pyston还不断在开发中&lt;/a&gt;，大概Pyston也不会就此挂掉吧…&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20616374</guid>
<pubDate>Thu, 03 Mar 2016 09:43:19 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[新闻] Azul Systems正式宣布32位ARM上的Zulu Embedded</title>
<link>https://zhuanlan.zhihu.com/p/20595654</link>
<description>新闻稿：&lt;a href=&quot;https://www.azul.com/press_release/azul-systems-enhances-zulu-embedded-to-support-32-bit-arm-processors/&quot; data-editable=&quot;true&quot; data-title=&quot;Azul Systems enhances Zulu Embedded to support 32-bit ARM processors&quot;&gt;Azul Systems enhances Zulu Embedded to support 32-bit ARM processors&lt;/a&gt;&lt;p&gt;这是Azul Systems在OpenJDK的基础上做的ARMv7 / AArch32 port。目前已经有解释器以及完整的Client Compiler（C1）实现。&lt;/p&gt;&lt;p&gt;贯彻Zulu产品线的一贯作风，这个ARM port的所有代码都会在&lt;a href=&quot;http://openjdk.java.net/projects/aarch32-port/&quot; data-title=&quot;OpenJDK AArch32项目&quot; class=&quot;&quot;&gt;OpenJDK AArch32项目&lt;/a&gt;下完全开源。同事最近发的&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/aarch32-port-dev/2016-February/000094.html&quot;&gt;一个大patch&lt;/a&gt;就是为接下来提交C1代码而做的铺垫。&lt;/p&gt;&lt;p&gt;欢迎关注ARM上的Zulu Embedded！&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595654</guid>
<pubDate>Wed, 24 Feb 2016 08:15:57 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[号外] Cliff Click大神也看上给Python加JIT了</title>
<link>https://zhuanlan.zhihu.com/p/20595643</link>
<description>&lt;a href=&quot;http://www.cliffc.org/blog/2016/02/19/winds-of-change&quot; data-editable=&quot;true&quot; data-title=&quot;Winds of Change&quot; class=&quot;&quot;&gt;Winds of Change - Cliff Click&#39;s Blog&lt;/a&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Python Go Fast:&lt;/strong&gt; Do Unto Python as Thou hast Done Unto Java. I hack the guts of Python; add a high power JIT, a full-fledged low-pause GC, true multi-threading support, i.e. make Python as fast and as parallel as Java (about the same speed as C).  This blog is really a request for an open discussion on this topic.  Is the Python community interested?  How does this get funded?  (uber Kickstarter?)  I’ll only go here with the full support of the core Python committers, and general “feel goods” from the general python community – and I’m hoping to start a discussion.  At this point I’m a premier language implementer, and making Python Go Fast is well within my abilities and past experiences. Take about 2 years &amp;amp; $2M for this effort to be self-sustaining (build all the core new tech and hand it off to other contributors).&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;困难啊…Cliff大神可能还没体会过CPython社区对“改变”的抗拒orz&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">20595643</guid>
<pubDate>Wed, 24 Feb 2016 08:09:04 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
