<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>impress your cat</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 19 Sep 2015 17:31:26 +0800</lastBuildDate>
<item>
<title>第1个21天</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20226408</link>
<description>&lt;p&gt;首先感谢&lt;a data-title=&quot;@萧井陌&quot; data-editable=&quot;true&quot; class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/fd7c571a0ada1a72e42e8d7992c4a780&quot; data-hash=&quot;fd7c571a0ada1a72e42e8d7992c4a780&quot; data-tip=&quot;p$b$fd7c571a0ada1a72e42e8d7992c4a780&quot;&gt;@萧井陌&lt;/a&gt;论坛打算先蹭他的cocode.cc了。 看这里，&lt;a class=&quot; wrap external&quot; href=&quot;http://cocode.cc/c/erlang21&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;21天学通Erlang 主题列表&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;制作虚拟机镜像这事碰到了一点麻烦。首先是把osv-apps里的Erlang从17改成18，这个没啥大问题。18因为用的是Apache License而不是之前那个不知道咋搞出来的License，至少不用担心怎么判断和其他License是否兼容的问题了。接着想把dns解析的问题解决了，结果发现OSv自带的DHCP client竟然不会写resolv.conf，于是先用8.8.8.8凑数了。最后发现一个巨大的问题，Fedora 22上gcc升级之后暴露了OSv在ELF处理上的大bug，感觉我是修不好了。&lt;/p&gt;&lt;p&gt;Github pages暂定用pelican生成，用i18n_subsites来解决多语言的问题。一开始会先介绍和编辑内容相关的，比如Erlang代码是怎么测试，怎么保证PDF里面贴的代码都是被检查过的，怎么保证代码片段在多个地方出现内容是同步的等等。现在问题来了，英语渣表示英语写不来，&lt;b&gt;求翻译&lt;/b&gt;啊&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20226408</guid>
<pubDate>Sat, 19 Sep 2015 17:17:30 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>21天学通Erlang即将恢复更新</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20165279</link>
<description>&lt;p&gt;目前打算每隔大约21天更新一次。&lt;/p&gt;&lt;p&gt;接下去，内容方面，先集中精力完成Prolog之前的内容。写的解释器能运行大部分99 Prolog Problems的答案，还有最早Erlang解释器的原型就可以了。可以参考列在&lt;a class=&quot; wrap external&quot; href=&quot;https://github.com/xn--21Erlang-p00o82pmp3o/erlang-for-dummies-zh-cn/wiki&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wiki&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;上的这些。还有就是要增加习题。一方面可以把后面章节用到的辅助函数换个马甲放到前面。这肯定是不够的，所以也要到处去收集。&lt;/p&gt;&lt;p&gt;一开始推荐的安装方式，将会统一成VirtualBox里运行虚拟机镜像，通过端口转发让宿主机的浏览器可以访问。最好能顺便把例子还有习题能做成互动的形式。&lt;/p&gt;&lt;p&gt;github pages的首页将会改成blog的形式，用来发布更新。&lt;/p&gt;&lt;p&gt;另外就是最好能有个论坛，虽然GitHub Issues也可以，我希望门槛能更低一点，不知道你们有没有好主意。&lt;/p&gt;&lt;p&gt;显然这一切都需要你们的大力帮助才能继续，毕竟现在bus factor=1啊。欢迎Pull Request，当然假如不知道如何参与，可以从吐槽开始嘛。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20165279</guid>
<pubDate>Sun, 30 Aug 2015 16:22:45 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>专栏也要友善度了</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20035863</link>
<description>&lt;p&gt;&lt;a class=&quot;internal&quot; href=&quot;http://www.zhihu.com/question/30392735/answer/47889055&quot;&gt;如何申请和使用知乎专栏？ - 知乎小管家的回答&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;内容和方向不符也不行， 一次就要收回权限。&lt;/p&gt;&lt;p&gt;专栏的编辑器也巨难用，经常陷入无法删除几个字的状况&lt;/p&gt;&lt;p&gt;还是不玩了吧。坐等被删除。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20035863</guid>
<pubDate>Tue, 19 May 2015 19:33:03 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 2. Naive Evaluation</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20033711</link>
<description>&lt;p&gt;Datalog相比Prolog，少了复合类型，但是要求结果是和求值顺序无关。这点就比Prolog好多了，Prolog完全没有逻辑可言，而Datalog至少是和一阶逻辑类似的。&lt;/p&gt;&lt;p&gt;我们用 {var, &#39;X&#39;} 的形式来表示Datalog中的变量。那么，类型定义可以写成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-type datalog_term() :: atom() | {&#39;var&#39;, atom()}.
-type datalog_goal() :: {atom(), [datalog_term()]}.
-type datalog_clause() :: {datalog_goal(), [datalog_goal()]}.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 一个简单的例子&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;%% start(a).
{{start, [a]},         []},
%% arc(d,a).
{{arc,   [d,a]},       []},
%% arc(e,a).
{{arc,   [e,a]},       []},
%% arc(a,b).
{{arc,   [a,b]},       []},
%% arc(a,c).
{{arc,   [a,c]},       []},
%% arc(b,f).
{{arc,   [b,f]},       []},
%% arc(c,f).
{{arc,   [c,f]},       []},
%% black(X):- start(X).
{{black, [{var,&#39;X&#39;}]}, [{start,[{var,&#39;X&#39;}]}]},
%% black(X):- white(Y), arc(Y,X).
{{black, [{var,&#39;X&#39;}]}, [{white,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;Y&#39;},{var,&#39;X&#39;}]}]},
%% white(X):- black(Y), arc(Y,X).
{{white, [{var,&#39;X&#39;}]}, [{black,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;Y&#39;},{var,&#39;X&#39;}]}]},
%% black(X):- white(Y), arc(X,Y).
{{black, [{var,&#39;X&#39;}]}, [{white,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;X&#39;},{var,&#39;Y&#39;}]}]},
%% white(X):- black(Y), arc(X,Y).
{{white, [{var,&#39;X&#39;}]}, [{black,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;X&#39;},{var,&#39;Y&#39;}]}]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而所谓的naive evaluation，既然都叫naive了，那肯定是非常简单的。&lt;/p&gt;&lt;p&gt;首先，把所有clause分成两类，EDB (extensional) 和 IDB (intentional)&lt;/p&gt;&lt;p&gt;EDB&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;start(a).
arc(d,a).
arc(e,a).
arc(a,b).
arc(a,c).
arc(b,f).
arc(c,f).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;IDB&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;black(X): start(X).
black(X): white(Y), arc(Y,X).
white(X): black(Y), arc(Y,X).
black(X): white(Y), arc(X,Y).
white(X): black(Y), arc(X,Y).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;直接提供Fact的就是EDB，提供规则的就是IDB&lt;/p&gt;&lt;br&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;build_db(Clauses) -&amp;gt;
    EDB =
        lists:foldl(
          fun add_fact/2,
          dict:new(),
          [Head || {Head, []} &amp;lt;- Clauses]),

    IDB =
        [Clause || {_, Body} = Clause &amp;lt;- Clauses, Body =/= []],

    EDB1 = build_db(IDB, EDB),
    [ {P, sets:to_list(Tuples)} || {P,Tuples} &amp;lt;- dict:to_list(EDB1) ].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;IDB里每条规则的正文部分，可以看作是查询。每条规则都出EDB里查一遍，&lt;br&gt;并把结果加到EDB里。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;naive_iteration([], EDB) -&amp;gt;
    EDB;
naive_iteration([{{P,A}, Goals}|IDB], EDB) -&amp;gt;
    EDB1 =
        lists:foldl(
          fun add_fact/2,
          EDB,
          [ {P, [subst(T, VarMap) || T &amp;lt;- A]}
            || VarMap &amp;lt;- query_db(Goals, EDB) ]),
    naive_iteration(IDB, EDB1).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 可是，这样并不能得到所有结果。那么就不断重复这个过程，直到EDB不变为止。(为了让人觉得高深莫测，那就叫不动点吧)。 &lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;build_db(IDB, EDB) -&amp;gt;
    case naive_iteration(IDB, EDB) of
        EDB -&amp;gt;
            EDB;
        EDB1 -&amp;gt;
            build_db(IDB, EDB1)
    end.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;剩下的函数定义，主要就是简单的unification。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;subst({var, V}, VarMap) -&amp;gt;
    case dict:find(V, VarMap) of
        {ok, V1} -&amp;gt;
            subst(V1, VarMap);
        error -&amp;gt;
            {var, V}
    end;
subst(V, _) -&amp;gt;
    V.

bind(V, T, VarMap) -&amp;gt;
    case dict:is_key(V, VarMap) of
        true -&amp;gt;
            false;
        false -&amp;gt;
            dict:store(V, T, VarMap)
    end.


unify(V1, V2, VarMap) -&amp;gt;
    case {subst(V1, VarMap), subst(V2, VarMap)} of
        {{var, X}, {var, X}} -&amp;gt;
            VarMap;
        {{var, X1}, X2} -&amp;gt;
            bind(X1, X2, VarMap);
        {X1, {var, X2}} -&amp;gt;
            bind(X2, X1, VarMap);
        {X, X} -&amp;gt;
            VarMap;
        _ -&amp;gt;
            false
    end.

unify_list([], [], VarMap) -&amp;gt;
    VarMap;
unify_list([H1|T1], [H2|T2], VarMap) -&amp;gt;
    case unify(H1, H2, VarMap) of
        false -&amp;gt;
            false;
        VarMap1 -&amp;gt;
            unify_list(T1, T2, VarMap1)
    end.

add_fact({P, A}, EDB) -&amp;gt;
    dict:update(P, fun (Old) -&amp;gt; sets:add_element(A, Old) end, sets:from_list([A]), EDB).

find_facts(P, EDB) -&amp;gt;
    case dict:find(P, EDB) of
        {ok, S} -&amp;gt;
            sets:to_list(S);
        error -&amp;gt;
            []
    end.

query_db([], VarMaps, _EDB) -&amp;gt;
    VarMaps;
query_db([{P, A}|Goals], VarMaps, EDB) -&amp;gt;
    VarMaps1 =
        [ M || M &amp;lt;- [ unify_list(A, Fact, VarMap)
                      || Fact &amp;lt;- find_facts(P, EDB),
                         VarMap &amp;lt;- VarMaps ],
               M =/= false],

    query_db(Goals, VarMaps1, EDB).

query_db(Goals, EDB) -&amp;gt;
    query_db(Goals, [dict:new()], EDB).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考 &lt;a href=&quot;http://www.inf.unibz.it/%7Enutt/Teaching/CL0910/CLSlides/5-datalog-eval.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;inf.unibz.it/%7Enutt/Te&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;aching/CL0910/CLSlides/5-datalog-eval.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://webdam.inria.fr/Alice/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;webdam.inria.fr/Alice/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20033711</guid>
<pubDate>Sun, 17 May 2015 20:37:51 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>芝麻传奇</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20031049</link>
<description>&lt;p&gt;星新一的某一篇超短篇小说，一直觉得要是反过来，也是挺有意思的。下面就是反过来的&lt;/p&gt;&lt;p&gt;---------------------------------------------------&lt;/p&gt;&lt;p&gt; 一家神教要成功，首先就得有很多信仰值。然而，在如何获得更多信仰值的问题上，长期以来，一直充斥着各种经不起推敲的巫术和玄学。&lt;/p&gt;&lt;p&gt;在这方面，首先取得突破的是道人神教。他们找到了信仰徽章的生产方法，教徒们只要购买信仰徽章，即可充值信仰。他们并不满足于此，不断在徽章上增加播放神曲等功能，以蛊动不坚定的教徒购买。所以尽管其他神教也能仿制徽章，他们仍然只用短短十年就成为了天下第一神教，被众神教评论家誉为21世纪的神教。&lt;/p&gt;&lt;p&gt;然而好景不长，还没到21世纪，道人神教就已经衰落了。他们想在徽章上增加直接充值信仰的功能，而又不想增加徽章的大小，他们遇到的前所未有的困难，迟迟不能推出新一代徽章，很快就让出了天下第一神教的宝座。&lt;/p&gt;&lt;p&gt;忍者神教另辟徯径。既然很难把徽章做小，那么就以大为卖点。他们通过蛊吹徽章越大越好，很快就吸引了大量不明真相的其他神教的教徒转化为忍者神教教徒。不到5年，就成为了天下第一神教。为了避免打脸，众神教评论家这次就称赞忍者神教是勇于创新的神教。&lt;/p&gt;&lt;p&gt;可是很快他们又打自己脸了。没过多久，芝麻神教成为了天下第一神教，却没人能发现芝麻神教成功的原因。忍者神教把徽章做大来吸引教徒，而芝麻神教却反其道而行之，把徽章的附加功能都去掉，一味的把徽章做小。众神教皆嘲笑他这是芝麻徽章，他也没反对，还直接改名叫芝麻神教了。&lt;/p&gt;&lt;p&gt;芝麻徽章效果如此之烂，以至于只有买不起别的教的徽章的人才会购买芝麻徽章，只要买的起，他们就会自动转化为其他教的教徒。每每看到这样的情况，芝麻神教就会有一些有识之信仰法师，出来建议生产有很多功能的徽章，而不是只生产芝麻徽章。而芝麻神教教主却不为所动，反而怒斥他们信仰不坚定。要是再敢提生产其他徽章，就要将他们逐出神教。&lt;/p&gt;&lt;p&gt;一些虚伪的信仰法师看到这种情况，自以为摸清了芝麻神教的运作模式，时刻准备着转投其他神教，以实现更大的个人抱负。他们也很快等到了这一天。看到芝麻神教惊人的信仰值增长速度，众神教的态度很快从嘲笑变成了羡慕。有些机灵的神教教主，很快就开始笼络芝麻神教里被认为坚定的信仰法师。&lt;/p&gt;&lt;p&gt;这些法师叛逃到其他神教之后，纷纷开始了野心勃勃的反超芝麻神教的行动。他们认为，同时销售芝麻徽章，以及改良神教原有的徽章，必然能比芝麻神教以更快的速度增加信仰值。他们有的叛逃时还顺走了芝麻徽章的生产秘方，以便能最快速度开始生产芝麻徽章。即便如此，在生产芝麻徽章时，还是碰到了很多麻烦。&lt;/p&gt;&lt;p&gt;A神教的法师花了很长时间却掌握不了芝麻徽章生产的奥妙，从芝麻神教来的法师认为这是因为他们信仰不坚定，对A神教的前景产生了怀疑，反而加深了对芝麻神教的信仰，很快回芝麻神教去了。而A神教的原来的法师却认为这些芝麻神教来的法师并没有理解芝麻徽章的生产方法，对A神教感到失望，决定转投芝麻神教。&lt;br&gt;&lt;/p&gt;&lt;p&gt;而B神教要幸运一些，B神教的法师和从芝麻神教来的法师，确实生产出了芝麻徽章，花了非常大的代价，可是充值效果却远远不及预期。而这也引发了外界对B神教的怀疑，到处都流传着B神教要完的流言。&lt;/p&gt;&lt;p&gt;C神教教主不想那么麻烦。他认为，只要按芝麻神教的标准来招募信仰法师就可以了。结果被法师协会认定是完全没有信仰的做法，遭到了法师们的集体抵制。而芝麻神教同样的做法，在法师协会看来是仅仅是一些简单的对信仰的考验。&lt;/p&gt;&lt;p&gt;此消彼长，芝麻神教的队伍在一天天壮大。各神教对芝麻神教嘴上偶有不服，但心里终究是一天比一天佩服。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20031049</guid>
<pubDate>Fri, 15 May 2015 16:25:51 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>OSv Elixir</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20029873</link>
<description>&lt;p&gt;在args_file的问题解决之后。运行BEAM语言应该没啥大问题了 (误 。那就来看一下Elixir吧。结果比预想的不顺利的多啊。&lt;/p&gt;&lt;p&gt;首先碰到一个诡异的问题，Elixir编译到一半不小心中断了，得make clean再重新开始。这都是怎么想的，这make竟然是冒牌的。&lt;/p&gt;&lt;p&gt;接着发现死活Erlang和Elixir只有一个能复制进image。经过调查发现，usr.manifest文件不能指向同一个目标。比如，有两个 /**&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/**: /path/to/some/dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么只能有一个生效。幸亏之前就把目录设置成不同的了。 &lt;br&gt;&lt;/p&gt;&lt;p&gt;顺便就带来了一个问题，之前还有 libz, openssl 什么的动态链接库是靠一段奇怪的脚本来复制的。幸好OSv已经把这个问题解决了，只要 require 对应的 module 就可以了。&lt;/p&gt;&lt;p&gt;总之，编译了很多次之后，Elixir也能在OSv上运行了。其他BEAM语言也开始蠢蠢欲动了。结果第一个LFE就运行不起来。经检查发现问题就出在编译的时候关闭了termcap。那就打开吧。打开之后傻眼了，还是进不了LFE Shell。&lt;/p&gt;&lt;p&gt;最后，经过反反复复debug，终于发现问题出在没有设置TERM环境变量。设置好之后，Erlang的ttsl_drv就能正常工作了。LFE Shell也就能运行了。 &lt;/p&gt;&lt;p&gt;就这点问题，竟然折腾了一天。 &lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20029873</guid>
<pubDate>Wed, 13 May 2015 21:37:44 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>OSv Erlang的进展</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20028805</link>
<description>&lt;p&gt;第一个问题是把编译参数里的 --without-os_mon 去掉了。到目前为止还没解决 cpu_sup的问题，主要原因是OSv根本就没实现必要的接口 ，于是就先禁用了。而memsup和disksup，都被我从port改成port driver了，这样就不需要开新的进程了。当然了，Bug肯定是少不了的。&lt;/p&gt;&lt;p&gt;第二个问题是怎么patch源代码的问题。第一个问题一开始我是把代码直接复制了一份。在nyh的建议下，改成patch了。现在的做法是，先把文件 x 复制一份 x.orig ，直接改 x ，改完了用 gendiff dirname .orig 生成 patch 。从头开始打 patch 时，用 patch -b 就会自动把原始文件复制一份，这样有改动之后重新 gendiff 就可以了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;第三个问题是epmd怎么启动的问题。一开始还妄图使用某个纯Erlang实现的epmd server。结果发现这样对release改动过大，根本没法用。又去看了看OSv的代码，发现，完全可以再开一个线程来运行epmd。只要把erlexec改改就可以了。剩下一个小问题，因为现在没有能用的wordexp，并不能完全替代system的功能。&lt;/p&gt;&lt;p&gt;接下来几天，还会加上从EC2 user-data读取args_file的功能(没有就用默认的)。这样一般的Erlang程序应该都能正常启动，每个节点也可以有不同的配置了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20028805</guid>
<pubDate>Tue, 12 May 2015 19:46:20 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 1. Prolog</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20013565</link>
<description>用Prolog语法来写Parser是一件很自然的事。比BNF要好的多。BNF 只是描述了语法，用Prolog写直接就把Parser给写完了。比如 &lt;br&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;plus_exp&amp;gt; ::= &amp;lt;mul_exp&amp;gt; | &amp;lt;mul_exp&amp;gt; &amp;lt;plus&amp;gt; &amp;lt;plus_exp&amp;gt;
&amp;lt;mul_exp&amp;gt; ::= &amp;lt;num&amp;gt; | &amp;lt;num&amp;gt; &amp;lt;mul&amp;gt; &amp;lt;mul_exp&amp;gt;
&amp;lt;plus&amp;gt; ::= &quot;plus&quot;
&amp;lt;mul&amp;gt; ::= &quot;mul&quot;
&amp;lt;num&amp;gt; ::= &amp;lt;integer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Prolog:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;plus(S0, S) :-
  S0 = [plus|S].

mul(S0, S) :-
  S0 = [mul|S].

num(N, S0, S) :-
  S0 = [N|S],
  integer(N).

plus_exp(Expr, S0, S) :-
  mul_exp(Expr, S0, S).

plus_exp(Expr, S0, S) :-
  mul_exp(E1, S0, S1),
  plus(S1, S2),
  plus_exp(E2, S2, S),
  Expr =.. [plus, E1, E2].

mul_exp(Expr, S0, S) :-
  num(Expr, S0, S).

mul_exp(Expr, S0, S) :-
  num(E1, S0, S1),
  mul(S1, S2),
  mul_exp(E2, S2, S),
  Expr =.. [mul, E1, E2].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题是虽然Prolog这语法看上去很好，真的很难用来写程序，动不动就不知道回溯到哪里去了，一cut又傻了，碰到左递归就死循环了。长的像一阶逻辑，其实完全没有逻辑可言。这也能叫Prolog ? &lt;br&gt;&lt;/p&gt;&lt;p&gt;即便无视这些缺点，对于写Parser来说，Prolog依旧是太强大了。Prolog可是图灵完全的。很容易构造出有无数个结果的查询&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;p([]).
p(L) :-
  L = [a|X],
  p(X).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 为了避免这个问题，就不能有复合类型。这样就没法用List来表示输入的字符串了。当然List还有另外一个问题就是，按这么写，必须一次提供完整的输入，而不是一次一个字符。&lt;/p&gt;&lt;p&gt;这是可以做到的，比如 &lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[1,plus,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 可以表示成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;token(1, 0, 1).
token(plus, 1, 2).
token(2, 2, 3).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 语法规则就可以写成 (先忽略生成的语法树)&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;plus(S0, S) :-
  token(plus, S0, S).

mul(S0, S) :-
  token(mul, S0, S).

num(S0, S) :-
  token(N, S0, S),
  integer(N).

plus_exp(S0, S) :-
  mul_exp(S0, S).

plus_exp(S0, S) :-
  mul_exp(S0, S1),
  plus(S1, S2),
  plus_exp(S2, S).

mul_exp(S0, S) :-
  num(S0, S).

mul_exp(S0, S) :-
  num(S0, S1),
  mul(S1, S2),
  mul_exp(S2, S).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就变成Datalog了嘛。&lt;/p&gt;&lt;p&gt;接下来就来看Datalog&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20013565</guid>
<pubDate>Mon, 27 Apr 2015 11:26:45 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>为什么还需要一个新的内核？</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20012190</link>
<description>&lt;p&gt;很多人(包括我)都有这么一种错觉，好像操作系统是一个已经解决的问题，新的内核已经没有存在的必要了。所以也就没必要去了解操作系统是怎么回事，只管用就是了。&lt;/p&gt;&lt;p&gt;事实恰好相反。 你肯定碰到过有那么一天，网络出故障了，惊讶的发现有人竟然不知道怎么截图了，原因竟然是打不开QQ。这只能说明现在流行的操作系统既不好用也不安全。&lt;/p&gt;&lt;p&gt;按正常的做法，操作系统应该有截图服务，只有提供截图服务的程序才有权在整个桌面上截图。别的程序，包括QQ，想要截图，必须向截图服务发请求。这样同时也保证了，在这个操作系统上，所有程序的桌面截图的用法都是一致的。&lt;/p&gt;&lt;p&gt;唯一一个在这方面做的比较好的，可能真的就只有Wayland了。Wayland当然有Wayland的问题。至少Wayland把最重要的一件事搞对了，整个显示是以Compositing方式来进行的。&lt;/p&gt;&lt;p&gt;Compositing简单来说就是每个窗口自己画自己的，最后由compositor拼成一张图，再交给驱动去画去。这么简单一个概念，查了好多资料，最后发现竟然只有AmigaOS才是这么做的。目前流行的操作系统差不多在AmigaOS推出之后20年，才有类似的功能，还仅仅是以扩展的形式出现的。&lt;br&gt;&lt;/p&gt;&lt;p&gt;从定义来看，操作系统就是用来解决多个正在运行的程序对资源的并发访问这个问题的。只运行一个程序当然就无所谓有没有操作系统了。可是现在在操作系统上运行的程序，看上去并没有获得操作操作系统虚拟出来的设备的好处，反倒更像是陷入到API的汪洋大海之中。&lt;/p&gt;&lt;p&gt;Compositing才算是回归了操作系统的本质。在进程看来一个窗口就应该类似操作系统看到的一块屏幕。需要联网的进程，都有一个虚拟的网口，操作系统完成的功能更应该接近交换机。这样的概念也比什么X Window，Socket什么的更容易理解。&lt;/p&gt;&lt;p&gt;操作系统是如何向硬件传输数据的？直接往某一段映射为硬件的内存地址写就可以了。类似的，直接把一个窗口buffer对应的内存页，同时在compositor和GUI进程的地址空间都映射一遍就好了嘛。只要有MMU，这个就不是什么问题。这样，所谓微内核就是把驱动都放到用户态的提法就没有多大意义了，通过MMU，一样也可以把一个用户态进程的一部分内存地址，映射到硬件对应的物理地址。把大部分驱动放到用户态根本就不存在任何问题嘛。&lt;/p&gt;&lt;p&gt;能放到用户态的进程现在并没有放到用户态。这一定是内核出了问题。问题就出在现在流行的内核，并没有提供IPC。比如在UNIX上，连向另外一个进程发一个file descriptor都很麻烦呢，各种奇怪的magic。Wayland应该也有类似的问题，一个进程很难为另外一个进程申请一个surface。比如，在Wayland里并不存在类似XEmbed的功能。&lt;/p&gt;&lt;p&gt;这个问题并没有看上去那么简单。可能是因为我没仔细看，我看了一下HelenOS里并没有和论文里提到的VFS对应的代码。其他类似的情况，可能也就只有SCTP socket的peel off了吧。&lt;/p&gt;&lt;p&gt;这也就是为什么还需要一个新的内核。&lt;/p&gt;&lt;p&gt;P.S. 至于那种至运行一个程序，也敢说自己是操作系统的，比如Lisp Machine什么的。现在有了像OSv之类的内核，一个普通的单进程的Linux程序，只要编译成PIE，就能直接在OSv上运行了。别说Lisp Machine了，不管啥语言，只要是单进程的都行了。都有Erlang Machine了，还要Lisp Machine干啥？&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20012190</guid>
<pubDate>Sat, 25 Apr 2015 16:50:03 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 0. 如何学Parsing</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20006819</link>
<description>&lt;p&gt;本来这是在21天学通Erlang第一章里的内容。只是现在还没远远写到那儿呢。&lt;/p&gt;&lt;p&gt;因为占了个坑，&lt;a class=&quot;internal&quot; href=&quot;http://www.zhihu.com/question/29636774/answer/45156848&quot;&gt;shift reduce，预测分析，递归下降分析（这是解析方法）和LL(K) LR(K) SLR以LALR的关系？ - 知乎用户的回答&lt;/a&gt; 。那就先写起来吧。毕竟这部分内容之前也没很仔细的检查过到底是不是这么回事。只是有个大体思路而已。趁着这个机会把提纲写了，顺便也减小一点bus factor可能的影响。&lt;br&gt;&lt;/p&gt;&lt;p&gt;学Parsing，最重要的思路，就是把parser看作一种特殊的解释器。先写Datalog解释器，再变形成CYK/Earley Parser。所有表达能力不足CFG的parser都可以由此推导出来，很容易就看清楚不同算法之间的联系。&lt;/p&gt;&lt;p&gt;接下来，就按这个思路来一遍。&lt;br&gt;&lt;/p&gt;&lt;p&gt;且看下回分解。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20006819</guid>
<pubDate>Wed, 22 Apr 2015 22:03:22 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
