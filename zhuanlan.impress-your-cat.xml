<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>impress your cat</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Thu, 02 Jul 2015 18:13:43 +0800</lastBuildDate>
<item>
<title>专栏也要友善度了</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20035863</link>
<description>&lt;p&gt;&lt;a class=&quot;internal&quot; href=&quot;http://www.zhihu.com/question/30392735/answer/47889055&quot;&gt;如何申请和使用知乎专栏？ - 知乎小管家的回答&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;内容和方向不符也不行， 一次就要收回权限。&lt;/p&gt;&lt;p&gt;专栏的编辑器也巨难用，经常陷入无法删除几个字的状况&lt;/p&gt;&lt;p&gt;还是不玩了吧。坐等被删除。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20035863</guid>
<pubDate>Tue, 19 May 2015 19:33:03 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 2. Naive Evaluation</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20033711</link>
<description>&lt;p&gt;Datalog相比Prolog，少了复合类型，但是要求结果是和求值顺序无关。这点就比Prolog好多了，Prolog完全没有逻辑可言，而Datalog至少是和一阶逻辑类似的。&lt;/p&gt;&lt;p&gt;我们用 {var, &#39;X&#39;} 的形式来表示Datalog中的变量。那么，类型定义可以写成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-type datalog_term() :: atom() | {&#39;var&#39;, atom()}.
-type datalog_goal() :: {atom(), [datalog_term()]}.
-type datalog_clause() :: {datalog_goal(), [datalog_goal()]}.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 一个简单的例子&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;%% start(a).
{{start, [a]},         []},
%% arc(d,a).
{{arc,   [d,a]},       []},
%% arc(e,a).
{{arc,   [e,a]},       []},
%% arc(a,b).
{{arc,   [a,b]},       []},
%% arc(a,c).
{{arc,   [a,c]},       []},
%% arc(b,f).
{{arc,   [b,f]},       []},
%% arc(c,f).
{{arc,   [c,f]},       []},
%% black(X):- start(X).
{{black, [{var,&#39;X&#39;}]}, [{start,[{var,&#39;X&#39;}]}]},
%% black(X):- white(Y), arc(Y,X).
{{black, [{var,&#39;X&#39;}]}, [{white,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;Y&#39;},{var,&#39;X&#39;}]}]},
%% white(X):- black(Y), arc(Y,X).
{{white, [{var,&#39;X&#39;}]}, [{black,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;Y&#39;},{var,&#39;X&#39;}]}]},
%% black(X):- white(Y), arc(X,Y).
{{black, [{var,&#39;X&#39;}]}, [{white,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;X&#39;},{var,&#39;Y&#39;}]}]},
%% white(X):- black(Y), arc(X,Y).
{{white, [{var,&#39;X&#39;}]}, [{black,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;X&#39;},{var,&#39;Y&#39;}]}]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而所谓的naive evaluation，既然都叫naive了，那肯定是非常简单的。&lt;/p&gt;&lt;p&gt;首先，把所有clause分成两类，EDB (extensional) 和 IDB (intentional)&lt;/p&gt;&lt;p&gt;EDB&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;start(a).
arc(d,a).
arc(e,a).
arc(a,b).
arc(a,c).
arc(b,f).
arc(c,f).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;IDB&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;black(X): start(X).
black(X): white(Y), arc(Y,X).
white(X): black(Y), arc(Y,X).
black(X): white(Y), arc(X,Y).
white(X): black(Y), arc(X,Y).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;直接提供Fact的就是EDB，提供规则的就是IDB&lt;/p&gt;&lt;br&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;build_db(Clauses) -&amp;gt;
    EDB =
        lists:foldl(
          fun add_fact/2,
          dict:new(),
          [Head || {Head, []} &amp;lt;- Clauses]),

    IDB =
        [Clause || {_, Body} = Clause &amp;lt;- Clauses, Body =/= []],

    EDB1 = build_db(IDB, EDB),
    [ {P, sets:to_list(Tuples)} || {P,Tuples} &amp;lt;- dict:to_list(EDB1) ].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;IDB里每条规则的正文部分，可以看作是查询。每条规则都出EDB里查一遍，&lt;br&gt;并把结果加到EDB里。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;naive_iteration([], EDB) -&amp;gt;
    EDB;
naive_iteration([{{P,A}, Goals}|IDB], EDB) -&amp;gt;
    EDB1 =
        lists:foldl(
          fun add_fact/2,
          EDB,
          [ {P, [subst(T, VarMap) || T &amp;lt;- A]}
            || VarMap &amp;lt;- query_db(Goals, EDB) ]),
    naive_iteration(IDB, EDB1).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 可是，这样并不能得到所有结果。那么就不断重复这个过程，直到EDB不变为止。(为了让人觉得高深莫测，那就叫不动点吧)。 &lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;build_db(IDB, EDB) -&amp;gt;
    case naive_iteration(IDB, EDB) of
        EDB -&amp;gt;
            EDB;
        EDB1 -&amp;gt;
            build_db(IDB, EDB1)
    end.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;剩下的函数定义，主要就是简单的unification。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;subst({var, V}, VarMap) -&amp;gt;
    case dict:find(V, VarMap) of
        {ok, V1} -&amp;gt;
            subst(V1, VarMap);
        error -&amp;gt;
            {var, V}
    end;
subst(V, _) -&amp;gt;
    V.

bind(V, T, VarMap) -&amp;gt;
    case dict:is_key(V, VarMap) of
        true -&amp;gt;
            false;
        false -&amp;gt;
            dict:store(V, T, VarMap)
    end.


unify(V1, V2, VarMap) -&amp;gt;
    case {subst(V1, VarMap), subst(V2, VarMap)} of
        {{var, X}, {var, X}} -&amp;gt;
            VarMap;
        {{var, X1}, X2} -&amp;gt;
            bind(X1, X2, VarMap);
        {X1, {var, X2}} -&amp;gt;
            bind(X2, X1, VarMap);
        {X, X} -&amp;gt;
            VarMap;
        _ -&amp;gt;
            false
    end.

unify_list([], [], VarMap) -&amp;gt;
    VarMap;
unify_list([H1|T1], [H2|T2], VarMap) -&amp;gt;
    case unify(H1, H2, VarMap) of
        false -&amp;gt;
            false;
        VarMap1 -&amp;gt;
            unify_list(T1, T2, VarMap1)
    end.

add_fact({P, A}, EDB) -&amp;gt;
    dict:update(P, fun (Old) -&amp;gt; sets:add_element(A, Old) end, sets:from_list([A]), EDB).

find_facts(P, EDB) -&amp;gt;
    case dict:find(P, EDB) of
        {ok, S} -&amp;gt;
            sets:to_list(S);
        error -&amp;gt;
            []
    end.

query_db([], VarMaps, _EDB) -&amp;gt;
    VarMaps;
query_db([{P, A}|Goals], VarMaps, EDB) -&amp;gt;
    VarMaps1 =
        [ M || M &amp;lt;- [ unify_list(A, Fact, VarMap)
                      || Fact &amp;lt;- find_facts(P, EDB),
                         VarMap &amp;lt;- VarMaps ],
               M =/= false],

    query_db(Goals, VarMaps1, EDB).

query_db(Goals, EDB) -&amp;gt;
    query_db(Goals, [dict:new()], EDB).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考 &lt;a href=&quot;http://www.inf.unibz.it/%7Enutt/Teaching/CL0910/CLSlides/5-datalog-eval.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;inf.unibz.it/%7Enutt/Te&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;aching/CL0910/CLSlides/5-datalog-eval.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://webdam.inria.fr/Alice/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;webdam.inria.fr/Alice/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20033711</guid>
<pubDate>Sun, 17 May 2015 20:37:51 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>芝麻传奇</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20031049</link>
<description>&lt;p&gt;星新一的某一篇超短篇小说，一直觉得要是反过来，也是挺有意思的。下面就是反过来的&lt;/p&gt;&lt;p&gt;---------------------------------------------------&lt;/p&gt;&lt;p&gt; 一家神教要成功，首先就得有很多信仰值。然而，在如何获得更多信仰值的问题上，长期以来，一直充斥着各种经不起推敲的巫术和玄学。&lt;/p&gt;&lt;p&gt;在这方面，首先取得突破的是道人神教。他们找到了信仰徽章的生产方法，教徒们只要购买信仰徽章，即可充值信仰。他们并不满足于此，不断在徽章上增加播放神曲等功能，以蛊动不坚定的教徒购买。所以尽管其他神教也能仿制徽章，他们仍然只用短短十年就成为了天下第一神教，被众神教评论家誉为21世纪的神教。&lt;/p&gt;&lt;p&gt;然而好景不长，还没到21世纪，道人神教就已经衰落了。他们想在徽章上增加直接充值信仰的功能，而又不想增加徽章的大小，他们遇到的前所未有的困难，迟迟不能推出新一代徽章，很快就让出了天下第一神教的宝座。&lt;/p&gt;&lt;p&gt;忍者神教另辟徯径。既然很难把徽章做小，那么就以大为卖点。他们通过蛊吹徽章越大越好，很快就吸引了大量不明真相的其他神教的教徒转化为忍者神教教徒。不到5年，就成为了天下第一神教。为了避免打脸，众神教评论家这次就称赞忍者神教是勇于创新的神教。&lt;/p&gt;&lt;p&gt;可是很快他们又打自己脸了。没过多久，芝麻神教成为了天下第一神教，却没人能发现芝麻神教成功的原因。忍者神教把徽章做大来吸引教徒，而芝麻神教却反其道而行之，把徽章的附加功能都去掉，一味的把徽章做小。众神教皆嘲笑他这是芝麻徽章，他也没反对，还直接改名叫芝麻神教了。&lt;/p&gt;&lt;p&gt;芝麻徽章效果如此之烂，以至于只有买不起别的教的徽章的人才会购买芝麻徽章，只要买的起，他们就会自动转化为其他教的教徒。每每看到这样的情况，芝麻神教就会有一些有识之信仰法师，出来建议生产有很多功能的徽章，而不是只生产芝麻徽章。而芝麻神教教主却不为所动，反而怒斥他们信仰不坚定。要是再敢提生产其他徽章，就要将他们逐出神教。&lt;/p&gt;&lt;p&gt;一些虚伪的信仰法师看到这种情况，自以为摸清了芝麻神教的运作模式，时刻准备着转投其他神教，以实现更大的个人抱负。他们也很快等到了这一天。看到芝麻神教惊人的信仰值增长速度，众神教的态度很快从嘲笑变成了羡慕。有些机灵的神教教主，很快就开始笼络芝麻神教里被认为坚定的信仰法师。&lt;/p&gt;&lt;p&gt;这些法师叛逃到其他神教之后，纷纷开始了野心勃勃的反超芝麻神教的行动。他们认为，同时销售芝麻徽章，以及改良神教原有的徽章，必然能比芝麻神教以更快的速度增加信仰值。他们有的叛逃时还顺走了芝麻徽章的生产秘方，以便能最快速度开始生产芝麻徽章。即便如此，在生产芝麻徽章时，还是碰到了很多麻烦。&lt;/p&gt;&lt;p&gt;A神教的法师花了很长时间却掌握不了芝麻徽章生产的奥妙，从芝麻神教来的法师认为这是因为他们信仰不坚定，对A神教的前景产生了怀疑，反而加深了对芝麻神教的信仰，很快回芝麻神教去了。而A神教的原来的法师却认为这些芝麻神教来的法师并没有理解芝麻徽章的生产方法，对A神教感到失望，决定转投芝麻神教。&lt;br&gt;&lt;/p&gt;&lt;p&gt;而B神教要幸运一些，B神教的法师和从芝麻神教来的法师，确实生产出了芝麻徽章，花了非常大的代价，可是充值效果却远远不及预期。而这也引发了外界对B神教的怀疑，到处都流传着B神教要完的流言。&lt;/p&gt;&lt;p&gt;C神教教主不想那么麻烦。他认为，只要按芝麻神教的标准来招募信仰法师就可以了。结果被法师协会认定是完全没有信仰的做法，遭到了法师们的集体抵制。而芝麻神教同样的做法，在法师协会看来是仅仅是一些简单的对信仰的考验。&lt;/p&gt;&lt;p&gt;此消彼长，芝麻神教的队伍在一天天壮大。各神教对芝麻神教嘴上偶有不服，但心里终究是一天比一天佩服。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20031049</guid>
<pubDate>Fri, 15 May 2015 16:25:51 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>OSv Elixir</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20029873</link>
<description>&lt;p&gt;在args_file的问题解决之后。运行BEAM语言应该没啥大问题了 (误 。那就来看一下Elixir吧。结果比预想的不顺利的多啊。&lt;/p&gt;&lt;p&gt;首先碰到一个诡异的问题，Elixir编译到一半不小心中断了，得make clean再重新开始。这都是怎么想的，这make竟然是冒牌的。&lt;/p&gt;&lt;p&gt;接着发现死活Erlang和Elixir只有一个能复制进image。经过调查发现，usr.manifest文件不能指向同一个目标。比如，有两个 /**&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/**: /path/to/some/dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么只能有一个生效。幸亏之前就把目录设置成不同的了。 &lt;br&gt;&lt;/p&gt;&lt;p&gt;顺便就带来了一个问题，之前还有 libz, openssl 什么的动态链接库是靠一段奇怪的脚本来复制的。幸好OSv已经把这个问题解决了，只要 require 对应的 module 就可以了。&lt;/p&gt;&lt;p&gt;总之，编译了很多次之后，Elixir也能在OSv上运行了。其他BEAM语言也开始蠢蠢欲动了。结果第一个LFE就运行不起来。经检查发现问题就出在编译的时候关闭了termcap。那就打开吧。打开之后傻眼了，还是进不了LFE Shell。&lt;/p&gt;&lt;p&gt;最后，经过反反复复debug，终于发现问题出在没有设置TERM环境变量。设置好之后，Erlang的ttsl_drv就能正常工作了。LFE Shell也就能运行了。 &lt;/p&gt;&lt;p&gt;就这点问题，竟然折腾了一天。 &lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20029873</guid>
<pubDate>Wed, 13 May 2015 21:37:44 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>OSv Erlang的进展</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20028805</link>
<description>&lt;p&gt;第一个问题是把编译参数里的 --without-os_mon 去掉了。到目前为止还没解决 cpu_sup的问题，主要原因是OSv根本就没实现必要的接口 ，于是就先禁用了。而memsup和disksup，都被我从port改成port driver了，这样就不需要开新的进程了。当然了，Bug肯定是少不了的。&lt;/p&gt;&lt;p&gt;第二个问题是怎么patch源代码的问题。第一个问题一开始我是把代码直接复制了一份。在nyh的建议下，改成patch了。现在的做法是，先把文件 x 复制一份 x.orig ，直接改 x ，改完了用 gendiff dirname .orig 生成 patch 。从头开始打 patch 时，用 patch -b 就会自动把原始文件复制一份，这样有改动之后重新 gendiff 就可以了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;第三个问题是epmd怎么启动的问题。一开始还妄图使用某个纯Erlang实现的epmd server。结果发现这样对release改动过大，根本没法用。又去看了看OSv的代码，发现，完全可以再开一个线程来运行epmd。只要把erlexec改改就可以了。剩下一个小问题，因为现在没有能用的wordexp，并不能完全替代system的功能。&lt;/p&gt;&lt;p&gt;接下来几天，还会加上从EC2 user-data读取args_file的功能(没有就用默认的)。这样一般的Erlang程序应该都能正常启动，每个节点也可以有不同的配置了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20028805</guid>
<pubDate>Tue, 12 May 2015 19:46:20 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 1. Prolog</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20013565</link>
<description>用Prolog语法来写Parser是一件很自然的事。比BNF要好的多。BNF 只是描述了语法，用Prolog写直接就把Parser给写完了。比如 &lt;br&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;plus_exp&amp;gt; ::= &amp;lt;mul_exp&amp;gt; | &amp;lt;mul_exp&amp;gt; &amp;lt;plus&amp;gt; &amp;lt;plus_exp&amp;gt;
&amp;lt;mul_exp&amp;gt; ::= &amp;lt;num&amp;gt; | &amp;lt;num&amp;gt; &amp;lt;mul&amp;gt; &amp;lt;mul_exp&amp;gt;
&amp;lt;plus&amp;gt; ::= &quot;plus&quot;
&amp;lt;mul&amp;gt; ::= &quot;mul&quot;
&amp;lt;num&amp;gt; ::= &amp;lt;integer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Prolog:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;plus(S0, S) :-
  S0 = [plus|S].

mul(S0, S) :-
  S0 = [mul|S].

num(N, S0, S) :-
  S0 = [N|S],
  integer(N).

plus_exp(Expr, S0, S) :-
  mul_exp(Expr, S0, S).

plus_exp(Expr, S0, S) :-
  mul_exp(E1, S0, S1),
  plus(S1, S2),
  plus_exp(E2, S2, S),
  Expr =.. [plus, E1, E2].

mul_exp(Expr, S0, S) :-
  num(Expr, S0, S).

mul_exp(Expr, S0, S) :-
  num(E1, S0, S1),
  mul(S1, S2),
  mul_exp(E2, S2, S),
  Expr =.. [mul, E1, E2].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题是虽然Prolog这语法看上去很好，真的很难用来写程序，动不动就不知道回溯到哪里去了，一cut又傻了，碰到左递归就死循环了。长的像一阶逻辑，其实完全没有逻辑可言。这也能叫Prolog ? &lt;br&gt;&lt;/p&gt;&lt;p&gt;即便无视这些缺点，对于写Parser来说，Prolog依旧是太强大了。Prolog可是图灵完全的。很容易构造出有无数个结果的查询&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;p([]).
p(L) :-
  L = [a|X],
  p(X).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 为了避免这个问题，就不能有复合类型。这样就没法用List来表示输入的字符串了。当然List还有另外一个问题就是，按这么写，必须一次提供完整的输入，而不是一次一个字符。&lt;/p&gt;&lt;p&gt;这是可以做到的，比如 &lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[1,plus,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 可以表示成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;token(1, 0, 1).
token(plus, 1, 2).
token(2, 2, 3).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 语法规则就可以写成 (先忽略生成的语法树)&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;plus(S0, S) :-
  token(plus, S0, S).

mul(S0, S) :-
  token(mul, S0, S).

num(S0, S) :-
  token(N, S0, S),
  integer(N).

plus_exp(S0, S) :-
  mul_exp(S0, S).

plus_exp(S0, S) :-
  mul_exp(S0, S1),
  plus(S1, S2),
  plus_exp(S2, S).

mul_exp(S0, S) :-
  num(S0, S).

mul_exp(S0, S) :-
  num(S0, S1),
  mul(S1, S2),
  mul_exp(S2, S).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就变成Datalog了嘛。&lt;/p&gt;&lt;p&gt;接下来就来看Datalog&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20013565</guid>
<pubDate>Mon, 27 Apr 2015 11:26:45 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>为什么还需要一个新的内核？</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20012190</link>
<description>&lt;p&gt;很多人(包括我)都有这么一种错觉，好像操作系统是一个已经解决的问题，新的内核已经没有存在的必要了。所以也就没必要去了解操作系统是怎么回事，只管用就是了。&lt;/p&gt;&lt;p&gt;事实恰好相反。 你肯定碰到过有那么一天，网络出故障了，惊讶的发现有人竟然不知道怎么截图了，原因竟然是打不开QQ。这只能说明现在流行的操作系统既不好用也不安全。&lt;/p&gt;&lt;p&gt;按正常的做法，操作系统应该有截图服务，只有提供截图服务的程序才有权在整个桌面上截图。别的程序，包括QQ，想要截图，必须向截图服务发请求。这样同时也保证了，在这个操作系统上，所有程序的桌面截图的用法都是一致的。&lt;/p&gt;&lt;p&gt;唯一一个在这方面做的比较好的，可能真的就只有Wayland了。Wayland当然有Wayland的问题。至少Wayland把最重要的一件事搞对了，整个显示是以Compositing方式来进行的。&lt;/p&gt;&lt;p&gt;Compositing简单来说就是每个窗口自己画自己的，最后由compositor拼成一张图，再交给驱动去画去。这么简单一个概念，查了好多资料，最后发现竟然只有AmigaOS才是这么做的。目前流行的操作系统差不多在AmigaOS推出之后20年，才有类似的功能，还仅仅是以扩展的形式出现的。&lt;br&gt;&lt;/p&gt;&lt;p&gt;从定义来看，操作系统就是用来解决多个正在运行的程序对资源的并发访问这个问题的。只运行一个程序当然就无所谓有没有操作系统了。可是现在在操作系统上运行的程序，看上去并没有获得操作操作系统虚拟出来的设备的好处，反倒更像是陷入到API的汪洋大海之中。&lt;/p&gt;&lt;p&gt;Compositing才算是回归了操作系统的本质。在进程看来一个窗口就应该类似操作系统看到的一块屏幕。需要联网的进程，都有一个虚拟的网口，操作系统完成的功能更应该接近交换机。这样的概念也比什么X Window，Socket什么的更容易理解。&lt;/p&gt;&lt;p&gt;操作系统是如何向硬件传输数据的？直接往某一段映射为硬件的内存地址写就可以了。类似的，直接把一个窗口buffer对应的内存页，同时在compositor和GUI进程的地址空间都映射一遍就好了嘛。只要有MMU，这个就不是什么问题。这样，所谓微内核就是把驱动都放到用户态的提法就没有多大意义了，通过MMU，一样也可以把一个用户态进程的一部分内存地址，映射到硬件对应的物理地址。把大部分驱动放到用户态根本就不存在任何问题嘛。&lt;/p&gt;&lt;p&gt;能放到用户态的进程现在并没有放到用户态。这一定是内核出了问题。问题就出在现在流行的内核，并没有提供IPC。比如在UNIX上，连向另外一个进程发一个file descriptor都很麻烦呢，各种奇怪的magic。Wayland应该也有类似的问题，一个进程很难为另外一个进程申请一个surface。比如，在Wayland里并不存在类似XEmbed的功能。&lt;/p&gt;&lt;p&gt;这个问题并没有看上去那么简单。可能是因为我没仔细看，我看了一下HelenOS里并没有和论文里提到的VFS对应的代码。其他类似的情况，可能也就只有SCTP socket的peel off了吧。&lt;/p&gt;&lt;p&gt;这也就是为什么还需要一个新的内核。&lt;/p&gt;&lt;p&gt;P.S. 至于那种至运行一个程序，也敢说自己是操作系统的，比如Lisp Machine什么的。现在有了像OSv之类的内核，一个普通的单进程的Linux程序，只要编译成PIE，就能直接在OSv上运行了。别说Lisp Machine了，不管啥语言，只要是单进程的都行了。都有Erlang Machine了，还要Lisp Machine干啥？&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20012190</guid>
<pubDate>Sat, 25 Apr 2015 16:50:03 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 0. 如何学Parsing</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20006819</link>
<description>&lt;p&gt;本来这是在21天学通Erlang第一章里的内容。只是现在还没远远写到那儿呢。&lt;/p&gt;&lt;p&gt;因为占了个坑，&lt;a class=&quot;internal&quot; href=&quot;http://www.zhihu.com/question/29636774/answer/45156848&quot;&gt;shift reduce，预测分析，递归下降分析（这是解析方法）和LL(K) LR(K) SLR以LALR的关系？ - 知乎用户的回答&lt;/a&gt; 。那就先写起来吧。毕竟这部分内容之前也没很仔细的检查过到底是不是这么回事。只是有个大体思路而已。趁着这个机会把提纲写了，顺便也减小一点bus factor可能的影响。&lt;br&gt;&lt;/p&gt;&lt;p&gt;学Parsing，最重要的思路，就是把parser看作一种特殊的解释器。先写Datalog解释器，再变形成CYK/Earley Parser。所有表达能力不足CFG的parser都可以由此推导出来，很容易就看清楚不同算法之间的联系。&lt;/p&gt;&lt;p&gt;接下来，就按这个思路来一遍。&lt;br&gt;&lt;/p&gt;&lt;p&gt;且看下回分解。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20006819</guid>
<pubDate>Wed, 22 Apr 2015 22:03:22 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[USACO]Your Ride Is Here</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20006355</link>
<description>&lt;p&gt;USACO Training主要的好处是提供了测试数据。假如你有更好的推荐，赶快告诉我吧&lt;/p&gt;&lt;p&gt;主要部分的代码很简单&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;ride(&amp;lt;&amp;lt;&amp;gt;&amp;gt;, Acc) -&amp;gt;
    Acc;
ride(&amp;lt;&amp;lt;A, Rest/binary&amp;gt;&amp;gt;, Acc) -&amp;gt;
    ride(Rest, (Acc * (A - 64)) rem 47).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果碰到一个问题，之前只实现了tuple和list，忘记实现binary了。GC里有太多Bug。竟然花了大半天才搞定。&lt;/p&gt;&lt;p&gt;一开始还打算直接抄袭Erlang的实现，仔细一想就感觉不妙了。Erlang里还有bitstring的概念，这个一点都不好实现啊。所以直接忽略。只考虑按字节的。&lt;/p&gt;&lt;p&gt;和Erlang一样，在matching的时候，只允许最后一个segment是 binary 类型的。也就是&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;&amp;lt;X:3/binary, Y, Z/binary&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是允许的&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;&amp;lt;X/binary, Y, Z/binary&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就不允许了&lt;/p&gt;&lt;p&gt;若最后一项不是binary，比如&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;&amp;lt;X:3/binary, Y, Z&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就先判断binary的长度是不是5，接着在分别判断各个segment上的pattern&lt;/p&gt;&lt;p&gt;若最后一项是binary，比如&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;&amp;lt;X:3/binary, Y, Z/binary&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就先判断binary的长度是不是大于等于4&lt;/p&gt;&lt;p&gt;因为binary immutable的，为了避免不必要的copy。实际的数据类型要有两种，一种是binary真正存储内容的，在代码里不能直接访问。另一种是subbinary，定义类似&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;struct subbin {
    struct binary *bin;
    size_t offset;
    size_t length;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;生成binary时，比如&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;&amp;lt;X/binary, Y/binary, Z/binary&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;先求X, Y, Z长度之和。先创建一个能容纳这么多字节的binary。返回一个长度为0的subbinary，再做3次拼接的操作。在拼接A B两个subbinary时，假如A对应的binary后面还有足够空间，那么就可以直接把B的内容复制过去。因为这里预先占好空间了，并不会导致不必要的copy。&lt;/p&gt;&lt;p&gt;这样就实现了binary。解决了USACO Training里的第一题。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20006355</guid>
<pubDate>Sat, 18 Apr 2015 21:51:43 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>开发刷题专用语言</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20001987</link>
<description>&lt;p&gt;刷题都没法用现成的库，复制粘贴代码又太麻烦了，必然导致刷题效率太低，一天就刷没几个题，和不刷也没啥区别。所以非常需要一门专门用来刷题的语言。&lt;/p&gt;&lt;p&gt;看上去好像不管怎么搞，只要最终是一个单独的C文件就可以了。可问题是，要想在尽可能多的OJ上提交，这个文件必须非常小，可以认为得控制在32K之内。&lt;/p&gt;&lt;p&gt;一开始，我还想就先塞个比如Python解释器进去，根据刷题需要再慢慢改就是了。可是这体积实在是太大了。别说Python了，连比Python小好多的Lua都塞不下。&lt;/p&gt;&lt;p&gt;只能去找找有那些能编译成C的语言/编译器。试过后来改名叫Nim的Nimrod，也试试过MLton，可生成出来的C代码，体积实在是太大了。&lt;/p&gt;&lt;p&gt;那就自己造个静态类型语言吧。结果死在类型上了。&lt;/p&gt;&lt;p&gt;转了一大圈，后来想了想，还是Erlang好。只要不允许动态生成atom，那么atom就用一个整数表示就好了，和自己用magic number表示是一样的。只要不允许 fun M:F/A 这种形式里出现变量，那么所有用到的函数在编译的时候就是知道的，连手动import都不需要了。这样也就顺便把所有没用到的函数在编译时直接丢掉了，体积就小了嘛。&lt;/p&gt;&lt;p&gt;内存大不了就自己mmap/VirtualAlloc内存，用TLSF这种比较土的算法来分配。malloc时，若发现内存不足需要申请新的内存页，就先GC一下。而且GC在sweep时，并不需要额外的双向链表，只要用memory allocator的block信息就可以了嘛。对于其他代码来说，只比手动管理内存多了个遍历所有直接子节点的函数，对于动态类型来说，这段代码就很短了。&lt;/p&gt;&lt;p&gt;Hello, world走通之后，就可以开始写库，写编译器优化了。假如你也在刷题，不妨一起来开发这门语言。&lt;/p&gt;&lt;p&gt;就是这样 &lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20001987</guid>
<pubDate>Mon, 13 Apr 2015 20:21:23 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
