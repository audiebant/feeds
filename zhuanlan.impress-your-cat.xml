<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>impress your cat</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Wed, 07 Oct 2015 18:14:39 +0800</lastBuildDate>
<item>
<title>[刷题]barelibc及其他</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20255574</link>
<description>&lt;p&gt;一直对各种沙盒都不满意。主要是SECCOMP STRICT模式限制实在太严格，不得不自己整个libc出来，还得是静态链接才行。后来想了想还是基于musl libc删吧。反正启动后在一个固定地址mmap一片内存，之后直接设置SECCOMP，除了__libc_start_main和__syscall这两个函数地址可能被覆盖以外，没啥好担心的了。&lt;a href=&quot;https://github.com/bhuztez/barelibc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;bhuztez/barelibc · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;。当然malloc算法换成了最土的TLSF。&lt;/p&gt;&lt;p&gt;另外就是开始收集各种题目，之前因为发生了各种意外没好好刷题，现在恢复。网上很多题解，基本上就一个代码，简单几句解释，有帮助，但问题是每次面试前过一遍太不现实了。我打算把考点和题目分开，单独写。题目按出处和按公司两种方式列出。 而各种Online Judge基本上都不提供数据，那么就只能自己补了。刚开的新仓库， &lt;a href=&quot;https://github.com/bhuztez/interview-questions&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;bhuztez/interview-questions · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 欢迎多多Pull Request，希望能在大家的帮助下成为题目收录最多的仓库&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20255574</guid>
<pubDate>Wed, 07 Oct 2015 17:31:07 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[21天]第一章内容提要</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20250615</link>
<description>&lt;p&gt;&lt;b&gt;把这个发出来，这样大家都可以开始写起来了。写好了，就可以赶紧发Pull Request了。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;参考资料 &lt;a class=&quot; wrap external&quot; href=&quot;https://github.com/xn--21Erlang-p00o82pmp3o/erlang-for-dummies-zh-cn/wiki&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Home · xn--21Erlang-p00o82pmp3o/erlang-for-dummies-zh-cn Wiki · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在第一章之前会简单介绍Erlang最最基本的功能，也就是函数和模式匹配&lt;/p&gt;&lt;p&gt;以下是第一章内容提要。注意不是目录，有些是正文，有些是习题，且不保证严格按这个顺序来。&lt;/p&gt;&lt;p&gt;&lt;br&gt;1. 写一个最原始的Lisp解释器&lt;br&gt;2. 加pattern matching&lt;br&gt;3. 用Erlang解释之前写的Erlang代码&lt;br&gt;4. 改写之前的解释器，改成自己维护call stack&lt;br&gt;5. 写一个程序，来完成4的工作&lt;br&gt;6. 加回溯&lt;br&gt;7. pattern matching升级成unification&lt;br&gt;8. 改成Prolog那样，以predicate为主的风格 (此时只有AST)&lt;br&gt;9. 用Prolog写Parser(DCG风格)来parse Prolog代码(这样就可以直接从Prolog代码开始了)&lt;br&gt;10. 让这个Prolog解释器足够解释大部分99 Prolog Problems里的答案&lt;br&gt;11. 让这个Prolog解释器足够解释Erlang解释器最早的原型&lt;br&gt;### Prolog太难用了，我们需要Datalog ###&lt;br&gt;12. Datalog之Naive/Semi Naive Evaluation&lt;br&gt;13. Datalog之QSQI&lt;br&gt;14. Datalog之Magic Set&lt;br&gt;15. Datalog之OLDT/SLG&lt;br&gt;### Datalog也可以是Parser，扔掉DCG了 ###&lt;br&gt;16.  从Datalog到CYK/Earley&lt;br&gt;17. 改成LR&lt;br&gt;18. 改成正则表达式&lt;br&gt;### 加一点backtracking回来 ###&lt;br&gt;19. Packrat&lt;br&gt;20. PCRE风格的Regex&lt;br&gt;### 来写个Shell ###&lt;br&gt;21. Erlang I/O protocol&lt;br&gt;22. 第一章这么快就结束了，简单回顾一下&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20250615</guid>
<pubDate>Sat, 03 Oct 2015 21:17:06 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>第1个21天</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20226408</link>
<description>&lt;p&gt;首先感谢&lt;a data-title=&quot;@萧井陌&quot; data-editable=&quot;true&quot; class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/fd7c571a0ada1a72e42e8d7992c4a780&quot; data-hash=&quot;fd7c571a0ada1a72e42e8d7992c4a780&quot; data-tip=&quot;p$b$fd7c571a0ada1a72e42e8d7992c4a780&quot;&gt;@萧井陌&lt;/a&gt;论坛打算先蹭他的cocode.cc了。 在这里，&lt;a class=&quot; wrap external&quot; href=&quot;http://cocode.cc/c/erlang21&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;21天学通Erlang 主题列表&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; ，想吐槽什么的直接发个贴就可以了。&lt;/p&gt;&lt;p&gt;制作虚拟机镜像这事碰到了一点麻烦。首先是把osv-apps里的Erlang从17改成18，这个没啥大问题。18因为用的是Apache License而不是之前那个不知道咋搞出来的License，至少不用担心怎么判断和其他License是否兼容的问题了。接着想把dns解析的问题解决了，结果发现OSv自带的DHCP client竟然不会写resolv.conf，于是先用8.8.8.8凑数了。最后发现一个巨大的问题，Fedora 22上gcc升级之后暴露了OSv在ELF处理上的大bug，感觉我是修不好了。&lt;/p&gt;&lt;p&gt;Github pages暂定用pelican生成，用i18n_subsites来解决多语言的问题。一开始会先介绍和编辑内容相关的，比如Erlang代码是怎么测试，怎么保证PDF里面贴的代码都是被检查过的，怎么保证代码片段在多个地方出现内容是同步的等等。现在问题来了，英语渣表示英语写不来，&lt;b&gt;求翻译&lt;/b&gt;啊&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20226408</guid>
<pubDate>Sat, 19 Sep 2015 17:17:30 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>21天学通Erlang即将恢复更新</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20165279</link>
<description>&lt;p&gt;目前打算每隔大约21天更新一次。&lt;/p&gt;&lt;p&gt;接下去，内容方面，先集中精力完成Prolog之前的内容。写的解释器能运行大部分99 Prolog Problems的答案，还有最早Erlang解释器的原型就可以了。可以参考列在&lt;a class=&quot; wrap external&quot; href=&quot;https://github.com/xn--21Erlang-p00o82pmp3o/erlang-for-dummies-zh-cn/wiki&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wiki&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;上的这些。还有就是要增加习题。一方面可以把后面章节用到的辅助函数换个马甲放到前面。这肯定是不够的，所以也要到处去收集。&lt;/p&gt;&lt;p&gt;一开始推荐的安装方式，将会统一成VirtualBox里运行虚拟机镜像，通过端口转发让宿主机的浏览器可以访问。最好能顺便把例子还有习题能做成互动的形式。&lt;/p&gt;&lt;p&gt;github pages的首页将会改成blog的形式，用来发布更新。&lt;/p&gt;&lt;p&gt;另外就是最好能有个论坛，虽然GitHub Issues也可以，我希望门槛能更低一点，不知道你们有没有好主意。&lt;/p&gt;&lt;p&gt;显然这一切都需要你们的大力帮助才能继续，毕竟现在bus factor=1啊。欢迎Pull Request，当然假如不知道如何参与，可以从吐槽开始嘛。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20165279</guid>
<pubDate>Sun, 30 Aug 2015 16:22:45 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>专栏也要友善度了</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20035863</link>
<description>&lt;p&gt;&lt;a class=&quot;internal&quot; href=&quot;http://www.zhihu.com/question/30392735/answer/47889055&quot;&gt;如何申请和使用知乎专栏？ - 知乎小管家的回答&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;内容和方向不符也不行， 一次就要收回权限。&lt;/p&gt;&lt;p&gt;专栏的编辑器也巨难用，经常陷入无法删除几个字的状况&lt;/p&gt;&lt;p&gt;还是不玩了吧。坐等被删除。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20035863</guid>
<pubDate>Tue, 19 May 2015 19:33:03 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 2. Naive Evaluation</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20033711</link>
<description>&lt;p&gt;Datalog相比Prolog，少了复合类型，但是要求结果是和求值顺序无关。这点就比Prolog好多了，Prolog完全没有逻辑可言，而Datalog至少是和一阶逻辑类似的。&lt;/p&gt;&lt;p&gt;我们用 {var, &#39;X&#39;} 的形式来表示Datalog中的变量。那么，类型定义可以写成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-type datalog_term() :: atom() | {&#39;var&#39;, atom()}.
-type datalog_goal() :: {atom(), [datalog_term()]}.
-type datalog_clause() :: {datalog_goal(), [datalog_goal()]}.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 一个简单的例子&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;%% start(a).
{{start, [a]},         []},
%% arc(d,a).
{{arc,   [d,a]},       []},
%% arc(e,a).
{{arc,   [e,a]},       []},
%% arc(a,b).
{{arc,   [a,b]},       []},
%% arc(a,c).
{{arc,   [a,c]},       []},
%% arc(b,f).
{{arc,   [b,f]},       []},
%% arc(c,f).
{{arc,   [c,f]},       []},
%% black(X):- start(X).
{{black, [{var,&#39;X&#39;}]}, [{start,[{var,&#39;X&#39;}]}]},
%% black(X):- white(Y), arc(Y,X).
{{black, [{var,&#39;X&#39;}]}, [{white,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;Y&#39;},{var,&#39;X&#39;}]}]},
%% white(X):- black(Y), arc(Y,X).
{{white, [{var,&#39;X&#39;}]}, [{black,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;Y&#39;},{var,&#39;X&#39;}]}]},
%% black(X):- white(Y), arc(X,Y).
{{black, [{var,&#39;X&#39;}]}, [{white,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;X&#39;},{var,&#39;Y&#39;}]}]},
%% white(X):- black(Y), arc(X,Y).
{{white, [{var,&#39;X&#39;}]}, [{black,[{var,&#39;Y&#39;}]}, {arc,[{var,&#39;X&#39;},{var,&#39;Y&#39;}]}]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而所谓的naive evaluation，既然都叫naive了，那肯定是非常简单的。&lt;/p&gt;&lt;p&gt;首先，把所有clause分成两类，EDB (extensional) 和 IDB (intentional)&lt;/p&gt;&lt;p&gt;EDB&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;start(a).
arc(d,a).
arc(e,a).
arc(a,b).
arc(a,c).
arc(b,f).
arc(c,f).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;IDB&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;black(X): start(X).
black(X): white(Y), arc(Y,X).
white(X): black(Y), arc(Y,X).
black(X): white(Y), arc(X,Y).
white(X): black(Y), arc(X,Y).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;直接提供Fact的就是EDB，提供规则的就是IDB&lt;/p&gt;&lt;br&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;build_db(Clauses) -&amp;gt;
    EDB =
        lists:foldl(
          fun add_fact/2,
          dict:new(),
          [Head || {Head, []} &amp;lt;- Clauses]),

    IDB =
        [Clause || {_, Body} = Clause &amp;lt;- Clauses, Body =/= []],

    EDB1 = build_db(IDB, EDB),
    [ {P, sets:to_list(Tuples)} || {P,Tuples} &amp;lt;- dict:to_list(EDB1) ].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;IDB里每条规则的正文部分，可以看作是查询。每条规则都出EDB里查一遍，&lt;br&gt;并把结果加到EDB里。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;naive_iteration([], EDB) -&amp;gt;
    EDB;
naive_iteration([{{P,A}, Goals}|IDB], EDB) -&amp;gt;
    EDB1 =
        lists:foldl(
          fun add_fact/2,
          EDB,
          [ {P, [subst(T, VarMap) || T &amp;lt;- A]}
            || VarMap &amp;lt;- query_db(Goals, EDB) ]),
    naive_iteration(IDB, EDB1).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 可是，这样并不能得到所有结果。那么就不断重复这个过程，直到EDB不变为止。(为了让人觉得高深莫测，那就叫不动点吧)。 &lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;build_db(IDB, EDB) -&amp;gt;
    case naive_iteration(IDB, EDB) of
        EDB -&amp;gt;
            EDB;
        EDB1 -&amp;gt;
            build_db(IDB, EDB1)
    end.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;剩下的函数定义，主要就是简单的unification。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;subst({var, V}, VarMap) -&amp;gt;
    case dict:find(V, VarMap) of
        {ok, V1} -&amp;gt;
            subst(V1, VarMap);
        error -&amp;gt;
            {var, V}
    end;
subst(V, _) -&amp;gt;
    V.

bind(V, T, VarMap) -&amp;gt;
    case dict:is_key(V, VarMap) of
        true -&amp;gt;
            false;
        false -&amp;gt;
            dict:store(V, T, VarMap)
    end.


unify(V1, V2, VarMap) -&amp;gt;
    case {subst(V1, VarMap), subst(V2, VarMap)} of
        {{var, X}, {var, X}} -&amp;gt;
            VarMap;
        {{var, X1}, X2} -&amp;gt;
            bind(X1, X2, VarMap);
        {X1, {var, X2}} -&amp;gt;
            bind(X2, X1, VarMap);
        {X, X} -&amp;gt;
            VarMap;
        _ -&amp;gt;
            false
    end.

unify_list([], [], VarMap) -&amp;gt;
    VarMap;
unify_list([H1|T1], [H2|T2], VarMap) -&amp;gt;
    case unify(H1, H2, VarMap) of
        false -&amp;gt;
            false;
        VarMap1 -&amp;gt;
            unify_list(T1, T2, VarMap1)
    end.

add_fact({P, A}, EDB) -&amp;gt;
    dict:update(P, fun (Old) -&amp;gt; sets:add_element(A, Old) end, sets:from_list([A]), EDB).

find_facts(P, EDB) -&amp;gt;
    case dict:find(P, EDB) of
        {ok, S} -&amp;gt;
            sets:to_list(S);
        error -&amp;gt;
            []
    end.

query_db([], VarMaps, _EDB) -&amp;gt;
    VarMaps;
query_db([{P, A}|Goals], VarMaps, EDB) -&amp;gt;
    VarMaps1 =
        [ M || M &amp;lt;- [ unify_list(A, Fact, VarMap)
                      || Fact &amp;lt;- find_facts(P, EDB),
                         VarMap &amp;lt;- VarMaps ],
               M =/= false],

    query_db(Goals, VarMaps1, EDB).

query_db(Goals, EDB) -&amp;gt;
    query_db(Goals, [dict:new()], EDB).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考 &lt;a href=&quot;http://www.inf.unibz.it/%7Enutt/Teaching/CL0910/CLSlides/5-datalog-eval.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;inf.unibz.it/%7Enutt/Te&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;aching/CL0910/CLSlides/5-datalog-eval.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://webdam.inria.fr/Alice/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;webdam.inria.fr/Alice/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20033711</guid>
<pubDate>Sun, 17 May 2015 20:37:51 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>OSv Elixir</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20029873</link>
<description>&lt;p&gt;在args_file的问题解决之后。运行BEAM语言应该没啥大问题了 (误 。那就来看一下Elixir吧。结果比预想的不顺利的多啊。&lt;/p&gt;&lt;p&gt;首先碰到一个诡异的问题，Elixir编译到一半不小心中断了，得make clean再重新开始。这都是怎么想的，这make竟然是冒牌的。&lt;/p&gt;&lt;p&gt;接着发现死活Erlang和Elixir只有一个能复制进image。经过调查发现，usr.manifest文件不能指向同一个目标。比如，有两个 /**&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/**: /path/to/some/dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么只能有一个生效。幸亏之前就把目录设置成不同的了。 &lt;br&gt;&lt;/p&gt;&lt;p&gt;顺便就带来了一个问题，之前还有 libz, openssl 什么的动态链接库是靠一段奇怪的脚本来复制的。幸好OSv已经把这个问题解决了，只要 require 对应的 module 就可以了。&lt;/p&gt;&lt;p&gt;总之，编译了很多次之后，Elixir也能在OSv上运行了。其他BEAM语言也开始蠢蠢欲动了。结果第一个LFE就运行不起来。经检查发现问题就出在编译的时候关闭了termcap。那就打开吧。打开之后傻眼了，还是进不了LFE Shell。&lt;/p&gt;&lt;p&gt;最后，经过反反复复debug，终于发现问题出在没有设置TERM环境变量。设置好之后，Erlang的ttsl_drv就能正常工作了。LFE Shell也就能运行了。 &lt;/p&gt;&lt;p&gt;就这点问题，竟然折腾了一天。 &lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20029873</guid>
<pubDate>Wed, 13 May 2015 21:37:44 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>OSv Erlang的进展</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20028805</link>
<description>&lt;p&gt;第一个问题是把编译参数里的 --without-os_mon 去掉了。到目前为止还没解决 cpu_sup的问题，主要原因是OSv根本就没实现必要的接口 ，于是就先禁用了。而memsup和disksup，都被我从port改成port driver了，这样就不需要开新的进程了。当然了，Bug肯定是少不了的。&lt;/p&gt;&lt;p&gt;第二个问题是怎么patch源代码的问题。第一个问题一开始我是把代码直接复制了一份。在nyh的建议下，改成patch了。现在的做法是，先把文件 x 复制一份 x.orig ，直接改 x ，改完了用 gendiff dirname .orig 生成 patch 。从头开始打 patch 时，用 patch -b 就会自动把原始文件复制一份，这样有改动之后重新 gendiff 就可以了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;第三个问题是epmd怎么启动的问题。一开始还妄图使用某个纯Erlang实现的epmd server。结果发现这样对release改动过大，根本没法用。又去看了看OSv的代码，发现，完全可以再开一个线程来运行epmd。只要把erlexec改改就可以了。剩下一个小问题，因为现在没有能用的wordexp，并不能完全替代system的功能。&lt;/p&gt;&lt;p&gt;接下来几天，还会加上从EC2 user-data读取args_file的功能(没有就用默认的)。这样一般的Erlang程序应该都能正常启动，每个节点也可以有不同的配置了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20028805</guid>
<pubDate>Tue, 12 May 2015 19:46:20 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[Parsing] 1. Prolog</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20013565</link>
<description>用Prolog语法来写Parser是一件很自然的事。比BNF要好的多。BNF 只是描述了语法，用Prolog写直接就把Parser给写完了。比如 &lt;br&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;plus_exp&amp;gt; ::= &amp;lt;mul_exp&amp;gt; | &amp;lt;mul_exp&amp;gt; &amp;lt;plus&amp;gt; &amp;lt;plus_exp&amp;gt;
&amp;lt;mul_exp&amp;gt; ::= &amp;lt;num&amp;gt; | &amp;lt;num&amp;gt; &amp;lt;mul&amp;gt; &amp;lt;mul_exp&amp;gt;
&amp;lt;plus&amp;gt; ::= &quot;plus&quot;
&amp;lt;mul&amp;gt; ::= &quot;mul&quot;
&amp;lt;num&amp;gt; ::= &amp;lt;integer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Prolog:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;plus(S0, S) :-
  S0 = [plus|S].

mul(S0, S) :-
  S0 = [mul|S].

num(N, S0, S) :-
  S0 = [N|S],
  integer(N).

plus_exp(Expr, S0, S) :-
  mul_exp(Expr, S0, S).

plus_exp(Expr, S0, S) :-
  mul_exp(E1, S0, S1),
  plus(S1, S2),
  plus_exp(E2, S2, S),
  Expr =.. [plus, E1, E2].

mul_exp(Expr, S0, S) :-
  num(Expr, S0, S).

mul_exp(Expr, S0, S) :-
  num(E1, S0, S1),
  mul(S1, S2),
  mul_exp(E2, S2, S),
  Expr =.. [mul, E1, E2].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题是虽然Prolog这语法看上去很好，真的很难用来写程序，动不动就不知道回溯到哪里去了，一cut又傻了，碰到左递归就死循环了。长的像一阶逻辑，其实完全没有逻辑可言。这也能叫Prolog ? &lt;br&gt;&lt;/p&gt;&lt;p&gt;即便无视这些缺点，对于写Parser来说，Prolog依旧是太强大了。Prolog可是图灵完全的。很容易构造出有无数个结果的查询&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;p([]).
p(L) :-
  L = [a|X],
  p(X).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 为了避免这个问题，就不能有复合类型。这样就没法用List来表示输入的字符串了。当然List还有另外一个问题就是，按这么写，必须一次提供完整的输入，而不是一次一个字符。&lt;/p&gt;&lt;p&gt;这是可以做到的，比如 &lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[1,plus,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 可以表示成&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;token(1, 0, 1).
token(plus, 1, 2).
token(2, 2, 3).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 语法规则就可以写成 (先忽略生成的语法树)&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;plus(S0, S) :-
  token(plus, S0, S).

mul(S0, S) :-
  token(mul, S0, S).

num(S0, S) :-
  token(N, S0, S),
  integer(N).

plus_exp(S0, S) :-
  mul_exp(S0, S).

plus_exp(S0, S) :-
  mul_exp(S0, S1),
  plus(S1, S2),
  plus_exp(S2, S).

mul_exp(S0, S) :-
  num(S0, S).

mul_exp(S0, S) :-
  num(S0, S1),
  mul(S1, S2),
  mul_exp(S2, S).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就变成Datalog了嘛。&lt;/p&gt;&lt;p&gt;接下来就来看Datalog&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20013565</guid>
<pubDate>Mon, 27 Apr 2015 11:26:45 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>为什么还需要一个新的内核？</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat/20012190</link>
<description>&lt;p&gt;很多人(包括我)都有这么一种错觉，好像操作系统是一个已经解决的问题，新的内核已经没有存在的必要了。所以也就没必要去了解操作系统是怎么回事，只管用就是了。&lt;/p&gt;&lt;p&gt;事实恰好相反。 你肯定碰到过有那么一天，网络出故障了，惊讶的发现有人竟然不知道怎么截图了，原因竟然是打不开QQ。这只能说明现在流行的操作系统既不好用也不安全。&lt;/p&gt;&lt;p&gt;按正常的做法，操作系统应该有截图服务，只有提供截图服务的程序才有权在整个桌面上截图。别的程序，包括QQ，想要截图，必须向截图服务发请求。这样同时也保证了，在这个操作系统上，所有程序的桌面截图的用法都是一致的。&lt;/p&gt;&lt;p&gt;唯一一个在这方面做的比较好的，可能真的就只有Wayland了。Wayland当然有Wayland的问题。至少Wayland把最重要的一件事搞对了，整个显示是以Compositing方式来进行的。&lt;/p&gt;&lt;p&gt;Compositing简单来说就是每个窗口自己画自己的，最后由compositor拼成一张图，再交给驱动去画去。这么简单一个概念，查了好多资料，最后发现竟然只有AmigaOS才是这么做的。目前流行的操作系统差不多在AmigaOS推出之后20年，才有类似的功能，还仅仅是以扩展的形式出现的。&lt;br&gt;&lt;/p&gt;&lt;p&gt;从定义来看，操作系统就是用来解决多个正在运行的程序对资源的并发访问这个问题的。只运行一个程序当然就无所谓有没有操作系统了。可是现在在操作系统上运行的程序，看上去并没有获得操作操作系统虚拟出来的设备的好处，反倒更像是陷入到API的汪洋大海之中。&lt;/p&gt;&lt;p&gt;Compositing才算是回归了操作系统的本质。在进程看来一个窗口就应该类似操作系统看到的一块屏幕。需要联网的进程，都有一个虚拟的网口，操作系统完成的功能更应该接近交换机。这样的概念也比什么X Window，Socket什么的更容易理解。&lt;/p&gt;&lt;p&gt;操作系统是如何向硬件传输数据的？直接往某一段映射为硬件的内存地址写就可以了。类似的，直接把一个窗口buffer对应的内存页，同时在compositor和GUI进程的地址空间都映射一遍就好了嘛。只要有MMU，这个就不是什么问题。这样，所谓微内核就是把驱动都放到用户态的提法就没有多大意义了，通过MMU，一样也可以把一个用户态进程的一部分内存地址，映射到硬件对应的物理地址。把大部分驱动放到用户态根本就不存在任何问题嘛。&lt;/p&gt;&lt;p&gt;能放到用户态的进程现在并没有放到用户态。这一定是内核出了问题。问题就出在现在流行的内核，并没有提供IPC。比如在UNIX上，连向另外一个进程发一个file descriptor都很麻烦呢，各种奇怪的magic。Wayland应该也有类似的问题，一个进程很难为另外一个进程申请一个surface。比如，在Wayland里并不存在类似XEmbed的功能。&lt;/p&gt;&lt;p&gt;这个问题并没有看上去那么简单。可能是因为我没仔细看，我看了一下HelenOS里并没有和论文里提到的VFS对应的代码。其他类似的情况，可能也就只有SCTP socket的peel off了吧。&lt;/p&gt;&lt;p&gt;这也就是为什么还需要一个新的内核。&lt;/p&gt;&lt;p&gt;P.S. 至于那种至运行一个程序，也敢说自己是操作系统的，比如Lisp Machine什么的。现在有了像OSv之类的内核，一个普通的单进程的Linux程序，只要编译成PIE，就能直接在OSv上运行了。别说Lisp Machine了，不管啥语言，只要是单进程的都行了。都有Erlang Machine了，还要Lisp Machine干啥？&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20012190</guid>
<pubDate>Sat, 25 Apr 2015 16:50:03 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
