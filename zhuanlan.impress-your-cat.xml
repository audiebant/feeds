<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>impress your cat</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat</link>
<description>Erlang, the Bananarama of languages, is a language out of Sweden that can be used to build web scale, asynchronous, non-blocking, sharded, event driven, message passing, NoSQL, reliable, highly available, high performance, real time, clusterable, bad ass, rock star, get the girls, get the boys, impress your mom, impress your cat applications.</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 16 Apr 2016 21:12:32 +0800</lastBuildDate>
<image>
<url>https://pic2.zhimg.com/b7567464789337f354d554ea0dbd28b5_xl.jpg</url>
<title>impress your cat</title>
<link>http://zhuanlan.zhihu.com/impress-your-cat</link>
</image>
<item>
<title>第6/7/8/9个21天</title>
<link>http://zhuanlan.zhihu.com/p/20760395</link>
<description>&lt;p&gt;因为现在在最最基本的语法之后，直接就开始解释Erlang的AST了，而不是从括号语言那里取绕了。而之前的做法有个问题是，在Prolog之后才开始写parser，但是要解释Prolog就得先写个parser。现在既然已经在用AST了，那么引入parse_transform也不是什么问题。所以可以用一个简单的parse_transform把代码转换成PEG风格的parser。所以在能解释之前所有Erlang模块的AST之后，就开始写PEG parser。这样在Prolog前就有parser了，且在backtracking之前过渡更自然一点。&lt;/p&gt;&lt;p&gt;expression.erl 类似 Erlang Shell 里解释Erlang表达式的功能。比如 &lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;{ok,1,[{&#39;X&#39;,1}]} = expression:eval_string(&quot;X.&quot;,[{&#39;X&#39;,1}]).
&lt;/code&gt;&lt;p&gt;function.erl 更进一步，能解释单个模块里的函数，比如&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;function:test({module,&quot;seq.erl&quot;}).
&lt;/code&gt;&lt;p&gt; 相当于&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;ok = seq:test().
&lt;/code&gt;&lt;p&gt;只是所有seq里的函数是由function.erl来解释的。目前，运行seq.erl, board.erl, bindings.erl, expression.erl以及function.erl都没有问题。&lt;/p&gt;&lt;p&gt;最简单的parse_transform，实现的功能相当于&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-compile(export_all).
&lt;/code&gt;&lt;p&gt;因为是parse_transform，所以得这么用&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-compile({parse_transform, export_all}).
&lt;/code&gt;&lt;p&gt;接下来就可以有PEG transform了。plain Erlang风格写个简单的parse整数的功能&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;digit([H|T])
  when H &amp;gt;= $0, H =&amp;lt; $9 -&amp;gt;
    {ok, H - $0, T};
digit(_S) -&amp;gt;
    error.

int(Acc, S) -&amp;gt;
    case digit(S) of
        {ok, N, S1} -&amp;gt;
            Acc1 = Acc*10 + N,
            case int(Acc1, S1) of
                {ok, N1, S2} -&amp;gt;
                    {ok, N1, S2};
                error -&amp;gt;
                    {ok, Acc1, S1}
            end;
        error -&amp;gt;
            error
    end.
&lt;/code&gt;&lt;p&gt;有了peg_transform之后，可以只关心能匹配的情况，不匹配的情况自动返回error。特别的int函数，第一个clause失败后会尝试第二个clause。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-compile({parse_transform, peg_transform}).

-rules([int/2, digit/1]).

digit([H|T])
  when H &amp;gt;= $0, H =&amp;lt; $9 -&amp;gt;
    {ok, H - $0, T}.

int(Acc, S) -&amp;gt; %%
    {ok, N, S1} = digit(S), %%
    int(Acc*10+N, S1);
int(Acc, S) -&amp;gt;
    {ok, N, S1} = digit(S),
    {ok, Acc*10+N, S1}.
&lt;/code&gt;&lt;p&gt;失败包括两种情况，一种是clause的pattern不匹配，另一种不匹配是发生在类似这种地方&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;{ok, Expr, Remain} = rule(...)&lt;/code&gt;&lt;p&gt;利用peg_transform，就可以写一个简单的parser，替换掉 parse_util:parse_expr/1&lt;/p&gt;&lt;p&gt;这些代码都已经在 &lt;a data-title=&quot;GitHub - xn--21Erlang-p00o82pmp3o/skeleton&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/xn--21Erlang-p00o82pmp3o/skeleton&quot;&gt;GitHub - xn--21Erlang-p00o82pmp3o/skeleton&lt;/a&gt; 里更新了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20760395</guid>
<pubDate>Sat, 16 Apr 2016 20:50:09 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>欢迎投稿本专栏</title>
<link>http://zhuanlan.zhihu.com/p/20689218</link>
<description>&lt;p&gt;假如您看得上只有仅仅2K+粉丝的专栏，刚好又没有专栏。任何和编程或者形式证明相关的，特别是能和Erlang, APL(包括APL家族的A+, J, K等等), Metamath等扯上关系的，欢迎来稿。&lt;/p&gt;&lt;p&gt;根据知乎专栏的新玩法，在知乎允许的范围(我也懒得了解了)内，假如有幸收录您的一篇投稿，就会把您列为作者之一，也就是下一次就可以直接发了。 (不知道能不能抢文章，那样就好玩了) &lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20689218</guid>
<pubDate>Wed, 30 Mar 2016 21:06:10 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>向OJ提交编译出来的汇编代码2</title>
<link>http://zhuanlan.zhihu.com/p/20656358</link>
<description>&lt;p&gt;之前只是解决了是否可能的问题。真正要能用，还是要把代码长度控制在允许的范围内。 &lt;br&gt;&lt;/p&gt;&lt;p&gt;一是需要压缩率更高的算法&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;&quot; data-title=&quot;如何提高写在C语言里的汇编代码的压缩率？ - 知乎用户的回答&quot; data-editable=&quot;true&quot; href=&quot;https://www.zhihu.com/question/39504416/answer/88728975&quot;&gt;如何提高写在C语言里的汇编代码的压缩率？ - 知乎用户的回答&lt;/a&gt;&lt;/p&gt;&lt;p&gt;二是用gcc编译时，加上参数 -fwhole-program 而不是通常的 -flto &lt;br&gt;&lt;/p&gt;&lt;p&gt;这样提交上去的代码长度不少就只有10K左右了。而算法库的源代码目前都已经接近50K了，无脑复制成一个文件已经没啥OJ会接受了。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20656358</guid>
<pubDate>Fri, 18 Mar 2016 21:15:21 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Awesome Ancient Chinese Books</title>
<link>http://zhuanlan.zhihu.com/p/20627628</link>
<description>&lt;p&gt;&lt;a class=&quot;&quot; data-title=&quot;GitHub - bhuztez/awesome-ancient-chinese-books: A curated list of awesome chinese books&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/bhuztez/awesome-ancient-chinese-books&quot;&gt;GitHub - bhuztez/awesome-ancient-chinese-books: A curated list of awesome chinese books&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;暂时没时间维护。先把坑挖开，&lt;b&gt;求支持&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;目标就是整理个目录，把网上能找到的古籍的地址按书名记录好，以便查阅。 &lt;/p&gt;&lt;p&gt;主要是为了以后开发中文编程语言时有据可循，而不是自己胡编乱造&lt;/p&gt;&lt;p&gt;就是这样&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20627628</guid>
<pubDate>Mon, 07 Mar 2016 20:21:45 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>[黑魔法]Python模拟HTML表单提交</title>
<link>http://zhuanlan.zhihu.com/p/20612720</link>
<description>&lt;p&gt;application/x-www-form-urlencoded这种比较简单就不讨论了。&lt;/p&gt;&lt;p&gt;multipart/form-data就比较麻烦了。搜了一下结果发现要么是远古时期的，要么就是推荐requests。有必要这么麻烦么？Python明明自带MIME库了，为啥就没人推荐用标准库的方法？只能自己来了&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;from urllib2 import Request
from email.message import Message


class Form(Message):

    def __init__(self):
        Message.__init__(self)
        self.add_header(&#39;Content-Type&#39;, &#39;multipart/form-data&#39;)
        self._payload = []

    def _write_headers(self, _generator):
        # DARK MAGIC followed
        pass


class Field(Message):

    def __init__(self,name,text):
        Message.__init__(self)
        self.add_header(&#39;Content-Disposition&#39;,&#39;form-data&#39;,name=name)
        self.set_payload(text,None)


def make_request(url,form_data):
    form = Form()

    for name,value in form_data.iteritems():
        form.attach(Field(name,str(value)))

    data = form.as_string()
    # THIS IS A SEPARATION BARRIER
    # NEVER LET CODE MOVE ACROSS THIS
    headers = {&#39;Content-Type&#39;: form[&#39;Content-Type&#39;]}

    return Request(url,data,headers)
&lt;/code&gt;&lt;p&gt; 就是这样&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20612720</guid>
<pubDate>Tue, 01 Mar 2016 20:32:54 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>barelibc问题修复及其他</title>
<link>http://zhuanlan.zhihu.com/p/20521163</link>
<description>&lt;p&gt;&lt;a data-title=&quot;bhuztez/barelibc&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/bhuztez/barelibc&quot;&gt;bhuztez/barelibc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在&lt;a class=&quot;&quot; data-title=&quot;为什么链接时__libc_start_main和__syscall行为不同？ - bsdelf 的回答&quot; data-editable=&quot;true&quot; href=&quot;https://www.zhihu.com/question/39519315/answer/81747490&quot;&gt;为什么链接时__libc_start_main和__syscall行为不同？ - bsdelf 的回答&lt;/a&gt;的启发下，我把 __syscall 挪到 crt1.o 里去了，免得被覆盖还不知道。&lt;/p&gt;&lt;p&gt;之前可能没提用barelibc也可以支持一部分C++了。注意编译的命令是 gcc 而不是 g++，不然会链接 libstdc++ ，就见鬼了。&lt;/p&gt;&lt;p&gt;--------------------------&lt;/p&gt;&lt;p&gt;正式开始在刷题的库。主要卖点是写完运行一行命令可以生成能提交到OJ的代码。在正式发布之前暂时不会公开源代码。假如你手上有很多现成优质代码捐赠给我，那果断加入吧。&lt;br&gt;&lt;/p&gt;&lt;p&gt;没代码，你也可以来完善这个TODO list。目标是收集各种topic，可能出现的题型，以及每个题型一个例题。以便我的库能覆盖所有常见题型。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;&quot; data-title=&quot;oj-solutions/TODO.md at master · bhuztez/oj-solutions · GitHub&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/bhuztez/oj-solutions/blob/master/TODO.md&quot;&gt;oj-solutions/TODO.md at master · bhuztez/oj-solutions · GitHub&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;欢迎Pull Request &lt;/p&gt;&lt;p&gt;--------------------------&lt;/p&gt;&lt;p&gt;另外，第6个21天的更新会和第7个21天一起发布&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20521163</guid>
<pubDate>Thu, 21 Jan 2016 22:45:21 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>向OJ提交编译出来的汇编代码</title>
<link>http://zhuanlan.zhihu.com/p/20494114</link>
<description>&lt;p&gt; 比如 x.c 的内容如下&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;asm(&quot;\t.globl main\n&quot;
&quot;\t.type main,@function\n&quot;
&quot;main:\n&quot;
&quot;\tmovl $1,%eax\n&quot;
&quot;\tret\n&quot;);
&lt;/code&gt;&lt;p&gt;编译，运行，可以看到退出代码确实是1&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ gcc -o x x.c
$ ./x
$ echo $?
1
$
&lt;/code&gt;&lt;p&gt;所以，理论上我们只需要把汇编代码，改写成C语言字符串就好了。&lt;/p&gt;&lt;p&gt;用 gcc -S -o- x.c 就能看到编译出来的汇编代码了&lt;/p&gt;&lt;p&gt;可是，发现在某些运行在Windows的OJ(用老版本的MinGW gcc)提交这些汇编代码时，会编译不过去，提示缺少 ___chkstk_ms ，假如关掉这个会导致程序出错。参考&lt;a class=&quot;&quot; data-title=&quot;c++ - What is the purpose of the _chkstk() function?&quot; data-editable=&quot;true&quot; href=&quot;https://stackoverflow.com/questions/8400118/what-is-the-purpose-of-the-chkstk-function&quot;&gt;c++ - What is the purpose of the _chkstk() function?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;假设当前函数栈横跨 B - E ，假如直接跳过C页访问D页，就出错了&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;  A    B    C    D    E
+----+----+----+----+----
|    |    |    |    |
+----+----+----+----+----
       |         ^     |-&amp;gt;
&lt;/code&gt;&lt;p&gt;暂时的办法就是直接抄一份现在版本的代码进去，反正也不长&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;&quot; data-title=&quot;mingw-w64/dll_dependency.S at cf136d93e41ffff7f593230e20c5854a68322b5d · mirror/mingw-w64 · GitHub&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/mirror/mingw-w64/blob/cf136d93e41ffff7f593230e20c5854a68322b5d/mingw-w64-libraries/winpthreads/src/libgcc/dll_dependency.S&quot;&gt;mingw-w64/dll_dependency.S at cf136d93e41ffff7f593230e20c5854a68322b5d · mirror/mingw-w64 · GitHub&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那C++怎么办？不同的libstdc++可能有不小的区别。需要关掉一些C++的功能，使得用gcc也能正常链接C++代码就没问题了。也就是使用以下命令编译&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gcc -fno-rtti -fno-exceptions
&lt;/code&gt;&lt;p&gt;-----------------------------------------------------------------------&lt;/p&gt;&lt;p&gt;这样生成出来的汇编代码很长，尝试压缩。比如&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;asm(&quot;...movl...&quot;)
&lt;/code&gt;&lt;p&gt; 可以替换成&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define M &quot;movl&quot;
asm(&quot;...&quot;M&quot;...&quot;)
&lt;/code&gt;&lt;p&gt;这么做的好处是不需要考虑escape什么的。 可是压缩率不太行，找了几个文件试了一下，仅仅在10%-15%之间。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20494114</guid>
<pubDate>Tue, 12 Jan 2016 18:57:45 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>Coq sucks.</title>
<link>http://zhuanlan.zhihu.com/p/20441953</link>
<description>&lt;p&gt;珍爱生命，远离Coq邪教。 &lt;a class=&quot;&quot; data-title=&quot;传教文：Coq - The Dairy of Marisa - 知乎专栏&quot; data-editable=&quot;true&quot; href=&quot;http://zhuanlan.zhihu.com/marisa/20439796&quot;&gt;传教文：Coq - The Dairy of Marisa - 知乎专栏&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Coq超级难入门啊。比如我前1024次尝试都以失败告终。装完Coq之后就不知道自己在干什么了，就没找到一个能看的教程。&lt;/p&gt;&lt;p&gt;(以下内容根据官方教程改编。) &lt;/p&gt;&lt;p&gt;不推荐先用CoqIDE或者Proof General &lt;br&gt;&lt;/p&gt;&lt;p&gt;先学会退出&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ coqtop
Welcome to Coq ......

Coq &amp;lt; Quit.
&lt;/code&gt;&lt;p&gt;好，现在来证明第一个定理。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Coq &amp;lt; Theorem my_first_theorem :
Coq &amp;lt;   forall A B C : Prop,
Coq &amp;lt;     (A-&amp;gt;(B-&amp;gt;C)) -&amp;gt; ((A-&amp;gt;B)-&amp;gt;(A-&amp;gt;C)).
1 subgoal
  
  ============================
   forall A B C : Prop, (A -&amp;gt; B -&amp;gt; C) -&amp;gt; (A -&amp;gt; B) -&amp;gt; A -&amp;gt; C

my_first_theorem &amp;lt; 
&lt;/code&gt;&lt;p&gt;输入定理。Coq的显示，============================上方是假设，下方是待证明的命题。我们的目标就是从假设推出待证明的结果。 &lt;/p&gt;&lt;p&gt;先intros A&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;my_first_theorem &amp;lt; intros A.
1 subgoal
  
  A : Prop
  ============================
   forall B C : Prop, (A -&amp;gt; B -&amp;gt; C) -&amp;gt; (A -&amp;gt; B) -&amp;gt; A -&amp;gt; C

my_first_theorem &amp;lt; 
&lt;/code&gt;&lt;p&gt;如下图所示，intros A这一步把我们一个开始的目标不妨称为X，转换成了一个新的目标不妨称为Y，只要证明了Y，我们就能证明X。也就是说，Coq通常证明过程是反着来的，把目标不断改写直到待证明的命题都是显然的或者都出现在上方的假设当中，证明就完成了。 &lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;                         intros A A : Prop
======================= &amp;lt;======== =======================
forall A B C : Prop,              forall B C : Prop
(A-&amp;gt;B-&amp;gt;C)-&amp;gt;(A-&amp;gt;B)-&amp;gt;A-&amp;gt;C           (A-&amp;gt;B-&amp;gt;C)-&amp;gt;(A-&amp;gt;B)-&amp;gt;A-&amp;gt;C
&lt;/code&gt;&lt;p&gt; 同样的 intros B, intros C&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;my_first_theorem &amp;lt; intros B.
1 subgoal
  
  A : Prop
  B : Prop
  ============================
   forall C : Prop, (A -&amp;gt; B -&amp;gt; C) -&amp;gt; (A -&amp;gt; B) -&amp;gt; A -&amp;gt; C

my_first_theorem &amp;lt; intros C.
1 subgoal
  
  A : Prop
  B : Prop
  C : Prop
  ============================
   (A -&amp;gt; B -&amp;gt; C) -&amp;gt; (A -&amp;gt; B) -&amp;gt; A -&amp;gt; C

&lt;/code&gt;&lt;p&gt;intros的另一种作用&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;my_first_theorem &amp;lt; intros H0.
1 subgoal
  
  A : Prop
  B : Prop
  C : Prop
  H0 : A -&amp;gt; B -&amp;gt; C
  ============================
   (A -&amp;gt; B) -&amp;gt; A -&amp;gt; C

my_first_theorem &amp;lt; intros H1.
1 subgoal
  
  A : Prop
  B : Prop
  C : Prop
  H0 : A -&amp;gt; B -&amp;gt; C
  H1 : A -&amp;gt; B
  ============================
   A -&amp;gt; C

my_first_theorem &amp;lt; intros H2.
1 subgoal
  
  A : Prop
  B : Prop
  C : Prop
  H0 : A -&amp;gt; B -&amp;gt; C
  H1 : A -&amp;gt; B
  H2 : A
  ============================
   C
&lt;/code&gt;&lt;p&gt;不妨把上一个目标称为M，下面两个目标称为N。apply H0的意思是，只要证明了N，代入到H0中，我们就能证明M。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;my_first_theorem &amp;lt; apply H0.
2 subgoals
  
  A : Prop
  B : Prop
  C : Prop
  H0 : A -&amp;gt; B -&amp;gt; C
  H1 : A -&amp;gt; B
  H2 : A
  ============================
   A

subgoal 2 is:
 B 
&lt;/code&gt;&lt;p&gt;也就是说，根据A和H0可以得到 B-&amp;gt;C，再根据B可以得到C。 如下图所示&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;                  ...
                  ======
...    apply H0   A
===== &amp;lt;=========
C                 ...
                  ======
                  B

... 表示
  A : Prop
  B : Prop
  C : Prop
  H0 : A -&amp;gt; B -&amp;gt; C
  H1 : A -&amp;gt; B
  H2 : A
&lt;/code&gt;&lt;p&gt;产生多个目标后，Coq会按顺序让你提供证明。因为H2就是A，所以，exact H2。 &lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;my_first_theorem &amp;lt; exact H2.
1 subgoal
  
  A : Prop
  B : Prop
  C : Prop
  H0 : A -&amp;gt; B -&amp;gt; C
  H1 : A -&amp;gt; B
  H2 : A
  ============================
   B

my_first_theorem &amp;lt; 
&lt;/code&gt;&lt;p&gt; 类似的。apply H1, exact H2后，剩下一个目标的证明也完成了&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;my_first_theorem &amp;lt; apply H1.
1 subgoal
  
  A : Prop
  B : Prop
  C : Prop
  H0 : A -&amp;gt; B -&amp;gt; C
  H1 : A -&amp;gt; B
  H2 : A
  ============================
   A

my_first_theorem &amp;lt; exact H2.
No more subgoals.

my_first_theorem &amp;lt; 

&lt;/code&gt;&lt;p&gt; QED&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;my_first_theorem &amp;lt; Qed.
intros A.
intros B.
intros C.
intros H0.
intros H1.
intros H2.
apply H0.
 exact H2.

 apply H1.
 exact H2.

my_first_theorem is defined

Coq &amp;lt; 
&lt;/code&gt;&lt;p&gt;反过来，是不是感觉好多了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;A-&amp;gt;(B-&amp;gt;C), A  A-&amp;gt;B, A
============= =======
B-&amp;gt;C,         B
======================
C

((A-&amp;gt;(B-&amp;gt;C)) /\ (A-&amp;gt;B) /\ A) -&amp;gt; C
===================================
((A-&amp;gt;(B-&amp;gt;C)) /\ (A-&amp;gt;B)) -&amp;gt; (A-&amp;gt;C)
===================================
(A-&amp;gt;(B-&amp;gt;C)) -&amp;gt; ((A-&amp;gt;B) -&amp;gt; (A-&amp;gt;C))

A : Prop
B : Prop
C : Prop
=============================
(A-&amp;gt;(B-&amp;gt;C))-&amp;gt;((A-&amp;gt;B)-&amp;gt;(A-&amp;gt;C))

||
\/

==================================================
forall A B C : Prop, (A-&amp;gt;(B-&amp;gt;C))-&amp;gt;((A-&amp;gt;B)-&amp;gt;(A-&amp;gt;C))&lt;/code&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20441953</guid>
<pubDate>Wed, 23 Dec 2015 22:24:49 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>第5个21天</title>
<link>http://zhuanlan.zhihu.com/p/20432737</link>
<description>&lt;p&gt;调整了git仓库的名字，改成book了。GitHub Pages上也加上了链接。重新生成了PDF。&lt;/p&gt;&lt;p&gt;之前老是写完了不满意重写，反反复复两个小节都没写完。现在特别开了skeleton仓库(&lt;a data-title=&quot;xn--21Erlang-p00o82pmp3o/skeleton · GitHub&quot; data-editable=&quot;true&quot; class=&quot;&quot; href=&quot;https://github.com/xn--21Erlang-p00o82pmp3o/skeleton&quot;&gt;xn--21Erlang-p00o82pmp3o/skeleton · GitHub&lt;/a&gt;)，先把想到的都记下来，降低反馈以及参与的难度。等skeleton里讨论了差不多了再挪到book里。&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以赶紧来吐槽，来补充内容吧。&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20432737</guid>
<pubDate>Sun, 20 Dec 2015 20:30:14 +0800</pubDate>
<media:thumbnail url="" />
</item>
<item>
<title>derecho</title>
<link>http://zhuanlan.zhihu.com/p/20412482</link>
<description>&lt;p&gt;很多公司都在开发自己的监控系统。出发点肯定是现有的并不够好用。而这个看上去很容易嘛，那就自己开发一个。(尽管我不认同这个答案的观点) &lt;a class=&quot;&quot; data-title=&quot;为什么很多公司都自主开发监控系统？（Linux运维方面） - gashero 的回答&quot; data-editable=&quot;true&quot; href=&quot;https://www.zhihu.com/question/27464246/answer/75704392&quot;&gt;为什么很多公司都自主开发监控系统？（Linux运维方面） - gashero 的回答&lt;/a&gt; 一针见血的指出了很多公司自己开发的结果是把时间都花在了怎么采集数据，怎么展示上了，往往最后还不如现成的开源的方案。这不就是在浪费时间啊。&lt;br&gt;&lt;/p&gt;&lt;p&gt;我认为他们几乎都掉进了&lt;a class=&quot;&quot; data-title=&quot;Inventor&#39;s paradox&quot; data-editable=&quot;true&quot; href=&quot;https://en.wikipedia.org/wiki/Inventor&#39;s_paradox&quot;&gt;Inventor&#39;s paradox&lt;/a&gt; 。 毫无疑问，一开始开发的时候，就会以XXX为目标，把所有XXX中需要的功能都山寨一遍，等这个OK了，替换掉XXX，接着开发自己需要的功能。这实际上是没有必要的，无非是自己给自己设限制。&lt;/p&gt;&lt;p&gt;不仅仅是机器的状态，某个端口能不能连上需要监控。更细的，比如统计IP包的Header，看看是不是有人在攻击你的服务，更贴近业务的，比如某个时间段，来自某个地区的访问是不是突然消失了，又比如付钱是不是突然都失败了。这些东西都是监控要做的。&lt;/p&gt;&lt;p&gt;转换到这种思路之后，你就不会再考虑自己去实现采集数据的功能了，因为根本就不知道会有哪些数据，而是反过来，提供一些接口，要求需要使用监控的一方自己来提供数据。有现成开源的采集数据的工具就先用着再说。展示也是类似的，提供一个取数据的接口，至于怎么展示那是需要使用监控的一方自己说了算。&lt;/p&gt;&lt;p&gt;那监控到底要做什么呢？首先当然是报警啦。而很多工具报警的功能就只针对某一个非常小的领域，要加别的类型的报警很不容易，更别说大部分实现实际上报警是定时读一下日志判断要不要报警的。报警不是单纯的发出通知就够了，肯定需要限制发送频率，也肯定需要能合并多个通知。定时读日志尽管产生报警可以做到stateless，发送报警通知是不可能做到stateless，用adhoc, informally-specified, bug-ridden, ...的方式来存这个状态，往往就是导致使用者想自己开发的导火索。&lt;/p&gt;&lt;p&gt;而这些实际上可以用Complex Event Processing/Event Stream Processing(buzzword)的形式统一起来。把一个比较通用的实时事件流分析处理的功能做好了，报警的问题就迎刃而解了。而开发这么一个东西需要的技术，在2000年前后就已经是路人皆知了。现在最推荐的是看&lt;a data-title=&quot;Portland State University CS 510-Data Streams&quot; data-editable=&quot;true&quot; href=&quot;http://web.cecs.pdx.edu/~tufte/410-510DS/&quot;&gt;Portland State University CS 510-Data Streams&lt;/a&gt;这个课程提到的相关资料。&lt;br&gt;&lt;/p&gt;&lt;p&gt;因为等了好多年，发现实在是没有堪用的。于是我决定自己写一个了。毫无疑问，这个语言得选Erlang。很多实现一个stream operator就有一个消息队列，还要弄个scheduler把这几个operator调度来调度去的。用Erlang这些事都省了。&lt;/p&gt;&lt;p&gt;当然了，现在写的这一个derecho并不会是一个实用的版本，因为现在这个还是单机的，而且是完全按顺序处理的。主要是为了尝试一个新想法，既然大部分这种流处理都是DAG，为什么不直接用Erlang代码来写呢，变量之间的依赖关系不刚好是一个DAG么，用List来代替流，测试一个查询的功能更方便直观了。&lt;/p&gt;&lt;p&gt;现在derecho只是刚刚开始，刚刚把第一个例子跑起来。就是一个非常常见的例子，计算某个拍卖物品最高竞拍价格。当你实用streams这个parse_transform的时候，streams:query里面的代码就会被转换成流的查询。而不用parse_transform，那就是对普通的List操作(这个还没写)。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;streams:query(
  fun (Bid) -&amp;gt;
      Price =
          streams:groupby(
            fun(P) -&amp;gt;
                    streams:aggregate(aggregate:max(price), P)
            end,
            item,
            Bid),
      {Price}
  end,
  [bid],
  [bid_price]),
&lt;/code&gt;&lt;p&gt;欢迎各种Issue/Pull Request&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;&quot; data-title=&quot;bhuztez/derecho · GitHub&quot; data-editable=&quot;true&quot; href=&quot;https://github.com/bhuztez/derecho&quot;&gt;bhuztez/derecho · GitHub&lt;/a&gt;&lt;/p&gt;</description>
<author>bhuztez</author>
<guid isPermaLink="false">20412482</guid>
<pubDate>Sat, 12 Dec 2015 23:04:32 +0800</pubDate>
<media:thumbnail url="" />
</item>
</channel>
</rss>
