<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 18 Dec 2017 03:44:06 +0800</lastBuildDate>
<item>
<title>怪名乱神</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-17-32085338.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;怪名乱神&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32085338&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我想给大家介绍一门语言。&lt;/p&gt;&lt;p&gt;C*。&lt;/p&gt;&lt;p&gt;C*有什么特点呢？很著名很流行。&lt;/p&gt;&lt;p&gt;我们可以看看TIOBE Index：到2017年12月，这门语言的rating达到了30.965%以上，比Java，下一个最热的语言，高了一倍有余。&lt;/p&gt;&lt;p&gt;这门语言被广泛使用于各种领域：操作系统（Linux, Windows），分布式（Spark），深度学习（部分tensorflow），区块链（bitcoin），游戏引擎（Unity）。&lt;/p&gt;&lt;p&gt;同时，C*的方言包含C, C++, Java, C#等知名语言。&lt;/p&gt;&lt;p&gt;我们先从语法开始介绍：C*的一个程序，由多个声明组成。其中，一些声明属于函数声明，而一个函数又由多条语句组成。。。&lt;/p&gt;&lt;p&gt;是不是觉得很荒谬？C没有Class, C++没有垃圾回收，Java跟C#水火不容，为什么被认作同一语言？&lt;/p&gt;&lt;p&gt;而如果我告诉你，现实比这还魔幻呢？世界上有很多语言正被冠以‘C*’这样的名字，而这些语言中，毫无共通点？这些语言中，有的有静态类型，有的有动态类型，有的两个都有，有的GC，有的是为Arduino设计的，有的在JVM上，有的有Class，有的有Reflection，有的没有Assignment，有的基于Lambda Calculus，有的则不是，有的可以任意改自身语法，有的语法是二维的，是个表格，而不是线性的，而有的甚至自带GUI，是livecoding的鼻祖之一。。&lt;/p&gt;&lt;p&gt;而这些语言，通通被称作同一个语言：Lisp。&lt;/p&gt;&lt;p&gt;而更魔幻的在后面：于是，有很多人开始讨论，为啥这门语言没有取得主流化，为啥这门语言效率这么高。。。然后得出很多答案，其中一半的直接是错误的，如：&lt;/p&gt;&lt;blockquote&gt;Lisp是第二早的高级语言，所以XXX，所以效率很高&lt;/blockquote&gt;&lt;p&gt;最早的编程语言Plankalkül，是1942到1945设计的，然后Fortran也比任何被称为Lisp的语言早。就算我们取最乐观的时间，1946到1955之间差了10年，里面出现了各种语言，AutoCode, ShortCode, Flow Chart, Haskell Curry的语言。。。&lt;/p&gt;&lt;p&gt;不过上述问题是技术错误，下面的论证则更离谱：&lt;/p&gt;&lt;blockquote&gt;Lisp社区很分裂，大家无法合作，所以没有流行&lt;/blockquote&gt;&lt;p&gt;。。。Excuse Me？如果有一天，C, C++, Java, C#都衰落了，再也没有人用，是不是因为C*社区很分裂，C/C++/Java/C#，你任意选出一对，肯定在互捏？大家无法合作也是啊，Java自己有一套库，C#自己一套，C跟C++也是，这么分裂，不衰退才怪！&lt;/p&gt;&lt;p&gt;欲加之罪，何患无辞啊！本来就不是同一个语言，为啥要放一起论证，然后去吐槽大家之间不兼容？&lt;/p&gt;&lt;p&gt;在一推只是因为历史原因被称作一家族的语言之间，找共通点，然后去论证这些语言的兴衰，特性，适用范围。。。能找出啥有价值，nontrivial的insight才怪。&lt;/p&gt;&lt;p&gt;至于S表达式？Logo不用括号，Racket有2d syntax，也有infix expression, Common Lisp有reader macro。。。试问这些语言是不是Lisp?而JMC也说过我们应该往M表达式迁移，那是不是JMC 发现了Lisp的本质劣根性？我们也可以用argument by absurdity，论证C*这个词的合理性 - 有花括号跟分号的就是C*，C*成为世界上最主流语言，C*万岁！&lt;/p&gt;&lt;p&gt;&#39;Lisp&#39;，这个词，已经没有任何有价值的意义，早就该被废弃，或者仅仅指JMC在1950末造的一个语言。就如同C*这个词不应该被引入一样。&lt;/p&gt;&lt;p&gt;另：最后，我想吐槽小部分所谓的‘Lisp’ 厨。往往，当你问，‘Lisp有什么优势/值得学’的时候（我们先不吐槽这问题提得很糟糕，就如同你不会问为啥要学C*/C*有啥优势），会跳出大致如下的答案：‘大部分主流语言的特性，早在Lisp中存在。主流PL发展只不过是catch up 1960 Lisp。’&lt;/p&gt;&lt;p&gt;这回答并很具误导性。&lt;/p&gt;&lt;p&gt;因为1960的时候，JMC 的确公开了一个语言，但是这个语言没有macro，是dynamic scope（读作：没有符合lambda calculus的first class function），连special form quote也没有（取而代之的是一个atom，换句话说你要quote compound expression得手动把(A B)转成(pair A B)）。在1967年，影响了Smalltalk跟无数学计算机人士的Logo出世，而在1970年，Scheme借鉴了Algol，修复了dynamic scope，也有macro跟continuation。Common Lisp在1984诞生，又在1990带来了Common Lisp Object System，跟metaobject protocol。1994，racket诞生，又在2002带来了composable &amp;amp; compilable macro。在今年，则出现了Collapsing Tower of Interpreter，实现了看上去有无数个interpreter，并且可以到达任何一个interpreter，更改语义，最后再运行普通的代码（并且看到更改语义带来的change），也出现了Type System as Macro，可以用宏代表静态类型。&lt;/p&gt;&lt;p&gt;这些语言都很有价值，很多都值得看。&lt;/p&gt;&lt;p&gt;但是没有一门叫Lisp的，在1960，搞对了Lambda Calculus，拥有大量影响力，有各种现代语言特性(Continuation, Type, Reflection, Macro)，有各种库，然后只有7条规则的语言。&lt;/p&gt;&lt;p&gt;我希望大家在讨论/宣传这些语言之一的时候，明白自己是在说啥。想说历史影响，可以用Scheme，玩极简主义，可以用JMC的Lisp，讨论OO，上Common Lisp，用Type/Contract，搞Racket。而不是一棒子打死，认为这些语言之间有任何共通点。&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-12-17-32085338</guid>
<pubDate>Sun, 17 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Ad Infinitum!</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-15-32045442.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Ad Infinitum!&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32045442&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近读了一篇paper，Duplication and Partial Evaluation，讲的是一门很。。奇怪的语言，&lt;/p&gt;&lt;p&gt;这门语言，可以大致想象是有无数个interpreter，一个stack着一个，interpret下一个，在最下，则是被解释的用户输入的代码。&lt;/p&gt;&lt;p&gt;你可以更改各种built in function，或者打印出来。比如说，你可以更改第1层（第0层为用户代码，第n+1层解释第n层代码）的apply，输入值print一次，输出值print一次，这样就实现了简陋debugger了。又或者对第二层解释器这样做，运行代码的时候就知道内部执行了啥&lt;/p&gt;&lt;p&gt;实现方法自然不能靠构造无限个interpreter，所以要先上laziness，按需增加，然后任何时刻，都有一个被解释的解释器去解释当下代码，然后有个被编译的解释器解释前一个解释器，这样就只有两轮。但是，这样，如果你更改n+2的代码，不会由n+1暴露到n层（换句话说n层看不出有啥区别），因为n层的时候，n+1层是被预编译的解释器执行，只有在n+1层看的到。这样，就顶多是两个编译器的开销。&lt;/p&gt;&lt;p&gt;‘顶多’，双重编译很疼，于是用了下Partial Evaluation，手动优化成一个编译器。&lt;/p&gt;&lt;p&gt;什么鬼啊这是。&lt;/p&gt;&lt;p&gt;可以在&lt;a href=&quot;http://io.livecode.ch/learn/readevalprintlove/black&quot;&gt;The reflective language Black&lt;/a&gt;试试看。&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-12-15-32045442</guid>
<pubDate>Fri, 15 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译14】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-15-32037390.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Programming Languages: Application and Interpretation【译14】&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32037390&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;审校： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;14 控制指令&lt;/h2&gt;&lt;p&gt;术语&lt;b&gt;控制&lt;/b&gt;指的是编程语言中任何使得计算过程前进的指令，因为它“控制”了计算机的程序计数器（program counter）。从这个意义上说，即使是简单的算术表达式也应该被认为是一种“控制”，而像顺序执行、函数调用和返回这样的操作，就更应该是了。不过，实践中我们通常用这个名词指代那些导致控制&lt;b&gt;非局部&lt;/b&gt;转移的——尤其是除了函数、过程以及将要学到的异常（exception）之外的——指令。本章我们将学习这类指令。&lt;/p&gt;&lt;p&gt;在研究这些控制指令时，需要指出的是，即使没有它们，我们的语言也是图灵完备的，也就是说我们并没有获得额外的“能力”。因此，控制指令所做的是，改变、改善我们的表达方式，从而增强程序的结构。所以，专注于程序的结构有益于本章的学习。&lt;/p&gt;&lt;h2&gt;14.1 Web上的控制&lt;/h2&gt;&lt;p&gt;让我们从研究Web程序的结构开始。考虑下面的程序：【注释】&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(display
  (+ (read-number &quot;First number&quot;)
     (read-number &quot;Second number&quot;)))&lt;/code&gt;&lt;blockquote&gt;今后，我们将把它称为“加法服务”。当然，你应该将它理解为更为复杂应用的一个简化版。例如，应用可能提示输入的是旅程的起点和目的地，加法对应的实际服务可能是根据输入的起点终点计算航线或者机票的价格。在两个（输入）步骤之间甚至可能也有计算：例如，在输入第一个城市后，航空公司可能会提示我们可供选择的目的地。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;为了测试这些想法，下面是read-number的实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (read-number [prompt : string]) : number
  (begin
    (display prompt)
    (let ([v (read)])
      (if (s-exp-number? v)
          (s-exp-&amp;gt;number v)
          (read-number prompt)))))&lt;/code&gt;&lt;p&gt;在控制台或DrRacket中运行时，该程序会提示我们输入一个数字，然后输入另一个数字，最后显示它们的总和。&lt;/p&gt;&lt;p&gt;现在假设我们想在Web服务器上运行。我们立即遇到难点：服务器端Web程序的结构是这样的：它们生成一个网页，比如请求第一个数字的网页，然后&lt;b&gt;停止&lt;/b&gt;。结果，&lt;b&gt;程序的其余部分&lt;/b&gt;——在这里，提示第二个数字，然后求和，然后打印结果——丢失了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么Web服务器的行为如此奇怪？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这种行为至少有两个原因：一个也许是历史的，另一个是技术的。历史原因是Web服务器最初设计为供应&lt;b&gt;页面&lt;/b&gt;，即静态内容。任何程序的运行都必须将其输出生成为文件，服务器将该文件提供给客户端。很自然的，开发人员想到为什么同样的程序在web上就不能按需运行。于是，后来Web上出现了&lt;b&gt;动态&lt;/b&gt;内容。构成Web应用的最小增量单元不再是页面，而是一个个执行结束后生成页面各个部分所需内容的程序。&lt;/p&gt;&lt;p&gt;更重要的原因——也是导致目前状况的原因——是技术性的。想象一下，我们的加法服务器已经生成了第一个提示。回想一下，有相当多的计算要进行：第二个提示，求和和显示结果。这些计算必须暂停，等待用户的输入。如果有成千上万的用户，那么必须暂停成千上万的计算，这会产生巨大的性能问题。此外，假设用户实际上没有完成计算——类似于在网上书店或航空公司网站上搜索，而不完成购买。服务器如何知道何时终止计算，甚至是否终止计算？而在终止之前，与该计算相关的资源仍被占用。&lt;/p&gt;&lt;p&gt;因此，Web协议从其概念上就被设计为&lt;b&gt;无状态的&lt;/b&gt;（stateless）：它不将与中间计算相关的状态存储在服务器上。这使得Web程序员被迫在其他地方维护所有必要的状态，每个请求都需要携带能够完全恢复计算所需的状态。在实践中，Web并不都是完全无状态的，但是它们在很大程度上倾向这个方向，因此研究这类程序的结构是非常有教益的。&lt;/p&gt;&lt;p&gt;接下来考虑一下客户端的Web程序：那些在浏览器中运行的程序，通常用JavaScript编写，或被编译成JavaScript。假设某个计算需要与服务器进行通信。（JavaScript提供的）指令为XMLHttpRequest。用户创建这个指令的实例，然后调用其&lt;code class=&quot;inline&quot;&gt;send&lt;/code&gt;方法向服务器发送消息。然而，与服务器通信并不是即时的（并且根据网络的状态，实际上可能永远不会完成）。这导致发送进程被挂起。&lt;/p&gt;&lt;p&gt;JavaScript的设计者决定让该语言是&lt;b&gt;单线程&lt;/b&gt;的，即，任意时间只能有一个线程在执行。【注释】这避免了赋值与线程结合而产生的各种风险。因此，JavaScript进程会被锁定以等待响应，这期间不可能做任何其他事情：例如，页面上的其他处理程序不再响应。&lt;/p&gt;&lt;blockquote&gt;因为这会导致结构性问题，现在有各种提议，实际上是要为JavaScript添加“安全的”线程。本章所描述的想法可以被看作是另一种方案，提供类似的结构优势。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;为了避免这个问题，XMLHttpRequest的设计要求开发者提供一个函数来响应请求（请求到达时将调用该程序）。该回调函数在系统中注册。需要传递请求结果给该回调函数让其完成&lt;b&gt;后续处理过程&lt;/b&gt;。因此，并非处于性能方面的考虑，而是为了避免同步、非原子性和死锁问题，客户端Web也发展出相同的程序模式。让我们更好地理解这种模式。&lt;/p&gt;&lt;h2&gt;14.1.1 将程序分解成现在和以后&lt;/h2&gt;&lt;p&gt;我们来考虑如何让上述程序在无状态的环境下——比如在Web服务器上——工作。首先我们需要确定&lt;b&gt;第一个&lt;/b&gt;交互，是提示输入第一个数字，因为Racket从左到右计算参数。将程序分成两部分是有益的：第一个交互产生啥（现在就可以运行），以及之后需要发生什么（必须以某种方式“记住”）。前者很容易：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number &quot;First number&quot;)&lt;/code&gt;&lt;p&gt;我们已经用文字解释过剩下的东西了，但是现在是时候把它写成程序了。似乎应该类似于【注释】&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(display
  (+ &amp;lt;第一个交互的返回值&amp;gt;
     (read-number &quot;Second number&quot;)))&lt;/code&gt;&lt;blockquote&gt;我们现在故意忽略read-number部分，但会回过来讨论它。现在，我们假设它是内置的。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;但是，Web服务器不能执行这个东西，因为它显然不是&lt;b&gt;程序&lt;/b&gt;。我们需要一种方式将其写成程序。&lt;/p&gt;&lt;p&gt;观察一下这个计算的特点：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它是合法的程序。&lt;/li&gt;&lt;li&gt;它需要保持暂停状态，直到请求进入。&lt;/li&gt;&lt;li&gt;它需要某种方式——例如参数——来引用前一个交互的值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;综合这些特点，显然我们应该将其表示为函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (v1)
  (display
    (+ v1
       (read-number &quot;Second number&quot;))))&lt;/code&gt;&lt;h2&gt;14.1.2 部分的解决方案&lt;/h2&gt;&lt;p&gt;在Web上，还有个额外的问题：每个带有输入元素的Web页面都需要引用存储在Web上的程序，该程序将从表单接收数据并对其进行处理。这个程序是在表单的action字段中指明的。因此，设想服务器生成一个新的标签，将前述函数存储在与该标签相关联的表格中，并且在action字段中引用该表格。如果客户端最终提交了表单，这个时候，服务器提取出关联的函数，向其提供表单的值，从而恢复执行。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;上述方案是无状态的吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;假设我们在自定义的Web服务器上维护这么一个表格。在这个服务器上，可能会有一个特殊版本的read-number，称之为call-read-number/suspend，记录程序的其余部分：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/suspend &quot;First number&quot;
                     (lambda (v1)
                       (display
                        (+ v1
                           (read-number &quot;Second number&quot;)))))&lt;/code&gt;&lt;p&gt;为了测试，我们来实现这个子程序。首先，我们需要标签的表示法；用数字就好：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias label number)&lt;/code&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;new-label&lt;/code&gt;在每次调用时都会生成新标签。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义&lt;code class=&quot;inline&quot;&gt;new-label&lt;/code&gt;。需要的话参考&lt;code class=&quot;inline&quot;&gt;new-loc&lt;/code&gt;以获得灵感。&lt;/blockquote&gt;&lt;p&gt;需要一个表，来存储代表程序其余部分的子程序。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define table (make-hash empty))&lt;/code&gt;&lt;p&gt;存储这些子程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (read-number/suspend [prompt : string] rest)
  (let ([g (new-label)])
    (begin
      (hash-set! table g rest)
      (display prompt)
      (display &quot; To enter it, use the action field label &quot;)
      (display g))))&lt;/code&gt;&lt;p&gt;现在运行上面的read-number/suspend调用，系统会打印&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1&lt;/code&gt;&lt;p&gt;这就相当于，在Web页面中打印提示，并在action字段中放入“标签1”。因为我们在模拟网页，需要有个东西来表示浏览器的提交过程。这里需要标签（来自action字段）和表单中输入的值。给定了这两个值，这个子程序需要从表中提取出相关子程序，并将其应用于表单值。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (resume [g : label] [n : number])
  ((some-v (hash-ref table g)) n))&lt;/code&gt;&lt;p&gt;有了这些，我们现在可以模拟输入3并点击“提交”按钮的行为，运行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 1 3)&lt;/code&gt;&lt;p&gt;其中1是标签，3是用户输入。不幸的是，这么做只会产生另一个提示，因为我们还没有完成程序的转换。要去除read-number，我们需要转换整个程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/suspend &quot;First number&quot;
                     (lambda (v1)
                       (read-number/suspend &quot;Second number&quot;
                                            (lambda (v2)
                                              (display
                                               (+ v1 v2))))))&lt;/code&gt;&lt;p&gt;为了安全起见，我们还可以在read-number/suspend结束的地方添加报错，从而确保计算在每次输出之后终止（以确保“挂起”的最极端形式）。&lt;/p&gt;&lt;p&gt;执行这个程序时，必须两次使用resume：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1
halting: Program shut down
&amp;gt; (resume 1 3)
Second number To enter it, use the action field label 2
halting: Program shut down
&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;其中两次用户输入分别是3和10，总和给出是13，而&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;halting&lt;/code&gt;&lt;p&gt;信息是我们添加的报错命令生成的。&lt;/p&gt;&lt;p&gt;我们故意略去了程序中某些有趣部分的类型。来看看这些类型应该是什么。read-number/suspend的第二个参数是读入数字并返回最终结果的子程序：&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; &#39;a)&lt;/code&gt;。同样，resume的返回类型也是&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;。这些&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;如何相互沟通？是通过将标签映射到&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; ’a)&lt;/code&gt;的表完成的。也就是说，计算过程中的每一步都产生相同类型的结果。&lt;code class=&quot;inline&quot;&gt;read-number/suspend&lt;/code&gt;写入表中，&lt;code class=&quot;inline&quot;&gt;resume&lt;/code&gt;从表中读取。&lt;/p&gt;&lt;h2&gt;14.1.3 实现无状态&lt;/h2&gt;&lt;p&gt;实际上我们并没有实现无状态，因为服务器上有一大张表，而我们缺乏明确手段去除此表。如果可以完全避免服务器上的状态就好了。这意味着我们必须将相关的状态移交给客户端。&lt;/p&gt;&lt;p&gt;服务器实际上以两种方式持有了状态。其一，可以存放任意多个——而不是常数个（比如线性相关于程序本身的大小）——条目的哈希表，。其二，我们在表中存放的是实实在在的闭包，而闭包中可以保有任意数量的状态。我们很快就会更清楚地看到这一点。&lt;/p&gt;&lt;p&gt;先从消除闭包开始着手。我们可以把所有的函数参数改成实名的全局函数（这迫使我们只会拥有有限个闭包，因为程序的长度不可能是无限的）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/stateless &quot;First number&quot; prog1)
 
(define (prog1 v1)
  (read-number/stateless &quot;Second number&quot; prog2))
 
(define (prog2 v2)
  (display (+ v1 v2)))&lt;/code&gt;&lt;p&gt;注意到每块代码都只引用下一块代码的名称，而没有引入真正的闭包。参数的值来自于表单。唯一的问题是：prog2中的v1是未绑定的标识符！&lt;/p&gt;&lt;p&gt;解决这个问题的方法是，不要在每一步之后创建闭包，而是将v1发送到客户端并存储在那里。存储在哪里呢？浏览器为此提供了两种机制：&lt;b&gt;Cookie&lt;/b&gt;和&lt;b&gt;隐藏字段&lt;/b&gt;。我们用哪一个？&lt;/p&gt;&lt;h2&gt;14.1.4 与状态互动&lt;/h2&gt;&lt;p&gt;Cookie和隐藏字段之间的本质区别是，&lt;b&gt;所有页面共享相同的cookie，但每个页面都包含自己的隐藏字段&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;先来考虑与现有程序的一串交互，（在两个地方都）使用read-number/suspend。就像这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1
&amp;gt; (resume 1 3)
Second number To enter it, use the action field label 2
&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;因此，恢复标签2似乎表示将3加到给定的参数（即，表单字段值）。保险起见，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 2 15)
18&lt;/code&gt;&lt;p&gt;一切正常。现在假设我们再次使用标签1：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 1 5)
Second number To enter it, use the action field label 3&lt;/code&gt;&lt;p&gt;注意，需要使用标签3，而不是标签1来恢复这个新的程序执行。的确，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 3 10)
15&lt;/code&gt;&lt;p&gt;但是我们应该问，如果重用标签2会发生什么？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;试试&lt;code class=&quot;inline&quot;&gt;(resume 2 10)&lt;/code&gt;。&lt;/blockquote&gt;&lt;p&gt;这就是恢复之前的计算。因此，我们期望它产生和之前一样的结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;现在来创建一个有状态的实现。通过共享一个可变状态但是拥有自己环境的闭包可以模拟这种行为。所以我们可以这样做，使用现有的read-number/suspend，但是不依赖lambda的闭包行为，即不使用任何自由变量。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define cookie &#39;-100)
 
(read-number/suspend &quot;First number&quot;
                     (lambda (v1)
                       (begin
                         (set! cookie v1)
                         (read-number/suspend &quot;Second number&quot;
                                            (lambda (v2)
                                              (display
                                               (+ cookie v2)))))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;对于之前的交互序列，现在的&lt;b&gt;期望&lt;/b&gt;值是啥？&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;计算过程是什么样的？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;起初，似乎没啥不同：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1
&amp;gt; (resume 1 3)
Second number To enter it, use the action field label 2
&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;当再次使用最初的计算时，我们确实得到新的恢复标签：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 1 5)
Second number To enter it, use the action field label 3&lt;/code&gt;&lt;p&gt;使用新标签时，计算结果如我们所期望的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 3 10)
15&lt;/code&gt;&lt;p&gt;关键的一步来了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 2 10)
15&lt;/code&gt;&lt;p&gt;标签2的两次恢复产生了不同的答案，这一点不足为奇，因为它们依赖于可变状态。问题是，当我们将相同的行为转换到Web时会发生什么。&lt;/p&gt;&lt;p&gt;想象一下，访问某旅馆预订网站，寻找某个城市的旅馆。返回的网页中，你看到一个旅馆的列表和标签1。你在新（浏览器）标签或窗口中浏览其中的一个旅馆；这个页面中生成了那个旅馆的信息，还有标签2用作预订旅馆。然而，你返回旅馆列表，并在新的标签或窗口中查看了另一家旅馆。这产生了第二家旅馆的信息，还有标签3用作该旅馆的预订。然而，你决定选择第一家旅馆，返回第一家旅馆的页面，然后选择预订按钮，也就是提交了标签2。你想要预订的是哪家旅馆？尽管你预期订的是&lt;b&gt;第一家&lt;/b&gt;，大多数旅游网站上，你要么预订了&lt;b&gt;第二家&lt;/b&gt;旅馆——即最后查看的，而不是预订按钮所在的网页上的那家——要么被报告错误。这是因为在Web站点普遍使用了cookie，这是大多数Web API所鼓励的做法。&lt;/p&gt;&lt;h2&gt;14.2 Continuation传递模式&lt;/h2&gt;&lt;p&gt;之前所说的函数是有名称的。虽然用Web描述问题，但是我们用的是更古老的概念：这类函数被称为&lt;b&gt;continuation&lt;/b&gt;（延续），而这种风格的程序被称为&lt;b&gt;continuation-passing style&lt;/b&gt;（Continuation传递模式，简称CPS）。【注释】这值得研究一下，因为它是学习其他各种非平凡控制指令——如生成器——的基础。&lt;/p&gt;&lt;blockquote&gt;我们会自由地将CPS当作名词和动词使用：一种特定的代码模式，将代码转化为此种模式。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;此前，我们将程序转化为，没有Web输入操作嵌套在另一个中。动机很简单：当程序终止时，所有嵌套的计算都会丢失。对于XMLHttpRequest来说，类似的论据（在程序本地意义上）成立：所有依赖于Web服务器响应结果的计算，都需要驻留在对服务器请求相关联的回调中。&lt;/p&gt;&lt;p&gt;事实上，我们并不需要转化&lt;b&gt;每一个&lt;/b&gt;表达式。只需要处理涉及实际Web交互的表达式。比如说，如果要进行的计算不是加法，而是比它复杂得多的数学表达式，这个数学表达式我们是不需要转换的（不涉及Web交互）。不过，如果这里有个函数调用，那么我们必须绝对确定这个函数、它调用的函数、这些函数调用的函数（整个调用链）中不存在任何的Web调用，才可以不对它进行转换。否则，保险起见，我们必须转化所有的这些函数。总之，我们必须转化每个我们无法确定不执行任何Web交互的表达方式。&lt;/p&gt;&lt;p&gt;因此，这里转化的核心就是把每个单参数函数&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;转换成具有额外参数的函数。这个额外的参数就是continuation，代表了其余的计算。Continuation本身也是单参数的函数。这个参数的输入是&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;&lt;b&gt;本来的&lt;/b&gt;返回值，后续计算本来需要使用这个返回值继续。转换后&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;将不再&lt;b&gt;返回&lt;/b&gt;值，而是将原来的返回值&lt;b&gt;传递给&lt;/b&gt;它的continuation。&lt;/p&gt;&lt;p&gt;CPS是种通用的转化，可以作用在任何程序上。因为它是一种程序转换，所以我们可以把它看作是特殊的去语法糖：特别之处是，它不是把程序从大语言转化到小语言（类似于宏），或者从一种语言转化到另一种语言（就像编译器那样），而是在&lt;b&gt;同一种&lt;/b&gt;语言中的程序转换：从完整语言转化到受限制的形式，遵从这里讨论的模式。因此，我们可以使用完整语言的求值器对CPS程序求值。&lt;/p&gt;&lt;h2&gt;14.2.1 用去语法糖实现&lt;/h2&gt;&lt;p&gt;我们已经对去语法糖有了很好的支持，所以我们来它来定义CPS转换。具体来说，我们将实现CPS宏。为了更加干净地将源语言与目标语言分开，我们所使用的大部分语言结构都会用略有不同的名称：单变量的rec和with而不是let和letrec；lam而不是lambda；cnd而不是if；seq取代begin；set取代set!。这会是足够丰富的语言，可以编写一些有趣的程序！&lt;/p&gt;&lt;blockquote&gt;后文中宏的子句按照我认为从容易到困难的顺序排列。但是，宏定义的代码必须避免模式的重复，因此遵循不同的顺序。&lt;br&gt;&lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro&amp;gt; ::=  ;CPS宏

    (define-syntax (cps e)
      (syntax-case e (with rec lam cnd seq set quote display read-number)
        &amp;lt;cps-macro-with-case&amp;gt;
        &amp;lt;cps-macro-rec-case&amp;gt;
        &amp;lt;cps-macro-lam-case&amp;gt;
        &amp;lt;cps-macro-cnd-case&amp;gt;
        &amp;lt;cps-macro-display-case&amp;gt;
        &amp;lt;cps-macro-read-number-case&amp;gt;
        &amp;lt;cps-macro-seq-case&amp;gt;
        &amp;lt;cps-macro-set-case&amp;gt;
        &amp;lt;cps-macro-quote-case&amp;gt;
        &amp;lt;cps-macro-app-1-case&amp;gt;
        &amp;lt;cps-macro-app-2-case&amp;gt;
        &amp;lt;cps-macro-atomic-case&amp;gt;))&lt;/code&gt;&lt;p&gt;我们的CPS表示法会将&lt;b&gt;每个&lt;/b&gt;表达式转变成单参数的函数，参数就是continuation。转换后的表达式最终要么提供值调用continuation，要么将continuation传递给其他表达式，归纳地说，其他表达式也遵从这个不变量关系，因此最终continuation会被提供某个值。所以说，所有的CPS输出看起来都类似于&lt;code class=&quot;inline&quot;&gt;(lambda (k) ...)&lt;/code&gt;（我们将依赖卫生来保证所有引入的k不会相互冲突）。&lt;/p&gt;&lt;p&gt;首先，我们来处理简单的情况，原子值。尽管概念上来说它是最简单的，但是我们将其放在最后一项，因为放在前面的话它会遮盖掉其他匹配。（理想情况下，我们应该将其放在第一个位置，然后提供一个能精确定义我们原子值的匹配表达式，这里放宽要求是因为我们对其他情况更为关心。）原子值的情况中，我们已经有一个值，将其传递给continutaion即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-atomic-case&amp;gt; ::=  ;原子

    [(_ atomic)
     #&#39;(lambda (k)
         (k atomic))]&lt;/code&gt;&lt;p&gt;被引用的常量也一样处理：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-quote-case&amp;gt; ::=

    [(_ &#39;e)
     #&#39;(lambda (k) (k &#39;e))]&lt;/code&gt;&lt;p&gt;我们还知道，with和rec可以当作宏来处理：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-with-case&amp;gt; ::=

    [(_ (with (v e) b))
     #&#39;(cps ((lam (v) b) e))]

&amp;lt;cps-macro-rec-case&amp;gt; ::=

    [(_ (rec (v f) b))
     #&#39;(cps (with (v (lam (arg) (error &#39;dummy &quot;nothing&quot;)))
                  (seq
                   (set v f)
                   b)))]&lt;/code&gt;&lt;p&gt;赋值也是容易的：先求出新的值，然后再执行实际的更新操作：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-set-case&amp;gt; ::=

    [(_ (set v e))
     #&#39;(lambda (k)
         ((cps e) (lambda (ev)
                    (k (set! v ev)))))]&lt;/code&gt;&lt;p&gt;序列指令也是直白的：依次执行每个操作。请注意我们保持了序列的语义：不仅遵守了操作的顺序，第一个子项（e1）的值在第二个（e2）的计算中不会被用到，所以该值所绑定到的标识符的名称也就无关紧要。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-seq-case&amp;gt; ::=

    [(_ (seq e1 e2))
     #&#39;(lambda (k)
         ((cps e1) (lambda (_)
                     ((cps e2) k))))]&lt;/code&gt;&lt;p&gt;处理条件指令时，需要创建新的continuation，用来记住我们在等待条件表达式的求值结果。不过，一旦获得了其值，根据其值的不同我们可以选择进入已有的continuation分支。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-cnd-case&amp;gt; ::=

    [(_ (cnd tst thn els))
     #&#39;(lambda (k)
         ((cps tst) (lambda (tstv)
                      (if tstv
                          ((cps thn) k)
                          ((cps els) k)))))]&lt;/code&gt;&lt;p&gt;处理函数调用时，有两种情况需要考虑。我们必须要处理语言中创建的函数，也就是单参数函数。然而，为了编写示例程序，能够使用诸如+和*之类的指令很有用。因此，&lt;b&gt;为了简单起见&lt;/b&gt;，我们将&lt;b&gt;假定&lt;/b&gt;单参数函数是用户编写的，因此需要CPS转换，而双参数函数是不会执行任何Web或其他控制操作的指令，因此可以直接调用； 我们&lt;b&gt;还&lt;/b&gt;假定原生指令可以直接写出（即，函数位置不是复杂表达式，本身不会执行Web交互）。&lt;/p&gt;&lt;p&gt;对于函数调用，我们必须先对函数和参数表达式求值，一旦获取了这些就可以实际进行函数的调用。因此我们很容易将函数调用的转换写成这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-app-1-case-take-1&amp;gt; ::=

    [(_ (f a))
     #&#39;(lambda (k)
         ((cps f) (lambda (fv)
                    ((cps a) (lambda (av)
                               (k (fv av)))))))]&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;你看出为什么这是错的吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;问题在于，虽然函数现在是值了，也就是闭包，其函数体可以很复杂：比如说，对函数体求值可以导致进一步的Web交互，此时函数体的其余部分，包括待处理的&lt;code class=&quot;inline&quot;&gt;(k ...)&lt;/code&gt;（即程序的其余部分）将全部丢失。为了避免这种情况，我们必须把k提供给函数的值，让归纳不变量保证k最终会被调用于fv作用于av的得到的值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-app-1-case&amp;gt; ::=

    [(_ (f a))
     #&#39;(lambda (k)
         ((cps f) (lambda (fv)
                    ((cps a) (lambda (av)
                               (fv av k))))))]&lt;/code&gt;&lt;p&gt;处理内置双目操作的特殊情况比较容易：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-app-2-case&amp;gt; ::=

    [(_ (f a b))
     #&#39;(lambda (k)
         ((cps a) (lambda (av)
                    ((cps b) (lambda (bv)
                               (k (f av bv)))))))]&lt;/code&gt;&lt;p&gt;用户定义的函数不能使用这个模式，因为我们假设这里f的调用总是会返回，而不进行任何不寻常的控制转移。&lt;/p&gt;&lt;p&gt;函数本身就是一种值，该值本身应该被返回给挂起的计算（一个continuation）。然而，前面函数调用的情况表明，函数转化后需要传入额外的参数——调用点的continuation。这就留下一个问题：该向函数体提供哪个continuation？&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-lam-case-take-1&amp;gt; ::=

    [(_ (lam (a) b))
     (identifier? #&#39;a)
     #&#39;(lambda (k)
         (k (lambda (a dyn-k)
              ((cps b) ...))))]&lt;/code&gt;&lt;p&gt;也就是说，在这里的...位置上，我们该填入k还是dyn-k？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;该填入哪个continuation呢？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;前者是&lt;b&gt;闭包创建位置&lt;/b&gt;的continuation。后者是&lt;b&gt;闭包调用位置&lt;/b&gt;的continuation。换一种说法，前者是“静态的”，后者是“动态的”。这里，我们需要使用动态的continuation，否则会发生非常奇怪的事情：程序会返回到创建闭包的地方，而不是它被使用的地方！这会导致非常奇怪的程序行为，所以我们避免这么做。请注意，这里我们有意识地选择动态的continuation，就如同在处理作用域时，我们选择了静态的环境。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-lam-case&amp;gt; ::=

    [(_ (lam (a) b))
     (identifier? #&#39;a)
     #&#39;(lambda (k)
         (k (lambda (a dyn-k)
              ((cps b) dyn-k))))]&lt;/code&gt;&lt;p&gt;最后，为了建模Web编程的目的，我们需要添加输入和输出指令。输出遵循前述函数调用的模式：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-display-case&amp;gt; ::=

    [(_ (display output))
     #&#39;(lambda (k)
         ((cps output) (lambda (ov)
                         (k (display ov)))))]&lt;/code&gt;&lt;p&gt;对于输入，使用现有的read-number/suspend就可以了，不过这里由我们来&lt;b&gt;生成&lt;/b&gt;其使用，而不是让程序员来创建：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-read-number-case&amp;gt; ::=

    [(_ (read-number prompt))
     #&#39;(lambda (k)
         ((cps prompt) (lambda (pv)
                         (read-number/suspend pv k))))]&lt;/code&gt;&lt;p&gt;请注意，绑定为k的continuation就是在Web交互处我们需要存储的continuation。&lt;/p&gt;&lt;p&gt;测试CPS转换后的代码有些小麻烦，因为所有CPS项都需要读入continuation。最初的continuation可以是（a）读入值并返回它，或者（b）读入值并打印它，或者（c）读入值，打印它并准备好进行下一个计算（DrRacket的交互窗口就是这么做的）。这三者其实都只是恒等函数的变体。所以，我们定义以下函数辅助测试：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (run c) (c identity))&lt;/code&gt;&lt;p&gt;例如，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps 3))                           3)
(test (run (cps ((lam ()    5)       )))      5)
(test (run (cps ((lam (x)   (* x x)) 5)))     25)
(test (run (cps (+ 5 ((lam (x) (* x x)) 5)))) 30)&lt;/code&gt;&lt;p&gt;也可以测试之前的Web程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(run (cps (display (+ (read-number &quot;First&quot;)
                      (read-number &quot;Second&quot;)))))&lt;/code&gt;&lt;p&gt;为了避免你迷失在众多代码之中，我强调一下这里的重点：&lt;b&gt;我们恢复了代码的结构&lt;/b&gt;。换种说法，即借由恰当的嵌套表达式以及帮助将其翻译以使其可以和底层API协作的代码的编译器（本例中即CPS转换程序），我们得以使用**直述的风格（direct style）**编写程序。这正是优秀的编程语言所应做的！&lt;/p&gt;&lt;h2&gt;14.2.2 例子的转化&lt;/h2&gt;&lt;p&gt;让我们来看看上面的例子是怎么转换的。你可以手工操作，也可以采取简单的办法，用DrRacket的Macro Stepper（宏步进器）完成。【注释】放入run函数传入的恒等函数，我们得到：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (k)
  ((lambda (k)
     ((lambda (k)
        ((lambda (k)
           (k &quot;First&quot;)) (lambda (pv)
                          (read-number/suspend pv k))))
      (lambda (lv)
        ((lambda (k)
           ((lambda (k)
              (k &quot;Second&quot;)) (lambda (pv)
                              (read-number/suspend pv k))))
         (lambda (rv)
           (k (+ lv rv)))))))
   (lambda (ov)
     (k (display ov)))))&lt;/code&gt;&lt;blockquote&gt;这里，为了获取的Macro Stepper的全部功能，请使用&lt;code class=&quot;inline&quot;&gt;#lang racket&lt;/code&gt;语言。&lt;/blockquote&gt;&lt;p&gt;什么！这和我们手写的版本完全不同！&lt;/p&gt;&lt;p&gt;实际上，这个程序中充满了所谓的&lt;b&gt;管理性&lt;/b&gt;lambda（administrative lambda），由我们所用的CPS算法引入。【注释】请不用担心！如果我们逐一调用这些lambda，完成替代，那么——&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;完成此步。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;——这个程序会简化为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/suspend &quot;First&quot;
                     (lambda (lv)
                       (read-number/suspend &quot;Second&quot;
                                            (lambda (rv)
                                              (identity
                                               (display (+ lv rv)))))))&lt;/code&gt;&lt;p&gt;这正是我们想要的。&lt;/p&gt;&lt;blockquote&gt;设计更好的CPS算法，消除不必要的管理性lambda，是个研究前沿问题。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.2.3 在核心中实现&lt;/h2&gt;&lt;p&gt;在研究了通过去语法糖实现CPS之后，我们应该问问，是否可将其以放在核心中。&lt;/p&gt;&lt;p&gt;回想一下，我们说过CPS适用于任何程序。有一个我们特别感兴趣的程序：解释器。显然，我们可以将CPS转换应用于其上，从而获得事实上的continuation。&lt;/p&gt;&lt;p&gt;首先，这里使用函数来表示闭包较为方便（译注，12.1节）。我们让解释器读入多读入一个参数，该参数读入值（需要传给continuation的那些值）并最终返回它们：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp&amp;gt; ::=  ;cps解释器

    (define (interp/k [expr : ExprC] [env : Env] [k : (Value -&amp;gt; Value)]) : Value
      &amp;lt;cps-interp-body&amp;gt;)  ;cps解释器主体&lt;/code&gt;&lt;p&gt;对于简单的情况，我们不直接返回值，而是将其传递给continuation参数即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-body&amp;gt; ::=

    (type-case ExprC expr
      [numC (n) (k (numV n))]
      [idC (n) (k (lookup n env))]
      &amp;lt;cps-interp-plusC-case&amp;gt;
      &amp;lt;cps-interp-appC-case&amp;gt;
      &amp;lt;cps-interp-lamC-case&amp;gt;)&lt;/code&gt;&lt;p&gt;（请注意，multC的处理完全类似于plusC。）&lt;/p&gt;&lt;p&gt;还是从简单的情况开始，plusC。第一步我们解释左子表达式。该计算的continuation进行右子表达式的解释。这个计算的continuation对结果求和。求和的结果怎么处理？在interp中，它被返回，返回到那个调用解释plusC的计算。请记住，现在我们不再返回值；反之，我们将其传给continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-plusC-case&amp;gt; ::=

    [plusC (l r) (interp/k l env
                           (lambda (lv)
                             (interp/k r env
                                       (lambda (rv)
                                         (k (num+ lv rv))))))]&lt;/code&gt;&lt;p&gt;&lt;b&gt;习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;实现multC。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;还剩下两种相互关联的情况，它们相对更难些。&lt;/p&gt;&lt;p&gt;对于函数调用，还是需要解释两个子表达式，然后将结果的闭包应用于参数。不过，我们已经说好了，每个调用都需要带上continuation参数。因此，必须更新一下值的定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Value
  [numV (n : number)]
  [closV (f : (Value (Value -&amp;gt; Value) -&amp;gt; Value))])&lt;/code&gt;&lt;p&gt;接下来必须决定传给它啥continuation。对于函数调用，就是传入解释器的continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-appC-case&amp;gt; ::=

    [appC (f a) (interp/k f env
                          (lambda (fv)
                            (interp/k a env
                                      (lambda (av)
                                        ((closV-f fv) av k)))))]&lt;/code&gt;&lt;p&gt;最后处理lamC的情况。和以前一样，我们必须使用lambda创建closV。不过，这个函数需要两个参数：实际的参数和调用的continuation。关键的问题是，后者该是什么？&lt;/p&gt;&lt;p&gt;有两个选择。k表示&lt;b&gt;静态的&lt;/b&gt;continuation：在闭包&lt;b&gt;创建&lt;/b&gt;位置的那个continuation。不过，我们想要的是在闭包&lt;b&gt;调用&lt;/b&gt;之处的continuation，也就是&lt;b&gt;动态的&lt;/b&gt;continuation。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-lamC-case&amp;gt; ::=

    [lamC (a b) (k (closV (lambda (arg-val dyn-k)
                            (interp/k b
                                      (extend-env (bind a arg-val)
                                                  env)
                                      dyn-k))))]&lt;/code&gt;&lt;p&gt;要测试这个修改后的解释器，我们需要用某个初始continuation调用interp/k。这个子程序表示的是无需任何其他计算。自然的选择是恒等函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (interp [expr : ExprC]) : Value
  (interp/k expr mt-env
            (lambda (ans)
              ans)))&lt;/code&gt;&lt;p&gt;为了强调这只是interp/k的顶层接口，interp放弃了环境参数，自动传递空环境给interp/k。如果需要特别确定没有意外地递归使用这个函数，我们可以在其最后插入一个对error的调用，以防止它返回，或者其返回值被使用。&lt;/p&gt;&lt;h2&gt;14.3 生成器&lt;/h2&gt;&lt;p&gt;现在许多编程语言都拥有&lt;b&gt;生成器&lt;/b&gt;（generator）这一概念。生成器类似于函数，可以被调用。区别在于，常规函数总是从头开始执行，生成器从最后一次停止的地方&lt;b&gt;恢复&lt;/b&gt;。当然，这意味着生成器需要“在完成之前退出”的概念。这就是所谓的&lt;b&gt;yield&lt;/b&gt;（让位），即把控制权归还给调用者。&lt;/p&gt;&lt;h2&gt;14.3.1 各种设计&lt;/h2&gt;&lt;p&gt;生成器有许多不同的变体。可以想见，不同之处在于如何进入和退出生成器：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在某些语言中，生成器是一种对象，需要和其他对象一样实例化，恢复其执行是通过调用方法（例如Python中的next）。在其他语言中，生成器则类似于函数，而且重入是通过像函数一样调用。【注释】&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在某些语言中，让位操作——例如Python的yield——只能在生成器的语法主体中使用。在其他语言中，例如Racket，yield是在生成器主体中被绑定的、可调用的值，正由于它是值，它可以被抽象的传递、存储于数据结构中，等等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;在有些语言中，除了普通的函数，其他值也可以用做调用，所有这些值被统称为&lt;b&gt;可调用值&lt;/b&gt;（applicable）。&lt;/blockquote&gt;&lt;p&gt;Python的设计代表了一种极端，生成器是&lt;b&gt;任何包含关键字yield的函数&lt;/b&gt;。此外，Python的yield不能作为参数传递给另一个函数，由该函数代理来执行让位。&lt;/p&gt;&lt;p&gt;还有个关于命名的小问题。在许多支持生成器的语言中，让位指令就是&lt;b&gt;字面上&lt;/b&gt;的yield：要么是关键字（如Python），要么是绑定为可调用值的标识符（如在Racket中）。还有种可能，生成器的用户必须在生成器表达式中指明让位指令的名字。【注释】也就是说，生成器是这样的&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(generator (yield) (from)
           (rec (f (lam (n)
                     (seq
                       (yield n)
                       (f (+ n 1)))))
             (f from)))&lt;/code&gt;&lt;p&gt;但是等价的写法&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(generator (y) (from)
           (rec (f (lam (n)
                     (seq
                       (y n)
                       (f (+ n 1)))))
             (f from)))&lt;/code&gt;&lt;p&gt;如果这个让位指令实际上是值，那么用户也可以这样抽象地使用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(generator (y) (from)
           (rec (f (lam (n)
                     (seq
                       ((yield-helper y) n)
                       (f (+ n 1)))))
             (f from)))&lt;/code&gt;&lt;p&gt;其中yield-helper会去调用让位指令。&lt;/p&gt;&lt;p&gt;实际上还有两个设计上的决定：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;yield是声明还是表达式？在许多语言中，它是表达式，这意味着它有值：在恢复生成器时提供的值。这使得生成器更加灵活，因为生成器的使用者可以使用参数来改变生成器的行为，而不是&lt;b&gt;被迫&lt;/b&gt;使用状态来传达所需的改变。&lt;/li&gt;&lt;li&gt;生成器执行结束时会发生什么？在很多语言中，生成器会产生异常来表示完成。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;奇怪的是，Python在对象中期望用户来确定self或this的名称，但是它没有为yield提供相同的灵活性，因为这是唯一确定哪些函数是生成器的方式！&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.3.2 实现生成器&lt;/h2&gt;&lt;p&gt;要实现生成器，有效的方式是使用我们的CPS宏语言。先来确定这个设计决定的意义。我们用调用来表示生成器：即，要获得来自生成器的下一个值，是通过将其应用于任何必要的参数来完成的。类似的，让位指令也是可调用的值，并且还是表达式。虽然我们已经研究过宏如何自动捕获名称（译注：13.5节），但是简单起见我们还是明确给出让位指令的名称好了。最后，当生成器执行完成时，我们会报错。&lt;/p&gt;&lt;p&gt;生成器如何工作？ 要yield，生成器必须&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;记住它现在执行到哪里，&lt;/li&gt;&lt;li&gt;知道应该返回到调用者的哪里。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而当生成器被调用时，它应该&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;记住它的调用者执行到哪里，&lt;/li&gt;&lt;li&gt;知道它应该返回到其主体内的哪里。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;请注意调用与让位之间的对偶。&lt;/p&gt;&lt;p&gt;你可能猜到了，这些“哪里”就是continuation。&lt;/p&gt;&lt;p&gt;我们来逐步实现生成器，这相当于添加一条cps宏的规则。先写下模式的头部：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-generator-case&amp;gt; ::=  ;CPS宏，生成器子句

    [(_ (generator (yield) (v) b))
     (and (identifier? #&#39;v) (identifier? #&#39;yield))
     &amp;lt;generator-body&amp;gt;]  ;生成器主体&lt;/code&gt;&lt;p&gt;主体第一部分很简单：CPS中的所有代码都需要先读入continuation，而且由于生成器是值，所以这个值要被传给continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;generator-body&amp;gt; ::=  ;生成器主体

    #&#39;(lambda (k)
        (k &amp;lt;generator-value&amp;gt;))  ;生成器的值&lt;/code&gt;&lt;p&gt;下一步要处理生成器的核心了。&lt;/p&gt;&lt;p&gt;回忆一下，生成器是可调用的值。这就是说，它可以被放在函数调用的位置，因此它必须具有与函数相同的“接口”：函数有两个参数，第一个是值，第二个是调用位置的continuation。这个子程序应该做什么？我们刚刚描述过这个。首先，生成器必须记住它的调用者正在执行的地方，这正是调用位置的continuation；“记住”这里最简单的意思是“必须保存在状态中”。然后，生成器应该返回到它之前所在的地方，即它&lt;b&gt;自己&lt;/b&gt;的continuation，这个显然必须被保存过。因此，这里可调用值的核心是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;generator-core&amp;gt; ::=  ;生成器的核心

    (lambda (v dyn-k)
      (begin
        (set! where-to-go dyn-k)
        (resumer v)))&lt;/code&gt;&lt;p&gt;这里，where-to-go记录了调用者的continuation，让位时恢复；resumer是生成器的本地continuation。让我们考虑一下它们的初始值是什么：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;where-to-go没有初始值（因为生成器尚未被调用），所以如果它被调用，需要抛出错误。幸运的是，这个错误永远不会发生，因为第一次进入生成器时会对where-to-go赋值，所以这个错误只是防范实现中出现bug。&lt;/li&gt;&lt;li&gt;最初，生成器的其余部分是整个生成器，所以resumer应该被绑定到b（的CPS）。它的continuation是什么？是整个生成器的continuation，即当生成器结束时该做啥。我们已经讨论过，这里也应该给出错误（区别是，在这种情况下错误确实会发生，如果生成器被要求产生比它配备的更多的值）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;还需要绑定yield。正如我们已经指出的，它对称于生成器的恢复：将本地continuation保存在resumer中，然后通过调用where-to-go返回。&lt;/p&gt;&lt;p&gt;把这些片段放到一起，我们得到：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;generator-value&amp;gt; ::=  ;生成器的值

    (let ([where-to-go (lambda (v) (error &#39;where-to-go &quot;nothing&quot;))])
      (letrec([resumer (lambda (v)
                         ((cps b) (lambda (k)
                                    (error &#39;generator &quot;fell through&quot;))))]
              [yield (lambda (v gen-k)
                       (begin
                         (set! resumer gen-k)
                         (where-to-go v)))])
        &amp;lt;generator-core&amp;gt;))&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么这里使用let和letrec，而不只用let？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;请注意这些代码片段之间的依赖关系。where-to-go不依赖于resumer或yield。yield显然依赖于where-to-go和resumer。但是，为什么resumer和yield相互引用呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;试试不这么做。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;你可能会遗漏的巧妙依赖是，resumer中包含b，生成器的主体，它可能包含对yield的引用。因此，它需要包含退位指令的绑定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;生成器与协程（coroutine）和线程（thread）有什么不同？使用类似的策略来实现协程和线程。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.4 Continuation和堆栈&lt;/h2&gt;&lt;p&gt;虽然看上去不明显，但是CPS转换实际上对程序执行的&lt;b&gt;栈&lt;/b&gt;（译注，调用栈）本质提供了深入的了解。首先要理解的是，continuation实际上就是&lt;b&gt;栈本身&lt;/b&gt;。这可能看起来很奇怪，因为堆栈是底层的机器实现，而continuation看似复杂。那么栈到底是什么呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;栈是还有待完成的计算的记录。continuation也是。&lt;/li&gt;&lt;li&gt;栈传统上被认为是&lt;b&gt;栈帧&lt;/b&gt;（stack &lt;br&gt;frame）的列表。也就是说，每个帧都引用该帧完成后剩余的帧。类似地，每个continuation都是个小程序，其中引用——因此包含——自己的continuation。如果为程序指令选择不同的表示形式，将其与闭包的数据结构表示相结合，我们将得到一种与计算机堆栈基本相同的continuation表示法。&lt;/li&gt;&lt;li&gt;每个栈帧中还存储了函数的参数。continuation的子程序表示法隐式地管理了此项信息，明确地由数据结构（绑定）表示。&lt;/li&gt;&lt;li&gt;栈帧中还有“局部变量”的空间。continuation原则上也是如此，尽管我们使用宏实现本地绑定，因此相当于将一切都还原成函数参数。然而从概念上讲，其中一些是“真实的”函数参数，而另一些是通过宏变成函数参数的局部绑定。&lt;/li&gt;&lt;li&gt;栈引用了堆，但没有内含堆。因此，堆中的变化在不同的栈帧都是可见的。同样地，闭包中引用了贮存，但不内含贮存，所以对贮存的修改在不同闭包中都是可见的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，传统上，栈负责维护词法范围，而我们使用（静态范围的语言中的）闭包自动获得此功能。&lt;/p&gt;&lt;p&gt;现在我们可以研究各种子项的转换，从而解到堆栈的映射。例如，考虑函数应用的转换：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[(_ (f a))
 #&#39;(lambda (k)
     ((cps f) (lambda (fv)
                ((cps a) (lambda (av)
                           (fv av k))))))]&lt;/code&gt;&lt;p&gt;该怎么“读”呢？这样：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我们用k表示函数调用之前的栈。&lt;/li&gt;&lt;li&gt;在对函数位置（&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;）求值时，创建新的栈帧（&lt;code class=&quot;inline&quot;&gt;(lambda (fv) ...)&lt;/code&gt;）。该帧包含一个自由标识符：&lt;code class=&quot;inline&quot;&gt;k&lt;/code&gt;。因此，它的闭包需要记录环境中的这个元素，即栈的其余部分。&lt;/li&gt;&lt;li&gt;栈帧的代码部分表示一旦我们获得了函数的值，剩下的工作：计算参数，执行调用，将结果返回给等待调用结果的栈：k。&lt;/li&gt;&lt;li&gt;对f的求值完成后，对a求值，这也需要创建栈帧：&lt;code class=&quot;inline&quot;&gt;(lambda (av) ...)&lt;/code&gt;。该帧有&lt;b&gt;两个&lt;/b&gt;自由标识符：k和fv。这说明：&lt;br&gt; &lt;/li&gt;&lt;ul&gt;&lt;li&gt;我们不再需要对函数位置求值的栈帧了，但是&lt;/li&gt;&lt;li&gt;我们需要用&lt;b&gt;临时变量&lt;/b&gt;记录函数位置求值的结果，它最好是函数值。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这第二个帧的代码部分代表也是剩下要做的事情：对参数调用函数，在等待调用结果的栈中进行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;条件指令也是同样的推理：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[(_ (cnd tst thn els))
 #&#39;(lambda (k)
     ((cps tst) (lambda (tstv)
                  (if tstv
                      ((cps thn) k)
                      ((cps els) k)))))]&lt;/code&gt;&lt;p&gt;它说的是，要对条件表达式求值，我们先要创建新的栈帧。该帧中包含等待整个条件表达式值的栈。该帧根据条件表达式的值来决定，调用其子表达式之一。在判断了条件的值之后，为了求它的值而创建的帧就不再需要了，因此求值可以在k中继续。&lt;/p&gt;&lt;p&gt;从这个角度出发，我们可以更好的解释生成器的操作。每个生成器都有自己的私有栈，当执行超越其栈底时，我们的实现会报错。被调用时，生成器将表示“剩余程序”的栈的引用存储在where-to-go中，然后恢复自己的栈。在让位时，系统交换堆栈的引用。协程，线程和生成器在概念上都是相似的：它们都是创建“许多小堆栈”的机制，而不仅仅只是单个的全局堆栈。&lt;/p&gt;&lt;h2&gt;14.5 尾调用&lt;/h2&gt;&lt;p&gt;观察上面的栈模式，为当前栈添加帧，执行一些计算，最终总是返回到当前栈。特别要注意的是，在函数调用中，我们需要栈的空间来对函数求值，然后是对参数求值，但是一旦所有这些求值完成，我们就使用函数调用开始之前的栈来恢复计算。换一种说法，&lt;b&gt;函数调用本身不需要消耗栈空间&lt;/b&gt;：我们只需要空间来计算参数。&lt;/p&gt;&lt;p&gt;但是，并非所有的语言都遵守或尊重这一属性。在这样做的语言中，程序员可以使用&lt;b&gt;递归&lt;/b&gt;来获得&lt;b&gt;迭代行为&lt;/b&gt;：即，一系列函数调用不会比没有函数调用的情况下消耗更多空间。这消除了创建特殊循环结构的需要；实际上，循环可以简单地表示为语法糖。&lt;/p&gt;&lt;p&gt;当然，这个属性不适用于一般情况。如果调用f来计算调用g所需的参数，那么对f的调用相对于围绕g的上下文仍然会占用空间。因此，我们需要说明表达式之间的关系：一个表达式的处于另一表达式的&lt;b&gt;尾位置&lt;/b&gt;，如果对它的求值不需要另一表达式（求值）之外的额外空间。在我们的CPS宏中，所有使用k作为其continuation的表达式——例如，在所有子表达式求值完成之后的函数调用，或者条件表达式的then和else分支——都在其外层表达式的尾位置（也许递归地还在其外层的尾位置）。反之，所有必须创建新栈帧的表达式都不在尾位置。&lt;/p&gt;&lt;p&gt;有些语言对&lt;b&gt;尾递归&lt;/b&gt;——某个函数在其函数体的尾位置调用自己——有特殊的支持。这显然是有用的，因为它使得递归得以有效地实现循环。然而，它破坏了不能被挤入单个递归函数的“循环”。例如，当实现状态机时，最方便的方法是用一组函数，每个函数代表一个状态，然后通过（尾）调用表示状态转换。把它们变成单一的递归函数会非常繁琐（并且失去了意义）。但是，如果一种语言能够识别尾调用，它就可以（和函数内调用自己一样）优化这些跨函数的调用。&lt;/p&gt;&lt;p&gt;Racket的实现保证尾调用不会分配额外的栈空间。有人把这称为“尾调用的优化”，但这个术语是误导性的：优化是可选性的，而某种语言是否承诺正确实现尾调用是种&lt;b&gt;语义&lt;/b&gt;特性。程序员需要了解语言的行为方式，因为这会影响他们的编程方式。&lt;/p&gt;&lt;p&gt;由于这个特性，观察CPS转换之后的程序的有趣之处：其中所有的函数调用本身都是尾调用的！从本章开头的read-number/suspend例子开始，你就可以看到这点：所有待处理的计算都被放入了continuation参数。假设程序可能在任何调用中终止，等同于根本不使用任何栈空间（因为栈将会被清除）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;程序如何在没有栈的情况下运行？&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.6 语言特性中支持continuation&lt;/h2&gt;&lt;p&gt;了解connection和栈之间的这种关联之后，现在可以回过头讨论函数的处理：我们忽略了在&lt;b&gt;创建&lt;/b&gt;闭包时的continuation，而只使用了在闭包调用时的continuation。当然，这对应于普通的函数行为。但现在我们可以问，如果我们用创建时的connection呢？这等同于，在“程序”创建时保存对栈的（副本）的引用，然后在调用函数时忽略动态的求值，返回到函数创建点。&lt;/p&gt;&lt;p&gt;实际上，我想说的是，让lambda保持不变，而给我们的语言提供新的、对于与这种行为的指令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-let/cc-case&amp;gt; ::=  ;cps宏

    [(_ (let/cc kont b))
     (identifier? #&#39;kont)
     #&#39;(lambda (k)
         (let ([kont (lambda (v dyn-k)
                       (k v))])
           ((cps b) k)))]&lt;/code&gt;&lt;p&gt;这说的是，两种情况下，控制都将返回到直接包含let/cc的表达式：要么通过正常返回（因为主体b的continuation是k），要么通过更有意思的方式，调用continuation，这会丢弃动态的continuation&lt;br&gt; dyn/k，简单地忽略它直接返回到k。&lt;/p&gt;&lt;p&gt;最简单的测试是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (let/cc esc 3)))
      3)&lt;/code&gt;&lt;p&gt;这证实了，如果我们从不使用continuation，那么对主体的求值就好像let/cc根本不存在一样（因为&lt;code class=&quot;inline&quot;&gt;((cps b) k)&lt;/code&gt;）。如果我们使用它，传给continuation的值返回到创建点：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (let/cc esc (esc 3))))
      3)&lt;/code&gt;&lt;p&gt;当然，这个例子揭露的还不够，不过考虑这个：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (+ 1 (let/cc esc (esc 3)))))
      4)&lt;/code&gt;&lt;p&gt;这证实了加法会实际执行。那么动态的continuation呢？&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (let/cc esc (+ 2 (esc 3)))))
      3)&lt;/code&gt;&lt;p&gt;这表明加2不会发生，即动态continuation确实被忽略了。为了确保创建位置的continuation被保留，请观察：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (+ 1 (let/cc esc (+ 2 (esc 3))))))
      4)&lt;/code&gt;&lt;p&gt;从这些例子中，你可能已经注意到熟悉的模式：esc在这里的表现类似于异常。也就是说，如果你不抛出异常（在这里，调用continuation）它就好像不在那里，但是如果你抛出异常，所有未完成的中间计算都将被忽略，计算返回到异常创建点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;使用let/cc和宏实现异常的抛出和捕获机制。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;然而，这些例子只用到了最浅层的（let/cc的）能力，因为这里调用点处的continuation总是创建点处的continuation的扩展：即后者在栈中比前者更早。然而，没有任何东西要求k和dyn-k之间存在相关。它们实际上可以是&lt;b&gt;无&lt;/b&gt;关的，这意味着它们可以是两个独立的栈，所以我们可以用它轻松地实现栈切换功能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为了真正与lambda类似，我们应该引入如下展开的构造，称其为cont-lambda好了：&lt;br&gt;[(_ (cont-lambda (a) b))&lt;br&gt; (identifier? #&#39;a)&lt;br&gt; #&#39;(lambda (k)&lt;br&gt;     (k (lambda (a dyn-k)&lt;br&gt;          ((cps b) k))))]&lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;为什么我们没有这么做呢？从两方面考虑，静态类型的角度，还有，我们如何使用这个构造来构建上述类似于异常的行为。&lt;/code&gt;&lt;h2&gt;14.6.1 用语言表达&lt;/h2&gt;&lt;p&gt;用我们的小玩具语言编写程序很快会变得令人沮丧。幸运的是，Racket已经提供了叫做call/cc的构造，用来操作continuation。call/cc是单参数的函数，其参数本身又是单参数的函数，Racket会将当前continuation传给它进行调用，而当前continuation也是单参数的子程序。能理解吗？&lt;/p&gt;&lt;p&gt;幸运的是，我们可以用call/cc轻松地将let/cc实现为宏，然后用它来编写程序。这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax let/cc
  (syntax-rules ()
    [(let/cc k b)
     (call/cc (lambda (k) b))]))&lt;/code&gt;&lt;p&gt;之前的所有测试仍然通过：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (let/cc esc 3) 3)
(test (let/cc esc (esc 3)) 3)
(test (+ 1 (let/cc esc (esc 3))) 4)
(test (let/cc esc (+ 2 (esc 3))) 3)
(test (+ 1 (let/cc esc (+ 2 (esc 3)))) 4)&lt;/code&gt;&lt;h2&gt;14.6.2 定义生成器&lt;/h2&gt;&lt;p&gt;现在我们可以创建有趣的抽象了。比如，让我们来编写生成器。之前我们需要将表达式CPS转化，并传递continuation，现在都可以通过call/cc自动完成。因此，当需要目前的continuation时，我们都可以简单地召唤它而无需改变程序。所以，额外的&lt;code class=&quot;inline&quot;&gt;...-k&lt;/code&gt;参数都会消失，在同一个地方可以用let/cc捕获相同的continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax (generator e)
  (syntax-case e ()
    [(generator (yield) (v) b)
     #&#39;(let ([where-to-go (lambda (v) (error &#39;where-to-go &quot;nothing&quot;))])
         (letrec ([resumer (lambda (v)
                             (begin b
                                    (error &#39;generator &quot;fell through&quot;)))]
                  [yield (lambda (v)
                           (let/cc gen-k
                             (begin
                               (set! resumer gen-k)
                               (where-to-go v))))])
           (lambda (v)
             (let/cc dyn-k
               (begin
                 (set! where-to-go dyn-k)
                 (resumer v))))))]))&lt;/code&gt;&lt;p&gt;请观察这段代码和去语法糖到CPS代码实现的生成器之间的密切相似性。具体而言，我们去掉了额外的continuation参数，用let/cc调用替换它们，这些调用能捕获完全相同的continuation。其余的代码基本不变。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如果我们将（两处）let/cc和赋值移到begin内的第一个语句，会发生什么呢？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;例如，我们可以编写从初始值向上迭代的生成器：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define g1 (generator (yield) (v)
                      (letrec ([loop (lambda (n)
                                       (begin
                                         (yield n)
                                         (loop (+ n 1))))])
                        (loop v))))&lt;/code&gt;&lt;p&gt;其行为是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (g1 10)
10
&amp;gt; (g1 10)
11
&amp;gt; (g1 0)
12
&amp;gt;&lt;/code&gt;&lt;p&gt;因为（生成器）主体只引用了初始值，调用yield所返回的值被忽略，所以在后续调用传入的值不起作用。相反，考虑这个生成器：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define g2 (generator (yield) (v)
                      (letrec ([loop (lambda (n)
                                       (loop (+ (yield n) n)))])
                        (loop v))))&lt;/code&gt;&lt;p&gt;在第一次调用时，它返回输入的值。在此后的调用中，该值被加到后续调用生成器所提供的值上。换一种说法，该发生器累加它的所有输入值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (g2 10)
10
&amp;gt; (g2 15)
25
&amp;gt; (g2 5)
30&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;现在我们已经使用call/cc和let/cc实现了生成器，请用它们实现协程和线程。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.6.3 定义线程&lt;/h2&gt;&lt;p&gt;完成生成器之后，我们再做个类似的功能：线程。具体来说，我们希望能够编写如下的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define d display) ;;有用的简写
 
(scheduler-loop-0
 (list
  (thread-0 (y) (d &quot;t1-1  &quot;) (y) (d &quot;t1-2  &quot;) (y) (d &quot;t1-3 &quot;))
  (thread-0 (y) (d &quot;t2-1  &quot;) (y) (d &quot;t2-2  &quot;) (y) (d &quot;t2-3 &quot;))
  (thread-0 (y) (d &quot;t3-1  &quot;) (y) (d &quot;t3-2  &quot;) (y) (d &quot;t3-3 &quot;))))&lt;/code&gt;&lt;p&gt;输出应该是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3&lt;/code&gt;&lt;p&gt;我们来创建必要的组件实现此功能。&lt;/p&gt;&lt;p&gt;我们先来定义线程调度器。它读入“线程”的列表，我们假设线程的接口读入continuation，并最终将控制返回给此continuation。每当调度器重新激活某个线程时，都会向其提供continuation。调度器可以用简单的循环（round-robin）方式选择线程，也可以使用更复杂的算法；这里我们不关心如何选择的细节。&lt;/p&gt;&lt;p&gt;类似于生成器，我们假定让位由调用用户命名的子程序完成，例如这里的y。我们也可以使用名称捕获（译注，13.5节）自动绑定其名称，比如yield。&lt;/p&gt;&lt;p&gt;这里的要点的是，请注意让位由线程系统的用户手动控制。这就是所谓的&lt;b&gt;协作式多任务处理&lt;/b&gt;（cooperative multitasking）。相反，我们可以选择通过生成定时器或其他内在机制自动触发让位，而无需用户许可。这被称为&lt;b&gt;抢占式多任务处理&lt;/b&gt;（preemptive multitasking）（因为系统从线程中“抢占”——也就是夺取了——控制权）。虽然这种区别对于构建系统来说是非常重要的，但从设置continuation的角度来看，这并不重要。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;在完成协作式多任务之后，实现抢占式多任务。哪里需要修改？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;陈述了这些限制，我们可以着手编写调度器了。它读入线程的列表，只要还有剩下的线程就继续执行。每次，它将线程应用于continuation，这个continuation表示返回到调度器并继续下一个线程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (scheduler-loop-0 threads)
  (cond
    [(empty? threads) &#39;done]
    [(cons? threads)
     (begin
       (let/cc after-thread ((first threads) after-thread))
       (scheduler-loop-0 (append (rest threads)
                                 (list (first threads)))))]))&lt;/code&gt;&lt;p&gt;当接收线程调用绑定到after-thread的continuation时，控制返回到begin序列中第一个语句的结尾。因此，提供给continuation的值会被忽略（所以可以用任何值；我们选择用&lt;code class=&quot;inline&quot;&gt;&#39;dummy&lt;/code&gt;，以便其莫名出现时方便地发现问题）。将最近调用的线程附加到线程列表的末尾（即，将该列表视为循环队列）之后，控制将继续调度器循环的其余部分。&lt;/p&gt;&lt;p&gt;接下来我们定义线程。我们说过，它是单参数的函数，参数就是调度器的continuation。由于线程需要能&lt;b&gt;恢复&lt;/b&gt;，也就是从停止的地方继续，所以它必须存储上次执行到的位置：我们将其称为thread-resumer。起初thread-resumer是整个线程体，但在后续的实例中，它将是continuation：调用yield的continuation。于是，我们得到如下的框架：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax thread-0
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...))])
       (lambda (sched-k)
         (thread-resumer &#39;dummy)))]))&lt;/code&gt;&lt;p&gt;还剩下yielder没实现。它是无参数的函数，将线程的continuation存入thread-resumer，然后用&lt;code class=&quot;inline&quot;&gt;&#39;dummy&lt;/code&gt;调用调度器的continuation。不过，调用&lt;b&gt;哪个&lt;/b&gt;调度器的continuation呢？不是线程初始化时传入的那个，而是最新的那个。因此，我们必须以某种方式将sched-k中的值“thread”（译注，传递）给yielder。有很多种方式可以实现，但最简单的，也许是最暴力的方式是，简单地为每个线程恢复重建yielder，总是包含sched-k的最新值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax thread-0
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...))]
              [yielder (lambda () (error &#39;yielder &quot;nothing here&quot;))])
       (lambda (sched-k)
         (begin
           (set! yielder
                 (lambda ()
                   (let/cc thread-k
                     (begin
                       (set! thread-resumer thread-k)
                       (sched-k &#39;dummy)))))
           (thread-resumer &#39;tres))))]))&lt;/code&gt;&lt;p&gt;将这些放到一起运行，我们得到：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3&lt;/code&gt;&lt;p&gt;嘿，这就是我们想要的！但是运行继续：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 t1-3 t2-3 t3-3&lt;/code&gt;&lt;p&gt;嗯。&lt;/p&gt;&lt;p&gt;怎么回事？恩，我们并没有说明当线程运行结束时需要怎么处理。实际上，控制只是返回到线程调度器，调度器将线程追加到队列的末尾，然后，当线程再次到达队列的头部时，控制从之前存储的那个continuation中恢复：对应于打印第三个值。打印，控制返回，线程被追加到队尾……无限循环。&lt;/p&gt;&lt;p&gt;显然，在线程终止时，我们需要通知线程调度器，这样调度器可以将其从线程队列中移除。我们创建简单的数据类型来表示该信号：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type ThreadStatus
  [Tsuspended]
  [Tdone])&lt;/code&gt;&lt;p&gt;（当然，在真实的系统中，这些状态消息也可以带上和计算相关的值。）那么我们必须修改调度器，实际检查和使用这些值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (scheduler-loop-1 threads)
  (cond
    [(empty? threads) &#39;done]
    [(cons? threads)
     (type-case ThreadStatus (let/cc after-thread ((first threads) after-thread))
       [Tsuspended () (scheduler-loop-1 (append (rest threads)
                                                (list (first threads))))]
       [Tdone () (scheduler-loop-1 (rest threads))])]))&lt;/code&gt;&lt;p&gt;线程的表示中有两个地方需要修改：中间返回的时候它必须传Tsuspended给调度器的continuation，终止时传Tdone。哪里是终止呢？在执行完线程体代码&lt;code class=&quot;inline&quot;&gt;b ...&lt;/code&gt;之后。最后，请注意和退位一样，终止程序必须也使用最新的调度器continuation。因而：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax thread-1
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...
                                       (finisher)))]
              [finisher (lambda () (error &#39;finisher &quot;nothing here&quot;))]
              [yielder (lambda () (error &#39;yielder &quot;nothing here&quot;))])
       (lambda (sched-k)
         (begin
           (set! finisher
                 (lambda ()
                   (let/cc thread-k
                     (sched-k (Tdone)))))
           (set! yielder
                 (lambda ()
                         (let/cc thread-k
                           (begin
                             (set! thread-resumer thread-k)
                             (sched-k (Tsuspended))))))
           (thread-resumer &#39;tres))))]))&lt;/code&gt;&lt;p&gt;用scheduler-loop-1和thread-1替换scheduler-loop-0和thread-0，重新运行前面的示例程序，我们就得到了想要的输出。&lt;/p&gt;&lt;h2&gt;14.6.4 更好的Web编程指令&lt;/h2&gt;&lt;p&gt;最后，我们回过头看看read-number：请注意，如果运行服务器程序的语言有call/cc，我们就不必CPS整个程序，而是可以简单地捕获当前continuation，将其保存在哈希表中，从而使程序结构保持不变。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2017-12-15-32037390</guid>
<pubDate>Fri, 15 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译13】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-08-31817926.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Programming Languages: Application and Interpretation【译13】&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31817926&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;审校： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://www.gitbook.com/book/lotuc/plai-cn/details&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;13 语言中支持去语法糖&lt;/h2&gt;&lt;p&gt;关于去语法糖（desugaring），之前很多讨论都谈到、用到了，但是我们目前的去语法糖机制是薄弱的。实际上我们用两种不同的方式来使用去语法糖。一方面，我们用它来&lt;b&gt;缩小&lt;/b&gt;语言：输入是一个大语言，去语法糖后得到其核心。另一方面，我们也用它来&lt;b&gt;扩展&lt;/b&gt;语言：给定现有语言，为其添加新的功能。这表明，去语法糖是非常有用的功能。它是如此之有用，我们该思考一下如下两个问题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我们创建语言的目的是简化常见任务的创建，那么，设计一种支持去语法糖的语言，它会长什么样子呢？请注意，这里的“样子”不仅仅指语法，也包括语言的行为特性。&lt;/li&gt;&lt;li&gt;通用语言常常被用作去语法糖的目标，那为什么他们不&lt;b&gt;内建&lt;/b&gt;去语法糖的能力呢？比如说，扩展某个基本语言，添加上一个问题的答案所描述的语言。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本章我们将通过研究Racket提供的解决方案同时探索这两个问题。&lt;/p&gt;&lt;h2&gt;13.1 第一个例子&lt;/h2&gt;&lt;blockquote&gt;DrRacket有个非常有用的工具叫做Macro Stepper（宏步进器），它能逐步逐步地显示程序的展开。你应该对本章中的所有例子尝试Macro Stepper。不过现在，你应该用#lang plai而不是#lang plai-typed来运行。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;回忆一下，前文我们添加&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;时，是将其当作&lt;code class=&quot;inline&quot;&gt;lambda&lt;/code&gt;的语法糖的。它的模式是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let (var val) body)&lt;/code&gt;&lt;p&gt;被转换为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((lambda (var) body) val)&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如果这听起来不太熟悉，那么现在是时候回忆一下它是怎么运作的了。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;描述这个转换最简单的方法就是直接把它写出来，比如：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let (var val) body)
-&amp;gt;
((lambda (var) body) val)&lt;/code&gt;&lt;p&gt;事实上，这差不多正是Racket语法允许你做的。&lt;/p&gt;&lt;blockquote&gt;我们将其命名为&lt;code class=&quot;inline&quot;&gt;my-let&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;，因为后者在Racket中已经有定义了。&lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax my-let-1  ;定义语法
  (syntax-rules ()       ;语法规则
    [(my-let-1 (var val) body)
     ((lambda (var) body) val)]))&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;syntax-rules&lt;/code&gt;告诉Racket，只要看到的某个表达式在左括号之后跟的是&lt;code class=&quot;inline&quot;&gt;my-let-1&lt;/code&gt;，就应该检查它是否遵循模式&lt;code class=&quot;inline&quot;&gt;(my-let-1 (var val) body)&lt;/code&gt;。这里&lt;code class=&quot;inline&quot;&gt;var&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;val&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;body&lt;/code&gt;是&lt;b&gt;语法变量&lt;/b&gt;：它们是代表代码的变量，可以匹配该位置的任意表达式。如果表达式和模式匹配，那么语法变量就绑定为对应的表达式，并且在右边（的表达式中）可用。&lt;/p&gt;&lt;blockquote&gt;您可能已经注意到一些额外的语法，如&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。 我们稍后再解释。&lt;/blockquote&gt;&lt;p&gt;右边（的表达式）——在这里是&lt;code class=&quot;inline&quot;&gt;((lambda (var) body) val)&lt;/code&gt;——就是最后的输出。每个语法变量都被替换（注意我们的老朋友，替换）其对应的输入部分。这个替换过程非常简单，不会做过多的处理。因此，如果我们尝试这么用&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(my-let-1 (3 4) 5)&lt;/code&gt;&lt;p&gt;第一步Racket不会抱怨3出现在标识符的位置；相反，它会照常处理，去语法糖得&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((lambda (3) 5) 4)&lt;/code&gt;&lt;p&gt;下一步会产生错误：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;lambda: expected either &amp;lt;id&amp;gt; or `[&amp;lt;id&amp;gt; : &amp;lt;type&amp;gt;]&#39;
  for function argument in: 3&lt;/code&gt;&lt;p&gt;这就表明，去语法糖的过程在其功能上直截了当：它不会尝试猜测啥或者做啥聪明事，就是简单的替换重写而已。其输出是表达式，这个表达式也可以被进一步去语法糖。&lt;/p&gt;&lt;p&gt;前文中提到过，这种简单的表达式重写通常使用术语&lt;b&gt;宏&lt;/b&gt;（macro）称呼。传统上，这种类型的去语法糖被称为&lt;b&gt;宏展开&lt;/b&gt;（macro expansion），不过这个术语有误导性，因为去语法糖后的输出可以比输入更小（通常还是更大啦）。&lt;/p&gt;&lt;p&gt;当然，在Racket中，&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;可以绑定多个标识符，而不仅仅是一个。非正式的写下这种语法的描述的话，比如在黑板上，我们可能会这样写，&lt;code class=&quot;inline&quot;&gt;(let ([var val] ...) body) -&amp;gt; ((lambda (var ...) body) val ...)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;...&lt;/code&gt;表示“零或更多个” ，意思是，输出中的&lt;code class=&quot;inline&quot;&gt;var ...&lt;/code&gt;要对应输入中的多个&lt;code class=&quot;inline&quot;&gt;var&lt;/code&gt;。同样，描述它的Racekt语法长的差不多就是这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax my-let-2
  (syntax-rules ()
    [(my-let-2 ([var val] ...) body)
     ((lambda (var ...) body) val ...)]))&lt;/code&gt;&lt;p&gt;请注意&lt;code class=&quot;inline&quot;&gt;...&lt;/code&gt;符号的能力：输入中“对”的序列在输出中变成序列对了；换句话说，Racket将输入序列“解开”了。与之相对，同样的符号也可以用来组合序列。&lt;/p&gt;&lt;h2&gt;13.2 用函数实现语法变换器&lt;/h2&gt;&lt;p&gt;之前我们看到，my-let-1并不会试图确保标识符位置中的语法是真正的（即语法上的）标识符。用syntax-rules机制我们没法弥补这一点，不过使用更强大的机制，称为syntax-case，就可以做到。由于syntax-case还有很多其他有用的功能，我们分步来介绍它。&lt;/p&gt;&lt;p&gt;首先要理解的是，宏实际上是一种&lt;b&gt;函数&lt;/b&gt;。但是，它并不是从常见的运行时值到（其他）运行时值的函数，而是&lt;b&gt;从语法到语法&lt;/b&gt;的函数。这种函数执行的目的是&lt;b&gt;创建要被执行的程序&lt;/b&gt;。注意这里我们说的是&lt;b&gt;要被&lt;/b&gt;执行的程序：程序的实际执行可能会晚得多（甚至根本不执行）。看看去语法糖的过程，这点就很清楚了，很显然它是（一种）语法到（另一种）语法的函数。两个方面可能导致混淆：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;syntax-rules&lt;/code&gt;的表示中并没有明确的参数名或者函数头部，可能没有明确表明这是一个转换函数（不过重写规则的格式有暗示这个事实）。&lt;/li&gt;&lt;li&gt;去语法糖指的是，有个（完整的）函数完成了整个过程。这里，我们实际写的是一系列小函数，每个函数处理一种新的语法结构（比如my-let-1），这些小函数被某个看不见的函数组合起来，完成整个重写过程。（比如说，我们并没有说明，某个宏展开后的输出是否还会进一步被展开——不过简单试一下就知道，事实确实如此。）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;编写一个或多个宏，以确定宏的输出会被进一步展开。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;还有个微妙之处。宏的外观和Racket代码非常类似，并没有指明它“生活在另一个世界”。想象宏定义使用的是完全不同的语言——这种语言只处理语法——写就很有助于我们建立抽象。然而，这种简化并不成立。现实中，程序变换器——也被称为&lt;b&gt;编译器&lt;/b&gt;（compiler）——也是完整的程序，它们也需要普通程序所需要的全部功能。也就是说我们还需要创立一种平行语言，专门处理程序。这是浪费和毫无意义的；因此，Racket自身就支持语法转换所需的全部功能。&lt;/p&gt;&lt;p&gt;背景说完了，接下来开始介绍&lt;code class=&quot;inline&quot;&gt;syntax-case&lt;/code&gt;。首先我们用它重写my-let-1（重写时使用名字my-let-3）。第一步还是先写定义的头部；注意到参数被明确写出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;sc-macro-eg&amp;gt; ::=  ;syntax-case宏，示例

    (define-syntax (my-let-3 x)
      &amp;lt;sc-macro-eg-body&amp;gt;)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;被绑定到整个&lt;code class=&quot;inline&quot;&gt;(my-let-3 ...)&lt;/code&gt;表达式&lt;/p&gt;&lt;p&gt;你可能想到了，&lt;code class=&quot;inline&quot;&gt;define-syntax&lt;/code&gt;只是告诉Racket你要定义新的宏。它不会指定你想要实现的方式，你可以自由地使用任何方便的机制。之前我们用了&lt;code class=&quot;inline&quot;&gt;syntax-rules&lt;/code&gt;；现在我们要用&lt;code class=&quot;inline&quot;&gt;syntax-case&lt;/code&gt;。对于&lt;code class=&quot;inline&quot;&gt;syntax-case&lt;/code&gt;，它需要显式的被告知要进行模式匹配的表达式：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;sc-macro-eg-body&amp;gt; ::=

    (syntax-case x ()
      &amp;lt;sc-macro-eg-rule&amp;gt;)&lt;/code&gt;&lt;p&gt;现在可以写我们想要表达的重写规则了。之前的重写规则有两个部分：输入结构和对应的输出。这里也一样。前者（输入匹配）和以前一样，但后者（输出）略有不同：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;sc-macro-eg-rule&amp;gt; ::=

    [(my-let-3 (var val) body)
     #&#39;((lambda (var) body) val)]&lt;/code&gt;&lt;p&gt;关键是多出了几个字符：&lt;code class=&quot;inline&quot;&gt;#’&lt;/code&gt;。让我们来看看这是什么。&lt;/p&gt;&lt;p&gt;在&lt;code class=&quot;inline&quot;&gt;syntax-rules&lt;/code&gt;中，输出部分就指定输出的结构。与之不同，&lt;code class=&quot;inline&quot;&gt;syntax-case&lt;/code&gt;揭示了转换过程函数的本质，因此其输出部分实际上是任意表达式，该表达式可以执行任何它想要进行的计算。该表达式的求值结果应该是语法。&lt;/p&gt;&lt;p&gt;语法其实是个数据类型。和其他数据类型一样，它有自己的构造规则。具体来说，我们通过写&lt;code class=&quot;inline&quot;&gt;#’&lt;/code&gt;来构造语法值；之后的那个s-expression被当作语法值。（顺便提一句，上面宏定义中的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;绑定的也是这种数据类型。）&lt;/p&gt;&lt;p&gt;语法构造器&lt;code class=&quot;inline&quot;&gt;#’&lt;/code&gt;有种特殊属性。在宏的输出部分中，所有输入中出现的语法变量都被自动绑定并替换。因此，比方说，当展开函数在输出中遇到var时，它会将var替换为相应的输入表达式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;在上述宏定义中去掉&lt;code class=&quot;inline&quot;&gt;#’&lt;/code&gt;试试看。后果如何？&lt;/blockquote&gt;&lt;p&gt;到目前为止，syntax-case似乎只是更为复杂的syntax-rules：唯一稍微好些的地方是，它更清楚地描述了展开过程的函数本质，同时明确了输出的类型，但其他方面则更加笨拙。但是，我们将会看到，它还提供了强大的功能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;事实上，syntax-rules可以被表述为基于syntax-case的&lt;b&gt;宏&lt;/b&gt;。请定义这个宏。&lt;/blockquote&gt;&lt;h2&gt;13.3 防护装置&lt;/h2&gt;&lt;p&gt;现在我们可以回过来考虑到最初引致syntax-case的问题：确保my-let-3的绑定位置在语法上是标识符。为此，您需要知道syntax-case的一个新特性：每一条重写规则可以包含两个部分（如同前面的例子），也可以包含三个部分。如果有三个部分，&lt;b&gt;中间&lt;/b&gt;那个被视为&lt;b&gt;防护装置&lt;/b&gt;（guard）:它是一个判断，仅当其计算值为真时，展开才会进行，否则就报告语法错误。在这个例子中，有用的判断函数是&lt;code class=&quot;inline&quot;&gt;identifier?&lt;/code&gt;，它能判定某个语法对象是否是标识符（即变量）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;写出防护装置，并写出包含防护（装置）的（重写）规则。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;希望你发现了其中的微妙之处：&lt;code class=&quot;inline&quot;&gt;identifier?&lt;/code&gt;的参数是语法类型的。要传给它的是绑定到var的实际语法片段。回想一下，var是在语法空间中绑定的，而&lt;code class=&quot;inline&quot;&gt;#’&lt;/code&gt;会替换其中的绑定变量。因此，这里防护装置的正确写法是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(identifier? #&#39;var)&lt;/code&gt;&lt;p&gt;有了这些信息，我们现在可以写出整个规则：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;sc-macro-eg-guarded-rule&amp;gt; ::=

    [(my-let-3 (var val) body)
     (identifier? #&#39;var)
     #&#39;((lambda (var) body) val)]&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;现在有了带防护的规则定义，尝试使用宏，在绑定位置使用非标识符，看看会发生什么。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;13.4 Or：简单但是包含很多特性的宏&lt;/h2&gt;&lt;p&gt;考虑&lt;code class=&quot;inline&quot;&gt;or&lt;/code&gt;，它实现或操作。使用前缀语法的话，自然的做法是允许&lt;code class=&quot;inline&quot;&gt;or&lt;/code&gt;有任意数目的子项。我们把&lt;code class=&quot;inline&quot;&gt;or&lt;/code&gt;展开为嵌套的条件（表达式），以此判断表达式的真假。&lt;/p&gt;&lt;h2&gt;13.4.1 第一次尝试&lt;/h2&gt;&lt;p&gt;试试这样的or：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax (my-or-1 x)
  (syntax-case x ()
    [(my-or-1 e0 e1 ...)
     #&#39;(if e0
           e0
           (my-or-1 e1 ...))]))&lt;/code&gt;&lt;p&gt;它说，我们可以提供任何数量的子项（待会儿再解释这点）。（宏）展开将其重写为条件表达式，其中的条件是第一个子项；如果该项为真值，就返回这个值（待会再讨论这点！），否则就返回其余项的或。&lt;/p&gt;&lt;p&gt;我们来试一个简单的例子。这应该计算为真，但是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (my-or-1 #f #t)
my-or-1: bad syntax in: (my-or-1)&lt;/code&gt;&lt;p&gt;发生了什么？这个表达式变成了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if #f
    #f
    (my-or-1 #t))&lt;/code&gt;&lt;p&gt;继续展开&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if #f
    #f
    (if #t
        #t
        (my-or-1)))&lt;/code&gt;&lt;p&gt;对此我们没有定义。这是因为，模式&lt;code class=&quot;inline&quot;&gt;e0 e1 ...&lt;/code&gt;表示&lt;b&gt;一个或更多&lt;/b&gt;子项，但是我们忽略了没有子项的情况。&lt;/p&gt;&lt;p&gt;没有子项时&lt;b&gt;应该&lt;/b&gt;怎么办？或运算的单位元是假值。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么正确的默认值是&lt;code class=&quot;inline&quot;&gt;#f&lt;/code&gt;？&lt;/blockquote&gt;&lt;p&gt;我们可以通过加上这条规则，展示不止一条规则的宏。宏的规则是顺序匹配的，所以我们必须把最具体的规则放在最前面，以免它们被更一般的规则覆盖（尽管在这个例子中，两条规则并不重叠）。改进后的宏是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax (my-or-2 x)
  (syntax-case x ()
    [(my-or-2)
     #&#39;#f]
    [(my-or-2 e0 e1 ...)
     #&#39;(if e0
           e0
           (my-or-2 e1 ...))]))&lt;/code&gt;&lt;p&gt;现在宏可以和预期一样展开了。虽然没有必要，但是我们加上一条规则，处理只有一个子项的情况：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax (my-or-3 x)
  (syntax-case x ()
    [(my-or-3)
     #&#39;#f]
    [(my-or-3 e)
     #&#39;e]
    [(my-or-3 e0 e1 ...)
     #&#39;(if e0
           e0
           (my-or-3 e1 ...))]))&lt;/code&gt;&lt;p&gt;这使展开的输出更加简约，对后文中我们的讨论是有帮助的。&lt;/p&gt;&lt;blockquote&gt;注意到在这个版本的宏中，规则&lt;b&gt;不&lt;/b&gt;再是互不重叠的了：第三条规则（一个或多个子项）包含了第二条（一个子项）。因此，第二条规则与第三条不能互换，这是至关重要的。&lt;/blockquote&gt;&lt;h2&gt;13.4.2 防护装置的求值&lt;/h2&gt;&lt;p&gt;之前说这个宏的展开符合我们的预期，是吧？试试这个例子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([init #f])
  (my-or-3 (begin (set! init (not init))
                  init)
           #f))&lt;/code&gt;&lt;p&gt;请注意，or返回的是第一个“真值”的值，以便程序员在进一步的计算中使用它。因此，这个例子返回init的值。我们期望它是什么？因为我们已经翻转了init的价值，自然而然的，我们期望它返回&lt;code class=&quot;inline&quot;&gt;#t&lt;/code&gt;。但是计算得到的是&lt;code class=&quot;inline&quot;&gt;#f&lt;/code&gt;！&lt;/p&gt;&lt;blockquote&gt;这里的问题不在&lt;code class=&quot;inline&quot;&gt;set!&lt;/code&gt;。比如说，如果我们在这里不放赋值，而是放上打印输出，那么打印输出就会发生两次。&lt;/blockquote&gt;&lt;p&gt;要理解为何如此，我们必须检查展开后的代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([init #f])
  (if (begin (set! init (not init))
             init)
      (begin (set! init (not init))
             init)
      #f))&lt;/code&gt;&lt;p&gt;啊哈！因为我们把输出模式写成了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#&#39;(if e0
      e0
      ...)&lt;/code&gt;&lt;p&gt;当我们第一次写下它时，看起来完全没有问题，而这正表明了编写宏（或，其他的程序转换系统）时的一个非常重要的原则：&lt;b&gt;不要复制代码&lt;/b&gt;！在我们的设定中，语法变量永远不应被重复；如果你需要重复某个语法变量，以至于它所代表的代码会被多次执行，请确保已经考虑到了这么做的后果。或者，如果只需要该表达式的&lt;b&gt;值&lt;/b&gt;，那么绑定一下，接下来使用绑定标识符的名字就好。示例如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax (my-or-4 x)
  (syntax-case x ()
    [(my-or-4)
     #&#39;#f]
    [(my-or-4 e)
     #&#39;e]
    [(my-or-4 e0 e1 ...)
     #&#39;(let ([v e0])
         (if v
             v
             (my-or-4 e1 ...)))]))&lt;/code&gt;&lt;p&gt;这个引入绑定的模式会导致潜在的新问题：你可能会对不必要的表达式求值。事实上，它还会导致第二个、更微妙的问题：即使该表达式需要被求值，你可能在错误的上下文中对其求值了！因此，你必须仔细推敲表达式&lt;b&gt;是否&lt;/b&gt;要被求值，如果是的话，只在正确的地方求一次值，然后存贮其值以供后续使用。&lt;/p&gt;&lt;p&gt;用&lt;code class=&quot;inline&quot;&gt;my-or-4&lt;/code&gt;重复之前包含&lt;code class=&quot;inline&quot;&gt;set!&lt;/code&gt;的例子，结果是&lt;code class=&quot;inline&quot;&gt;#t&lt;/code&gt;，符合我们的预期。&lt;/p&gt;&lt;h2&gt;13.4.3 卫生&lt;/h2&gt;&lt;p&gt;希望你现在觉得没啥问题了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;还有啥问题？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;考虑这个宏&lt;code class=&quot;inline&quot;&gt;(let ([v #t]) (my-or-4 #f v))&lt;/code&gt;。我们希望其计算的结果是啥？显然是&lt;code class=&quot;inline&quot;&gt;#t&lt;/code&gt;：第一个分支是&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;#f&lt;/code&gt;，但第二个分支是&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;绑定到&lt;code class=&quot;inline&quot;&gt;#t&lt;/code&gt;。但是观察展开后：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([v #t])
  (let ([v #f])
    (if v
        v
        v)))&lt;/code&gt;&lt;p&gt;直接运行该表达式，结果为&lt;code class=&quot;inline&quot;&gt;#f&lt;/code&gt;。但是，&lt;code class=&quot;inline&quot;&gt;(let ([v #t]) (my-or-4 #f v))&lt;/code&gt;求值得&lt;code class=&quot;inline&quot;&gt;#t&lt;/code&gt;。换种说法，这个宏似乎神奇地得到了正确的值：在宏中使用的标识符名称似乎与宏引入的标识符无关！当它发生在&lt;b&gt;函数&lt;/b&gt;中时，并不令人惊讶；宏展开过程也享有这种特性，它被称为&lt;b&gt;卫生&lt;/b&gt;（hygiene）。&lt;/p&gt;&lt;p&gt;理解卫生的一种方法是，它相当于自动将所有绑定标识符改名。也就是说，程序的展开如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([v #t])
  (or #f v))&lt;/code&gt;&lt;p&gt;变成&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([v1 #t])
  (or #f v1))&lt;/code&gt;&lt;p&gt;（注意到v一致的重命名为v1），接下来变成&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([v1 #t])
  (let ([v #f])
       v
       v1))&lt;/code&gt;&lt;p&gt;重命名后变成&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([v1 #t])
  (let ([v2 #f])
       v2
       v1))&lt;/code&gt;&lt;p&gt;此时展开结束。注意上述每一个程序，如果直接运行的话，都会产生正确的结果。&lt;/p&gt;&lt;h2&gt;13.5 标识符捕获&lt;/h2&gt;&lt;p&gt;卫生宏解决了语法糖的创造者常常会面对的重要痛点。然而，在少数情况下，开发人员需要故意违反卫生原则。回过来考虑对象，对于这个输入程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define os-1
  (object/self-1
   [first (x) (msg self &#39;second (+ x 1))]
   [second (x) (+ x 1)]))&lt;/code&gt;&lt;p&gt;（对应的）宏应该是什么样的？试试这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax object/self-1
  (syntax-rules ()
    [(object [mtd-name (var) val] ...)
     (let ([self (lambda (msg-name)
                   (lambda (v) (error &#39;object &quot;nothing here&quot;)))])
       (begin
         (set! self
               (lambda (msg)
                 (case msg
                   [(mtd-name) (lambda (var) val)]
                   ...)))
         self))]))&lt;/code&gt;&lt;p&gt;不幸的是，这个宏会产生以下错误：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;self: unbound identifier in module in: self
;self: 未绑定的标识符&lt;/code&gt;&lt;p&gt;错误指向的是first方法体中的self。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;给出卫生展开的步骤，理解为何报错是我们预期的结果。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;在正面解决该问题之前，让我们考虑输入项的一种变体，使绑定显式化：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define os-2
  (object/self-2 self
   [first (x) (msg self &#39;second (+ x 1))]
   [second (x) (+ x 1)]))&lt;/code&gt;&lt;p&gt;对应的宏只需要稍加修改：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax object/self-2
  (syntax-rules ()
    [(object self [mtd-name (var) val] ...)
     (let ([self (lambda (msg-name)
                   (lambda (v) (error &#39;object &quot;nothing here&quot;)))])
       (begin
         (set! self
               (lambda (msg)
                 (case msg
                   [(mtd-name) (lambda (var) val)]
                 ...)))
         self))]))&lt;/code&gt;&lt;p&gt;这个宏展开正确。&lt;/p&gt;&lt;p&gt;&lt;b&gt;习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;给出这个版本的展开步骤，看看不同在哪里。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;洞察其中的区别：&lt;b&gt;如果进入绑定位置的标识符是由宏的用户提供的话&lt;/b&gt;，那么就没有问题了。因此，我们想要&lt;b&gt;假装&lt;/b&gt;引入的标识符是由用户编写的。函数&lt;code class=&quot;inline&quot;&gt;datum-&amp;gt;syntax&lt;/code&gt;接收两个参数，第一个参数是语法，它将第二个参数——s-expression——转换为语法，假装其是第一个参数的一部分（在我们的例子中，就是宏的原始形式，它被绑定为x）。为了将其结果引入到用于展开的环境中，我们使用&lt;code class=&quot;inline&quot;&gt;with-syntax&lt;/code&gt;在环境中进行绑定：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax (object/self-3 x)
  (syntax-case x ()
    [(object [mtd-name (var) val] ...)
     (with-syntax ([self (datum-&amp;gt;syntax x &#39;self)])
       #&#39;(let ([self (lambda (msg-name)
                       (lambda (v) (error &#39;object &quot;nothing here&quot;)))])
           (begin
             (set! self
                   (lambda (msg-name)
                     (case msg-name
                       [(mtd-name) (lambda (var) val)]
                       ...)))
             self)))]))&lt;/code&gt;&lt;p&gt;于是我们可以隐式的使用self了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define os-3
  (object/self-3
   [first (x) (msg self &#39;second (+ x 1))]
   [second (x) (+ x 1)]))&lt;/code&gt;&lt;h2&gt;13.6 对编译器设计的影响&lt;/h2&gt;&lt;p&gt;在一个语言的定义中使用宏对所有其工具都有影响，特别是编译器。作为例子，考虑&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;的优点是，它可以被高效的编译，只需要扩展当前环境就行了。相比之下，将&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;展开成函数调用会导致更昂贵的操作：创建闭包，再将其应用于参数，实际上获得的效果是一样的，但是花费更多时间（通常还要更多空间）。&lt;/p&gt;&lt;p&gt;这似乎是反对使用宏的论据。不过，聪明的编译器会发现这个模式老是出现，并会在其内部将左括号左括号lambda转换回&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;的等价形式。这么做有两个好处。第一个好处是，语言设计者可以自由地使用宏来获得更小的核心语言，而不必与执行成本进行权衡。&lt;/p&gt;&lt;p&gt;第二个好处更微妙。因为编译器能识别这个模式，&lt;b&gt;其他的&lt;/b&gt;宏也可以利用它并获得相同的优化；它们不再需要扭曲自己的输出，如果自然的输出恰好是左括号左括号lambda，将其再转化成let（否则就必须这么做）。比如说，在编写某些模式匹配（的宏）的时候，左括号左括号lambda模式就会自然的出现，而想要将其转换为let的话就必须多做一步——现在不必要了。&lt;/p&gt;&lt;h2&gt;13.7 其他语言中的去语法糖&lt;/h2&gt;&lt;p&gt;不仅仅是Racket，许多现代语言也通过去语法糖来定义操作。例如在Python中，for迭代就是语法模式。程序员写下&lt;code class=&quot;inline&quot;&gt;for x in o&lt;/code&gt;时，他&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;引入了新标识符（称之为i，但是，不要让其捕获了程序员定义的i，即，卫生的绑定i！），&lt;/li&gt;&lt;li&gt;将其绑定到从o获得的迭代器（iterator），&lt;/li&gt;&lt;li&gt;创建（可能）无限的while循环，反复调用i的.next方法，直到迭代器引发StopIteration异常。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现代编程语言中有许多这样的模式。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2017-12-08-31817926</guid>
<pubDate>Fri, 08 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>在Haskell中模拟dependent type</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-04-31690842.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;在Haskell中模拟dependent type&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31690842&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-49d3d08432de8f11409880942f0bf9a5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;题图的PixivID为：&lt;i&gt;pixiv-ID:&lt;/i&gt; &lt;i&gt;&lt;a href=&quot;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=61127101&quot;&gt;61127101&lt;/a&gt;，画师为&lt;/i&gt;&lt;a href=&quot;https://www.pixiv.net/member.php?id=10710834&quot;&gt;Novelance&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本文始发于&lt;a href=&quot;https://saul-mirone.github.io/2017/12/04/dependent-type-in-haskll/&quot;&gt;我的博客&lt;/a&gt;，转载请注明作者。&lt;/p&gt;&lt;p&gt;Dependent type是一种依赖于值的类型，它增强了类型表达能力，让我们可以构造更强大的类型定义，无论用在定理证明还是用在减少程序出错的可能都是极好的。&lt;/p&gt;&lt;p&gt;本文我们讨论在Haskell中如何合理使用扩展模拟Dependent type。&lt;/p&gt;&lt;h2&gt;入门级LIST&lt;/h2&gt;&lt;p&gt;让我们先从一个简单的List开始，看看没有dependent type的时候，会发生什么。&lt;/p&gt;&lt;p&gt;先定义自然数和一个List结构：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Nat = Zero | Succ Nat
 data List a = Nil | Cons a (List a)
 -- example
 one = Succ Zero -- 1
 two = Succ $ Succ Zero -- 2
 listOne :: List Nat
 listOne = Cons Zero $ Nil -- [0]
 listOne :: List Nat
 listTwo = Cons (Succ Zero) $ Cons Zero Nil -- [1, 0]&lt;/code&gt;&lt;p&gt;此时让我们定义一个&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;函数，根据下标返回List中的元素：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; listIndex :: Nat -&amp;gt; List a -&amp;gt; a
 listIndex Zero (Cons x _) = x
 listIndex (Succ n) (Cons _ xs) = listIndex n xs
 -- example
 listIndex Zero listTwo =&amp;gt; Succ Zero
 listIndex one listTwo =&amp;gt; Zero&lt;/code&gt;&lt;p&gt;此时会产生一个问题：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; listIndex Zero Nil -- 编译通过
 listIndex two listOne -- 编译通过&lt;/code&gt;&lt;p&gt;可以看到，无论是去空数组中取值，还是下标超过了List的总长度这种明显是错误的代码，依然被编译了，一直到运行期才会产生异常。&lt;/p&gt;&lt;h2&gt;升级版LIST—GADT&lt;/h2&gt;&lt;p&gt;现在让我们在类型层面上解决这个问题。我们定先义一个新的List，让它有记录List长度的功能。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Vec a n = VNil a n | VCons a n&lt;/code&gt;&lt;p&gt;但是这个太弱了，几乎是换汤不换药：a和n都是可以由手动控制的，万一制造出了&lt;code class=&quot;inline&quot;&gt;VNil a (Succ Zero)&lt;/code&gt;的类型，编译器只能默默接受。仔细观察，&lt;code class=&quot;inline&quot;&gt;VNil&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;VCons&lt;/code&gt;都是函数，那么它们的类型其实可以写出：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; VNil :: Vec a Zero
 VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (Succ n)&lt;/code&gt;&lt;p&gt;所以我们需要一个叫&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/GADT&quot;&gt;GADT&lt;/a&gt;的扩展来添加第一层限制，它可以让我们在类型定义中约束返回的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; {-# LANGUAGE GADTs #-}
 data Zero
 data Succ n
 data Nat = Zero | Succ Nat
 data Vec a n where
   Nil  :: Vec a Zero
   Cons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (Succ n)
 -- example
 vecOne :: Vec Nat (Succ Zero)
 vecOne = VCons Zero VNil -- [0]
 vecTwo :: Vec Nat (Succ (Succ Zero))
 vecTwo = VCons Zero $ VCons (Succ Zero) VNil -- [1, 0]&lt;/code&gt;&lt;p&gt;这样一来，我们可以通过类型直接约束List的长度了。你也许注意到了，我们为了在类型定义中添加约束而将&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;类型拆分了，这样看上去很蠢，其实我们可以借助一个叫做&lt;a href=&quot;https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html&quot;&gt;DataKinds&lt;/a&gt;的扩展来让编译器自动帮我们做这件事：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; {-# LANGUAGE DataKinds #-}
 data Nat = Zero | Succ Nat
 -- 可以代替
 data Zero
 data Succ n
 data Nat = Zero | Succ n&lt;/code&gt;&lt;p&gt;当然，此时编译器会提醒你在接下来的类型中使用&lt;code class=&quot;inline&quot;&gt;&#39;Zero&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;Succ&lt;/code&gt;来指向那个type constructor来避免歧义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Vec a n where
    VNil  :: Vec a &#39;Zero
    VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (&#39;Succ n)&lt;/code&gt;&lt;p&gt;我们还有最后一个不顺眼的地方：那就是&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;构造器的第二个参数&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;其实应该是&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;类型的，不可能是其它类型，所以我们希望也给它指定好类型，这时候我们就需要&lt;a href=&quot;https://downloads.haskell.org/~ghc/7.8.1-rc1/docs/html/users_guide/kind-polymorphism.html&quot;&gt;KindSignatures&lt;/a&gt;扩展了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Vec :: * -&amp;gt; Nat -&amp;gt; * where
    VNil  :: Vec a &#39;Zero
    VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (&#39;Succ n)&lt;/code&gt;&lt;p&gt;OK，这样就得到了我们的升级版List，它能够通过类型直观的表现出它的长度。但是它还没有解决我们上一节的问题，那就是如何用类型约束index函数的参数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; vecIndex :: Nat -&amp;gt; Vec x b -&amp;gt; x
 vecIndex Zero (VCons x _) = x
 vecIndex (Succ n) (VCons _ xs) = vecIndex n xs&lt;/code&gt;&lt;p&gt;问题依然存在着。&lt;/p&gt;&lt;h2&gt;终极版LIST—TYPE FAMILIES&lt;/h2&gt;&lt;p&gt;现在让我们把注意力集中到&lt;code class=&quot;inline&quot;&gt;vecIndex :: Nat -&amp;gt; Vec x b -&amp;gt; x&lt;/code&gt;这里，既然我们已经用函数来表示出了类型，那么其实只要约束&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;小于 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;就好了，这时我们需要&lt;a href=&quot;https://wiki.haskell.org/GHC/Type_families&quot;&gt;TypeFamilies&lt;/a&gt;扩展来让类型可以重载，这样我们就可以为类型定义一些二元运算了（要支持运算符的话还要添加一个&lt;a href=&quot;https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/data-type-extensions.html&quot;&gt;TypeOperators&lt;/a&gt;扩展）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type family (a :: Nat) :&amp;lt; (b :: Nat) where
  m         :&amp;lt; &#39;Zero     = &#39;False
  &#39;Zero     :&amp;lt; &#39;Succ n   = &#39;True
  (&#39;Succ m) :&amp;lt; (&#39;Succ n) = m :&amp;lt; n&lt;/code&gt;&lt;p&gt;现在还有一个问题，&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;是不能够比较的，因此我们需要创造一个能够比较的版本：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data SNat a where
    SZero :: SNat &#39;Zero
    SSucc :: SNat a -&amp;gt; SNat (&#39;Succ a)&lt;/code&gt;&lt;p&gt;现在我们可以重写我们的&lt;code class=&quot;inline&quot;&gt;vecIndex&lt;/code&gt;了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; vecIndex :: ((a :&amp;lt; b) ~ &#39;True) =&amp;gt; SNat a -&amp;gt; Vec x b -&amp;gt; x
 vecIndex SZero (VCons x _) = x
 vecIndex (SSucc n) (VCons _ xs) = vecIndex n xs
 -- example
 vecIndex (SSucc SZero) vecTwo --成功
 vecIndex (SSucc $ SSucc SZero) vecTwo --报错&lt;/code&gt;&lt;p&gt;非常安全。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在你可以试试这道题目来自己体会一下了：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/54750ed320c64c64e20002e2&quot;&gt;codewars-Singletons&lt;/a&gt;&lt;/p&gt;</description>
<author>mirone</author>
<guid isPermaLink="false">2017-12-04-31690842</guid>
<pubDate>Mon, 04 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译12】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-01-31582536.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Programming Languages: Application and Interpretation【译12】&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31582536&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;审校：&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot; data-hash=&quot;802e5a4b8b40cc8d665968a2ad620302&quot; data-hovercard=&quot;p$b$802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.gitbook.com/book/lotuc/plai-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;12 表示层抉择&lt;/h2&gt;&lt;p&gt;回去看看我们将函数作为值的那个解释器，你能找到其中不一致的地方吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;找到了吗？&lt;/blockquote&gt;&lt;p&gt;考虑一下我们是怎么表示这两种值的：数和函数。忽略其外面&lt;code class=&quot;inline&quot;&gt;numV&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;closV&lt;/code&gt;这一层，注意它们底层的数据表示。我们使用Racket中的数来表示要解释的语言中的数，但是我们没有使用Racket中的函数（闭包）来表示要解释的语言中的函数（闭包）。&lt;/p&gt;&lt;p&gt;这就是不一致的地方。更一致的做法是，要么都用Racket中的值表示，要么都&lt;b&gt;不&lt;/b&gt;用。那么我们为什么要做出这种决定呢？&lt;/p&gt;&lt;p&gt;这么做是要说明一个问题。本章我们就讨论此问题。&lt;/p&gt;&lt;h2&gt;12.1 改变表示&lt;/h2&gt;&lt;p&gt;我们暂且探究一下数。Racket中数很强大所以我们重用它：它支持任意大小的整数（&lt;b&gt;bignum&lt;/b&gt;）、有理数（这点受益于整数的bignum表示）、复数等等。因此，它能表示出大部分常规语言中的数系统。然而，这并不意味着它就是我们&lt;b&gt;想要的&lt;/b&gt;：它可能过于简单或者过于复杂：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果我们需要的是某种受限的数系统，它就过于复杂了。例如Java中规定了一组定长的数的表示（如：int被指定为32位的）。超出这个规定范围的数在Java中将不能直接被表示，同时算术运算也遵循此范围（例如：由于溢出，1加2147483647将&lt;b&gt;不能&lt;/b&gt;得到2147483648）。&lt;/li&gt;&lt;li&gt;如果我们需要更为丰富的数系统，它又会捉襟见肘，比如包含四元数或者和概率相关的数。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;糟糕的是，我们根本没有想过自己的需求，就直接轻率的使用Racket中的数作为我们语言中数的表示。&lt;/p&gt;&lt;p&gt;之所以这样做，是因为我们并不关心数本身；我们关心的是诸如将函数作为值这样的编程语言特性。然而，作为语言设计者，你应当在最开始的时候就考虑到这些问题。&lt;/p&gt;&lt;p&gt;接下来讨论闭包的表示。我们其实可以利用Racket的闭包来表示目标语言中的对应概念，与之对应的，用Racket中最基本的函数调用来实现目标语言中的函数调用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;使用Racket函数替换之前闭包的实现。&lt;/blockquote&gt;&lt;p&gt;答案在此：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Value
  [numV (n : number)]
  [closV (f : (Value -&amp;gt; Value))])

(define (interp [expr : ExprC] [env : Env]) : Value
  (type-case ExprC expr
    [numC (n) (numV n)]
    [idC (n) (lookup n env)]
    [appC (f a) (local ([define f-value (interp f env)]
                        [define a-value (interp a env)])
                  ((closV-f f-value) a-value))]
    [plusC (l r) (num+ (interp l env) (interp r env))]
    [multC (l r) (num* (interp l env) (interp r env))]
    [lamC (a b) (closV (lambda (arg-val)
                         (interp b
                                 (extend-env (bind a arg-val)
                                             env))))]))
&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;注意到一个有趣的变化。之前的实现中，环境是在解释appC时被扩展的。这里它是在lamC的解释过程中被扩展的。是这两个中有一个出错了吗？如果不是的话，为什么会出现这种情况？&lt;/blockquote&gt;&lt;p&gt;这种实现方式显然更为简洁，但是我们失去了一项重要的东西：&lt;b&gt;理解&lt;/b&gt;。告诉别人源语言中的函数对应于lambda等于什么都没说：如果我们已经知道lambda是干嘛的我们可能就不会花时间去研究它；如果不知道的话，这种直接映射的实现方式也不会教给我们啥（而且很可能会让本来就对该概念一无所知的我们更加困惑）。出于同样的理由，我们没有使用Racket中的状态去理解各种对状态的操作。&lt;/p&gt;&lt;p&gt;然而，一旦我们理解了某个特性，使用它来表示将不再是问题。实际上，这样做会使得我们的解释器更为简洁，毕竟我们不再手工实现所有事情。事实上，如果不使用这种表示方式，后面的一些解释器会变得毫无可读性。【注释】尽管如此，我们还是应该注意防范过度使用宿主语言的特性可能招致的风险。&lt;/p&gt;&lt;blockquote&gt;有点像是，“现在我们已经能够通过加一来理解加法，我们可以用加法来定义乘法：不再需要使用加一来定义乘法。”&lt;/blockquote&gt;&lt;h2&gt;12.2 错误&lt;/h2&gt;&lt;p&gt;当程序出错时，程序员需要得到相应的错误信息。直接使用宿主语言特性可能导致用户收到宿主语言中抛出的错误，这些错误将无法被理解。因此，我们需要谨慎的将各种情况的错误翻译成我们语言的用户所能理解的术语，且不让宿主语言中的错误信息“泄漏过来”。&lt;/p&gt;&lt;p&gt;更糟糕的情形是，那些本应出错的程序可能不会报错！例如，假设我们设计时决定让函数只出现在顶层位置，如果我们没有特意地检测这点，其被去语法糖后得到lambda，最后可能在解释器中被解释得到结果，而它本来应该使解释器出错停止。因此，我们应该极其注意，&lt;b&gt;仅允许符合期望的表层语言被映射到宿主语言中&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;再举个例子，考虑不同的赋值操作。在我们的语言中，给未绑定的变量赋值会导致错误。但是在有些语言中，这种操作会导致该变量被定义。语言设计者常犯的错误是没有很好的确定想要的语义，然后推脱说“它就是实现出来的那个样子”。这种态度（a）是懒惰、马虎的，（b）可能招致不可预料、负面的后果，（c）它使得将语言从一个实现平台移到另一个实现平台变得困难。不要犯这个错误！&lt;/p&gt;&lt;h2&gt;12.3 改变含义&lt;/h2&gt;&lt;p&gt;将作为值的函数映射为lambda之所以可行是因为我们本来就希望它们&lt;b&gt;拥有相同的含义&lt;/b&gt;。但是这种实现方式使得改变函数的含义变得极为困难。让我给你设想一个情形：假设我们想要实现动态作用域。【注释】在我们原来的解释器中，这很简单（历史告诉我们，简直太简单了）。试着在使用了lambda的解释器中实现动态作用域。同样的，将及早求值（eager evaluation）特性映射到惰性求值（lazy application）的语言中（译注，第17章）也是挺有难度的，或者说至少不太容易。&lt;/p&gt;&lt;blockquote&gt;只是假设而已。&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;将上面的解释器改成动态作用域的。&lt;/blockquote&gt;&lt;p&gt;重点是，使用自己构造的数据结构并不会使事情更为简单，但一般来说也不会使事情变得更为复杂；与之相对，映射成语言本身特性的方式会使某些特性——通常是宿主语言中已有的特性——的实现极为简单，但是使其他特性的实现变得微妙或困难。还有一个风险是，我们可能并不十分清楚宿主语言的某个特性具体实现了些什么（比如，“lambda”是否真的实现了静态作用域？）。&lt;/p&gt;&lt;p&gt;教训是，仅当我们想要“保留”底层语言的意义时，这才是好用的——甚至是特别明智的，因为它确保我们不会意外地改变其意义。但是，如果我们要利用基础语言的重要组成部分，而只是扩展它的含义，那么其他的实现策略可能也不错（译注，第13章），而不是编写解释器。&lt;/p&gt;&lt;h2&gt;12.4 另一个例子&lt;/h2&gt;&lt;p&gt;我们再考虑改变一个特性的表示方式。还记得环境是什么吗？&lt;/p&gt;&lt;p&gt;环境是名字到值（如果有赋值的话，那么是名字到地址）的&lt;b&gt;映射&lt;/b&gt;。我们通过自建的数据结构实现了这种映射，但是我们可以通过其他方式实现映射吗？当然可以，使用函数就行！这样，环境就变成了读入名字为参数、返回其绑定值（或者报错）的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias Env (symbol -&amp;gt; Value))
&lt;/code&gt;&lt;p&gt;空的环境是什么？对于任何名字的查询都抛出错误的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (mt-env [name : symbol])
  (error &#39;lookup &quot;name not found&quot;))
&lt;/code&gt;&lt;p&gt;（原则上我们应该给它的返回值添加类型注解，应该是Value，但是在这里没啥意义）。给环境添加新的绑定就是创建新函数，该函数检查该名字是不是正在扩展的那个绑定；如果是，直接放回对应的绑定值，如果不是，往被扩展的环境传就行。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (extend-env [b : Binding] [e : Env])
  (lambda ([name : symbol]) : Value
    (if (symbol=? name (bind-name b))
        (bind-val b)
        (lookup name e))))
&lt;/code&gt;&lt;p&gt;最后，怎么再环境中查询某个名称呢？&lt;b&gt;调用&lt;/b&gt;该环境即可。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (lookup [n : symbol] [e : Env]) : Value
  (e n))
&lt;/code&gt;&lt;p&gt;大功告成！&lt;/p&gt;</description>
<author>lotuc</author>
<guid isPermaLink="false">2017-12-01-31582536</guid>
<pubDate>Fri, 01 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译11】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-01-31582483.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Programming Languages: Application and Interpretation【译11】&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31582483&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;审校：&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot; data-hash=&quot;802e5a4b8b40cc8d665968a2ad620302&quot; data-hovercard=&quot;p$b$802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.gitbook.com/book/lotuc/plai-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;11 内存管理&lt;/h2&gt;&lt;h2&gt;11.1 垃圾&lt;/h2&gt;&lt;p&gt;&lt;b&gt;垃圾&lt;/b&gt;（garbage）指的是已分配但是不再需要的内存。典型的编程语言的运行时系统采用两种不同的内存分配方式。一种是分配给环境；这种分配方式要和静态作用域保持一致，所以它只需要支持推入（push）和弹出（pop）操作。函数调用返回时，为其环境分配的空间也被返回，供后续函数使用，看似没有成本。【注释】与之相对，在贮存中分配的内存必须伴随某个值的一生，可能要超过其创建位置的作用域——事实上，它可能一直存活下去。因此，我们需要不同的策略来回收在贮存中分配空间所产生的垃圾。&lt;/p&gt;&lt;blockquote&gt;并非没有成本。硬件必须执行“弹出”指令。这&lt;b&gt;不见得&lt;/b&gt;就一定比其他内存管理策略更高效。&lt;/blockquote&gt;&lt;p&gt;空间回收的方法有很多，大体可以分到两个阵营中：人工和自动。人工的方式依赖于开发者能够了解内存的使用，并正确的释放不需要的内存。一般认为，人并不擅长做这种事（虽然在某些情况下，人类拥有机器所无法获取的知识）。因此，几十年来，自动化的方法越来越普及。&lt;/p&gt;&lt;h2&gt;11.2 什么样的垃圾回收是“正确的”？&lt;/h2&gt;&lt;p&gt;垃圾回收既不应该太早地收回空间（&lt;b&gt;可靠性&lt;/b&gt;，soundness）也不能太晚（&lt;b&gt;完备性&lt;/b&gt;，completeness）。虽然两者都可以被视为缺陷，但是它们的影响并不是对称的：可以说，过早收回糟糕得多。这是因为，如果过早回收了某个贮存地址，计算将继续，并可能将其他数据写入该地址，从而访问到无意义的数据。往好了说，这会导致程序不正确，极端情况下后果更严重，比如可能会导致安全问题。反之，过迟收回会导致性能损失，并且可能最终导致程序终止，尽管此时理论上存在理论上可用的内存。这种性能损失以及程序过早终止很令人讨厌，在某些关键任务系统中可能会导致重大问题，不过，至少程序不会进行无意义的运算。&lt;/p&gt;&lt;p&gt;理想情况下，我们希望拥有所有的这三项：自动化（automation），可靠性和完备性。然而，这里我们面对的是不可兼得的情形，最多只能选择两项。理想的人类能够做到可靠性和完备性，但实践中实现其中一个都很少见。【注释】计算机可以实现自动化，同时可以提供可靠性和完备性中的一个，但可计算性论证表明，自动化的计算过程不能同时达成这两者。实践中，自动化技术一般选择实现可靠性，出于以下原因：（a）它造成的损害最小；（b）它相对更容易实现；（c）在添加一些人工帮助的情况下，可以接近完备性。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;你&lt;/b&gt;当然是完美的，但是你的程序员同行呢？顺便说一下，经济学理论在等你验证呢。&lt;/blockquote&gt;&lt;h2&gt;11.3 人工回收&lt;/h2&gt;&lt;p&gt;人工的最彻底的方式是将所有内存回收交由人操作。例如，在C语言中提供了两个基本指令：&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;用于分配内存，&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;用于释放内存。&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;的输入是（内存的）大小，返回是对贮存的引用；&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;的输入是这种引用，释放其占用的内存。&lt;/p&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;       “在当代欧美语言，&quot;Moloch&quot;摩洛这个词有特定的引申义，指代需要极大牺牲的人物或者事业。”——维基百科，摩洛词条&lt;br&gt;        “我不认为这个名字听起来像malloc是巧合。”——Ian Barland&lt;br&gt;&lt;/code&gt;&lt;/blockquote&gt;&lt;h2&gt;11.3.1 完全人工回收的代价&lt;/h2&gt;&lt;p&gt;先来考虑一下这些操作的复杂度。首先我们假设&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;有个指向贮存的关联寄存器（比如&lt;code class=&quot;inline&quot;&gt;new-loc&lt;/code&gt;），每次分配的时候直接获取下一个可用地址。这个模型非常简单——可惜只是看上去简单而已。问题出在当你需要用&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;释放内存时。如果调用&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;针对的是最后一次&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;分配的内存，那么没有问题；但是贮存中数据一般不遵堆栈的规律。如果释放的不是最新分配的内存，将会在贮存中留下空洞。空洞会导致&lt;b&gt;碎片化&lt;/b&gt;（fragmentation），最坏的情况下，即使贮存中有足够的空间，也无法分配任何对象——许多分割的碎片，没有一个足够大。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;原则上，我们可以通过使所有空余空间相邻来解决碎片化的问题。怎么达成这一点？仔细考虑所有的后果，然后描述一下如何手工进行这项工作。&lt;/blockquote&gt;&lt;p&gt;在大多数手动内存管理方案中，碎片化仍然是个不可克服的问题，不过在这个看上去很简单的方案里还有其他东西值得考虑。释放某个值之后会发生什么？运行时系统需要用某种方式记录这块内存可被分配。它是通过维护&lt;b&gt;空闲表&lt;/b&gt;——空闲空间的链表——来达成这点的。稍作思考就会想到问题，空闲表存在哪，&lt;b&gt;它的&lt;/b&gt;内存又由谁来管理呢？答案是空闲表存放在空闲的内存单元格中，这就意味着内存分配时存在最小分配单元。&lt;/p&gt;&lt;p&gt;那么，原则上，每次&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;现在必须遍历空闲表以找到合适的位置。说“合适”是因为分配者必须做出复杂的决定。遇到第一个匹配的空间就分配呢还是继续找找？而且“匹配”又是怎么定义的呢？应该选取那些大小刚好的空间，还是将大些的空间拆分成小块（从而增加创建不可用的小空间的可能性）？还有其它诸多问题。&lt;/p&gt;&lt;p&gt;程序员希望内存分配高效。【注释1】因此，实践中，分配系统倾向于只使用一组固定的尺寸，通常是2的幂。这样我们就可以不是只维护一个空闲表，而是为每个尺寸（都是2的幂）维护一个空闲表。然后再维护一个指向这些表的数组，位操作可以减小数组索引的代价。当然，这样会浪费一些空间，因为当需要那些不是2的幂尺寸的内存时，最终分配给其的内存尾部将会有空余。（这是计算机科学中经典的取舍(trade-off)：空间换时间）。&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;需要将释放的内存放到合适的链表中，有时候还需要将较大块的内存分割成小块以为将来的分配做准备。这个模型中的任何部分都不像看上去的那样高效。【注释2】&lt;/p&gt;&lt;blockquote&gt;如果内存分配不够高效，开发者会尝试各种奇技赢巧来重用程序中的值，这会降低代码的清晰性，很有可能会导致错误。&lt;br&gt;特别地，&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;并不免费（译注：双关）。&lt;/blockquote&gt;&lt;p&gt;当然，所有这些都基于程序员可以写出可靠（忽略完备）程序的基础上。但是他们做不到。&lt;/p&gt;&lt;h2&gt;11.3.2 引用计数&lt;/h2&gt;&lt;p&gt;由于完全手工内存回收给程序员带来极大的负担，一些半自动化技术被广为使用，最为人知的便是&lt;b&gt;引用计数&lt;/b&gt;（reference counting）。&lt;/p&gt;&lt;p&gt;使用引用计数的方式，每个值都关联一个计数，记录对其引用的个数。程序员负责负责递增和递减这些计数。当计数降为0时，该值的空间可以安全的回收供未来使用。&lt;/p&gt;&lt;p&gt;请注意，上面简单的定义中隐藏了两个重要假设：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;程序员可以记录每一次引用。回忆一下，别名也是引用。因此，当写出下面的代码时，&lt;code class=&quot;inline&quot;&gt; (let ([x &amp;lt;some value&amp;gt;])&lt;br&gt;   (let ([y x])&lt;br&gt;     ..))&lt;br&gt;&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;text&quot;&gt;程序员需要记住y是对x引用的那个值的第二次引用，因此要增加该值的引用计数。&lt;/code&gt;&lt;ol&gt;&lt;li&gt;每个值只有有限个引用。如果数据中存在环路，这条假设不成立。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于需要手动递增和递减引用，这种技术缺乏可靠性与完备性。事实上，上述第二个假设自然导致完备性的丧失，而第一个假设则指出了最简单的方式来打破可靠性。&lt;/p&gt;&lt;p&gt;手工管理内存的弊端还可以更为深层隐晦。由于程序员负责释放内存（或者，等效的，管理引用计数），内存管理策略必须成为每个库接口的一部分：即，“库中分配的值谁来释放？库会否释放传递给它的值？”很不幸，用文档准确记录、并遵守这种策略信息极其困难，更糟的是，它会导致文档中充斥关于底层的细节，它们通常与库要封装的行为毫无关系。&lt;/p&gt;&lt;p&gt;一个有趣的想法是将计数值的增减&lt;b&gt;自动化&lt;/b&gt;。另一个想法是在实现中添加循环检测（cycle-detection）。引入这两者将解决上述的很多问题，但是引用计数还有一些其它问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;引用计数会增加每个对象的大小。计数器需要足够大以防止溢出，又要足够小以避免过多的内存占用。&lt;/li&gt;&lt;li&gt;对这些计数器值的增减花费的时间会相当可观。&lt;/li&gt;&lt;li&gt;如果一个对象的引用计数降至0，那么它所引用的所有内容的计数值都需要减一，这种行为可能会是递归的。这意味着一次释放操作可能会花费大量时间，除非使用聪明的“惰性（lazy）”技巧（这样的话又会导致内存占用增加）。&lt;/li&gt;&lt;li&gt;为了减少计数值，我们需要遍历已经是垃圾的对象。这看上去很违反直觉：遍历我们已经不感兴趣的对象。工程实践中这会产生后果：这些我们不感兴趣的对象有可能已经很久没有被访问过了，这意味着它们可能被换页换出内存了。引用计数器需要将它们换页回内存，仅为了告诉它们它们不再被需要了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;出于所有这些原因，应谨慎引用计数。你不应接受它作为默认，而是应该问自己，为什么拒绝通常被认为更好的自动化技术。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如果引用计数溢出了，哪些正确性属性被破坏，是怎么被破坏的？权衡利弊。&lt;/blockquote&gt;&lt;h2&gt;11.4 自动回收，或垃圾收集&lt;/h2&gt;&lt;blockquote&gt;有些人认为引用计数是“垃圾收集”技术的一种。我更喜欢用后一个术语来指完全自动的技术。但是浏览网页时请注意可能的混淆。&lt;/blockquote&gt;&lt;p&gt;现在让我们来简要地考察一下让语言的运行时系统自动化回收垃圾的过程。我们将使用缩写GC（&lt;b&gt;Garbage Collection&lt;/b&gt;）同时指代垃圾回收的算法与垃圾回收的过程，上下文可以帮你区分具体指代哪个。&lt;/p&gt;&lt;h2&gt;11.4.1 概览&lt;/h2&gt;&lt;p&gt;所有GC算法的核心是通过值间引用关系遍历内存。遍历从&lt;b&gt;根集&lt;/b&gt;（root set）开始，也就是是程序可能引用贮存中值的所有地方。通常，根集由环境中的绑定变量以及全局变量组成。在实际实现中，还需要考虑到类似寄存器中的引用这种易逝值。从根集开始，算法使用一系列算法——通常是深度优先搜索【注释】的变体——来遍历所有可访问的值，以识别所有&lt;b&gt;存活的&lt;/b&gt;值（即，通过一些程序操作的序列可用到的值）。按定义所有其它数据就是垃圾。不同的算法使用不同的方式回收这些空间。&lt;/p&gt;&lt;blockquote&gt;通常选用深度优先搜索，因为它适用于基于堆栈的实现。当然，你可能（也应该）想知道GC自己的栈存储在哪里！&lt;/blockquote&gt;&lt;h2&gt;11.4.2 事实和可证性&lt;/h2&gt;&lt;p&gt;如果你仔细阅读的话，你会发现上面我描述了一个&lt;b&gt;算法&lt;/b&gt;。这是&lt;b&gt;实现的细节&lt;/b&gt;，而不是&lt;b&gt;规范&lt;/b&gt;的一部分！垃圾回收的规范是&lt;b&gt;事实&lt;/b&gt;（truth）的表述：我们要准确地回收所有是垃圾的值，不多也不少。但是对于任何图灵完备的编程语言，我们都没法得出这一事实，于是我们退而求其次，寻求&lt;b&gt;可证性&lt;/b&gt;（provability）。上述的算法描述提供了存活性的有效“证明”，其补集就是垃圾。这个方案当然还有变种，收集更多或更少的垃圾，取决于证明“垃圾性”的不同强度。&lt;/p&gt;&lt;p&gt;上面的说的最后一点指出了严格规范术语描述中的缺陷，对于要回收多少垃圾它完全没有说明。考虑一下极端情况实际上是有益的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义一个可靠的垃圾回收策略很简单。同样，定义一个完备的的垃圾回收策略也非常简单。你能想到怎么做吗？&lt;/blockquote&gt;&lt;p&gt;要做到可靠，我们只要确保不会错误的移除任何可能存活的数据。一种确保无疑的方式就是&lt;b&gt;完全不回收垃圾&lt;/b&gt;。与之对应，完备的GC回收&lt;b&gt;所有东西&lt;/b&gt;。显然这两者都是无用的（后者显然极其危险）。这为我们的工程实践指明了一点，我们不仅需要GC是可靠的，也希望它足够完备，同时还要足够高效。&lt;/p&gt;&lt;h2&gt;11.4.3 核心假设&lt;/h2&gt;&lt;p&gt;能够可靠地执行GC依赖于两条关键的假设。一条有关语言的实现，另一条有关语言的语义。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;对语言中的值，GC需要知道该值的类型以及它在内存中的表示法。例如，当遍历到&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;单元，它必须知道：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;这是一个&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;单元；因此，&lt;/li&gt;&lt;li&gt;它的&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;在哪里，例如位于4个字节的偏移量的地方，&lt;/li&gt;&lt;li&gt;它的&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;在哪里，例如位于8个字节的偏移量的地方。&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;显然，这个属性必须递归地保持，使得遍历算法能够正确映射内存中的值。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;程序不能通过下面两种方式&lt;b&gt;生成&lt;/b&gt;引用：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;对象引用不能发生在语言实现预先定义的根集之外。&lt;/li&gt;&lt;li&gt;对象引用只能指向对象中明确定义的点。&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;违反第二条时，GC将完全乱套，错误的解释数据。第一条看上去显而易见，如果它被违反，意味着运行时系统错误地理解语言的语义。然而这条的后果有点微妙，下面将会讨论。&lt;/p&gt;&lt;h2&gt;11.5 保守垃圾回收&lt;/h2&gt;&lt;p&gt;上文说过，一般根集包含环境、全局变量和一些易逝值。引用还可能出现在什么地方？&lt;/p&gt;&lt;p&gt;在大部分语言中，没有其他地方了。但是有些语言（说的就是你们，C和C++）允许将引用转换成数，以及将任意数转换成引用。因此，原则上，程序中的&lt;b&gt;任何&lt;/b&gt;数值（由于C和C++类型系统的特性，程序中几乎任何值）都可以被视为引用。&lt;/p&gt;&lt;p&gt;两个原因使得它问题重重。首先，GC不能只将其注意力集中到一个较小的根集；现在整个贮存都是潜在的根集。其次，如果GC试图以任何方式修改某个对象——例如在遍历时记录一个“访问”位——这时它可能修改了一个&lt;b&gt;非引用&lt;/b&gt;值：例如，它可能实际上改变了程序中某个（看似无关的）数型常量。因此，像C和C++这样的语言中的特征组合起来，使得合理而有效的GC非常困难。&lt;/p&gt;&lt;p&gt;但并不是不可能。一个令人兴奋的研究方向——称为&lt;b&gt;保守&lt;/b&gt;GC——成功的为此类语言创造了足够高效的GC系统。保守（conservative）GC背后的基本原则是，尽管理论上每个贮存地址都可能属于根集，但实际上它们大部分都不是。它会通过一系列聪明的观察来推断出哪些位置肯定不是引用（这点和传统GC相反），然后将它们安全地&lt;b&gt;忽略&lt;/b&gt;掉：例如，在字节对齐的体系架构中，奇数值不可能为引用。通过忽略大部分贮存，通过对程序行为作出一些基本的假定（例如程序不可能产生某种类型的引用），并且小心操作不去修改贮存（例如，不改变值中的比特，不移动数据）的情况下，可以得到一个还算有效的GC策略。&lt;/p&gt;&lt;blockquote&gt;刻鹄类鹜。&lt;/blockquote&gt;&lt;p&gt;保守GC在那些使用或者依赖C和C++实现的编程语言中比较常见。例如，早期的Racket就完全依靠它。这是基于以下原因：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它是种便捷的自举技术，语言实现者能得以将精力集中在其它更富革新性的特性上。&lt;/li&gt;&lt;li&gt;如果语言能控制所有的引用（比如Racket），那么可以使用便于提高GC效率的内存表示法（例如，用1填充所有(真正的)数的最低有效位）。&lt;/li&gt;&lt;li&gt;它使得该语言和C以及C++实现的库交互变得容易（当然前提是这些库也符合该技术的要求）。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里需要解释一下名词。如前所述，&lt;b&gt;所有&lt;/b&gt;实用的GC技术都是“保守的”，也就是说它们用（潜在的）可访问性代替真实中的是否访问。然而，“保守”这个词已经成为专门的术语，指在&lt;b&gt;不合作&lt;/b&gt;（但不是&lt;b&gt;故意对抗&lt;/b&gt;）的运行时系统中工作的GC技术。&lt;/p&gt;&lt;h2&gt;11.6 精确垃圾回收&lt;/h2&gt;&lt;p&gt;在传统的GC术语中，“保守”的反义词是&lt;b&gt;精确&lt;/b&gt;（precise）。这也是误称，因为GC不可是精确的，即同时做到可靠和完备。这里精确更多是对识别引用能力的表述：当面对值时，精确GC知道什么是和不是引用，以及引用的位置在哪。相对保守GC，这省去了猜测哪些值不是引用（并以此尽可能多地消除潜在引用）这项繁重的工作。&lt;/p&gt;&lt;p&gt;大多数当代语言的运行时系统使用精确GC，而精确GC领域中存在大量的实现技术。我推荐&lt;a href=&quot;ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps&quot;&gt;Paul Wilson 的调查报告&lt;/a&gt;（虽然这份材料有点显老，但在这个快速发展的领域中仍是很好的资源）和&lt;a href=&quot;https://www.cs.kent.ac.uk/people/staff/rej/gc.html&quot;&gt;Richard Jones&lt;/a&gt; 的书和资料。最后，对于世代垃圾收集器的概述，可以读一下&lt;a href=&quot;http://www.cs.princeton.edu/~appel/papers/143.ps&quot;&gt;简单的世代垃圾收集器和快速分配&lt;/a&gt;。&lt;/p&gt;</description>
<author>lotuc</author>
<guid isPermaLink="false">2017-12-01-31582483</guid>
<pubDate>Fri, 01 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Haskell 中的“定理证明”</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-30-31567423.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Haskell 中的“定理证明”&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31567423&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-24cc9824870cdcc4194b2c0ec0097d23_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;题图：鲸 | 花生( •̀ ω •́ ) [pixiv] &lt;a href=&quot;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=66023124&quot;&gt;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=66023124&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;这篇文章讲了什么&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;i&gt;这是一篇休闲向文章&lt;/i&gt;&lt;/p&gt;&lt;p&gt;总结了 Codewars 上面的几道证明题的思想并加以延拓，希望读者能在看完这篇文章之前/之后解决练习中的题目。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面是正文&lt;/p&gt;&lt;hr&gt;&lt;p&gt;众所周知，Haskell 并没有真正意义上的 dependent type，但通过一些技巧 （利用GADT）可以“模拟”dependent type，并可以通过其证明一些定理。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;利用 GADT 模拟 Dependent Type&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先我们需要作为&lt;b&gt;值&lt;/b&gt;的类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Z
 data S n&lt;/code&gt;&lt;p&gt;注意到，这里的 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;n 都只是单纯的类型，你甚至不能构造出相应类型的值出来。&lt;/p&gt;&lt;p&gt;所以我们需要把它们与实际存在的值联系起来&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Nat a where
      Zero :: Nat Z
      Succ :: Nat a -&amp;gt; Nat (S a)&lt;/code&gt;&lt;p&gt;于是我们有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (Succ Zero) :: Nat (S Z)
  (Succ (Succ Zero)) :: Nat (S (S Z))&lt;/code&gt;&lt;p&gt;这样我们获得了在类型层次上的自然数，并保持了它与实际的值的同构关系。&lt;/p&gt;&lt;p&gt;光有自然数是没有意义的，我们需要赋予它们运算的能力。&lt;/p&gt;&lt;p&gt;那么 &lt;code class=&quot;inline&quot;&gt;Nat n&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;Nat m&lt;/code&gt; 相加的结果应该是什么呢？&lt;/p&gt;&lt;p&gt;首先它应该是一个 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; ，其次它的类型应该对应于两数相加的结果。&lt;/p&gt;&lt;p&gt;借助于 GHC 的 Type Family 与 Type Operator 扩展，我们可以定义出 合理的 类型层面上的自然数的加法与乘法&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  type family (:+:) (n :: *) (m :: *) :: *
  type instance Z   :+: m = m
  type instance S n :+: m = S (n :+: m)
  
  type family (:*:) (n :: *) (m :: *) :: *
  type instance Z   :*: m = Z
  type instance S n :*: m = m :+: (n :*: m)&lt;/code&gt;&lt;p&gt;然后是数据层面的自然数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  infixl 4 +
  (+) :: Nat n -&amp;gt; Nat m -&amp;gt; Nat (n :+: m)
  Zero + a = a
  (Succ x) + a = Succ (x + a)
  
  infixl 5 *
  (*) :: Nat n -&amp;gt; Nat m -&amp;gt; Nat (n :*: m)
  Zero * _ = Zero
  (Succ x) * m = m + x * m&lt;/code&gt;&lt;p&gt;有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (Succ (Succ Zero)) * (Succ (Succ Zero)) :: Nat (S (S (S (S Z))))&lt;/code&gt;&lt;p&gt;基于类型上的自然数，我们可以定义 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; (在类型中包含了长度信息的 &lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;)了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  data Vec a n where
      VNil :: Vec a Z
      VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (S n)&lt;/code&gt;&lt;p&gt;长度为 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 与长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 连接起来之后的长度为 &lt;code class=&quot;inline&quot;&gt;n + m&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (++) :: Vec a n -&amp;gt; Vec a m -&amp;gt; Vec a (n :+: m)
  VNil ++ ys = ys
  VCons x xs ++ y = VCons x (xs ++ y)&lt;/code&gt;&lt;p&gt;把长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 重复 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 次之后得到的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 的长度为 &lt;code class=&quot;inline&quot;&gt;n * m&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  repeat :: Nat n -&amp;gt; Vec a m -&amp;gt; Vec a (n :*: m)
  repeat Zero _ = VNil
  repeat (Succ x) xs = xs ++ repeat x xs&lt;/code&gt;&lt;p&gt;有了长度信息，就有类型安全的 &lt;code class=&quot;inline&quot;&gt;head&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;tail&lt;/code&gt; 了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  headV :: Vec a (S n) -&amp;gt; a
  headV (VCons x _) = x
  
  tailV :: Vec a (S n) -&amp;gt; Vec a n
  tailV (VCons _ xs) = xs&lt;/code&gt;&lt;p&gt;因为 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 作为 GADT 的类型在这里受到了第二个类型参数为 &lt;code class=&quot;inline&quot;&gt;S n&lt;/code&gt; 的束缚，所以可以保证这里的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 不会是 &lt;code class=&quot;inline&quot;&gt;VNil&lt;/code&gt; ，这两个函数都是 &lt;b&gt;完全&lt;/b&gt; 的。&lt;/p&gt;&lt;p&gt;借鉴之前定义类型层面上自然数的加法与乘法的思想，我们可以定义相应的减法、求最大值、最小值等。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  type family (:-:) (n :: *) (m :: *) :: *
  type instance n :-: Z = n
  type instance Z :-: m = Z
  type instance S n :-: S m = n :-: m
  
  type family (:^:) (n :: *) (m :: *) :: *
  type instance Z :^: n = n
  type instance n :^: Z = n
  type instance S n :^: S m = S (n :^: m)
  
  type family (:~:) (n :: *) (m :: *) :: *
  type instance Z :~: m = Z
  type instance n :~: Z = Z
  type instance S n :~: S m = S (n :~: m)&lt;/code&gt;&lt;p&gt;(这里使用了 &lt;code class=&quot;inline&quot;&gt;:~:&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;:^:&lt;/code&gt; 分别代表求最大值和最小值)&lt;/p&gt;&lt;p&gt;于是有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  zip :: Vec a n -&amp;gt; Vec b m -&amp;gt; Vec (a, b) (n :~: m)
  zip VNil _ = VNil
  zip _ VNil = VNil
  zip (VCons x xs) (VCons y ys) = VCons (x, y) (zip xs ys)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;进行简单的定理证明&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Haskell&lt;/code&gt; 中没有 Prop ，所以我们得从头开始描述“相等”这个概念。&lt;/p&gt;&lt;p&gt;首先定义代表两个类型层面的自然数相等的类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Equal a b where
      EqZ :: Equal Z Z
      EqS :: Equal a b -&amp;gt; Equal (S a) (S b)&lt;/code&gt;&lt;p&gt;借助于 Type Operator 我们可以写成&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type a === b = Equal a b&lt;/code&gt;&lt;p&gt;相等关系具有自反性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  refl :: Nat n -&amp;gt; n === n
  refl Zero = EqZ
  refl (Succ x) = EqS $ refl x&lt;/code&gt;&lt;p&gt;相等关系具有对称性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  symm :: a === b -&amp;gt; b === a
  symm EqZ = EqZ
  symm (EqS x) = EqS $ symm x&lt;/code&gt;&lt;p&gt;相等关系具有传递性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (&amp;lt;=&amp;gt;) :: a === b -&amp;gt; b === c -&amp;gt; a === c
  EqZ &amp;lt;=&amp;gt; EqZ = EqZ
  EqS x &amp;lt;=&amp;gt; EqS y = EqS $ x &amp;lt;=&amp;gt; y&lt;/code&gt;&lt;p&gt;因为 Type Operator 也能定义优先级，所以下面给出：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  infixl 2 ===
  infixl 4 :+:
  infixr 4 :-:
  infixl 5 :*:&lt;/code&gt;&lt;p&gt; 来减少括号的个数&lt;/p&gt;&lt;h2&gt;加法结合律&lt;/h2&gt;&lt;p&gt;那么我们来试着证明一下加法的结合律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusComb :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :+: (m :+: p) === n :+: m :+: p&lt;/code&gt;&lt;p&gt;我们对 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 进行归纳：&lt;/p&gt;&lt;p&gt; 当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 0 的时，在加法中的 0 会直接消除，所以使用 &lt;code class=&quot;inline&quot;&gt;refl (m + p)&lt;/code&gt; 就好了；&lt;/p&gt;&lt;p&gt; 当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S n1&lt;/code&gt; 时，把等式两边的 S 用 &lt;code class=&quot;inline&quot;&gt;EqS&lt;/code&gt; 提取出来，再使用归纳假设就可以了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusComb :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :+: (m :+: p) === n :+: m :+: p
  plusComb Zero p q = refl (p + q)
  plusComb (Succ n) m p = EqS $ plusComb n m p&lt;/code&gt;&lt;h2&gt;加法交换律&lt;/h2&gt;&lt;p&gt;那么再尝试一下稍微困难一点的加法交换律吧&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusCommutes :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: m === m :+: n&lt;/code&gt;&lt;p&gt;当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 0 的时，证明很平凡。我们需要的是这么一个类型：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  Nat n -&amp;gt; n :+: Z === n&lt;/code&gt;&lt;p&gt;只需要对 n 进行归纳就好了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  nPlusZero :: n === n -&amp;gt; n === n :+: Z
  nPlusZero EqZ        = EqZ
  nPlusZero (EqS eq) = EqS $ nPlusZero eq&lt;/code&gt;&lt;p&gt;当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S m1&lt;/code&gt; 时，我们需要的东西的类型为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (n :+: S m1) === S (m1 :+: n)&lt;/code&gt;&lt;p&gt;根据归纳法，我们可以得到&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;EqS (plusCommutes n m1) :: S (m1 :+: n) === S (n :+: m1)&lt;/code&gt;&lt;p&gt;借助于相等关系的传递性，目标变成了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; (n :+: S m1) === S (n :+: m1)&lt;/code&gt;&lt;p&gt;而这个命题的证明也只需要对 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 进行归纳&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  nPlusSm :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: S m === S (n :+: m)
  nPlusSm Zero      m = EqS $ refl m
  nPlusSm (Succ n) m = EqS $ nPlusSm n m&lt;/code&gt;&lt;p&gt;把这些步骤拼起来，就得到了我们最终的证明&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plus2 :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: m === m :+: n
  plus2 n Zero = symm $ nPlusZero $ refl n
  plus2 n (Succ m) = nPlusSm n m &amp;lt;=&amp;gt; symm (EqS $ plus2 m n)&lt;/code&gt;&lt;h2&gt;乘法交换律&lt;/h2&gt;&lt;p&gt;看了加法我们再来看乘法&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; multCommute :: Nat n -&amp;gt; Nat m -&amp;gt; n :*: m === m :*: n&lt;/code&gt;&lt;p&gt;证明的方法和加法几乎一样，仍然从归纳法入手，对 n 进行归纳。中间需要用到一些引理，比如&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  multCommuteS :: Nat n -&amp;gt; Nat m -&amp;gt; m :*: S n === m :+: m :*: n
  plusSwap :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: (b :+: c) === b :+: (a :+: c)&lt;/code&gt;&lt;p&gt;等等，这里不再详细说明具体的推导，直接给出实现，有兴趣的同学可以试着自己写一遍&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; equalPlus :: Nat a -&amp;gt; Nat b -&amp;gt; a === b -&amp;gt; Nat c -&amp;gt; a :+: c === b :+: c
 equalPlus a b eq Zero = symm (nPlusZero a) &amp;lt;=&amp;gt; eq &amp;lt;=&amp;gt; nPlusZero b
 equalPlus a b eq (Succ c) = nPlusSm a c &amp;lt;=&amp;gt; Fuck (equalPlus a b eq c) &amp;lt;=&amp;gt; symm (nPlusSm b c)
  
 equalPlus&#39; :: Nat a -&amp;gt; Nat b -&amp;gt; a === b -&amp;gt; Nat c -&amp;gt; c :+: a === c :+: b
 equalPlus&#39; a b eq c = plusCommutes c a &amp;lt;=&amp;gt; equalPlus a b eq c &amp;lt;=&amp;gt; plusCommutes b c
  
 plusSwap&#39; :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: b :+: c === b :+: a :+: c
 plusSwap&#39; a b = equalPlus (a + b) (b + a) (plusCommutes a b)
  
 plusSwap :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: (b :+: c) === b :+: (a :+: c)
 plusSwap a b c = plusCommute a b c &amp;lt;=&amp;gt; plusSwap&#39; a b c &amp;lt;=&amp;gt; symm (plusCommute b a c)
  
 multCommuteS_1 :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: (m :*: S n) === m :+: (n :+: (m :*: n))
 multCommuteS_1 n m = equalPlus&#39; (m * Succ n) (m + m * n) (multCommuteS n m) n &amp;lt;=&amp;gt; plusSwap n m (m * n)
  
 multCommuteS :: Nat n -&amp;gt; Nat m -&amp;gt; m :*: S n === m :+: m :*: n
 multCommuteS _ Zero = Refl
 multCommuteS n (Succ m) = Fuck $ multCommuteS_1 n m
  
 multCommutes :: Nat n -&amp;gt; Nat m -&amp;gt; n :*: m === m :*: n
 multCommutes Zero m = symm $ multNZero m
 multCommutes (Succ n) m = symm
      (multCommuteS n m &amp;lt;=&amp;gt; equalPlus&#39; (m * n) (n * m) (multCommutes m n) m)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;从自然数说开去&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在上面定义的“相等”中，只对自然数进行了规定，那么我们怎么表示任何一种东西相等的概念呢？我们需要对 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 进行修改。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Equal a b where
      Refl :: Equal a a
      Derive :: Equal a b -&amp;gt; Equal (p a) (p b)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 对应之前的 &lt;code class=&quot;inline&quot;&gt;EqZ&lt;/code&gt; , &lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 对应 &lt;code class=&quot;inline&quot;&gt;EqS&lt;/code&gt; 。从定义上我们就能知道相等关系的自反性。&lt;/p&gt;&lt;p&gt;重新定义之后，我们就再也不需要 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 这个函数了，因为直接使用 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 就可以了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;symm&lt;/code&gt; 的定义和原来类似，&lt;code class=&quot;inline&quot;&gt;trans&lt;/code&gt; 则需要一点小小的修改：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; (&amp;lt;=&amp;gt;) :: a === b -&amp;gt; b === c -&amp;gt; a === c
 Refl        &amp;lt;=&amp;gt; Refl        = Refl
 Derive x &amp;lt;=&amp;gt; Refl        = Derive $ x      &amp;lt;=&amp;gt; Refl
 Refl        &amp;lt;=&amp;gt; Derive y = Derive $ Refl &amp;lt;=&amp;gt; y
 Derive x &amp;lt;=&amp;gt; Derive y = Derive $ x      &amp;lt;=&amp;gt; y&lt;/code&gt;&lt;p&gt;为了证明我们定义的 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 不仅仅对自然数有用，我们引入了类型层面的 &lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt; 来增加多样性。&lt;/p&gt;&lt;p&gt;首先是类型定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data T
data F&lt;/code&gt;&lt;p&gt;然后是对应的数据类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Boolean :: * -&amp;gt; * where
      Tr :: Boolean T
      Fa :: Boolean F&lt;/code&gt;&lt;p&gt;对于每一个需要参与证明的函数，我们需要在类型上实现一遍。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;Boolean&lt;/code&gt; 而言，先实现与或非 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type family Inv (n :: *) :: *
 type instance Inv T = F
 type instance Inv F = T
  
 type family (||) (n :: *) (m :: *) :: *
 type instance T || T = T
 type instance F || T = T
 type instance T || F = T
 type instance F || F = F
  
 type family (&amp;amp;&amp;amp;) (n :: *) (m :: *) :: *
 type instance T &amp;amp;&amp;amp; T = T
 type instance T &amp;amp;&amp;amp; F = F
 type instance F &amp;amp;&amp;amp; T = F
 type instance F &amp;amp;&amp;amp; F = F&lt;/code&gt;&lt;p&gt;首先证明双重否定律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  doubleNeg :: Boolean b -&amp;gt; Inv (Inv b) === b
  doubleNeg Tr = Refl
  doubleNeg Fa = Refl&lt;/code&gt;&lt;p&gt;要注意的是，这里并不能把两个分支合在一起写，因为它并不能直接把 &lt;code class=&quot;inline&quot;&gt;Inv (Inv b)&lt;/code&gt; 推导到 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然后是德摩根律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; demorgan :: Boolean a -&amp;gt; Boolean b -&amp;gt; Inv (a &amp;amp;&amp;amp; b) === Inv a || Inv b
 demorgan Tr Tr = Refl
 demorgan Tr Fa = Refl
 demorgan Fa Tr = Refl
 demorgan Fa Fa = Refl&lt;/code&gt;&lt;p&gt;仍然要进行详细的分类讨论，理由同上&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同样的，我们还能利用 Type Family 描述一些性质 ，比如自然数的奇偶性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type family IsOdd (n :: *) :: *
 type instance IsOdd Z = F
 type instance IsOdd (S Z) = T
 type instance IsOdd (S (S n)) = IsOdd n
  
 type family IsEven (n :: *) :: *
 type instance IsEven Z = T
 type instance IsEven (S Z) = F
 type instance IsEven (S (S n)) = IsEven n&lt;/code&gt;&lt;p&gt;试着证明一下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus :: Nat n -&amp;gt; Nat m -&amp;gt; IsOdd (n :+: m) === IsOdd n ^ IsOdd m&lt;/code&gt;&lt;p&gt;因为 &lt;code class=&quot;inline&quot;&gt;IsEven&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;IsOdd&lt;/code&gt; 的递归定义中都有两层的预设，所以我们在用归纳法证明时也需要考虑相应的 3 种情况&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus Zero m :: IsOdd m === (F ^ IsOdd m)&lt;/code&gt;&lt;p&gt;只需要实现这两个函数（它们的实现都是平凡的）&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; falseXor :: Boolean b -&amp;gt; b === F ^ b
 isodd :: Nat a -&amp;gt; Boolean (IsOdd a)&lt;/code&gt;&lt;p&gt;就有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus Zero x = falseXor $ isodd x&lt;/code&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S Z&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 进行归纳，当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;S Z&lt;/code&gt; 时，结果就是 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，而当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S (S m&#39;)&lt;/code&gt; 时，我们需要的类型为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ Zero) (Succ (Succ x)) :: IsOdd (S n3) === (T ^ IsOdd n3)&lt;/code&gt;&lt;p&gt;同样的，只需要把它拎出去，用归纳法再证一遍就好了&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S (S n&#39;)&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们需要的类型为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ (Succ x)) y :: IsOdd (n2 :+: m) === (IsOdd n2 ^ IsOdd m)&lt;/code&gt;&lt;p&gt;利用归纳假设就能直接证明了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ (Succ x)) y = oddPlus x y&lt;/code&gt;&lt;h2&gt;&lt;b&gt;还有什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;注意到我们的很多证明，实际上都只是在类型层面的变化。比如下面这个&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddEvenS :: Nat n -&amp;gt; IsOdd n === IsEven (S n)
 oddEvenS Zero = Refl
 oddEvenS (Succ Zero) = Refl
 oddEvenS (Succ (Succ x)) = oddEvenS x&lt;/code&gt;&lt;p&gt;把递归展开的话就能发现它所有情况下的 “值” 都是 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，但我们不能直接对所有的情况赋 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，因为这个递归是对 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 上的类型进行修改的过程。类型推导不会对 Type Family 中的递归定义进行展开，所以我们还是得自己动手证明一遍。&lt;/p&gt;&lt;h2&gt;“性质” 的表示方法&lt;/h2&gt;&lt;p&gt;我们使用了 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 表示两个类型相等的概念，那么同样的，我们还可以用这种方法描述其它的一元/二元/多元关系，比如我们可以换一种方式表示奇偶性：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Even :: * -&amp;gt; * where
      ZeroEven :: Even Z
      Add2Even :: Even n -&amp;gt; Even (S (S n))
  
data Odd :: * -&amp;gt; * where
      OneOdd :: Odd (S Z)
      Add2Odd :: Odd n -&amp;gt; Odd (S (S n))&lt;/code&gt;&lt;p&gt;或者描述两个自然数的大小关系：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Greater :: * -&amp;gt; * where
      GreZ :: Greater (S Z) Z
      GreS1 :: Greater x y -&amp;gt; Greater (S x) y
      GreS2 :: Greater x y -&amp;gt; Greater (S x) (S y)&lt;/code&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 的局限&lt;/h2&gt;&lt;p&gt;事实上，我们在 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 中定义的 &lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 并不是万能的，比如我们不能这样&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deriveOdd :: Nat n -&amp;gt; n === m -&amp;gt; IsOdd n === IsOdd m
 deriveOdd _ eq = Derive eq -- wrong !&lt;/code&gt;&lt;p&gt;报错信息为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;Couldn&#39;t match type ‘IsOdd n’ with ‘p0 n’
      Expected type : IsOdd n === IsOdd m
      Actual   type    : p0 n === p0 m&lt;/code&gt;&lt;p&gt;它只能对字面量进行推导，比如&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deriveS :: n === m -&amp;gt; S n === S m&lt;/code&gt;&lt;h2&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;你现在应该可以解决下面几道题目&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/singletons&quot;&gt;https://www.codewars.com/kata/singletons&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/odd-plus-even-equals-odd-prove-it&quot;&gt;https://www.codewars.com/kata/odd-plus-even-equals-odd-prove-it&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it&quot;&gt;https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最后一道题证明的是加法交换律，除了文中给出的方法，还有一种更精妙的写法，读者可以试着找一找&lt;/p&gt;&lt;h2&gt;更多练习&lt;/h2&gt;&lt;p&gt;证明乘法交换律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; multCommute :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :*: m :*: p === n :*: (m :*: p)&lt;/code&gt;&lt;p&gt;以及更多你能想到的东西&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>zjuwyd</author>
<guid isPermaLink="false">2017-11-30-31567423</guid>
<pubDate>Thu, 30 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Taba Taba!</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-28-31466428.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Taba Taba!&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31466428&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天发现了篇paper，&lt;a href=&quot;http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf&quot;&gt;http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;就是一个小trick，可以用于在2n pattern match下算出zip l (rev r)&lt;/p&gt;&lt;p&gt;看完以后觉得很简单啊，一点都不像某SM（Selection Monad（特大雾&lt;/p&gt;&lt;p&gt;不过为啥想不到呢，orz&lt;/p&gt;&lt;p&gt;最后：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6eba3265331b7fcae96f281a17bbc0d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;688&quot; data-rawheight=&quot;87&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bc18b93eb1df21c1c6d5d9632b9e58da_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;383&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-11-28-31466428</guid>
<pubDate>Tue, 28 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Lens: 从入门到再次入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-24-31328798.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Lens: 从入门到再次入门&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31328798&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-28c51979d43ba132a98057d07b183025_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;类型补全计画&lt;/h2&gt;&lt;p&gt;从上一篇我们可以看出，Lens 就是整合在一起的 &lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;和 &lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;，借助&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;&lt;i&gt;, &lt;/i&gt;&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;&lt;i&gt;, &lt;/i&gt;&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;这三个函数，我们可以分别使用 Lens 的&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;。但是我们目前的 Lens 类型定义并不是完整的，因此我们首先对 Lens 的类型进行补全。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens s a = Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; (s -&amp;gt; f s)&lt;/code&gt;&lt;p&gt;首先让我们看这样一个例子： &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;set _1 ((1,2),3) 3
set _1 ((1,2),3) True&lt;/code&gt;&lt;p&gt;在我们目前的类型定义上面的代码第一行可以正常工作，而第二行则不可以。但是第二行确实是合乎逻辑的，我们的确有时候需要讲一个原本是数字的地方设置为布尔值或是其他的什么东西。&lt;/p&gt;&lt;p&gt;让我们将原先的 Lens 类型定义进行简单的改变，这样就可以在通过 Lens 对数据操作时改变数据的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens s t a b = Functor f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; (s -&amp;gt; f t)&lt;/code&gt;&lt;p&gt;我们可以可以直观地解读这个新的类型定义的含义，对&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;类型的量的一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;类型的域进行某种操作，之后该域变为&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;，相应的&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;变为&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;。当然这里的&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;的关系并不是随意的，而是依赖于&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;的关系。&lt;/p&gt;&lt;p&gt;现在我们之前使用的 Lens 类型将定义如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens&#39; s a = Lens s s a a
-- Or
{-# LANGUAGE LiberalTypeSynonyms #-}
type Simple f a b = f a a b b
type Lens&#39; = Simple Lens &lt;/code&gt;&lt;p&gt;在这个定义下我们可以定义出由&lt;code class=&quot;inline&quot;&gt;getter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;setter&lt;/code&gt;构建 Lens 的函数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;lens :: (s -&amp;gt; a) -&amp;gt; (s -&amp;gt; b -&amp;gt; t) -&amp;gt; Lens s t a b
lens getter setter f s = setter s &amp;lt;$&amp;gt; f (getter s)&lt;/code&gt;&lt;p&gt;下面让我们来回忆一下&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;over lens f = runIdentity . lens (Identity . f)
view lens b = getConst $ lens Const b &lt;/code&gt;&lt;p&gt;我们发现在&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;分别取&lt;code class=&quot;inline&quot;&gt;Identity&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Const&lt;/code&gt;的时候，Lens 就分别表现出了 &lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;的特性。对于&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;而言，他们只需要使用单一的 Functor ，因此我们可以专门定义&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Getting r s a = (a -&amp;gt; Const r a) -&amp;gt; s -&amp;gt; Const r s
type Setter s t a b = (a -&amp;gt; Identity b) -&amp;gt; s -&amp;gt; Identity t
type Setting = Simple Setter &lt;/code&gt;&lt;p&gt;在有了这个定义之后，我们就可以修改之前三个常用函数的类型签名：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a s a -&amp;gt; b -&amp;gt; a
over :: Setter s t a b -&amp;gt; (a -&amp;gt; b) -&amp;gt; s -&amp;gt; t
set  :: Setter s t a b -&amp;gt; b -&amp;gt; s -&amp;gt; t&lt;/code&gt;&lt;p&gt;这样的改变看似没有什么作用，但通过这样的改变，三个常用函数不再以 Lens 为作用对象，而是更加聚焦于一类更加通用的类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;作为概念积类型的类型与作为概念的值&lt;/h2&gt;&lt;p&gt;通过之前的例子，我们可以看到我们用 Lens 来操作一个&lt;b&gt;积类型(Product Type)&lt;/b&gt;，例如元组、Record 或是列表；于此相对，Lens 不能用来操作&lt;b&gt;和类型(Sum Type)&lt;/b&gt;。我们可以用 Lens 改变或是读取积类型的某个&lt;b&gt;部分(Component)&lt;/b&gt;的值。但是实际上，我们不需要一个&lt;b&gt;实在的&lt;/b&gt;积类型，也不需要一个实在的部分，只需要概念上的积类型与概念上的部分即可。这样的表述显得非常抽象，让我们来看几个例子。&lt;/p&gt;&lt;p&gt;第一个例子是列表，从定义来看，列表的确是一个积类型，它由相继的元素组成，它的各个部分就是各个组成元素。但是，我们将要操作的却不是这些实在的部分，而是抽象的部分，&lt;b&gt;列表的长度&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;让我们定义这个玄乎的&lt;code class=&quot;inline&quot;&gt;_length&lt;/code&gt;Lens ：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_length :: Lens&#39; [a] Int
_length f l = const l &amp;lt;$&amp;gt; f (length l)&lt;/code&gt;&lt;p&gt;可以看出，它可以从一个列表中提取出它的长度，但是不会改变它的长度&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view (_1._length) (&quot;hello&quot;, 3)
--&amp;gt; 5
set (_1._length) 9 (&quot;world&quot;, 3) 
--&amp;gt; (&quot;world&quot;,3)&lt;/code&gt;&lt;p&gt;在这个例子中，长度并不是列表的一个实在的部分，我们操作的积类型也不是一个实在的积类型，而是概念中的某种包含长度的积类型。&lt;/p&gt;&lt;p&gt;再看第二个例子，我们操作一个数字的绝对值。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_abs :: (Num a, Ord a) =&amp;gt; Lens&#39; a a
_abs f i = setabs &amp;lt;$&amp;gt; f (abs i)
  where sgn x
            | x &amp;gt;= 0 = 1
            | x &amp;lt;  0 = -1
        setabs x
               | x &amp;gt;= 0 = x*sgn i
               | x &amp;lt;  0 = error &quot;Abs must be non-negative&quot;
view _abs -123
--&amp;gt; 123
set _abs 13 -99
--&amp;gt; -13&lt;/code&gt;&lt;p&gt;可以看出，概念上，数字确实含有“绝对值”这一部分的值，但是数字与绝对值的关系同样也不是“元组与每个元素”之间的关系，也不是“记录与它的域”的关系。同时，数字本身，并不明显是那种积类型，这里我们同样是将其看作了概念上的积类型。&lt;/p&gt;&lt;p&gt;引入这两个例子的目的是说明，Lens 是某种更加抽象与普遍化的工具，它不仅仅用来处理具体的数据结构与数据结构内部的值，也可以用来处理各种各样的情况；Lens 聚焦于某个数据结构（实在的或是概念上的）的某个值上，这无关乎这个值是实在地存在于这个数据结构里，还是抽象地、概念上地存在于这个数据上，这为我们以后利用 Lens 完成语义的表达提供了可行性。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;多焦点数据操作&lt;/h2&gt;&lt;p&gt;Lens 在工作的过程中，对某个数据结构内某个值应用了一个&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; f b&lt;/code&gt;的函数，并最终得到一个&lt;code class=&quot;inline&quot;&gt;f t&lt;/code&gt;类型的新数据结构。假设现在我们想要操作某个列表&lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;中的所有元素，那么我们期望对列表中的每个元素应用&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; f b&lt;/code&gt;的函数，并且最终得到一个&lt;code class=&quot;inline&quot;&gt;f [b]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于应用某个函数于列表中的每个元素这一任务，我们有非常熟悉的解决方案&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f :: a -&amp;gt; f b
xs :: [a]
---
map f xs :: [f b] &lt;/code&gt;&lt;p&gt;但是我们期望得到的类型是&lt;code class=&quot;inline&quot;&gt;f [b]&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;[f b]&lt;/code&gt;，我们需要一个将函子的列表转换为列表的函子的函数，而实际上，函子没有足够的约束来支持这样的操作，最简单的例子就是，一个空函子的列表我们没法直接找到对应的空列表的函子；此外更一般的场合我们需要将&lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt;合并至&lt;code class=&quot;inline&quot;&gt;f [a]&lt;/code&gt;得到一个新的&lt;code class=&quot;inline&quot;&gt;f [a]&lt;/code&gt;的函数，其类型为&lt;code class=&quot;inline&quot;&gt;f a -&amp;gt; f [a] -&amp;gt; f [a]&lt;/code&gt;，而我们有的列表拼接函数的类型为&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;，这也不是函子的升格可以直接完成的。而应用函子恰巧有我们需要的&lt;code class=&quot;inline&quot;&gt;pure&lt;/code&gt;函数处理第一种情况，又有可以对双参数函数升格的&lt;code class=&quot;inline&quot;&gt;liftA2&lt;/code&gt;。由此看来，我们需要的是使用应用函子代替函子完成我们的需要。&lt;/p&gt;&lt;p&gt;有了这些分析，我们不难写出将函子的列表提取为列表的函子的函数。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;(&amp;lt;:&amp;gt;) :: Applicative f =&amp;gt; f a -&amp;gt; f [a] -&amp;gt; f [a],
(&amp;lt;:&amp;gt;) = liftA2 (:)
sequenceA :: (Applicative f) =&amp;gt; [f a] -&amp;gt; f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = x &amp;lt;:&amp;gt; sequenceA xs&lt;/code&gt;&lt;p&gt;接下来我们需要的操作列表中全部元素的 Lens 的实现也可以容易给出，因为我们先前已经通过&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;实现了&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; f b) -&amp;gt; [a] -&amp;gt; [f b]&lt;/code&gt;，只需再对结果应用刚实现的&lt;code class=&quot;inline&quot;&gt;sequenceA&lt;/code&gt;就可以恰好得到我们需要的 Lens 类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_every :: Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; [a] -&amp;gt; f [b]
_every f xs = sequenceA $ map f xs

over _every (+1) [2,3,4]
--&amp;gt; [3,4,5]&lt;/code&gt;&lt;p&gt;由于应用函子是特殊的函子，所以&lt;code class=&quot;inline&quot;&gt;_every&lt;/code&gt;是特殊的 Lens， 我们将这类 Lens 命名为 Traversal。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Traversal s t a b = Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; s -&amp;gt; f t
type Traversal&#39; s a = Traversal s s a a&lt;/code&gt;&lt;p&gt;取这个名字的原因是，在标准库&lt;code class=&quot;inline&quot;&gt;Data.Traversal&lt;/code&gt;中实际上恰好有一个函数&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt;符合我们的要求， 这个函数并非为 Lens 专门设计，但它的类型恰好与我们先前的&lt;code class=&quot;inline&quot;&gt;_every&lt;/code&gt; 相同，不仅如此这个函数不仅可以在列表上工作，也可以在所有&lt;code class=&quot;inline&quot;&gt;Traversable&lt;/code&gt;类型上工作。由于这类 Lens 操作均依赖于&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt;， 所以取名为 Traversal 。&lt;/p&gt;&lt;p&gt;让我们简单地看一下 Traversal 是如何与&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;一通工作的： &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;traverse :: Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; t a -&amp;gt; f (t b)
over traverse (+1) [2,3,4]
runIdentity . traverse (Identity . (+1)) [2,3,4]
runIdentity $ sequenceA $ map (Identity . (+1)) [2,3,4]
runIdentity $ sequenceA [Identity 3, Identity 4, Identity 5]
runIdentity $ Identity 3 &amp;lt;:&amp;gt; Identity 4 &amp;lt;:&amp;gt; Identity 5 &amp;lt;:&amp;gt; Identity []
runIdentity $ Identity [3, 4, 5]
--&amp;gt; [3,4,5]&lt;/code&gt;&lt;p&gt;但是，现在我们的 Traversal 不能正确与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;工作。 例如，对于下面的代码&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
view traverse [1,2,3]&lt;/code&gt;&lt;p&gt;我们期望的结果是这样的，我们只需要它原封不动地返回即可&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
[1,2,3]&lt;/code&gt;&lt;p&gt;而实际上，我们得到了看似匪夷所思的结果&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&quot;123&quot;
--Ambiguous type variable ‘a0’ arising from a use of ‘print’&lt;/code&gt;&lt;p&gt;让我们展开 Traversal 与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;工作的过程 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ traverse (Const b) [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ sequenceA $ map (Const b) [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ sequenceA  [Const &quot;1&quot;, Const &quot;2&quot;, Const &quot;3&quot;]
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; pure []&lt;/code&gt;&lt;p&gt;我们实际上清楚&lt;code class=&quot;inline&quot;&gt;Const a&lt;/code&gt;本身并非应用函子,&lt;code class=&quot;inline&quot;&gt;Monoid a =&amp;gt; Const a&lt;/code&gt;才是 ，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;类型的值不是“容器”内的值，而是“容器”的一部分，容器内并不存在值。于是，将应用函子范畴上的值应用到应用函子范畴上的函数时，内部并无操作，有的只是“容器”的合并。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Monoid a =&amp;gt; Applicative (Const a) where
  pure _ = Const empty
  (Const x) &amp;lt;*&amp;gt; (Const y) = Const (x &amp;lt;&amp;gt; y)&lt;/code&gt;&lt;p&gt;列表的默认&lt;code class=&quot;inline&quot;&gt;mappend&lt;/code&gt;操作 列表合并，所以我们就可以将上面的计算继续写下去了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; pure []
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; Const &quot;&quot;
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot;
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;23&quot;
getConst $ sequenceA  Const &quot;123&quot;
&quot;123&quot;&lt;/code&gt;&lt;p&gt;可以看出，这并不是匪夷所思的结果，而是在这些定义下的合理结果。实际上，从&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;类型上我们也可以看出它的确做了它应当的工作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a s a -&amp;gt; s -&amp;gt; a

view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
-- view :: Getting String [String] String -&amp;gt; [String] -&amp;gt; String&lt;/code&gt;&lt;p&gt;它最终确实给了我们一个字符串。&lt;/p&gt;&lt;p&gt;所以，我们需要构建专用于 Traversal 的&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数。考虑之前&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a b a -&amp;gt; b -&amp;gt; a
view lens = getConst . lens Const &lt;/code&gt;&lt;p&gt;这里他将原来的值不加改变地喂给了&lt;code class=&quot;inline&quot;&gt;getConst&lt;/code&gt;， 我们可以讲原始值套在一个 Monoid 里完成我们需要的效果。这里，我们需要的就是最终得到一个列表，因此只需要再套一层列表的 Monoid 即可，外面套的这层 Monoid 会互相合并，最终只剩下一个列表，里面排满了原来的元素。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf :: Getting [a] s a -&amp;gt; s -&amp;gt; [a]
toListOf lens = getConst . lens (\x -&amp;gt; Const [x])

toListOf traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
--&amp;gt; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
toListOf traverse [1,2,3]
--&amp;gt; [1,2,3]&lt;/code&gt;&lt;p&gt;这个函数似乎没有多大用处，它原封不动地返回了原本的列表。但是，我们可以依托于&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt; 构建更多更有用的 Traversal。&lt;/p&gt;&lt;p&gt;例如聚焦于一个列表中全部满足某个条件的 Traversal&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_all :: Eq a =&amp;gt; a -&amp;gt; Traversal&#39; [a] a
_all st f s = traverse update s
  where
    update old = if st old then f old else pure old
    
toListOf (_all (/=0)) [1,2,0,3,4,0,5]
--&amp;gt; [1,2,3,4,5] &lt;/code&gt;&lt;p&gt;同时，我们描述过 Traversal 是一种特殊的 Lens， 所以它具有 Lens 各种有用的性质，例如通过互相复合来处理嵌套的列表。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf (traverse.traverse) [[1,2],[1,2,3,4]]
--&amp;gt; [1,2,1,2,3,4]
xs = [[1,2],[1,2,3,4],[4,5,6],[23,4,5,5,4],[1],[2,3]]
over (_all (\x-&amp;gt; length x &amp;lt;= 3 ) .traverse) (+1) xs
-- &amp;gt;[[2,3],[1,2,3,4],[5,6,7],[23,4,5,5,4],[2],[3,4]]&lt;/code&gt;&lt;p&gt;或者与普通的 Lens 复合，来完成复杂的操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf (traverse._1) [(1,2),(3,4),(5,6)]
--&amp;gt; [1,3,5]&lt;/code&gt;&lt;p&gt;需要注意的是，Traversal 是特殊的 Lens，也就是说在 Lens 上多出一些特定的限制，因此 Traversal 与普通 Lens 的复合将会仍然继承这些限制，即 Traversal 与 Lens 的复合仍是 Traversal。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;使用更多 Monoid 来获得多种效果&lt;/h2&gt;&lt;p&gt;在上面我们使用了&lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;这一 Monoid 来实现了合成列表的效果，实际上，我们还可以使用其他Monoid。下面让我们看几个例子。&lt;/p&gt;&lt;p&gt;第一个例子是将包装过的 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;作为一个 Monoid，并取名为 &lt;code class=&quot;inline&quot;&gt;First&lt;/code&gt; 。从名字我们也可以看出来，它的作用就是取出列表的首个元素。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype First a = First (Maybe a)

instance Monoid (First a) where
  mempty = First Nothing
  mappend (First Nothing) y = y
  mappend        x        _ = x

preview :: Getting (First a) s a -&amp;gt; s -&amp;gt; Maybe a
preview lens = getFirst . getConst . lens (Const . First . Just)

preview (_all (/=0)) [3, 2, 1, 0]
--&amp;gt; Just 3

preview (_all (/=0)) [0,0,0]
--&amp;gt; Nothing&lt;/code&gt;&lt;p&gt;同样，修改 &lt;code class=&quot;inline&quot;&gt;mappend&lt;/code&gt;的定义我们可以得到 &lt;code class=&quot;inline&quot;&gt;Last&lt;/code&gt;，这里不再具体给出。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;第二个例子是包装过的&lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt;，我们可以用它来判断一个列表中是否含有某个元素&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Any = Any { getAny :: Bool }

instance Monoid Any where
  mempty = Any False
  Any x `mappend` Any y = Any (x || y)
  
has :: Getting Any s a -&amp;gt; s -&amp;gt; Bool
has l = getAny . getConst . l (const $ Const (Any True)) 

has (_all (==0)) [3, 2, 1, 0]
--&amp;gt; True&lt;/code&gt;&lt;p&gt;我们发现，由于 Traversal 具有良好的抽象能力，我们仅仅选用不同的 Monoid 就实现了多种多用的效果，这无疑是非常令人振奋的。&lt;/p&gt;</description>
<author>孙浩然</author>
<guid isPermaLink="false">2017-11-24-31328798</guid>
<pubDate>Fri, 24 Nov 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
