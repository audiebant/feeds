<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Tue, 05 Dec 2017 04:53:39 +0800</lastBuildDate>
<item>
<title>在Haskell中模拟dependent type</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-04-31690842.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;在Haskell中模拟dependent type&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31690842&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-49d3d08432de8f11409880942f0bf9a5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;题图的PixivID为：&lt;i&gt;pixiv-ID:&lt;/i&gt; &lt;i&gt;&lt;a href=&quot;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=61127101&quot;&gt;61127101&lt;/a&gt;，画师为&lt;/i&gt;&lt;a href=&quot;https://www.pixiv.net/member.php?id=10710834&quot;&gt;Novelance&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本文始发于&lt;a href=&quot;https://saul-mirone.github.io/2017/12/04/dependent-type-in-haskll/&quot;&gt;我的博客&lt;/a&gt;，转载请注明作者。&lt;/p&gt;&lt;p&gt;Dependent type是一种依赖于值的类型，它增强了类型表达能力，让我们可以构造更强大的类型定义，无论用在定理证明还是用在减少程序出错的可能都是极好的。&lt;/p&gt;&lt;p&gt;本文我们讨论在Haskell中如何合理使用扩展模拟Dependent type。&lt;/p&gt;&lt;h2&gt;入门级LIST&lt;/h2&gt;&lt;p&gt;让我们先从一个简单的List开始，看看没有dependent type的时候，会发生什么。&lt;/p&gt;&lt;p&gt;先定义自然数和一个List结构：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Nat = Zero | Succ Nat
 data List a = Nil | Cons a (List a)
 -- example
 one = Succ Zero -- 1
 two = Succ $ Succ Zero -- 2
 listOne :: List Nat
 listOne = Cons Zero $ Nil -- [0]
 listOne :: List Nat
 listTwo = Cons (Succ Zero) $ Cons Zero Nil -- [1, 0]&lt;/code&gt;&lt;p&gt;此时让我们定义一个&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;函数，根据下标返回List中的元素：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; listIndex :: Nat -&amp;gt; List a -&amp;gt; a
 listIndex Zero (Cons x _) = x
 listIndex (Succ n) (Cons _ xs) = listIndex n xs
 -- example
 listIndex Zero listTwo =&amp;gt; Succ Zero
 listIndex one listTwo =&amp;gt; Zero&lt;/code&gt;&lt;p&gt;此时会产生一个问题：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; listIndex Zero Nil -- 编译通过
 listIndex two listOne -- 编译通过&lt;/code&gt;&lt;p&gt;可以看到，无论是去空数组中取值，还是下标超过了List的总长度这种明显是错误的代码，依然被编译了，一直到运行期才会产生异常。&lt;/p&gt;&lt;h2&gt;升级版LIST—GADT&lt;/h2&gt;&lt;p&gt;现在让我们在类型层面上解决这个问题。我们定先义一个新的List，让它有记录List长度的功能。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Vec a n = VNil a n | VCons a n&lt;/code&gt;&lt;p&gt;但是这个太弱了，几乎是换汤不换药：a和n都是可以由手动控制的，万一制造出了&lt;code class=&quot;inline&quot;&gt;VNil a (Succ Zero)&lt;/code&gt;的类型，编译器只能默默接受。仔细观察，&lt;code class=&quot;inline&quot;&gt;VNil&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;VCons&lt;/code&gt;都是函数，那么它们的类型其实可以写出：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; VNil :: Vec a Zero
 VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (Succ n)&lt;/code&gt;&lt;p&gt;所以我们需要一个叫&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/GADT&quot;&gt;GADT&lt;/a&gt;的扩展来添加第一层限制，它可以让我们在类型定义中约束返回的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; {-# LANGUAGE GADTs #-}
 data Zero
 data Succ n
 data Nat = Zero | Succ Nat
 data Vec a n where
   Nil  :: Vec a Zero
   Cons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (Succ n)
 -- example
 vecOne :: Vec Nat (Succ Zero)
 vecOne = VCons Zero VNil -- [0]
 vecTwo :: Vec Nat (Succ (Succ Zero))
 vecTwo = VCons Zero $ VCons (Succ Zero) VNil -- [1, 0]&lt;/code&gt;&lt;p&gt;这样一来，我们可以通过类型直接约束List的长度了。你也许注意到了，我们为了在类型定义中添加约束而将&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;类型拆分了，这样看上去很蠢，其实我们可以借助一个叫做&lt;a href=&quot;https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html&quot;&gt;DataKinds&lt;/a&gt;的扩展来让编译器自动帮我们做这件事：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; {-# LANGUAGE DataKinds #-}
 data Nat = Zero | Succ Nat
 -- 可以代替
 data Zero
 data Succ n
 data Nat = Zero | Succ n&lt;/code&gt;&lt;p&gt;当然，此时编译器会提醒你在接下来的类型中使用&lt;code class=&quot;inline&quot;&gt;&#39;Zero&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;Succ&lt;/code&gt;来指向那个type constructor来避免歧义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Vec a n where
    VNil  :: Vec a &#39;Zero
    VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (&#39;Succ n)&lt;/code&gt;&lt;p&gt;我们还有最后一个不顺眼的地方：那就是&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;构造器的第二个参数&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;其实应该是&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;类型的，不可能是其它类型，所以我们希望也给它指定好类型，这时候我们就需要&lt;a href=&quot;https://downloads.haskell.org/~ghc/7.8.1-rc1/docs/html/users_guide/kind-polymorphism.html&quot;&gt;KindSignatures&lt;/a&gt;扩展了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Vec :: * -&amp;gt; Nat -&amp;gt; * where
    VNil  :: Vec a &#39;Zero
    VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (&#39;Succ n)&lt;/code&gt;&lt;p&gt;OK，这样就得到了我们的升级版List，它能够通过类型直观的表现出它的长度。但是它还没有解决我们上一节的问题，那就是如何用类型约束index函数的参数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; vecIndex :: Nat -&amp;gt; Vec x b -&amp;gt; x
 vecIndex Zero (VCons x _) = x
 vecIndex (Succ n) (VCons _ xs) = vecIndex n xs&lt;/code&gt;&lt;p&gt;问题依然存在着。&lt;/p&gt;&lt;h2&gt;终极版LIST—TYPE FAMILIES&lt;/h2&gt;&lt;p&gt;现在让我们把注意力集中到&lt;code class=&quot;inline&quot;&gt;vecIndex :: Nat -&amp;gt; Vec x b -&amp;gt; x&lt;/code&gt;这里，既然我们已经用函数来表示出了类型，那么其实只要约束&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;小于 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;就好了，这时我们需要&lt;a href=&quot;https://wiki.haskell.org/GHC/Type_families&quot;&gt;TypeFamilies&lt;/a&gt;扩展来让类型可以重载，这样我们就可以为类型定义一些二元运算了（要支持运算符的话还要添加一个&lt;a href=&quot;https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/data-type-extensions.html&quot;&gt;TypeOperators&lt;/a&gt;扩展）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type family (a :: Nat) :&amp;lt; (b :: Nat) where
  m         :&amp;lt; &#39;Zero     = &#39;False
  &#39;Zero     :&amp;lt; &#39;Succ n   = &#39;True
  (&#39;Succ m) :&amp;lt; (&#39;Succ n) = m :&amp;lt; n&lt;/code&gt;&lt;p&gt;现在还有一个问题，&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;是不能够比较的，因此我们需要创造一个能够比较的版本：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data SNat a where
    SZero :: SNat &#39;Zero
    SSucc :: SNat a -&amp;gt; SNat (&#39;Succ a)&lt;/code&gt;&lt;p&gt;现在我们可以重写我们的&lt;code class=&quot;inline&quot;&gt;vecIndex&lt;/code&gt;了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; vecIndex :: ((a :&amp;lt; b) ~ &#39;True) =&amp;gt; SNat a -&amp;gt; Vec x b -&amp;gt; x
 vecIndex SZero (VCons x _) = x
 vecIndex (SSucc n) (VCons _ xs) = vecIndex n xs
 -- example
 vecIndex (SSucc SZero) vecTwo --成功
 vecIndex (SSucc $ SSucc SZero) vecTwo --报错&lt;/code&gt;&lt;p&gt;非常安全。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在你可以试试这道题目来自己体会一下了：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/54750ed320c64c64e20002e2&quot;&gt;codewars-Singletons&lt;/a&gt;&lt;/p&gt;</description>
<author>mirone</author>
<guid isPermaLink="false">2017-12-04-31690842</guid>
<pubDate>Mon, 04 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译12】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-01-31582536.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Programming Languages: Application and Interpretation【译12】&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31582536&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;审校：&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot; data-hash=&quot;802e5a4b8b40cc8d665968a2ad620302&quot; data-hovercard=&quot;p$b$802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.gitbook.com/book/lotuc/plai-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;12 表示层抉择&lt;/h2&gt;&lt;p&gt;回去看看我们将函数作为值的那个解释器，你能找到其中不一致的地方吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;找到了吗？&lt;/blockquote&gt;&lt;p&gt;考虑一下我们是怎么表示这两种值的：数和函数。忽略其外面&lt;code class=&quot;inline&quot;&gt;numV&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;closV&lt;/code&gt;这一层，注意它们底层的数据表示。我们使用Racket中的数来表示要解释的语言中的数，但是我们没有使用Racket中的函数（闭包）来表示要解释的语言中的函数（闭包）。&lt;/p&gt;&lt;p&gt;这就是不一致的地方。更一致的做法是，要么都用Racket中的值表示，要么都&lt;b&gt;不&lt;/b&gt;用。那么我们为什么要做出这种决定呢？&lt;/p&gt;&lt;p&gt;这么做是要说明一个问题。本章我们就讨论此问题。&lt;/p&gt;&lt;h2&gt;12.1 改变表示&lt;/h2&gt;&lt;p&gt;我们暂且探究一下数。Racket中数很强大所以我们重用它：它支持任意大小的整数（&lt;b&gt;bignum&lt;/b&gt;）、有理数（这点受益于整数的bignum表示）、复数等等。因此，它能表示出大部分常规语言中的数系统。然而，这并不意味着它就是我们&lt;b&gt;想要的&lt;/b&gt;：它可能过于简单或者过于复杂：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果我们需要的是某种受限的数系统，它就过于复杂了。例如Java中规定了一组定长的数的表示（如：int被指定为32位的）。超出这个规定范围的数在Java中将不能直接被表示，同时算术运算也遵循此范围（例如：由于溢出，1加2147483647将&lt;b&gt;不能&lt;/b&gt;得到2147483648）。&lt;/li&gt;&lt;li&gt;如果我们需要更为丰富的数系统，它又会捉襟见肘，比如包含四元数或者和概率相关的数。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;糟糕的是，我们根本没有想过自己的需求，就直接轻率的使用Racket中的数作为我们语言中数的表示。&lt;/p&gt;&lt;p&gt;之所以这样做，是因为我们并不关心数本身；我们关心的是诸如将函数作为值这样的编程语言特性。然而，作为语言设计者，你应当在最开始的时候就考虑到这些问题。&lt;/p&gt;&lt;p&gt;接下来讨论闭包的表示。我们其实可以利用Racket的闭包来表示目标语言中的对应概念，与之对应的，用Racket中最基本的函数调用来实现目标语言中的函数调用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;使用Racket函数替换之前闭包的实现。&lt;/blockquote&gt;&lt;p&gt;答案在此：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Value
  [numV (n : number)]
  [closV (f : (Value -&amp;gt; Value))])

(define (interp [expr : ExprC] [env : Env]) : Value
  (type-case ExprC expr
    [numC (n) (numV n)]
    [idC (n) (lookup n env)]
    [appC (f a) (local ([define f-value (interp f env)]
                        [define a-value (interp a env)])
                  ((closV-f f-value) a-value))]
    [plusC (l r) (num+ (interp l env) (interp r env))]
    [multC (l r) (num* (interp l env) (interp r env))]
    [lamC (a b) (closV (lambda (arg-val)
                         (interp b
                                 (extend-env (bind a arg-val)
                                             env))))]))
&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;注意到一个有趣的变化。之前的实现中，环境是在解释appC时被扩展的。这里它是在lamC的解释过程中被扩展的。是这两个中有一个出错了吗？如果不是的话，为什么会出现这种情况？&lt;/blockquote&gt;&lt;p&gt;这种实现方式显然更为简洁，但是我们失去了一项重要的东西：&lt;b&gt;理解&lt;/b&gt;。告诉别人源语言中的函数对应于lambda等于什么都没说：如果我们已经知道lambda是干嘛的我们可能就不会花时间去研究它；如果不知道的话，这种直接映射的实现方式也不会教给我们啥（而且很可能会让本来就对该概念一无所知的我们更加困惑）。出于同样的理由，我们没有使用Racket中的状态去理解各种对状态的操作。&lt;/p&gt;&lt;p&gt;然而，一旦我们理解了某个特性，使用它来表示将不再是问题。实际上，这样做会使得我们的解释器更为简洁，毕竟我们不再手工实现所有事情。事实上，如果不使用这种表示方式，后面的一些解释器会变得毫无可读性。【注释】尽管如此，我们还是应该注意防范过度使用宿主语言的特性可能招致的风险。&lt;/p&gt;&lt;blockquote&gt;有点像是，“现在我们已经能够通过加一来理解加法，我们可以用加法来定义乘法：不再需要使用加一来定义乘法。”&lt;/blockquote&gt;&lt;h2&gt;12.2 错误&lt;/h2&gt;&lt;p&gt;当程序出错时，程序员需要得到相应的错误信息。直接使用宿主语言特性可能导致用户收到宿主语言中抛出的错误，这些错误将无法被理解。因此，我们需要谨慎的将各种情况的错误翻译成我们语言的用户所能理解的术语，且不让宿主语言中的错误信息“泄漏过来”。&lt;/p&gt;&lt;p&gt;更糟糕的情形是，那些本应出错的程序可能不会报错！例如，假设我们设计时决定让函数只出现在顶层位置，如果我们没有特意地检测这点，其被去语法糖后得到lambda，最后可能在解释器中被解释得到结果，而它本来应该使解释器出错停止。因此，我们应该极其注意，&lt;b&gt;仅允许符合期望的表层语言被映射到宿主语言中&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;再举个例子，考虑不同的赋值操作。在我们的语言中，给未绑定的变量赋值会导致错误。但是在有些语言中，这种操作会导致该变量被定义。语言设计者常犯的错误是没有很好的确定想要的语义，然后推脱说“它就是实现出来的那个样子”。这种态度（a）是懒惰、马虎的，（b）可能招致不可预料、负面的后果，（c）它使得将语言从一个实现平台移到另一个实现平台变得困难。不要犯这个错误！&lt;/p&gt;&lt;h2&gt;12.3 改变含义&lt;/h2&gt;&lt;p&gt;将作为值的函数映射为lambda之所以可行是因为我们本来就希望它们&lt;b&gt;拥有相同的含义&lt;/b&gt;。但是这种实现方式使得改变函数的含义变得极为困难。让我给你设想一个情形：假设我们想要实现动态作用域。【注释】在我们原来的解释器中，这很简单（历史告诉我们，简直太简单了）。试着在使用了lambda的解释器中实现动态作用域。同样的，将及早求值（eager evaluation）特性映射到惰性求值（lazy application）的语言中（译注，第17章）也是挺有难度的，或者说至少不太容易。&lt;/p&gt;&lt;blockquote&gt;只是假设而已。&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;将上面的解释器改成动态作用域的。&lt;/blockquote&gt;&lt;p&gt;重点是，使用自己构造的数据结构并不会使事情更为简单，但一般来说也不会使事情变得更为复杂；与之相对，映射成语言本身特性的方式会使某些特性——通常是宿主语言中已有的特性——的实现极为简单，但是使其他特性的实现变得微妙或困难。还有一个风险是，我们可能并不十分清楚宿主语言的某个特性具体实现了些什么（比如，“lambda”是否真的实现了静态作用域？）。&lt;/p&gt;&lt;p&gt;教训是，仅当我们想要“保留”底层语言的意义时，这才是好用的——甚至是特别明智的，因为它确保我们不会意外地改变其意义。但是，如果我们要利用基础语言的重要组成部分，而只是扩展它的含义，那么其他的实现策略可能也不错（译注，第13章），而不是编写解释器。&lt;/p&gt;&lt;h2&gt;12.4 另一个例子&lt;/h2&gt;&lt;p&gt;我们再考虑改变一个特性的表示方式。还记得环境是什么吗？&lt;/p&gt;&lt;p&gt;环境是名字到值（如果有赋值的话，那么是名字到地址）的&lt;b&gt;映射&lt;/b&gt;。我们通过自建的数据结构实现了这种映射，但是我们可以通过其他方式实现映射吗？当然可以，使用函数就行！这样，环境就变成了读入名字为参数、返回其绑定值（或者报错）的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias Env (symbol -&amp;gt; Value))
&lt;/code&gt;&lt;p&gt;空的环境是什么？对于任何名字的查询都抛出错误的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (mt-env [name : symbol])
  (error &#39;lookup &quot;name not found&quot;))
&lt;/code&gt;&lt;p&gt;（原则上我们应该给它的返回值添加类型注解，应该是Value，但是在这里没啥意义）。给环境添加新的绑定就是创建新函数，该函数检查该名字是不是正在扩展的那个绑定；如果是，直接放回对应的绑定值，如果不是，往被扩展的环境传就行。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (extend-env [b : Binding] [e : Env])
  (lambda ([name : symbol]) : Value
    (if (symbol=? name (bind-name b))
        (bind-val b)
        (lookup name e))))
&lt;/code&gt;&lt;p&gt;最后，怎么再环境中查询某个名称呢？&lt;b&gt;调用&lt;/b&gt;该环境即可。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (lookup [n : symbol] [e : Env]) : Value
  (e n))
&lt;/code&gt;&lt;p&gt;大功告成！&lt;/p&gt;</description>
<author>lotuc</author>
<guid isPermaLink="false">2017-12-01-31582536</guid>
<pubDate>Fri, 01 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译11】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-01-31582483.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Programming Languages: Application and Interpretation【译11】&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31582483&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;审校：&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot; data-hash=&quot;802e5a4b8b40cc8d665968a2ad620302&quot; data-hovercard=&quot;p$b$802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.gitbook.com/book/lotuc/plai-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;11 内存管理&lt;/h2&gt;&lt;h2&gt;11.1 垃圾&lt;/h2&gt;&lt;p&gt;&lt;b&gt;垃圾&lt;/b&gt;（garbage）指的是已分配但是不再需要的内存。典型的编程语言的运行时系统采用两种不同的内存分配方式。一种是分配给环境；这种分配方式要和静态作用域保持一致，所以它只需要支持推入（push）和弹出（pop）操作。函数调用返回时，为其环境分配的空间也被返回，供后续函数使用，看似没有成本。【注释】与之相对，在贮存中分配的内存必须伴随某个值的一生，可能要超过其创建位置的作用域——事实上，它可能一直存活下去。因此，我们需要不同的策略来回收在贮存中分配空间所产生的垃圾。&lt;/p&gt;&lt;blockquote&gt;并非没有成本。硬件必须执行“弹出”指令。这&lt;b&gt;不见得&lt;/b&gt;就一定比其他内存管理策略更高效。&lt;/blockquote&gt;&lt;p&gt;空间回收的方法有很多，大体可以分到两个阵营中：人工和自动。人工的方式依赖于开发者能够了解内存的使用，并正确的释放不需要的内存。一般认为，人并不擅长做这种事（虽然在某些情况下，人类拥有机器所无法获取的知识）。因此，几十年来，自动化的方法越来越普及。&lt;/p&gt;&lt;h2&gt;11.2 什么样的垃圾回收是“正确的”？&lt;/h2&gt;&lt;p&gt;垃圾回收既不应该太早地收回空间（&lt;b&gt;可靠性&lt;/b&gt;，soundness）也不能太晚（&lt;b&gt;完备性&lt;/b&gt;，completeness）。虽然两者都可以被视为缺陷，但是它们的影响并不是对称的：可以说，过早收回糟糕得多。这是因为，如果过早回收了某个贮存地址，计算将继续，并可能将其他数据写入该地址，从而访问到无意义的数据。往好了说，这会导致程序不正确，极端情况下后果更严重，比如可能会导致安全问题。反之，过迟收回会导致性能损失，并且可能最终导致程序终止，尽管此时理论上存在理论上可用的内存。这种性能损失以及程序过早终止很令人讨厌，在某些关键任务系统中可能会导致重大问题，不过，至少程序不会进行无意义的运算。&lt;/p&gt;&lt;p&gt;理想情况下，我们希望拥有所有的这三项：自动化（automation），可靠性和完备性。然而，这里我们面对的是不可兼得的情形，最多只能选择两项。理想的人类能够做到可靠性和完备性，但实践中实现其中一个都很少见。【注释】计算机可以实现自动化，同时可以提供可靠性和完备性中的一个，但可计算性论证表明，自动化的计算过程不能同时达成这两者。实践中，自动化技术一般选择实现可靠性，出于以下原因：（a）它造成的损害最小；（b）它相对更容易实现；（c）在添加一些人工帮助的情况下，可以接近完备性。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;你&lt;/b&gt;当然是完美的，但是你的程序员同行呢？顺便说一下，经济学理论在等你验证呢。&lt;/blockquote&gt;&lt;h2&gt;11.3 人工回收&lt;/h2&gt;&lt;p&gt;人工的最彻底的方式是将所有内存回收交由人操作。例如，在C语言中提供了两个基本指令：&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;用于分配内存，&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;用于释放内存。&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;的输入是（内存的）大小，返回是对贮存的引用；&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;的输入是这种引用，释放其占用的内存。&lt;/p&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;       “在当代欧美语言，&quot;Moloch&quot;摩洛这个词有特定的引申义，指代需要极大牺牲的人物或者事业。”——维基百科，摩洛词条&lt;br&gt;        “我不认为这个名字听起来像malloc是巧合。”——Ian Barland&lt;br&gt;&lt;/code&gt;&lt;/blockquote&gt;&lt;h2&gt;11.3.1 完全人工回收的代价&lt;/h2&gt;&lt;p&gt;先来考虑一下这些操作的复杂度。首先我们假设&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;有个指向贮存的关联寄存器（比如&lt;code class=&quot;inline&quot;&gt;new-loc&lt;/code&gt;），每次分配的时候直接获取下一个可用地址。这个模型非常简单——可惜只是看上去简单而已。问题出在当你需要用&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;释放内存时。如果调用&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;针对的是最后一次&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;分配的内存，那么没有问题；但是贮存中数据一般不遵堆栈的规律。如果释放的不是最新分配的内存，将会在贮存中留下空洞。空洞会导致&lt;b&gt;碎片化&lt;/b&gt;（fragmentation），最坏的情况下，即使贮存中有足够的空间，也无法分配任何对象——许多分割的碎片，没有一个足够大。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;原则上，我们可以通过使所有空余空间相邻来解决碎片化的问题。怎么达成这一点？仔细考虑所有的后果，然后描述一下如何手工进行这项工作。&lt;/blockquote&gt;&lt;p&gt;在大多数手动内存管理方案中，碎片化仍然是个不可克服的问题，不过在这个看上去很简单的方案里还有其他东西值得考虑。释放某个值之后会发生什么？运行时系统需要用某种方式记录这块内存可被分配。它是通过维护&lt;b&gt;空闲表&lt;/b&gt;——空闲空间的链表——来达成这点的。稍作思考就会想到问题，空闲表存在哪，&lt;b&gt;它的&lt;/b&gt;内存又由谁来管理呢？答案是空闲表存放在空闲的内存单元格中，这就意味着内存分配时存在最小分配单元。&lt;/p&gt;&lt;p&gt;那么，原则上，每次&lt;code class=&quot;inline&quot;&gt;malloc&lt;/code&gt;现在必须遍历空闲表以找到合适的位置。说“合适”是因为分配者必须做出复杂的决定。遇到第一个匹配的空间就分配呢还是继续找找？而且“匹配”又是怎么定义的呢？应该选取那些大小刚好的空间，还是将大些的空间拆分成小块（从而增加创建不可用的小空间的可能性）？还有其它诸多问题。&lt;/p&gt;&lt;p&gt;程序员希望内存分配高效。【注释1】因此，实践中，分配系统倾向于只使用一组固定的尺寸，通常是2的幂。这样我们就可以不是只维护一个空闲表，而是为每个尺寸（都是2的幂）维护一个空闲表。然后再维护一个指向这些表的数组，位操作可以减小数组索引的代价。当然，这样会浪费一些空间，因为当需要那些不是2的幂尺寸的内存时，最终分配给其的内存尾部将会有空余。（这是计算机科学中经典的取舍(trade-off)：空间换时间）。&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;需要将释放的内存放到合适的链表中，有时候还需要将较大块的内存分割成小块以为将来的分配做准备。这个模型中的任何部分都不像看上去的那样高效。【注释2】&lt;/p&gt;&lt;blockquote&gt;如果内存分配不够高效，开发者会尝试各种奇技赢巧来重用程序中的值，这会降低代码的清晰性，很有可能会导致错误。&lt;br&gt;特别地，&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;并不免费（译注：双关）。&lt;/blockquote&gt;&lt;p&gt;当然，所有这些都基于程序员可以写出可靠（忽略完备）程序的基础上。但是他们做不到。&lt;/p&gt;&lt;h2&gt;11.3.2 引用计数&lt;/h2&gt;&lt;p&gt;由于完全手工内存回收给程序员带来极大的负担，一些半自动化技术被广为使用，最为人知的便是&lt;b&gt;引用计数&lt;/b&gt;（reference counting）。&lt;/p&gt;&lt;p&gt;使用引用计数的方式，每个值都关联一个计数，记录对其引用的个数。程序员负责负责递增和递减这些计数。当计数降为0时，该值的空间可以安全的回收供未来使用。&lt;/p&gt;&lt;p&gt;请注意，上面简单的定义中隐藏了两个重要假设：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;程序员可以记录每一次引用。回忆一下，别名也是引用。因此，当写出下面的代码时，&lt;code class=&quot;inline&quot;&gt; (let ([x &amp;lt;some value&amp;gt;])&lt;br&gt;   (let ([y x])&lt;br&gt;     ..))&lt;br&gt;&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;text&quot;&gt;程序员需要记住y是对x引用的那个值的第二次引用，因此要增加该值的引用计数。&lt;/code&gt;&lt;ol&gt;&lt;li&gt;每个值只有有限个引用。如果数据中存在环路，这条假设不成立。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于需要手动递增和递减引用，这种技术缺乏可靠性与完备性。事实上，上述第二个假设自然导致完备性的丧失，而第一个假设则指出了最简单的方式来打破可靠性。&lt;/p&gt;&lt;p&gt;手工管理内存的弊端还可以更为深层隐晦。由于程序员负责释放内存（或者，等效的，管理引用计数），内存管理策略必须成为每个库接口的一部分：即，“库中分配的值谁来释放？库会否释放传递给它的值？”很不幸，用文档准确记录、并遵守这种策略信息极其困难，更糟的是，它会导致文档中充斥关于底层的细节，它们通常与库要封装的行为毫无关系。&lt;/p&gt;&lt;p&gt;一个有趣的想法是将计数值的增减&lt;b&gt;自动化&lt;/b&gt;。另一个想法是在实现中添加循环检测（cycle-detection）。引入这两者将解决上述的很多问题，但是引用计数还有一些其它问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;引用计数会增加每个对象的大小。计数器需要足够大以防止溢出，又要足够小以避免过多的内存占用。&lt;/li&gt;&lt;li&gt;对这些计数器值的增减花费的时间会相当可观。&lt;/li&gt;&lt;li&gt;如果一个对象的引用计数降至0，那么它所引用的所有内容的计数值都需要减一，这种行为可能会是递归的。这意味着一次释放操作可能会花费大量时间，除非使用聪明的“惰性（lazy）”技巧（这样的话又会导致内存占用增加）。&lt;/li&gt;&lt;li&gt;为了减少计数值，我们需要遍历已经是垃圾的对象。这看上去很违反直觉：遍历我们已经不感兴趣的对象。工程实践中这会产生后果：这些我们不感兴趣的对象有可能已经很久没有被访问过了，这意味着它们可能被换页换出内存了。引用计数器需要将它们换页回内存，仅为了告诉它们它们不再被需要了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;出于所有这些原因，应谨慎引用计数。你不应接受它作为默认，而是应该问自己，为什么拒绝通常被认为更好的自动化技术。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如果引用计数溢出了，哪些正确性属性被破坏，是怎么被破坏的？权衡利弊。&lt;/blockquote&gt;&lt;h2&gt;11.4 自动回收，或垃圾收集&lt;/h2&gt;&lt;blockquote&gt;有些人认为引用计数是“垃圾收集”技术的一种。我更喜欢用后一个术语来指完全自动的技术。但是浏览网页时请注意可能的混淆。&lt;/blockquote&gt;&lt;p&gt;现在让我们来简要地考察一下让语言的运行时系统自动化回收垃圾的过程。我们将使用缩写GC（&lt;b&gt;Garbage Collection&lt;/b&gt;）同时指代垃圾回收的算法与垃圾回收的过程，上下文可以帮你区分具体指代哪个。&lt;/p&gt;&lt;h2&gt;11.4.1 概览&lt;/h2&gt;&lt;p&gt;所有GC算法的核心是通过值间引用关系遍历内存。遍历从&lt;b&gt;根集&lt;/b&gt;（root set）开始，也就是是程序可能引用贮存中值的所有地方。通常，根集由环境中的绑定变量以及全局变量组成。在实际实现中，还需要考虑到类似寄存器中的引用这种易逝值。从根集开始，算法使用一系列算法——通常是深度优先搜索【注释】的变体——来遍历所有可访问的值，以识别所有&lt;b&gt;存活的&lt;/b&gt;值（即，通过一些程序操作的序列可用到的值）。按定义所有其它数据就是垃圾。不同的算法使用不同的方式回收这些空间。&lt;/p&gt;&lt;blockquote&gt;通常选用深度优先搜索，因为它适用于基于堆栈的实现。当然，你可能（也应该）想知道GC自己的栈存储在哪里！&lt;/blockquote&gt;&lt;h2&gt;11.4.2 事实和可证性&lt;/h2&gt;&lt;p&gt;如果你仔细阅读的话，你会发现上面我描述了一个&lt;b&gt;算法&lt;/b&gt;。这是&lt;b&gt;实现的细节&lt;/b&gt;，而不是&lt;b&gt;规范&lt;/b&gt;的一部分！垃圾回收的规范是&lt;b&gt;事实&lt;/b&gt;（truth）的表述：我们要准确地回收所有是垃圾的值，不多也不少。但是对于任何图灵完备的编程语言，我们都没法得出这一事实，于是我们退而求其次，寻求&lt;b&gt;可证性&lt;/b&gt;（provability）。上述的算法描述提供了存活性的有效“证明”，其补集就是垃圾。这个方案当然还有变种，收集更多或更少的垃圾，取决于证明“垃圾性”的不同强度。&lt;/p&gt;&lt;p&gt;上面的说的最后一点指出了严格规范术语描述中的缺陷，对于要回收多少垃圾它完全没有说明。考虑一下极端情况实际上是有益的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义一个可靠的垃圾回收策略很简单。同样，定义一个完备的的垃圾回收策略也非常简单。你能想到怎么做吗？&lt;/blockquote&gt;&lt;p&gt;要做到可靠，我们只要确保不会错误的移除任何可能存活的数据。一种确保无疑的方式就是&lt;b&gt;完全不回收垃圾&lt;/b&gt;。与之对应，完备的GC回收&lt;b&gt;所有东西&lt;/b&gt;。显然这两者都是无用的（后者显然极其危险）。这为我们的工程实践指明了一点，我们不仅需要GC是可靠的，也希望它足够完备，同时还要足够高效。&lt;/p&gt;&lt;h2&gt;11.4.3 核心假设&lt;/h2&gt;&lt;p&gt;能够可靠地执行GC依赖于两条关键的假设。一条有关语言的实现，另一条有关语言的语义。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;对语言中的值，GC需要知道该值的类型以及它在内存中的表示法。例如，当遍历到&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;单元，它必须知道：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;这是一个&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;单元；因此，&lt;/li&gt;&lt;li&gt;它的&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;在哪里，例如位于4个字节的偏移量的地方，&lt;/li&gt;&lt;li&gt;它的&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;在哪里，例如位于8个字节的偏移量的地方。&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;显然，这个属性必须递归地保持，使得遍历算法能够正确映射内存中的值。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;程序不能通过下面两种方式&lt;b&gt;生成&lt;/b&gt;引用：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;对象引用不能发生在语言实现预先定义的根集之外。&lt;/li&gt;&lt;li&gt;对象引用只能指向对象中明确定义的点。&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;违反第二条时，GC将完全乱套，错误的解释数据。第一条看上去显而易见，如果它被违反，意味着运行时系统错误地理解语言的语义。然而这条的后果有点微妙，下面将会讨论。&lt;/p&gt;&lt;h2&gt;11.5 保守垃圾回收&lt;/h2&gt;&lt;p&gt;上文说过，一般根集包含环境、全局变量和一些易逝值。引用还可能出现在什么地方？&lt;/p&gt;&lt;p&gt;在大部分语言中，没有其他地方了。但是有些语言（说的就是你们，C和C++）允许将引用转换成数，以及将任意数转换成引用。因此，原则上，程序中的&lt;b&gt;任何&lt;/b&gt;数值（由于C和C++类型系统的特性，程序中几乎任何值）都可以被视为引用。&lt;/p&gt;&lt;p&gt;两个原因使得它问题重重。首先，GC不能只将其注意力集中到一个较小的根集；现在整个贮存都是潜在的根集。其次，如果GC试图以任何方式修改某个对象——例如在遍历时记录一个“访问”位——这时它可能修改了一个&lt;b&gt;非引用&lt;/b&gt;值：例如，它可能实际上改变了程序中某个（看似无关的）数型常量。因此，像C和C++这样的语言中的特征组合起来，使得合理而有效的GC非常困难。&lt;/p&gt;&lt;p&gt;但并不是不可能。一个令人兴奋的研究方向——称为&lt;b&gt;保守&lt;/b&gt;GC——成功的为此类语言创造了足够高效的GC系统。保守（conservative）GC背后的基本原则是，尽管理论上每个贮存地址都可能属于根集，但实际上它们大部分都不是。它会通过一系列聪明的观察来推断出哪些位置肯定不是引用（这点和传统GC相反），然后将它们安全地&lt;b&gt;忽略&lt;/b&gt;掉：例如，在字节对齐的体系架构中，奇数值不可能为引用。通过忽略大部分贮存，通过对程序行为作出一些基本的假定（例如程序不可能产生某种类型的引用），并且小心操作不去修改贮存（例如，不改变值中的比特，不移动数据）的情况下，可以得到一个还算有效的GC策略。&lt;/p&gt;&lt;blockquote&gt;刻鹄类鹜。&lt;/blockquote&gt;&lt;p&gt;保守GC在那些使用或者依赖C和C++实现的编程语言中比较常见。例如，早期的Racket就完全依靠它。这是基于以下原因：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它是种便捷的自举技术，语言实现者能得以将精力集中在其它更富革新性的特性上。&lt;/li&gt;&lt;li&gt;如果语言能控制所有的引用（比如Racket），那么可以使用便于提高GC效率的内存表示法（例如，用1填充所有(真正的)数的最低有效位）。&lt;/li&gt;&lt;li&gt;它使得该语言和C以及C++实现的库交互变得容易（当然前提是这些库也符合该技术的要求）。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里需要解释一下名词。如前所述，&lt;b&gt;所有&lt;/b&gt;实用的GC技术都是“保守的”，也就是说它们用（潜在的）可访问性代替真实中的是否访问。然而，“保守”这个词已经成为专门的术语，指在&lt;b&gt;不合作&lt;/b&gt;（但不是&lt;b&gt;故意对抗&lt;/b&gt;）的运行时系统中工作的GC技术。&lt;/p&gt;&lt;h2&gt;11.6 精确垃圾回收&lt;/h2&gt;&lt;p&gt;在传统的GC术语中，“保守”的反义词是&lt;b&gt;精确&lt;/b&gt;（precise）。这也是误称，因为GC不可是精确的，即同时做到可靠和完备。这里精确更多是对识别引用能力的表述：当面对值时，精确GC知道什么是和不是引用，以及引用的位置在哪。相对保守GC，这省去了猜测哪些值不是引用（并以此尽可能多地消除潜在引用）这项繁重的工作。&lt;/p&gt;&lt;p&gt;大多数当代语言的运行时系统使用精确GC，而精确GC领域中存在大量的实现技术。我推荐&lt;a href=&quot;ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps&quot;&gt;Paul Wilson 的调查报告&lt;/a&gt;（虽然这份材料有点显老，但在这个快速发展的领域中仍是很好的资源）和&lt;a href=&quot;https://www.cs.kent.ac.uk/people/staff/rej/gc.html&quot;&gt;Richard Jones&lt;/a&gt; 的书和资料。最后，对于世代垃圾收集器的概述，可以读一下&lt;a href=&quot;http://www.cs.princeton.edu/~appel/papers/143.ps&quot;&gt;简单的世代垃圾收集器和快速分配&lt;/a&gt;。&lt;/p&gt;</description>
<author>lotuc</author>
<guid isPermaLink="false">2017-12-01-31582483</guid>
<pubDate>Fri, 01 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Haskell 中的“定理证明”</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-30-31567423.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Haskell 中的“定理证明”&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31567423&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-24cc9824870cdcc4194b2c0ec0097d23_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;题图：鲸 | 花生( •̀ ω •́ ) [pixiv] &lt;a href=&quot;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=66023124&quot;&gt;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=66023124&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;这篇文章讲了什么&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;i&gt;这是一篇休闲向文章&lt;/i&gt;&lt;/p&gt;&lt;p&gt;总结了 Codewars 上面的几道证明题的思想并加以延拓，希望读者能在看完这篇文章之前/之后解决练习中的题目。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面是正文&lt;/p&gt;&lt;hr&gt;&lt;p&gt;众所周知，Haskell 并没有真正意义上的 dependent type，但通过一些技巧 （利用GADT）可以“模拟”dependent type，并可以通过其证明一些定理。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;利用 GADT 模拟 Dependent Type&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先我们需要作为&lt;b&gt;值&lt;/b&gt;的类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Z
 data S n&lt;/code&gt;&lt;p&gt;注意到，这里的 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;n 都只是单纯的类型，你甚至不能构造出相应类型的值出来。&lt;/p&gt;&lt;p&gt;所以我们需要把它们与实际存在的值联系起来&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Nat a where
      Zero :: Nat Z
      Succ :: Nat a -&amp;gt; Nat (S a)&lt;/code&gt;&lt;p&gt;于是我们有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (Succ Zero) :: Nat (S Z)
  (Succ (Succ Zero)) :: Nat (S (S Z))&lt;/code&gt;&lt;p&gt;这样我们获得了在类型层次上的自然数，并保持了它与实际的值的同构关系。&lt;/p&gt;&lt;p&gt;光有自然数是没有意义的，我们需要赋予它们运算的能力。&lt;/p&gt;&lt;p&gt;那么 &lt;code class=&quot;inline&quot;&gt;Nat n&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;Nat m&lt;/code&gt; 相加的结果应该是什么呢？&lt;/p&gt;&lt;p&gt;首先它应该是一个 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; ，其次它的类型应该对应于两数相加的结果。&lt;/p&gt;&lt;p&gt;借助于 GHC 的 Type Family 与 Type Operator 扩展，我们可以定义出 合理的 类型层面上的自然数的加法与乘法&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  type family (:+:) (n :: *) (m :: *) :: *
  type instance Z   :+: m = m
  type instance S n :+: m = S (n :+: m)
  
  type family (:*:) (n :: *) (m :: *) :: *
  type instance Z   :*: m = Z
  type instance S n :*: m = m :+: (n :*: m)&lt;/code&gt;&lt;p&gt;然后是数据层面的自然数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  infixl 4 +
  (+) :: Nat n -&amp;gt; Nat m -&amp;gt; Nat (n :+: m)
  Zero + a = a
  (Succ x) + a = Succ (x + a)
  
  infixl 5 *
  (*) :: Nat n -&amp;gt; Nat m -&amp;gt; Nat (n :*: m)
  Zero * _ = Zero
  (Succ x) * m = m + x * m&lt;/code&gt;&lt;p&gt;有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (Succ (Succ Zero)) * (Succ (Succ Zero)) :: Nat (S (S (S (S Z))))&lt;/code&gt;&lt;p&gt;基于类型上的自然数，我们可以定义 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; (在类型中包含了长度信息的 &lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;)了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  data Vec a n where
      VNil :: Vec a Z
      VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (S n)&lt;/code&gt;&lt;p&gt;长度为 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 与长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 连接起来之后的长度为 &lt;code class=&quot;inline&quot;&gt;n + m&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (++) :: Vec a n -&amp;gt; Vec a m -&amp;gt; Vec a (n :+: m)
  VNil ++ ys = ys
  VCons x xs ++ y = VCons x (xs ++ y)&lt;/code&gt;&lt;p&gt;把长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 重复 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 次之后得到的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 的长度为 &lt;code class=&quot;inline&quot;&gt;n * m&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  repeat :: Nat n -&amp;gt; Vec a m -&amp;gt; Vec a (n :*: m)
  repeat Zero _ = VNil
  repeat (Succ x) xs = xs ++ repeat x xs&lt;/code&gt;&lt;p&gt;有了长度信息，就有类型安全的 &lt;code class=&quot;inline&quot;&gt;head&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;tail&lt;/code&gt; 了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  headV :: Vec a (S n) -&amp;gt; a
  headV (VCons x _) = x
  
  tailV :: Vec a (S n) -&amp;gt; Vec a n
  tailV (VCons _ xs) = xs&lt;/code&gt;&lt;p&gt;因为 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 作为 GADT 的类型在这里受到了第二个类型参数为 &lt;code class=&quot;inline&quot;&gt;S n&lt;/code&gt; 的束缚，所以可以保证这里的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 不会是 &lt;code class=&quot;inline&quot;&gt;VNil&lt;/code&gt; ，这两个函数都是 &lt;b&gt;完全&lt;/b&gt; 的。&lt;/p&gt;&lt;p&gt;借鉴之前定义类型层面上自然数的加法与乘法的思想，我们可以定义相应的减法、求最大值、最小值等。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  type family (:-:) (n :: *) (m :: *) :: *
  type instance n :-: Z = n
  type instance Z :-: m = Z
  type instance S n :-: S m = n :-: m
  
  type family (:^:) (n :: *) (m :: *) :: *
  type instance Z :^: n = n
  type instance n :^: Z = n
  type instance S n :^: S m = S (n :^: m)
  
  type family (:~:) (n :: *) (m :: *) :: *
  type instance Z :~: m = Z
  type instance n :~: Z = Z
  type instance S n :~: S m = S (n :~: m)&lt;/code&gt;&lt;p&gt;(这里使用了 &lt;code class=&quot;inline&quot;&gt;:~:&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;:^:&lt;/code&gt; 分别代表求最大值和最小值)&lt;/p&gt;&lt;p&gt;于是有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  zip :: Vec a n -&amp;gt; Vec b m -&amp;gt; Vec (a, b) (n :~: m)
  zip VNil _ = VNil
  zip _ VNil = VNil
  zip (VCons x xs) (VCons y ys) = VCons (x, y) (zip xs ys)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;进行简单的定理证明&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Haskell&lt;/code&gt; 中没有 Prop ，所以我们得从头开始描述“相等”这个概念。&lt;/p&gt;&lt;p&gt;首先定义代表两个类型层面的自然数相等的类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Equal a b where
      EqZ :: Equal Z Z
      EqS :: Equal a b -&amp;gt; Equal (S a) (S b)&lt;/code&gt;&lt;p&gt;借助于 Type Operator 我们可以写成&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type a === b = Equal a b&lt;/code&gt;&lt;p&gt;相等关系具有自反性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  refl :: Nat n -&amp;gt; n === n
  refl Zero = EqZ
  refl (Succ x) = EqS $ refl x&lt;/code&gt;&lt;p&gt;相等关系具有对称性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  symm :: a === b -&amp;gt; b === a
  symm EqZ = EqZ
  symm (EqS x) = EqS $ symm x&lt;/code&gt;&lt;p&gt;相等关系具有传递性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (&amp;lt;=&amp;gt;) :: a === b -&amp;gt; b === c -&amp;gt; a === c
  EqZ &amp;lt;=&amp;gt; EqZ = EqZ
  EqS x &amp;lt;=&amp;gt; EqS y = EqS $ x &amp;lt;=&amp;gt; y&lt;/code&gt;&lt;p&gt;因为 Type Operator 也能定义优先级，所以下面给出：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  infixl 2 ===
  infixl 4 :+:
  infixr 4 :-:
  infixl 5 :*:&lt;/code&gt;&lt;p&gt; 来减少括号的个数&lt;/p&gt;&lt;h2&gt;加法结合律&lt;/h2&gt;&lt;p&gt;那么我们来试着证明一下加法的结合律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusComb :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :+: (m :+: p) === n :+: m :+: p&lt;/code&gt;&lt;p&gt;我们对 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 进行归纳：&lt;/p&gt;&lt;p&gt; 当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 0 的时，在加法中的 0 会直接消除，所以使用 &lt;code class=&quot;inline&quot;&gt;refl (m + p)&lt;/code&gt; 就好了；&lt;/p&gt;&lt;p&gt; 当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S n1&lt;/code&gt; 时，把等式两边的 S 用 &lt;code class=&quot;inline&quot;&gt;EqS&lt;/code&gt; 提取出来，再使用归纳假设就可以了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusComb :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :+: (m :+: p) === n :+: m :+: p
  plusComb Zero p q = refl (p + q)
  plusComb (Succ n) m p = EqS $ plusComb n m p&lt;/code&gt;&lt;h2&gt;加法交换律&lt;/h2&gt;&lt;p&gt;那么再尝试一下稍微困难一点的加法交换律吧&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusCommutes :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: m === m :+: n&lt;/code&gt;&lt;p&gt;当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 0 的时，证明很平凡。我们需要的是这么一个类型：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  Nat n -&amp;gt; n :+: Z === n&lt;/code&gt;&lt;p&gt;只需要对 n 进行归纳就好了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  nPlusZero :: n === n -&amp;gt; n === n :+: Z
  nPlusZero EqZ        = EqZ
  nPlusZero (EqS eq) = EqS $ nPlusZero eq&lt;/code&gt;&lt;p&gt;当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S m1&lt;/code&gt; 时，我们需要的东西的类型为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (n :+: S m1) === S (m1 :+: n)&lt;/code&gt;&lt;p&gt;根据归纳法，我们可以得到&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;EqS (plusCommutes n m1) :: S (m1 :+: n) === S (n :+: m1)&lt;/code&gt;&lt;p&gt;借助于相等关系的传递性，目标变成了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; (n :+: S m1) === S (n :+: m1)&lt;/code&gt;&lt;p&gt;而这个命题的证明也只需要对 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 进行归纳&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  nPlusSm :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: S m === S (n :+: m)
  nPlusSm Zero      m = EqS $ refl m
  nPlusSm (Succ n) m = EqS $ nPlusSm n m&lt;/code&gt;&lt;p&gt;把这些步骤拼起来，就得到了我们最终的证明&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plus2 :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: m === m :+: n
  plus2 n Zero = symm $ nPlusZero $ refl n
  plus2 n (Succ m) = nPlusSm n m &amp;lt;=&amp;gt; symm (EqS $ plus2 m n)&lt;/code&gt;&lt;h2&gt;乘法交换律&lt;/h2&gt;&lt;p&gt;看了加法我们再来看乘法&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; multCommute :: Nat n -&amp;gt; Nat m -&amp;gt; n :*: m === m :*: n&lt;/code&gt;&lt;p&gt;证明的方法和加法几乎一样，仍然从归纳法入手，对 n 进行归纳。中间需要用到一些引理，比如&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  multCommuteS :: Nat n -&amp;gt; Nat m -&amp;gt; m :*: S n === m :+: m :*: n
  plusSwap :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: (b :+: c) === b :+: (a :+: c)&lt;/code&gt;&lt;p&gt;等等，这里不再详细说明具体的推导，直接给出实现，有兴趣的同学可以试着自己写一遍&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; equalPlus :: Nat a -&amp;gt; Nat b -&amp;gt; a === b -&amp;gt; Nat c -&amp;gt; a :+: c === b :+: c
 equalPlus a b eq Zero = symm (nPlusZero a) &amp;lt;=&amp;gt; eq &amp;lt;=&amp;gt; nPlusZero b
 equalPlus a b eq (Succ c) = nPlusSm a c &amp;lt;=&amp;gt; Fuck (equalPlus a b eq c) &amp;lt;=&amp;gt; symm (nPlusSm b c)
  
 equalPlus&#39; :: Nat a -&amp;gt; Nat b -&amp;gt; a === b -&amp;gt; Nat c -&amp;gt; c :+: a === c :+: b
 equalPlus&#39; a b eq c = plusCommutes c a &amp;lt;=&amp;gt; equalPlus a b eq c &amp;lt;=&amp;gt; plusCommutes b c
  
 plusSwap&#39; :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: b :+: c === b :+: a :+: c
 plusSwap&#39; a b = equalPlus (a + b) (b + a) (plusCommutes a b)
  
 plusSwap :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: (b :+: c) === b :+: (a :+: c)
 plusSwap a b c = plusCommute a b c &amp;lt;=&amp;gt; plusSwap&#39; a b c &amp;lt;=&amp;gt; symm (plusCommute b a c)
  
 multCommuteS_1 :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: (m :*: S n) === m :+: (n :+: (m :*: n))
 multCommuteS_1 n m = equalPlus&#39; (m * Succ n) (m + m * n) (multCommuteS n m) n &amp;lt;=&amp;gt; plusSwap n m (m * n)
  
 multCommuteS :: Nat n -&amp;gt; Nat m -&amp;gt; m :*: S n === m :+: m :*: n
 multCommuteS _ Zero = Refl
 multCommuteS n (Succ m) = Fuck $ multCommuteS_1 n m
  
 multCommutes :: Nat n -&amp;gt; Nat m -&amp;gt; n :*: m === m :*: n
 multCommutes Zero m = symm $ multNZero m
 multCommutes (Succ n) m = symm
      (multCommuteS n m &amp;lt;=&amp;gt; equalPlus&#39; (m * n) (n * m) (multCommutes m n) m)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;从自然数说开去&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在上面定义的“相等”中，只对自然数进行了规定，那么我们怎么表示任何一种东西相等的概念呢？我们需要对 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 进行修改。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Equal a b where
      Refl :: Equal a a
      Derive :: Equal a b -&amp;gt; Equal (p a) (p b)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 对应之前的 &lt;code class=&quot;inline&quot;&gt;EqZ&lt;/code&gt; , &lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 对应 &lt;code class=&quot;inline&quot;&gt;EqS&lt;/code&gt; 。从定义上我们就能知道相等关系的自反性。&lt;/p&gt;&lt;p&gt;重新定义之后，我们就再也不需要 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 这个函数了，因为直接使用 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 就可以了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;symm&lt;/code&gt; 的定义和原来类似，&lt;code class=&quot;inline&quot;&gt;trans&lt;/code&gt; 则需要一点小小的修改：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; (&amp;lt;=&amp;gt;) :: a === b -&amp;gt; b === c -&amp;gt; a === c
 Refl        &amp;lt;=&amp;gt; Refl        = Refl
 Derive x &amp;lt;=&amp;gt; Refl        = Derive $ x      &amp;lt;=&amp;gt; Refl
 Refl        &amp;lt;=&amp;gt; Derive y = Derive $ Refl &amp;lt;=&amp;gt; y
 Derive x &amp;lt;=&amp;gt; Derive y = Derive $ x      &amp;lt;=&amp;gt; y&lt;/code&gt;&lt;p&gt;为了证明我们定义的 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 不仅仅对自然数有用，我们引入了类型层面的 &lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt; 来增加多样性。&lt;/p&gt;&lt;p&gt;首先是类型定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data T
data F&lt;/code&gt;&lt;p&gt;然后是对应的数据类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Boolean :: * -&amp;gt; * where
      Tr :: Boolean T
      Fa :: Boolean F&lt;/code&gt;&lt;p&gt;对于每一个需要参与证明的函数，我们需要在类型上实现一遍。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;Boolean&lt;/code&gt; 而言，先实现与或非 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type family Inv (n :: *) :: *
 type instance Inv T = F
 type instance Inv F = T
  
 type family (||) (n :: *) (m :: *) :: *
 type instance T || T = T
 type instance F || T = T
 type instance T || F = T
 type instance F || F = F
  
 type family (&amp;amp;&amp;amp;) (n :: *) (m :: *) :: *
 type instance T &amp;amp;&amp;amp; T = T
 type instance T &amp;amp;&amp;amp; F = F
 type instance F &amp;amp;&amp;amp; T = F
 type instance F &amp;amp;&amp;amp; F = F&lt;/code&gt;&lt;p&gt;首先证明双重否定律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  doubleNeg :: Boolean b -&amp;gt; Inv (Inv b) === b
  doubleNeg Tr = Refl
  doubleNeg Fa = Refl&lt;/code&gt;&lt;p&gt;要注意的是，这里并不能把两个分支合在一起写，因为它并不能直接把 &lt;code class=&quot;inline&quot;&gt;Inv (Inv b)&lt;/code&gt; 推导到 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然后是德摩根律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; demorgan :: Boolean a -&amp;gt; Boolean b -&amp;gt; Inv (a &amp;amp;&amp;amp; b) === Inv a || Inv b
 demorgan Tr Tr = Refl
 demorgan Tr Fa = Refl
 demorgan Fa Tr = Refl
 demorgan Fa Fa = Refl&lt;/code&gt;&lt;p&gt;仍然要进行详细的分类讨论，理由同上&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同样的，我们还能利用 Type Family 描述一些性质 ，比如自然数的奇偶性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type family IsOdd (n :: *) :: *
 type instance IsOdd Z = F
 type instance IsOdd (S Z) = T
 type instance IsOdd (S (S n)) = IsOdd n
  
 type family IsEven (n :: *) :: *
 type instance IsEven Z = T
 type instance IsEven (S Z) = F
 type instance IsEven (S (S n)) = IsEven n&lt;/code&gt;&lt;p&gt;试着证明一下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus :: Nat n -&amp;gt; Nat m -&amp;gt; IsOdd (n :+: m) === IsOdd n ^ IsOdd m&lt;/code&gt;&lt;p&gt;因为 &lt;code class=&quot;inline&quot;&gt;IsEven&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;IsOdd&lt;/code&gt; 的递归定义中都有两层的预设，所以我们在用归纳法证明时也需要考虑相应的 3 种情况&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus Zero m :: IsOdd m === (F ^ IsOdd m)&lt;/code&gt;&lt;p&gt;只需要实现这两个函数（它们的实现都是平凡的）&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; falseXor :: Boolean b -&amp;gt; b === F ^ b
 isodd :: Nat a -&amp;gt; Boolean (IsOdd a)&lt;/code&gt;&lt;p&gt;就有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus Zero x = falseXor $ isodd x&lt;/code&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S Z&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 进行归纳，当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;S Z&lt;/code&gt; 时，结果就是 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，而当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S (S m&#39;)&lt;/code&gt; 时，我们需要的类型为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ Zero) (Succ (Succ x)) :: IsOdd (S n3) === (T ^ IsOdd n3)&lt;/code&gt;&lt;p&gt;同样的，只需要把它拎出去，用归纳法再证一遍就好了&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S (S n&#39;)&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们需要的类型为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ (Succ x)) y :: IsOdd (n2 :+: m) === (IsOdd n2 ^ IsOdd m)&lt;/code&gt;&lt;p&gt;利用归纳假设就能直接证明了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ (Succ x)) y = oddPlus x y&lt;/code&gt;&lt;h2&gt;&lt;b&gt;还有什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;注意到我们的很多证明，实际上都只是在类型层面的变化。比如下面这个&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddEvenS :: Nat n -&amp;gt; IsOdd n === IsEven (S n)
 oddEvenS Zero = Refl
 oddEvenS (Succ Zero) = Refl
 oddEvenS (Succ (Succ x)) = oddEvenS x&lt;/code&gt;&lt;p&gt;把递归展开的话就能发现它所有情况下的 “值” 都是 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，但我们不能直接对所有的情况赋 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，因为这个递归是对 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 上的类型进行修改的过程。类型推导不会对 Type Family 中的递归定义进行展开，所以我们还是得自己动手证明一遍。&lt;/p&gt;&lt;h2&gt;“性质” 的表示方法&lt;/h2&gt;&lt;p&gt;我们使用了 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 表示两个类型相等的概念，那么同样的，我们还可以用这种方法描述其它的一元/二元/多元关系，比如我们可以换一种方式表示奇偶性：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Even :: * -&amp;gt; * where
      ZeroEven :: Even Z
      Add2Even :: Even n -&amp;gt; Even (S (S n))
  
data Odd :: * -&amp;gt; * where
      OneOdd :: Odd (S Z)
      Add2Odd :: Odd n -&amp;gt; Odd (S (S n))&lt;/code&gt;&lt;p&gt;或者描述两个自然数的大小关系：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Greater :: * -&amp;gt; * where
      GreZ :: Greater (S Z) Z
      GreS1 :: Greater x y -&amp;gt; Greater (S x) y
      GreS2 :: Greater x y -&amp;gt; Greater (S x) (S y)&lt;/code&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 的局限&lt;/h2&gt;&lt;p&gt;事实上，我们在 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 中定义的 &lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 并不是万能的，比如我们不能这样&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deriveOdd :: Nat n -&amp;gt; n === m -&amp;gt; IsOdd n === IsOdd m
 deriveOdd _ eq = Derive eq -- wrong !&lt;/code&gt;&lt;p&gt;报错信息为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;Couldn&#39;t match type ‘IsOdd n’ with ‘p0 n’
      Expected type : IsOdd n === IsOdd m
      Actual   type    : p0 n === p0 m&lt;/code&gt;&lt;p&gt;它只能对字面量进行推导，比如&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deriveS :: n === m -&amp;gt; S n === S m&lt;/code&gt;&lt;h2&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;你现在应该可以解决下面几道题目&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/singletons&quot;&gt;https://www.codewars.com/kata/singletons&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/odd-plus-even-equals-odd-prove-it&quot;&gt;https://www.codewars.com/kata/odd-plus-even-equals-odd-prove-it&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it&quot;&gt;https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最后一道题证明的是加法交换律，除了文中给出的方法，还有一种更精妙的写法，读者可以试着找一找&lt;/p&gt;&lt;h2&gt;更多练习&lt;/h2&gt;&lt;p&gt;证明乘法交换律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; multCommute :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :*: m :*: p === n :*: (m :*: p)&lt;/code&gt;&lt;p&gt;以及更多你能想到的东西&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>zjuwyd</author>
<guid isPermaLink="false">2017-11-30-31567423</guid>
<pubDate>Thu, 30 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Taba Taba!</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-28-31466428.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Taba Taba!&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31466428&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天发现了篇paper，&lt;a href=&quot;http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf&quot;&gt;http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;就是一个小trick，可以用于在2n pattern match下算出zip l (rev r)&lt;/p&gt;&lt;p&gt;看完以后觉得很简单啊，一点都不像某SM（Selection Monad（特大雾&lt;/p&gt;&lt;p&gt;不过为啥想不到呢，orz&lt;/p&gt;&lt;p&gt;最后：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6eba3265331b7fcae96f281a17bbc0d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;688&quot; data-rawheight=&quot;87&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bc18b93eb1df21c1c6d5d9632b9e58da_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;383&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-11-28-31466428</guid>
<pubDate>Tue, 28 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Lens: 从入门到再次入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-24-31328798.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Lens: 从入门到再次入门&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31328798&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-28c51979d43ba132a98057d07b183025_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;类型补全计画&lt;/h2&gt;&lt;p&gt;从上一篇我们可以看出，Lens 就是整合在一起的 &lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;和 &lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;，借助&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;&lt;i&gt;, &lt;/i&gt;&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;&lt;i&gt;, &lt;/i&gt;&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;这三个函数，我们可以分别使用 Lens 的&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;。但是我们目前的 Lens 类型定义并不是完整的，因此我们首先对 Lens 的类型进行补全。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens s a = Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; (s -&amp;gt; f s)&lt;/code&gt;&lt;p&gt;首先让我们看这样一个例子： &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;set _1 ((1,2),3) 3
set _1 ((1,2),3) True&lt;/code&gt;&lt;p&gt;在我们目前的类型定义上面的代码第一行可以正常工作，而第二行则不可以。但是第二行确实是合乎逻辑的，我们的确有时候需要讲一个原本是数字的地方设置为布尔值或是其他的什么东西。&lt;/p&gt;&lt;p&gt;让我们将原先的 Lens 类型定义进行简单的改变，这样就可以在通过 Lens 对数据操作时改变数据的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens s t a b = Functor f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; (s -&amp;gt; f t)&lt;/code&gt;&lt;p&gt;我们可以可以直观地解读这个新的类型定义的含义，对&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;类型的量的一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;类型的域进行某种操作，之后该域变为&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;，相应的&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;变为&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;。当然这里的&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;的关系并不是随意的，而是依赖于&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;的关系。&lt;/p&gt;&lt;p&gt;现在我们之前使用的 Lens 类型将定义如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens&#39; s a = Lens s s a a
-- Or
{-# LANGUAGE LiberalTypeSynonyms #-}
type Simple f a b = f a a b b
type Lens&#39; = Simple Lens &lt;/code&gt;&lt;p&gt;在这个定义下我们可以定义出由&lt;code class=&quot;inline&quot;&gt;getter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;setter&lt;/code&gt;构建 Lens 的函数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;lens :: (s -&amp;gt; a) -&amp;gt; (s -&amp;gt; b -&amp;gt; t) -&amp;gt; Lens s t a b
lens getter setter f s = setter s &amp;lt;$&amp;gt; f (getter s)&lt;/code&gt;&lt;p&gt;下面让我们来回忆一下&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;over lens f = runIdentity . lens (Identity . f)
view lens b = getConst $ lens Const b &lt;/code&gt;&lt;p&gt;我们发现在&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;分别取&lt;code class=&quot;inline&quot;&gt;Identity&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Const&lt;/code&gt;的时候，Lens 就分别表现出了 &lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;的特性。对于&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;而言，他们只需要使用单一的 Functor ，因此我们可以专门定义&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Getting r s a = (a -&amp;gt; Const r a) -&amp;gt; s -&amp;gt; Const r s
type Setter s t a b = (a -&amp;gt; Identity b) -&amp;gt; s -&amp;gt; Identity t
type Setting = Simple Setter &lt;/code&gt;&lt;p&gt;在有了这个定义之后，我们就可以修改之前三个常用函数的类型签名：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a s a -&amp;gt; b -&amp;gt; a
over :: Setter s t a b -&amp;gt; (a -&amp;gt; b) -&amp;gt; s -&amp;gt; t
set  :: Setter s t a b -&amp;gt; b -&amp;gt; s -&amp;gt; t&lt;/code&gt;&lt;p&gt;这样的改变看似没有什么作用，但通过这样的改变，三个常用函数不再以 Lens 为作用对象，而是更加聚焦于一类更加通用的类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;作为概念积类型的类型与作为概念的值&lt;/h2&gt;&lt;p&gt;通过之前的例子，我们可以看到我们用 Lens 来操作一个&lt;b&gt;积类型(Product Type)&lt;/b&gt;，例如元组、Record 或是列表；于此相对，Lens 不能用来操作&lt;b&gt;和类型(Sum Type)&lt;/b&gt;。我们可以用 Lens 改变或是读取积类型的某个&lt;b&gt;部分(Component)&lt;/b&gt;的值。但是实际上，我们不需要一个&lt;b&gt;实在的&lt;/b&gt;积类型，也不需要一个实在的部分，只需要概念上的积类型与概念上的部分即可。这样的表述显得非常抽象，让我们来看几个例子。&lt;/p&gt;&lt;p&gt;第一个例子是列表，从定义来看，列表的确是一个积类型，它由相继的元素组成，它的各个部分就是各个组成元素。但是，我们将要操作的却不是这些实在的部分，而是抽象的部分，&lt;b&gt;列表的长度&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;让我们定义这个玄乎的&lt;code class=&quot;inline&quot;&gt;_length&lt;/code&gt;Lens ：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_length :: Lens&#39; [a] Int
_length f l = const l &amp;lt;$&amp;gt; f (length l)&lt;/code&gt;&lt;p&gt;可以看出，它可以从一个列表中提取出它的长度，但是不会改变它的长度&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view (_1._length) (&quot;hello&quot;, 3)
--&amp;gt; 5
set (_1._length) 9 (&quot;world&quot;, 3) 
--&amp;gt; (&quot;world&quot;,3)&lt;/code&gt;&lt;p&gt;在这个例子中，长度并不是列表的一个实在的部分，我们操作的积类型也不是一个实在的积类型，而是概念中的某种包含长度的积类型。&lt;/p&gt;&lt;p&gt;再看第二个例子，我们操作一个数字的绝对值。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_abs :: (Num a, Ord a) =&amp;gt; Lens&#39; a a
_abs f i = setabs &amp;lt;$&amp;gt; f (abs i)
  where sgn x
            | x &amp;gt;= 0 = 1
            | x &amp;lt;  0 = -1
        setabs x
               | x &amp;gt;= 0 = x*sgn i
               | x &amp;lt;  0 = error &quot;Abs must be non-negative&quot;
view _abs -123
--&amp;gt; 123
set _abs 13 -99
--&amp;gt; -13&lt;/code&gt;&lt;p&gt;可以看出，概念上，数字确实含有“绝对值”这一部分的值，但是数字与绝对值的关系同样也不是“元组与每个元素”之间的关系，也不是“记录与它的域”的关系。同时，数字本身，并不明显是那种积类型，这里我们同样是将其看作了概念上的积类型。&lt;/p&gt;&lt;p&gt;引入这两个例子的目的是说明，Lens 是某种更加抽象与普遍化的工具，它不仅仅用来处理具体的数据结构与数据结构内部的值，也可以用来处理各种各样的情况；Lens 聚焦于某个数据结构（实在的或是概念上的）的某个值上，这无关乎这个值是实在地存在于这个数据结构里，还是抽象地、概念上地存在于这个数据上，这为我们以后利用 Lens 完成语义的表达提供了可行性。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;多焦点数据操作&lt;/h2&gt;&lt;p&gt;Lens 在工作的过程中，对某个数据结构内某个值应用了一个&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; f b&lt;/code&gt;的函数，并最终得到一个&lt;code class=&quot;inline&quot;&gt;f t&lt;/code&gt;类型的新数据结构。假设现在我们想要操作某个列表&lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;中的所有元素，那么我们期望对列表中的每个元素应用&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; f b&lt;/code&gt;的函数，并且最终得到一个&lt;code class=&quot;inline&quot;&gt;f [b]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于应用某个函数于列表中的每个元素这一任务，我们有非常熟悉的解决方案&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f :: a -&amp;gt; f b
xs :: [a]
---
map f xs :: [f b] &lt;/code&gt;&lt;p&gt;但是我们期望得到的类型是&lt;code class=&quot;inline&quot;&gt;f [b]&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;[f b]&lt;/code&gt;，我们需要一个将函子的列表转换为列表的函子的函数，而实际上，函子没有足够的约束来支持这样的操作，最简单的例子就是，一个空函子的列表我们没法直接找到对应的空列表的函子；此外更一般的场合我们需要将&lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt;合并至&lt;code class=&quot;inline&quot;&gt;f [a]&lt;/code&gt;得到一个新的&lt;code class=&quot;inline&quot;&gt;f [a]&lt;/code&gt;的函数，其类型为&lt;code class=&quot;inline&quot;&gt;f a -&amp;gt; f [a] -&amp;gt; f [a]&lt;/code&gt;，而我们有的列表拼接函数的类型为&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;，这也不是函子的升格可以直接完成的。而应用函子恰巧有我们需要的&lt;code class=&quot;inline&quot;&gt;pure&lt;/code&gt;函数处理第一种情况，又有可以对双参数函数升格的&lt;code class=&quot;inline&quot;&gt;liftA2&lt;/code&gt;。由此看来，我们需要的是使用应用函子代替函子完成我们的需要。&lt;/p&gt;&lt;p&gt;有了这些分析，我们不难写出将函子的列表提取为列表的函子的函数。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;(&amp;lt;:&amp;gt;) :: Applicative f =&amp;gt; f a -&amp;gt; f [a] -&amp;gt; f [a],
(&amp;lt;:&amp;gt;) = liftA2 (:)
sequenceA :: (Applicative f) =&amp;gt; [f a] -&amp;gt; f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = x &amp;lt;:&amp;gt; sequenceA xs&lt;/code&gt;&lt;p&gt;接下来我们需要的操作列表中全部元素的 Lens 的实现也可以容易给出，因为我们先前已经通过&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;实现了&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; f b) -&amp;gt; [a] -&amp;gt; [f b]&lt;/code&gt;，只需再对结果应用刚实现的&lt;code class=&quot;inline&quot;&gt;sequenceA&lt;/code&gt;就可以恰好得到我们需要的 Lens 类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_every :: Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; [a] -&amp;gt; f [b]
_every f xs = sequenceA $ map f xs

over _every (+1) [2,3,4]
--&amp;gt; [3,4,5]&lt;/code&gt;&lt;p&gt;由于应用函子是特殊的函子，所以&lt;code class=&quot;inline&quot;&gt;_every&lt;/code&gt;是特殊的 Lens， 我们将这类 Lens 命名为 Traversal。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Traversal s t a b = Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; s -&amp;gt; f t
type Traversal&#39; s a = Traversal s s a a&lt;/code&gt;&lt;p&gt;取这个名字的原因是，在标准库&lt;code class=&quot;inline&quot;&gt;Data.Traversal&lt;/code&gt;中实际上恰好有一个函数&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt;符合我们的要求， 这个函数并非为 Lens 专门设计，但它的类型恰好与我们先前的&lt;code class=&quot;inline&quot;&gt;_every&lt;/code&gt; 相同，不仅如此这个函数不仅可以在列表上工作，也可以在所有&lt;code class=&quot;inline&quot;&gt;Traversable&lt;/code&gt;类型上工作。由于这类 Lens 操作均依赖于&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt;， 所以取名为 Traversal 。&lt;/p&gt;&lt;p&gt;让我们简单地看一下 Traversal 是如何与&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;一通工作的： &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;traverse :: Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; t a -&amp;gt; f (t b)
over traverse (+1) [2,3,4]
runIdentity . traverse (Identity . (+1)) [2,3,4]
runIdentity $ sequenceA $ map (Identity . (+1)) [2,3,4]
runIdentity $ sequenceA [Identity 3, Identity 4, Identity 5]
runIdentity $ Identity 3 &amp;lt;:&amp;gt; Identity 4 &amp;lt;:&amp;gt; Identity 5 &amp;lt;:&amp;gt; Identity []
runIdentity $ Identity [3, 4, 5]
--&amp;gt; [3,4,5]&lt;/code&gt;&lt;p&gt;但是，现在我们的 Traversal 不能正确与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;工作。 例如，对于下面的代码&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
view traverse [1,2,3]&lt;/code&gt;&lt;p&gt;我们期望的结果是这样的，我们只需要它原封不动地返回即可&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
[1,2,3]&lt;/code&gt;&lt;p&gt;而实际上，我们得到了看似匪夷所思的结果&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&quot;123&quot;
--Ambiguous type variable ‘a0’ arising from a use of ‘print’&lt;/code&gt;&lt;p&gt;让我们展开 Traversal 与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;工作的过程 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ traverse (Const b) [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ sequenceA $ map (Const b) [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ sequenceA  [Const &quot;1&quot;, Const &quot;2&quot;, Const &quot;3&quot;]
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; pure []&lt;/code&gt;&lt;p&gt;我们实际上清楚&lt;code class=&quot;inline&quot;&gt;Const a&lt;/code&gt;本身并非应用函子,&lt;code class=&quot;inline&quot;&gt;Monoid a =&amp;gt; Const a&lt;/code&gt;才是 ，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;类型的值不是“容器”内的值，而是“容器”的一部分，容器内并不存在值。于是，将应用函子范畴上的值应用到应用函子范畴上的函数时，内部并无操作，有的只是“容器”的合并。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Monoid a =&amp;gt; Applicative (Const a) where
  pure _ = Const empty
  (Const x) &amp;lt;*&amp;gt; (Const y) = Const (x &amp;lt;&amp;gt; y)&lt;/code&gt;&lt;p&gt;列表的默认&lt;code class=&quot;inline&quot;&gt;mappend&lt;/code&gt;操作 列表合并，所以我们就可以将上面的计算继续写下去了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; pure []
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; Const &quot;&quot;
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot;
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;23&quot;
getConst $ sequenceA  Const &quot;123&quot;
&quot;123&quot;&lt;/code&gt;&lt;p&gt;可以看出，这并不是匪夷所思的结果，而是在这些定义下的合理结果。实际上，从&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;类型上我们也可以看出它的确做了它应当的工作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a s a -&amp;gt; s -&amp;gt; a

view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
-- view :: Getting String [String] String -&amp;gt; [String] -&amp;gt; String&lt;/code&gt;&lt;p&gt;它最终确实给了我们一个字符串。&lt;/p&gt;&lt;p&gt;所以，我们需要构建专用于 Traversal 的&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数。考虑之前&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a b a -&amp;gt; b -&amp;gt; a
view lens = getConst . lens Const &lt;/code&gt;&lt;p&gt;这里他将原来的值不加改变地喂给了&lt;code class=&quot;inline&quot;&gt;getConst&lt;/code&gt;， 我们可以讲原始值套在一个 Monoid 里完成我们需要的效果。这里，我们需要的就是最终得到一个列表，因此只需要再套一层列表的 Monoid 即可，外面套的这层 Monoid 会互相合并，最终只剩下一个列表，里面排满了原来的元素。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf :: Getting [a] s a -&amp;gt; s -&amp;gt; [a]
toListOf lens = getConst . lens (\x -&amp;gt; Const [x])

toListOf traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
--&amp;gt; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
toListOf traverse [1,2,3]
--&amp;gt; [1,2,3]&lt;/code&gt;&lt;p&gt;这个函数似乎没有多大用处，它原封不动地返回了原本的列表。但是，我们可以依托于&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt; 构建更多更有用的 Traversal。&lt;/p&gt;&lt;p&gt;例如聚焦于一个列表中全部满足某个条件的 Traversal&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_all :: Eq a =&amp;gt; a -&amp;gt; Traversal&#39; [a] a
_all st f s = traverse update s
  where
    update old = if st old then f old else pure old
    
toListOf (_all (/=0)) [1,2,0,3,4,0,5]
--&amp;gt; [1,2,3,4,5] &lt;/code&gt;&lt;p&gt;同时，我们描述过 Traversal 是一种特殊的 Lens， 所以它具有 Lens 各种有用的性质，例如通过互相复合来处理嵌套的列表。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf (traverse.traverse) [[1,2],[1,2,3,4]]
--&amp;gt; [1,2,1,2,3,4]
xs = [[1,2],[1,2,3,4],[4,5,6],[23,4,5,5,4],[1],[2,3]]
over (_all (\x-&amp;gt; length x &amp;lt;= 3 ) .traverse) (+1) xs
-- &amp;gt;[[2,3],[1,2,3,4],[5,6,7],[23,4,5,5,4],[2],[3,4]]&lt;/code&gt;&lt;p&gt;或者与普通的 Lens 复合，来完成复杂的操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf (traverse._1) [(1,2),(3,4),(5,6)]
--&amp;gt; [1,3,5]&lt;/code&gt;&lt;p&gt;需要注意的是，Traversal 是特殊的 Lens，也就是说在 Lens 上多出一些特定的限制，因此 Traversal 与普通 Lens 的复合将会仍然继承这些限制，即 Traversal 与 Lens 的复合仍是 Traversal。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;使用更多 Monoid 来获得多种效果&lt;/h2&gt;&lt;p&gt;在上面我们使用了&lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;这一 Monoid 来实现了合成列表的效果，实际上，我们还可以使用其他Monoid。下面让我们看几个例子。&lt;/p&gt;&lt;p&gt;第一个例子是将包装过的 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;作为一个 Monoid，并取名为 &lt;code class=&quot;inline&quot;&gt;First&lt;/code&gt; 。从名字我们也可以看出来，它的作用就是取出列表的首个元素。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype First a = First (Maybe a)

instance Monoid (First a) where
  mempty = First Nothing
  mappend (First Nothing) y = y
  mappend        x        _ = x

preview :: Getting (First a) s a -&amp;gt; s -&amp;gt; Maybe a
preview lens = getFirst . getConst . lens (Const . First . Just)

preview (_all (/=0)) [3, 2, 1, 0]
--&amp;gt; Just 3

preview (_all (/=0)) [0,0,0]
--&amp;gt; Nothing&lt;/code&gt;&lt;p&gt;同样，修改 &lt;code class=&quot;inline&quot;&gt;mappend&lt;/code&gt;的定义我们可以得到 &lt;code class=&quot;inline&quot;&gt;Last&lt;/code&gt;，这里不再具体给出。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;第二个例子是包装过的&lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt;，我们可以用它来判断一个列表中是否含有某个元素&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Any = Any { getAny :: Bool }

instance Monoid Any where
  mempty = Any False
  Any x `mappend` Any y = Any (x || y)
  
has :: Getting Any s a -&amp;gt; s -&amp;gt; Bool
has l = getAny . getConst . l (const $ Const (Any True)) 

has (_all (==0)) [3, 2, 1, 0]
--&amp;gt; True&lt;/code&gt;&lt;p&gt;我们发现，由于 Traversal 具有良好的抽象能力，我们仅仅选用不同的 Monoid 就实现了多种多用的效果，这无疑是非常令人振奋的。&lt;/p&gt;</description>
<author>孙浩然</author>
<guid isPermaLink="false">2017-11-24-31328798</guid>
<pubDate>Fri, 24 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>SKI组合子演算入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-21-31269072.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;SKI组合子演算入门&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31269072&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-30a6a81c41a2104b5a86f912660be680_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;题图的PixivID为：&lt;i&gt;pixiv-ID: &lt;a href=&quot;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=39597155&quot;&gt;39597155&lt;/a&gt;，画师为&lt;/i&gt;&lt;a href=&quot;https://www.pixiv.net/member.php?id=4846084&quot;&gt;アンミツ（QS）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文始发于&lt;a href=&quot;https://saul-mirone.github.io/2017/11/21/ski-guide/&quot;&gt;我的博客&lt;/a&gt;，转载请注明作者。&lt;/p&gt;&lt;p&gt;什么是SKI组合子演算？&lt;/p&gt;&lt;blockquote&gt;SKI组合子演算是一个计算系统，它是无类型版本的Lambda演算的简约。这个系统声称在Lambda演算中所有运算都可以用三个组合子S、K和I来表达。&lt;br&gt;	--&lt;a href=&quot;https://en.wikipedia.org/wiki/SKI_combinator_calculus&quot;&gt;维基百科&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Combinatory_logic&quot;&gt;组合子演算&lt;/a&gt;，我们只需要几个预定义的组合子(S、K、I)互相apply，就可以达到&lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_completeness&quot;&gt;图灵完备&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;定义&lt;/h2&gt;&lt;p&gt;所谓的SKI，一般来说可以这样定义：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;I x -&amp;gt; x&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;K x y -&amp;gt; x&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;S x y z -&amp;gt; x z (y z)&lt;/code&gt; &lt;/p&gt;&lt;h2&gt;推导&lt;/h2&gt;&lt;p&gt;让我们从一个简单的lambda开始，感受一下SKI组合子的威力。&lt;/p&gt;&lt;p&gt;首先是常用的compose函数。假设有：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;compose = \g -&amp;gt; \f -&amp;gt; \x -&amp;gt; g (f x)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;那么我们可以做如下转换：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;转化&lt;code class=&quot;inline&quot;&gt;g (f x)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;(K g x) (f x)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;由于&lt;code class=&quot;inline&quot;&gt;(K g x) (f x)&lt;/code&gt;满足 &lt;code class=&quot;inline&quot;&gt;x z (y z)&lt;/code&gt;的形式，所以可简化为&lt;code class=&quot;inline&quot;&gt;S (K g) f x&lt;/code&gt;&lt;/li&gt;&lt;li&gt;现在compose变成了&lt;code class=&quot;inline&quot;&gt;\g -&amp;gt; \f -&amp;gt; \x -&amp;gt; S (K g) f x&lt;/code&gt;，那么其实可以直接消去x变为&lt;code class=&quot;inline&quot;&gt;\g -&amp;gt; \f -&amp;gt; S (K g) f&lt;/code&gt;&lt;/li&gt;&lt;li&gt;同理可消去f，变为&lt;code class=&quot;inline&quot;&gt;\g -&amp;gt; S (K g)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;转化&lt;code class=&quot;inline&quot;&gt;S (K g)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;(K S g) (K g)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;与步骤2同理，简化为&lt;code class=&quot;inline&quot;&gt;S (K S) K g&lt;/code&gt;&lt;/li&gt;&lt;li&gt;于是得到&lt;code class=&quot;inline&quot;&gt;compose = S (K S) K&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所有的lambda表达式都可以用这种方式，转化为SKI组合子。&lt;/p&gt;&lt;p&gt;总结一下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;对于任意&lt;code class=&quot;inline&quot;&gt;f = \x -&amp;gt; x&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;f = I&lt;/code&gt;&lt;/li&gt;&lt;li&gt;对于任意&lt;code class=&quot;inline&quot;&gt;f = \x -&amp;gt; A&lt;/code&gt;且A与x无关, &lt;code class=&quot;inline&quot;&gt;f = K A&lt;/code&gt;&lt;/li&gt;&lt;li&gt;对于任意&lt;code class=&quot;inline&quot;&gt;f = \x -&amp;gt; A B&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;f = S (\x -&amp;gt; A) (\x -&amp;gt; B)&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于所有lambda表达式都可以转换为SKI组合子演算，所以递归、算数计算、布尔逻辑和数据结构这些自然也不在话下了。&lt;/p&gt;&lt;h2&gt;转化为SK&lt;/h2&gt;&lt;p&gt;一个有趣的事实：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;I
=&amp;gt; \x -&amp;gt; x
=&amp;gt; \x -&amp;gt; K x _
=&amp;gt; \x -&amp;gt; K x (K x)
=&amp;gt; \x -&amp;gt; S K K x
=&amp;gt; S K K&lt;/code&gt;&lt;p&gt;这说明了其实I组合子可以用SKK来表示，所以SKI组合子演算可以转化为SK组合子演算。&lt;/p&gt;&lt;h2&gt;动手试试&lt;/h2&gt;&lt;p&gt;看上去是不是很厉害的样子，来自己动手试试这道&lt;a href=&quot;https://www.codewars.com/kata/5a02dccf32b8b988120000da&quot;&gt;codewars题目&lt;/a&gt;吧。&lt;/p&gt;</description>
<author>mirone</author>
<guid isPermaLink="false">2017-11-21-31269072</guid>
<pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>point-free转换指南</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-15-31069901.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;point-free转换指南&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31069901&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-12b177788ee2bc152e6ceab68fae0674_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;题图的PixivID为：&lt;i&gt;pixiv-ID: 55550732，画师为&lt;/i&gt;&lt;a href=&quot;https://www.pixiv.net/member.php?id=408459&quot;&gt;純生文屋&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文始发于&lt;a href=&quot;https://saul-mirone.github.io/2017/11/15/point-free-guide/&quot;&gt;我的博客&lt;/a&gt;，转载请注明作者。&lt;/p&gt;&lt;p&gt;本文几乎是对一个&lt;a href=&quot;https://stackoverflow.com/questions/29596285/point-free-problems-in-haskell/29596461#29596461&quot;&gt;StackOverflow回答&lt;/a&gt;的翻译，欢迎有能力的同学去点个赞。&lt;/p&gt;&lt;p&gt;point-free是一种编程风格，简单的说，就是省略函数的参数。它的定义和内容不在本文讨论的范畴之中。理论上讲任何函数都可以被转换为point-free风格，本文讨论的内容就是如何将一个普通函数转换为point-free风格。&lt;/p&gt;&lt;p&gt;为了更简便的说明，本文代码使用Haskell编写，但是&lt;b&gt;读者就算不会Haskell也可以正常阅读&lt;/b&gt;。但是任何其它语言都可以通过几个工具函数来达到相同的效果。&lt;/p&gt;&lt;h2&gt;一个前提、五个函数&lt;/h2&gt;&lt;p&gt;一个函数要转换成point-free风格的函数，有一个前提和五个函数&lt;/p&gt;&lt;p&gt;前提：函数必须是curry的，也就是对于任何的&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;f x y = Z&lt;/code&gt; 有 &lt;code class=&quot;inline&quot;&gt;f = \x -&amp;gt; \y -&amp;gt; Z&lt;/code&gt;&lt;/p&gt;&lt;p&gt;对于函数式语言，这几乎是标配，而对于其它范式的语言，可能要借助一些工具库(例如js中的lodash)或者手写转换函数了。&lt;/p&gt;&lt;p&gt;还有五个帮助函数也是必要的，没有它们，转换之路会无比艰难：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;id :: a -&amp;gt; a
id x = x

const :: a -&amp;gt; (b -&amp;gt; a)
const x = \_ -&amp;gt; x

(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; (a -&amp;gt; c)
f . g = \x -&amp;gt; f (g x)
 
flip :: (a -&amp;gt; b -&amp;gt; c) -&amp;gt; (b -&amp;gt; a -&amp;gt; c)
flip f = \y x -&amp;gt; f x y

(&amp;lt;*&amp;gt;) :: (a -&amp;gt; b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; (a -&amp;gt; c)
(&amp;lt;*&amp;gt;) f g x = f x (g x)&lt;/code&gt;&lt;h2&gt;转换分析&lt;/h2&gt;&lt;p&gt;函数大体都可以分为以下情况：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;\x -&amp;gt; x&lt;/code&gt;：这种最简单，只要写为&lt;code class=&quot;inline&quot;&gt;id x&lt;/code&gt;就好了&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;\x -&amp;gt; A&lt;/code&gt;且A与x无关：则可以写为&lt;code class=&quot;inline&quot;&gt;const A&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;\x -&amp;gt; A x&lt;/code&gt; 且A与x无关：则可以写为A&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;\x -&amp;gt; A B&lt;/code&gt;：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;x与A和B都有关，则可以写为&lt;code class=&quot;inline&quot;&gt;(\x -&amp;gt; A) &amp;lt;*&amp;gt; (\x -&amp;gt; B)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;x只与A有关，则写为 &lt;code class=&quot;inline&quot;&gt;flip (\x -&amp;gt; A) B&lt;/code&gt;&lt;/li&gt;&lt;li&gt;x只与B有关，则写为&lt;code class=&quot;inline&quot;&gt;A . (\x -&amp;gt; B)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;x与AB都无关，emmmm…这函数你都能写出来，你是智障吗。&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;当函数体内出现条件表达式：这种情况可以用一些特殊函数来帮忙处理，例如如果出现&lt;code class=&quot;inline&quot;&gt;\x -&amp;gt; if x == 1 then 0 else -1&lt;/code&gt;这种函数，我们可以用一个帮助函数例如&lt;code class=&quot;inline&quot;&gt;bool f t b = if b then t else f&lt;/code&gt;替换为&lt;code class=&quot;inline&quot;&gt;\x -&amp;gt; bool (-1) 0 (x == 1)&lt;/code&gt; &lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;举个栗子&lt;/h2&gt;&lt;p&gt;对于原函数：&lt;code class=&quot;inline&quot;&gt;f x y z = foo z (bar x y)&lt;/code&gt; ，要把它转化为point-free风格，如果刚接触point-free的人肯定一脸懵逼，那么我们就来看看按照我们的指引来进行转化的过程吧：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f x y z = foo z (bar x y)
f x y = \z -&amp;gt; foo z (bar x y)
f x y = \z -&amp;gt; (foo z) (bar x y) --这就是curry函数的好处
f x y = flip (\z -&amp;gt; foo z) (bar x y) --使用规则4.2
f x y = flip foo (bar x y) --使用规则3
f x = \y -&amp;gt; flip foo (bar x y)
f x = \y -&amp;gt; (flip foo) (bar x y)
f x = flip foo . (\y -&amp;gt; bar x y) --使用规则4.3
f x = flip foo . (bar x)
f = \x -&amp;gt; flip foo . (bar x)
f = \x -&amp;gt; (.) (flip foo) (bar x) --在Haskell中，a+b == (+) a b
f = \x -&amp;gt; ((.) (flip foo)) (bar x) --别忘了curry
f = ((.) (flip foo)) . (\x -&amp;gt; bar x) --使用规则4.3
f = ((.) (flip foo)) . bar
f = (.) (flip foo) . bar&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当然了，point-free并不是适合所有场景，如果point-free完可读性反而变差了，你可能就要思考是否有这个必要了。&lt;/p&gt;</description>
<author>mirone</author>
<guid isPermaLink="false">2017-11-15-31069901</guid>
<pubDate>Wed, 15 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Folding infinite list through F-algebra</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-08-30833827.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Folding infinite list through F-algebra&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30833827&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6765c36a65c96091e2d1fb5522da91a0_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;嘛，在知乎写的第一篇文章，参考了很多现有文章的格式及表达思路www。主要目的还是讨论一些F-algebra的概念和锻炼自己的表达能力。起因是最近刷到codewars上一道题：&lt;a href=&quot;https://www.codewars.com/kata/folding-through-a-fixed-point&quot;&gt;Folding through a fixed point&lt;/a&gt;，其中涉及到一些以前接触过的F-algebra的概念，但题中并没有详细解释清楚F-algebra，评论区存在做完题但没明白到底发生了啥的评论。我也是在codewars上写了一个简单的解释，这里在不剧透题目的情况下搬运一些自己写的东西，并给出一个实际的例子：constructing, folding infinite list&lt;/p&gt;&lt;p&gt;注意：本文中存在一些伪代码，主要是类型签名用来说明类型。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;对范畴论的一个大概的认识会有很大帮助&lt;/li&gt;&lt;li&gt;Haskell的基础语法及Functor typeclass的使用&lt;/li&gt;&lt;li&gt;对交换图表的相关知识&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;什么是Algebra&lt;/h2&gt;&lt;p&gt;简单来说，Algebra可以理解为能以某种方式组织表达式，以及能以某种方式对表达式进行规约的结构。这里我们所关心的表达式是其中的一种：recursively defined的表达式。比如，在Haskell中我们可以通过如下语法来组织一个列表：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data List a = Nil | Cons a (List a)&lt;/code&gt;&lt;p&gt;接着，我们可以通过value constructor构造我们需要的列表，通过pattern matching以我们想要的方式对列表进行规约。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;list :: List String
list = Cons &quot;9&quot; $ Cons &quot;9&quot; $ Cons &quot;6&quot; $ Cons &quot;1&quot; $ Nil

stringify :: List String -&amp;gt; String
stringify Nil = &quot;&quot;
stringify (Cons x xs) = x ++ stringify xs

result :: String
result = stringify list&lt;/code&gt;&lt;h2&gt;非递归的定义我们的List&lt;/h2&gt;&lt;p&gt;我们可以将List中的递归定义提出来，增加一个Type constructor的参数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ListF a l = Nil | Cons a l&lt;/code&gt;&lt;p&gt;哪如何通过这个type来重新定义刚才的List呢？我们通过fixed point来实现，这里我们所选用的fixed point的定义least fixed point和greatest fixed point相等，且能直观的表现我们的意图：将非递归的type变成递归的。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Fix f = In (f (Fix f))&lt;/code&gt;&lt;p&gt;这样，我们可以重新定义我们的List：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type List a = Fix (ListF a)

list :: List String
list = In $ Cons &quot;9&quot; $ In $ Cons &quot;9&quot; $ In $ Cons &quot;6&quot; $ In $ Cons &quot;1&quot; $ In Nil&lt;/code&gt;&lt;h2&gt;一个F-Algebra的定义是什么&lt;/h2&gt;&lt;p&gt;不同代数结构会存在共有的特性，在猫论中，F-Algebra可以用来generalize algebraic structure，F-Algebra可以用来表示各种数据结构。具体的来说C是一个category，F: C → C是一个endofunctor，X是C中一个object，alg是C中F X → X的一个态射，那么F-Algebra就是一个(X, alg)的二元组。&lt;/p&gt;&lt;p&gt;对应到Haskell中则是在Hask范畴，f是一个Functor typeclass的instance，x是一个type，alg的类型则是：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;alg :: f x -&amp;gt; x&lt;/code&gt;&lt;h2&gt;一个F-Coalgebra的定义是什么&lt;/h2&gt;&lt;p&gt;既然名字里带co了，那么很容易想到是F-Algebra的dual。具体来说C是一个category，F: C → C是一个endofunctor，X是C中一个object，coalg是C中X → F X的一个态射，那么F-Coalgebra就是一个(X, coalg)的二元组。&lt;/p&gt;&lt;p&gt;对应到Haskell中则是在Hask范畴，f是一个Functor typeclass的instance，x是一个type，coalg的类型则是：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;coalg :: x -&amp;gt; f x&lt;/code&gt;&lt;h2&gt;理解Algebra间的态射&lt;/h2&gt;&lt;p&gt;根据不同的x的type，我们可以写出不同的algebra，猫论是一个研究不同东西间相同结构的理论，这里，我们要找出相同Functor间不同algebra的关系。&lt;/p&gt;&lt;p&gt;如果我们有以下两个type A和B，以及其algebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data A = A
newtype B = B A

mkA :: B -&amp;gt; A
mkA (B a) = a
mkB :: A -&amp;gt; B
mkB a = (B a)

algA :: F A -&amp;gt; A
algB :: F B -&amp;gt; B

coalgA :: A -&amp;gt; F A
coalgB :: B -&amp;gt; F B&lt;/code&gt;&lt;p&gt;那么我们有如下所示的态射关系，我们以Commutative Diagram表示：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \tag{F-Algebra} \begin{CD} {F A} @&amp;gt;{fmap \ mkB}&amp;gt;&amp;gt; {F B} \\ @V{algA}VV @VV{algB}V \\ {A} @&amp;gt;{mkB}&amp;gt;&amp;gt; {B} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;equation&gt;\begin{equation} \tag{F-Coalgebra} \begin{CD} {F A} @&amp;lt;{fmap \ mkA}&amp;lt;&amp;lt; {F B} \\ @A{coalgA}AA @AA{coalgB}A \\ {A} @&amp;lt;{mkA}&amp;lt;&amp;lt; {B} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;Initial F-Algebra和Terminal F-Coalgebra&lt;/h2&gt;&lt;p&gt;Initial F-Algebra和Terminal F-Coalgebra是一类具有特殊性质的F-Algebra和F-Coalgebra。对于一个endofunctor F: C → C来说，存在从其Initial F-Algebra到其他所有F-Algebra的唯一态射，存在从其他所有F-Coalgebra到其Terminal F-Coalgebra的唯一态射。我们将其分别称之为&lt;i&gt;catamorphism和&lt;/i&gt;anamorphism。&lt;/p&gt;&lt;p&gt;这里，我们的不动点Fix的In :: f (Fix f) -&amp;gt; Fix f就是Initial F-Algebra（和Terminal F-Coalgebra），根据Lambek’s Lemma我们可以知道存在unIn :: Fix f -&amp;gt; f (Fix f)，我们也很容易将其写出来，存在非常简单的isomorphism：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;In :: f (Fix f) -&amp;gt; Fix f
unIn :: Fix f -&amp;gt; f (Fix f)

newtype Fix f = In (f (Fix f))
unIn (In x) = x&lt;/code&gt;&lt;p&gt;那么如果我们构造出g和cog：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;g :: Fix f -&amp;gt; x
cog :: x -&amp;gt; Fix f&lt;/code&gt;&lt;p&gt;我们就可以很方便的将一个用Fix表示的代数表达式规约成我们想要的形式（或者反过来），我们用Commutative Diagram表示出来：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \tag{Initial F-Algebra} \begin{CD} {F (Fix \ F)} @&amp;gt;{fmap \ g}&amp;gt;&amp;gt; {F A} \\ @V{In}VV @VV{algA}V \\ {Fix \ F} @&amp;gt;{g}&amp;gt;&amp;gt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;equation&gt;\begin{equation} \tag{Terminal F-Coalgebra} \begin{CD} {F (Fix \ F)} @&amp;lt;{fmap \ cog}&amp;lt;&amp;lt; {F A} \\ @A{unIn}AA @AA{coalgA}A \\ {Fix \ F} @&amp;lt;{cog}&amp;lt;&amp;lt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;构造&lt;i&gt;catamorphism与&lt;/i&gt;anamorphism&lt;/h2&gt;&lt;p&gt;根据上面的Commutative Diagram，我们可以轻易发现，简单的将In和unIn交换，我们就能轻易从特定F-Algebra、F-Coalgebra构造出g和cog：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \tag{Initial F-Algebra} \begin{CD} {F (Fix \ F)} @&amp;gt;{fmap \ g}&amp;gt;&amp;gt; {F A} \\ @A{unIn}AA @VV{algA}V \\ {Fix \ F} @&amp;gt;{g}&amp;gt;&amp;gt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;equation&gt;\begin{equation} \tag{Terminal F-Coalgebra} \begin{CD} {F (Fix \ F)} @&amp;lt;{fmap \ cog}&amp;lt;&amp;lt; {F A} \\ @V{In}VV @AA{coalgA}A \\ {Fix \ F} @&amp;lt;{cog}&amp;lt;&amp;lt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们将其用Haskell表示出来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: Functor f =&amp;gt; (f x -&amp;gt; x) -&amp;gt; (Fix f -&amp;gt; x)
cata alg = alg . fmap (cata alg) . unIn

ana :: Functor f =&amp;gt; (x -&amp;gt; f x) -&amp;gt; (x -&amp;gt; Fix f)
ana coalg = In . fmap (ana coalg) . coalg&lt;/code&gt;&lt;h2&gt;Folding infinite list through F-algebra&lt;/h2&gt;&lt;p&gt;我们可以用F-Coalgebra来构造Infinite data structures，并使用F-algebra对其进行fold。例如我们的List：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ListF a l = Nil | Cons a l&lt;/code&gt;&lt;p&gt;很容易将其Functor instance写出来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Functor (ListF a) where
    fmap f Nil = Nil
    fmap f (Cons a l) = Cons a (f l)&lt;/code&gt;&lt;p&gt;这里我们定义这样一个Coalgebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;coalg :: Int -&amp;gt; ListF Int Int
coalg x = Cons x (x + 1)&lt;/code&gt;&lt;p&gt;我们通过这个Coalgebra和Anamorphism定义一个Infinite的自增List：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;list :: Fix (ListF Int)
list = ana coalg 256&lt;/code&gt;&lt;p&gt;接着，我们定义一个可以从Infinite的List中规约出值的Algebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;alg :: ListF Int Int -&amp;gt; Int
alg Nil = 0
alg (Cons a b) = if a &amp;lt; 1024 then a + b else a&lt;/code&gt;&lt;p&gt;接着我们使用C&lt;i&gt;atamorphism和这个&lt;/i&gt;Algebra规约出我们表达式的值：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;result :: Int
result = cata alg list&lt;/code&gt;&lt;p&gt;这里跟foldr很相似，只要我们规约Infinite的List时某次没有使用Cons里b的的值，那么规约就能终止。&lt;/p&gt;&lt;h2&gt;结束&lt;/h2&gt;&lt;p&gt;很久没写过这种类型的文章了，难免出现码字错误或者表述不清。有什么问题评论区轻喷/w\&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>不可构造的雨轩菌</author>
<guid isPermaLink="false">2017-11-08-30833827</guid>
<pubDate>Wed, 08 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Agda 中的证明，从一点五到二</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-06-30790920.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Agda 中的证明，从一点五到二&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30790920&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-043f810573d217996a346e86be90677f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;最近突然忙了起来。这篇文章只是填一下上篇文章的坑。原文链接 &lt;a href=&quot;http://ice1000.org/2017/11/06/ProofInAgda3/&quot;&gt;Agda 中的证明，从一点五到二&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上一篇说了很多只有一种情况的证明，这一篇说个有两种情况的。 到目前为止，按理说所有的字符都还能正常显示。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://ice1000.org/2017/11/02/ProofInAgda2/&quot;&gt;上一篇文章&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以及，由于 Agda 语言的特殊性，本文将继续使用 LaTeX 和代码块来共同展示代码。 代码块唯一的作用在于便于复制，主要的呈现途径为 LaTeX 。&lt;/p&gt;&lt;h2&gt;上一篇的习题&lt;/h2&gt;&lt;p&gt;上一篇文章我留下了一个没提供证明的命题，现在给出完整答案：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; {\land}{-}{\assoc}_0 : \forall \{P\ Q\ R\} \rightarrow ((P \land Q) \land R) \rightarrow (P \land (Q \land R)) \\ &amp;amp; {\land}{-}{\assoc}_0 \ ({\land}{-}{\intro}\ ({\land}{-}{\intro}\ p\ q)\ r) = {\land}{-}{\intro}\ p\ ({\land}{-}{\intro}\ q\ r) \\ &amp;amp; \\ &amp;amp; {\land}{-}{\assoc}_1 : \forall \{P\ Q\ R\} \rightarrow (P \land (Q \land R)) \rightarrow ((P \land Q) \land R) \\ &amp;amp; {\land}{-}{\assoc}_1 \ ({\land}{-}{\intro}\ p\ ({\land}{-}{\intro}\ q\ r)) = {\land}{-}{\intro}\ ({\land}{-}{\intro}\ p\ q)\ r \\ &amp;amp; \\ &amp;amp; {\land}{-}{\assoc} : \forall \{P\ Q\ R\} \rightarrow (P \land (Q \land R)) \Leftrightarrow ((P \land Q) \land R) \\ &amp;amp; {\land}{-}{\assoc} ={\land}{-}{\intro} \ {\land}{-}{\assoc}_1 \ {\land}{-}{\assoc}_0 \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-assoc₀ : ∀ {P Q R} → ((P ∧ Q) ∧ R) → (P ∧ (Q ∧ R))
∧-assoc₀ (∧-intro (∧-intro p q) r) = ∧-intro p (∧-intro q r)

∧-assoc₁ : ∀ {P Q R} → (P ∧ (Q ∧ R)) → ((P ∧ Q) ∧ R)
∧-assoc₁ (∧-intro p (∧-intro q r)) = ∧-intro (∧-intro p q) r

∧-assoc : ∀ {P Q R} → (P ∧ (Q ∧ R)) ⇔ ((P ∧ Q) ∧ R)
∧-assoc = ∧-intro ∧-assoc₁ ∧-assoc₀ &lt;/code&gt;&lt;p&gt;确实没什么好说的，所以才能说是即得易见平凡，仿照上例显然。&lt;/p&gt;&lt;h2&gt;或相关的证明&lt;/h2&gt;&lt;p&gt;上一篇我有个东西没讲完，就是 “或” 。 它和 “与” 相对，它只要求两个命题中的一个成立。&lt;/p&gt;&lt;p&gt;因此，它对应着两个不同的情况：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;p \rightarrow (p \lor q) \\ q \rightarrow (p \lor q)&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;定义 GADT&lt;/h2&gt;&lt;p&gt;把这个关系写成 GADT ，就是这样：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; \data\ \_{\lor}\_\ (P\ Q : \Set) : \Set \where \\ &amp;amp; \ \ {\lor}{-}{\intro}_0 : P \rightarrow P \lor Q \\ &amp;amp; \ \ {\lor}{-}{\intro}_1 : Q \rightarrow P \lor Q \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data _∨_ (P Q : Set) : Set where
  ∨-intro₀ : P → P ∨ Q
  ∨-intro₁ : Q → P ∨ Q &lt;/code&gt;&lt;p&gt;这里我们遇到了一种和之前不一样的情况： 我们的 GADT 有了两种 instance 。 这意味着我们需要在证明的时候考虑两种不同的情况，分别针对这两种 instance 。&lt;/p&gt;&lt;h2&gt;证明一&lt;/h2&gt;&lt;p&gt;比如，我们可以证明一下这个命题：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(p \rightarrow r) \land (q \rightarrow r) \land (p \lor q) \rightarrow r &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;它的逻辑很简单，在 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 都能推出 &lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt; 的时候， &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 只需要成立一个， &lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt; 就成立。 这个命题写成 Agda 的类型，就是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim} : \forall \{P\ Q\} \{R : \Set\} \rightarrow (P \rightarrow R) \rightarrow (Q \rightarrow R) \rightarrow (P \lor Q) \rightarrow R&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim : ∀ {P Q} {R : Set} → (P → R) → (Q → R) → (P ∨ Q) → R &lt;/code&gt;&lt;p&gt;我们在证明中，需要同时对 &lt;equation&gt;(P \lor Q)&lt;/equation&gt; 的两种可能的情况进行处理 （因为这个类型的东西既可以是通过 &lt;code class=&quot;inline&quot;&gt;P&lt;/code&gt; 构造的，也可以是通过 &lt;code class=&quot;inline&quot;&gt;Q&lt;/code&gt; 构造的）， 不然 Agda 的 exhaustiveness check 会报错的 （这也是为什么 &lt;code class=&quot;inline&quot;&gt;postulate&lt;/code&gt; 不被推荐使用）。&lt;/p&gt;&lt;p&gt;首先考虑 &lt;code class=&quot;inline&quot;&gt;P&lt;/code&gt; 成立的情况，我们有：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim}\pr \_ \ ({\lor}{-}{\elim}_0 \ p) = \pr p &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim pr _ (∨-intro₀ p) = pr p &lt;/code&gt;&lt;p&gt;然后考虑 &lt;code class=&quot;inline&quot;&gt;Q&lt;/code&gt; 成立的情况，我们有：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim}\ \_ \qr \ ({\lor}{-}{\elim}_1 \ q) = \qr q &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim _ qr (∨-intro₁ q) = qr q &lt;/code&gt;&lt;p&gt;放在一起，就是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; {\lor}{-}{\elim} : \forall \{P\ Q\} \{R : \Set\} \rightarrow (P \rightarrow R) \rightarrow (Q \rightarrow R) \rightarrow (P \lor Q) \rightarrow R \\ &amp;amp; {\lor}{-}{\elim}\pr \_ \ ({\lor}{-}{\elim}_0 \ p) = \pr p \\ &amp;amp; {\lor}{-}{\elim}\ \_ \qr \ ({\lor}{-}{\elim}_1 \ q) = \qr q \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim : ∀ {P Q} {R : Set} → (P → R) → (Q → R) → (P ∨ Q) → R
∨-elim pr _ (∨-intro₀ p) = pr p
∨-elim _ qr (∨-intro₁ q) = qr q &lt;/code&gt;&lt;p&gt;这样，就 check 了。 十分简单。&lt;/p&gt;&lt;h2&gt;证明二&lt;/h2&gt;&lt;p&gt;和 &lt;equation&gt;\land&lt;/equation&gt; 一样， &lt;equation&gt;\lor&lt;/equation&gt; 也有交换律：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; {\lor}{-}{\comm}&#39; : \forall \{P\ Q\} \rightarrow (P \lor Q) \rightarrow (Q \lor R) \\ &amp;amp; {\lor}{-}{\comm}&#39; \ ({\lor}{-}{\intro}_0 \ p) = {\lor}{-}{\intro}_1 \ p \\ &amp;amp; {\lor}{-}{\comm}&#39; \ ({\lor}{-}{\intro}_1 \ q) = {\lor}{-}{\intro}_0 \ q \\ \\ &amp;amp; {\lor}{-}{\comm} : \forall \{P\ Q\} \rightarrow (P \lor Q) \Leftrightarrow (Q \lor R) \\ &amp;amp; {\lor}{-}{\comm} = {\land}{-}{\intro} \ {\lor}{-}{\comm}&#39; \ {\lor}{-}{\comm}&#39; \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-comm′ : ∀ {P Q} → (P ∨ Q) → (Q ∨ P)
∨-comm′ (∨-intro₀ p) = ∨-intro₁ p
∨-comm′ (∨-intro₁ q) = ∨-intro₀ q

∨-comm : ∀ {P Q} → (P ∨ Q) ⇔ (Q ∨ P)
∨-comm = ∧-intro ∨-comm′ ∨-comm′ &lt;/code&gt;&lt;h2&gt;结束&lt;/h2&gt;&lt;p&gt;这么快就没了？&lt;/p&gt;&lt;p&gt;其实只是填一下上一篇留下的坑。&lt;/p&gt;&lt;p&gt;是的，我说完了。&lt;/p&gt;</description>
<author>大笨蛋千里冰封</author>
<guid isPermaLink="false">2017-11-06-30790920</guid>
<pubDate>Mon, 06 Nov 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
