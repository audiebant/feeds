<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 22 Oct 2017 09:49:08 +0800</lastBuildDate>
<item>
<title>Dafny与程序验证</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-21-30321583.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Dafny与程序验证&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30321583&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8f49af88768b20c6808b564c74a43abe_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;B大以前写过一个&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25568785&quot;&gt;怎样写出没有 bug 的程序：程序证明的简单例子&lt;/a&gt; ，是用Idris写的，我也来写一个，不过方法不太一样。&lt;/p&gt;&lt;p&gt;Dafny是MSR开发的程序设计语言，它混合了OOP和FP编程范式，并且自带程序验证功能，可以通过霍尔逻辑证明程序正确性。&lt;/p&gt;&lt;p&gt;它的语法非常简单，看起来就像C++，Scala和Haskell的混合。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;变量(scala风格，只是没有val)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;var x:Tree;
var y:nat := 0;&lt;/code&gt;&lt;ul&gt;&lt;li&gt;ADT(Haskell风格)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)
datatype List&amp;lt;T&amp;gt; = Nil | Cons(head: T, tail: List&amp;lt;T&amp;gt;)
Cons(5,Nil).Cons? &amp;amp;&amp;amp; Cons(5, Nil).head == 5&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Methed/Lemma(命令式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;expr表示表达式，col表示集合&lt;/p&gt;&lt;p&gt;modifies用来标记函数的副作用，requires是前置命题，ensures是后置命题，decreses用来证明递归函数可终止。&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method/lemma Abs(x: int) returns (y: int)
    modifies &amp;lt;col&amp;gt;
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 { return -x;}
    else {return x;}
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Function/Predicate(函数式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;reads用来标记函数捕获的外部变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;function abs(x: int):int
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    reads &amp;lt;col&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 then -x else x
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Assert用来下断言，只不过这个断言不是运行期的，而是编译期的，支持forall和exist量词以及基本的逻辑运算符。把Assert改为Assume，可以用来假定某些命题成立。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;assert forall x :: P(x) ==&amp;gt; Q(x)
assert forall(i | 0 &amp;lt;= i&amp;lt; n - m) { b[i] := a[m + i];}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;模式匹配(Scala风格，match的位置略有差异)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;match t
	case Empty =&amp;gt; …
	case Node(l:Empty,v,r) =&amp;gt; …&lt;/code&gt;&lt;ul&gt;&lt;li&gt;循环&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可用invariant标记循环不变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;var i:=0
while i&amp;lt;n
	invariant i&amp;lt;=n
	decreases n-i
{}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;支持C++类的写法，支持Lambda表达式，支持Trait，支持yield惰性流，有复杂的模块系统，支持泛型类和高阶类型（都是用&amp;lt;&amp;gt;表达）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上就是Dafny常用的语法，还有一些不常用的语法可以参考&lt;a href=&quot;https://github.com/Microsoft/dafny/blob/master/Docs/DafnyRef/out/DafnyRef.pdf&quot;&gt;DafnyRef&lt;/a&gt;&lt;/p&gt;&lt;p&gt;一起来看一个稍微复杂一点的例子吧！写一个二叉搜索树的插入函数&lt;/p&gt;&lt;p&gt;定义二叉树&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)&lt;/code&gt;&lt;p&gt;在类里定义变量&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class BST
{
    var tree:Tree;&lt;/code&gt;&lt;p&gt;定义in_tree和is_ordered函数，分别表示某个元素在树内和树符合二叉搜索树的条件&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;predicate method is_intree(t:Tree,x:real)
{
    match t
        case Empty =&amp;gt; false
        case Node(l,v,r) =&amp;gt; x==v || is_intree(l,x) || is_intree(r,x)
}
predicate is_ordered(t:Tree)
{
    match t
        case Empty =&amp;gt; true
        case Node(l,v,r) =&amp;gt; is_ordered(l) &amp;amp;&amp;amp; is_ordered(r) &amp;amp;&amp;amp;
            (forall x::is_intree(l,x) ==&amp;gt; x&amp;lt;v) &amp;amp;&amp;amp;
            (forall y::is_intree(r,y) ==&amp;gt; y&amp;gt;=v)
}&lt;/code&gt;&lt;p&gt;定义函数insert_into_left和insert_into_right&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;protected function method insert_into_left(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_left(t,x))
{
    match t.left
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.left,x)
            else
                insert_into_left(t.left,x)
}

protected function method insert_into_right(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_right(t,x))
{
    match t.right
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.right,x)
            else
                insert_into_left(t.right,x)
}
&lt;/code&gt;&lt;p&gt;以上全是pure function，最后，我们回到oop的世界，定义dirty的类成员函数&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method insert(x:real)
    requires is_ordered(tree)
    modifies this
    ensures is_ordered(tree)
{
    match tree
        case Empty =&amp;gt; {tree:=Node(Empty,x,Empty);}
        case Node(l,v,r) =&amp;gt; 
        {
            if x&amp;gt;=v
            {
                tree:=insert_into_right(tree,x);
            }
            else
            {
                tree:=insert_into_left(tree,x);
            }
        }
}&lt;/code&gt;&lt;p&gt;编译的时候，编译器会帮你验证你写的那些requires,ensures,assert是否满足，如果不满足，它会告诉你哪些命题无法证明。经过验证之后，你可以选择将Dafny代码编译为C#或编译成dll被其他.Net程序调用。&lt;/p&gt;&lt;p&gt;以上只是一个简单介绍，具体代码在&lt;a href=&quot;https://github.com/NiceKingWei/algorithm/blob/master/dafny/bst.dfy&quot;&gt;bst.dfy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我的slides &lt;a href=&quot;https://github.com/zju-lambda/slides/blob/master/Verification%20in%20Dafny.pdf&quot;&gt;Verification in Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;关于Dafny的更多精彩内容， 可以关注Dafny的项目主页，里面有一些学习资源 &lt;a href=&quot;https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Fdafny%2Freference.aspx&quot;&gt;MSR:Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>魏王雅望非常</author>
<guid isPermaLink="false">2017-10-21-30321583</guid>
<pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>关于AlphaGo</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-21-30319620.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;关于AlphaGo&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30319620&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近被Zero刷屏了，我也来蹭热点。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;既然大家都分析得差不多了，我就不分析，提一个问题。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;无可置疑，AlphaGo战胜李世石，柯洁，无人能胜，是一个成功。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是，为什么AlphaGo成功了，然而其他跟推理有关的任务没有？（假设，成功=达到顶尖人类水平）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如说，OpenAI搞Dota，1V1下失败：被找出漏洞，当ATM刷。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如说，Deepmind搞星际争霸，失败：打不过bot，连小任务（控制几个小兵消灭对方的小兵）都很困难。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如说，MS搞程序生成，失败（或者更准确的说，根本没尝试更难的task）：DeepCoder的确取得好成绩，但是无法scale到普通程序员。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;又比如说，Visual Question Answering，Natrual Language Processing也不能在复杂的数据集上超越人类。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我拿这个问题问了很多人，得到各个不同的答案，先别跳到‘Go搜索空间很低，并且是Partial Information上去’，我们想想有什么理论，然后能如何测试这些理论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案0：Go空间很低。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;按照这个答案，我们可以试试看把各个问题的空间再降低，差不多的时候就能超越人类了。&lt;/p&gt;&lt;p&gt;或者相反的，我们可以试试看39*39 Go棋盘，199*199 Go棋盘等等。。。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不过其实我挺不买账的，因为我可以很简单的给出一个搜索空间巨大，但是很简单的例子：ShakeSphere游戏。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ShakeSphere游戏很简单，你可以打a-z，还有空格，各类标点等，要求打出一个莎士比亚全集。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;很明显这个空间巨大，并且可以任意大（打两次，打三次），如果加入del键还能到达无限搜索空间，但是这个问题任何一个编程入门的人都会解。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更何况，人类也怕大的搜索空间啊。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案1：Partial Information疼&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果是这样，试试看给Go加上迷雾，或者给Dota, StarCraft去掉迷雾呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这也无法解释VQA，NLP等task。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案2：Go能利用CNN架构，但是NLP，Dota，套CNN，LSTM没有太大意义，都不能很好的encode信息。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得有点靠谱。如果是这样，我们是不是应该去更多研究GraphCNN，然后找LSTM的替代品？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案3：推理需要搜索，而AlphaGo成功的把搜索外包出去，由神经网络做&lt;/p&gt;&lt;p&gt;答案4：越需要推理的task越离散，越不平滑，于是NN不喜欢，也不stable。搜索能变得stable一些。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Dota/StarCraft或许能通过imagination做搜索，但是什么叫‘在阅读理解上搜索’？Hmmm。。。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当然，很可能答案是多个上面解释的组合，或者是上面没有列举的。如果你有想法，评论/私信我！&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-10-21-30319620</guid>
<pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>EBNFParser的原理解析以及使用教程</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-07-29908056.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;EBNFParser的原理解析以及使用教程&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29908056&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-78761dc79f02fa543f016e8cceedf4ba_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;(题图的来源，图上就有&lt;/p&gt;&lt;p&gt;前段时间有人在我答案底下说看不懂，所以我今天来讲一下我是怎么写成某个Parser框架的。&lt;/p&gt;&lt;p&gt;在此之前，我说一点别的话。&lt;/p&gt;&lt;p&gt;非常感谢CPython项目，深入阅读了Python码源的一部分，我从中获益良多。&lt;/p&gt;&lt;p&gt;虽然我并没有学过编译原理，但我想，我从这份源代码里得到的东西，应该能够囊括很多编译相关的东西，教会了我许多关于编程语言设计、C和Python的令人智熄的操作。当然还有一些非思想层面的的收获，比如，阅读Python码源的课后作业就是我的&lt;a href=&quot;https://github.com/thautwarm/flowpython&quot;&gt;Flowpython&lt;/a&gt;，作为一个完全兼容CPython3.5和CPython3.6的解释器，它提供了一些强力而有用的语法(糖)，应该说是个非常实用的东西。&lt;/p&gt;&lt;p&gt;向开源世界的一切贡献者(包括我自己hhh)致敬！&lt;/p&gt;&lt;p&gt;然后我们来看看EBNFParser效果。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;EBNFParser的作用可不仅仅是快速写出一门语言的前端，平常像解析json啊，yaml啊，xml啊这种数据文件，也是可以秒着玩的。更有甚者，你要是觉得正则表达式用着不够自由，你可以通过折中执行效率和功能来写一个用起来更顺手的正则引擎。&lt;/p&gt;&lt;p&gt;我的github项目有一个简短的介绍，让你用几行代码写一个Lisp的Parser。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser&quot;&gt;EBNFParser主页&lt;/a&gt;&lt;/p&gt;&lt;p&gt;当然，要解析完整的Lisp, 不考虑注释，应该需要5行。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/blob/master/tests/Python/Lang/Lisp/grammar&quot;&gt;较为完整的Lisp语法解析文件&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在完成EBNFParser的稳定版本后，除开上面的Lisp，我给出的示例还有以下几门语言的。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/Python&quot;&gt;Python表达式&lt;/a&gt;&lt;br&gt;Python的全部语法在&lt;a href=&quot;https://github.com/python/cpython/blob/master/Grammar/Grammar&quot;&gt;CPython的Grammar文件&lt;/a&gt;里有定义，你按照这个来，完成整个Python的解析仅仅是小菜一碟。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/EBNF&quot;&gt;旧版本的EEBNF语言自省&lt;/a&gt;。&lt;br&gt;我所使用的EBNF语法并不是标准的，为了区别我打算暂时称呼其为&lt;b&gt;EEBNF&lt;/b&gt;, 它比起标准的EBNF更像是一门编程语言，扩展能力更加强大。此处的&lt;b&gt;旧版本的EEBNF&lt;/b&gt;缺少了一些新的非常有用的语法，比如AST的过滤，以及取消字面量Parser对自动生成的Tokenizer的影响(后者对于实现类似Java的嵌套多重注释(/*.../*...*/...*/)非常方便)。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/Expy&quot;&gt;Extra Py&lt;/a&gt;&lt;br&gt;这是一门还未诞生的语言，我创造它的意图是解决使用科学计算语言的混乱现状。除开能力碾压其它的Julia，其他科学计算语言的特性都非常接近，而且都有些不太令人愉悦的地方。而Extra Py是一门语法及特性更加合理(内部结构的一致性，在这一点上Matlab非常的糟糕)的语言，应该可以符合很多人的口味。&lt;br&gt;同时，因为Extra Py非常的合理、优雅以及简单，解析到其他语言的方法可能非常得灵活。&lt;b&gt;非常欢迎有兴趣和能力的朋友参与Extra Py的后端开发，这会是又一个有趣又有用的开源项目&lt;/b&gt;。&lt;br&gt;未来，如果Extra Py如期出现，我打算弄一个科学计算主题的公共项目，该项目的Extra Py代码轻易地编译或解释到R、 Python、Matlab、Julia、C++甚至Mathematica(甚至如果你会写Perl和Fortran...)，接受任何人符合标准的、任何科学领域的代码。&lt;br&gt;我并不是要去取代这些科学计算语言，我要做的是让新手学会一门能很快转向这些语言的轻量级语言。然后，很多时候，库的编写者只需要写写Extra Py，就可以发布多门语言的库了(按照R语言的三方库代码质量，我相信即便是简单的代码转换生成，也算得上是质量上乘的库了，更何况我相信未来的后端处理者们一定有很多骚操作的，比如我会把Extra Py的代码编译到Cython然后使用gcc优化，就非常棒了)。&lt;br&gt;这是我的宏愿，暂且说这么多。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/Cm&quot;&gt;EBNFParser.tests.Cm&lt;/a&gt;  以及 &lt;a href=&quot;https://github.com/Cm-lang&quot;&gt;Cm-lang项目&lt;/a&gt;&lt;br&gt;这是一门非常非常非常非常非常优雅的、高性能的、静态编译的语言。虽然它暂时还没发布。它的创建者是伟大的后宫王，世界Online的主角 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hash=&quot;67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hovercard=&quot;p$b$67ebe1bd8e4a63f17a42572e40afaac7&quot;&gt;@大笨蛋千里冰封&lt;/a&gt; 。&lt;br&gt;我有一个愿望，就是&lt;b&gt;让小括号可以远离这门可以表现得像C一样迅捷&lt;/b&gt;的语言。虽然我暂时并没有想到一个没有语意冲突又没有小括号的解决方案。&lt;br&gt;Cm应该是EBNFParser的第一个挑战，&lt;b&gt;事实上我是为了给Cm写Parser&lt;/b&gt;(在此控诉某号称图形学帝球，有商业级音乐才能的无良be)&lt;b&gt;才写的EBNFParser。&lt;br&gt;&lt;/b&gt;Cm的&lt;b&gt;语法优雅，但设计上有相当程度的复杂&lt;/b&gt;，&lt;b&gt;可能是它吸取了kotlin、scala、rust的很多特点。&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;rust&quot;&gt;let $ = i:i32 -&amp;gt; (f:[i32=&amp;gt;i32]) -&amp;gt; f(i)  // 我倾向于可以不要分号，Parser不需要...
var x = 1;  // 但是大佬近期考sat，关于分号的事情未下结论。
until ({x&amp;gt;1})  //其实， until是个函数哦，你可以用这种方式造DSL啊
{
   doSomething
}   &lt;/code&gt;&lt;p&gt;      来个类型标注的完全版(&lt;b&gt;虽然你实际上一定不需要写这么多&lt;/b&gt;)，但我觉得&lt;b&gt;真是超好看&lt;/b&gt;...&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let F:[[i32=&amp;gt;i32]=&amp;gt;i32=&amp;gt;i32] = (f:[i32=&amp;gt;i32])=&amp;gt;[i32=&amp;gt;i32]-&amp;gt;{
      (x:i32)=&amp;gt;i32 -&amp;gt; f(x)*x
} :[[i32=&amp;gt;i32]=&amp;gt;i32=&amp;gt;i32]  //好吧这个尾标注我抄了一下scala
// 这个类型标注是我想出来的哇哈哈，详见我的Squirrel语言，那是我搞编译器的开始...
// https://github.com/thautwarm/SquirrelLanguage&lt;/code&gt;&lt;p&gt;好的，效果预览完毕。&lt;/p&gt;&lt;p&gt;让我们进入EBNFParser的原理解析。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;模式匹配&lt;/h2&gt;&lt;p&gt;在早些的时候，我非常恨Python为什么没有模式匹配。于是呢，我造了一个轮子。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/Stardust&quot;&gt;thautwarm/Stardust&lt;/a&gt; 看ReadMe的Pattern Matching部分。&lt;/p&gt;&lt;p&gt;这个轮子还是挺强的，比如一个对象，你可以用简单的语法匹配它是否有某些成员或者，对这些成员的值在匹配。同时你可以去匹配像列表啊、元组啊、字典啊这样的结构。总之万事万物都可以匹配。&lt;/p&gt;&lt;p&gt;不到两百行代码，还是很短的(但当时代码太丑了…)。&lt;/p&gt;&lt;p&gt;然后在我写这个Parser框架的时候，经过半天的瞎搞(我已经忘了那半天我在想什么策略了...)，我的脑袋里涌出了两个东西，一个是Python的Grammar文件(当时flowpython项目已经完成)，一个是我曾经给Python写的那个模式匹配扩展。&lt;/p&gt;&lt;p&gt;来我们看看EBNF是如何定义语法的。(具体语法我参照的是Python的Grammar文件和我数理逻辑书上的BNF语法...)&lt;/p&gt;&lt;code lang=&quot;ebnf&quot;&gt;lambdaDef ::= &#39;lambda&#39; argList &#39;:&#39; test&lt;/code&gt;&lt;p&gt;啊！这不就是个模式匹配嘛。。&lt;/p&gt;&lt;p&gt;来一个token好的词组&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[&#39;lambda&#39;,
&#39;x&#39;,&#39;,&#39;,&#39;y&#39;,
&#39;:&#39;,
&#39;x&#39;,&#39;+&#39;,&#39;y&#39;,...]&lt;/code&gt;&lt;p&gt;你看看你看看。看不出来的话，我们来个模式匹配。&lt;/p&gt;&lt;p&gt;我用Python的部分语法做一个可爱的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    好的，现在先把词组交到我们的lambdaDef小可爱手上。
    哇！第一个匹配成功,正好是我们要的 lambda 啊！
    好的，lambdaDef同学把lambda放到一个叫做AST的东西的第一个位置。
    继续...
    啊，下一个单元好像需要别人的帮助了，lambdaDef同学查了查自己的模式表，找到
一个熟悉的名字。
    &quot;argList同学在吗？&quot;lambdaDef大声地朝某索引区域喊道。
    &quot;啊？找我嘛？姐姐你把当前的词组递给我一下，对了，把当前解析到第几个词也说一下.&quot;
    索引区域里传来argList同学的声音，她把自己的一个方法委托到某个lambdaDef也
能碰到的地方。
    lambdaDef见状，急忙将词组和已解析词数1放到了argList同学的委托里。
    之后，argList同学那里发生了很多事情，她和argDef同学、Name同学以及Test老
师一起处理了词组，得到了一个结果(如下)。
----------------------------
    argList[argDef[Name[x]]]
----------------------------
// 注: argList ::= argDef (&#39;,&#39; argDef)*
//     argDef  ::= Name [&#39;=&#39; Test]
//     Test为Python表达式语法的最高级节点，能表述一切表达式。

同时，这个结果使得已解析词数变成了4。
    当然，这些事情，lambdaDef同学是不知道的，她看着argList同学满脸大汗地,
把结果和已解析词数交给了自己。
    &quot;谢谢你了，&quot;lambdaDef同学把这个结果放到了AST的第二个位置，然后更新了已解析
词数，&quot;辛苦啦... 不过，我听说我们的努力会被更高层的人给扔掉了。他们说选择我们一开
始就错了呢。&quot;
    &quot;啊咧，为什么要说这个呢，我们最高层的人是Test老师吧，不过我听说，有时候，较低
层的Atom妹妹也会把Test老师的工作扔掉呢。她说有些时候, 左括号匹配了，Test老师
也递交了结果，但是之后却没有跟着一个右括号呢。&quot;
// Atom的简化定义(去除列表解析等) ::= ... | &#39;(&#39; Test &#39;)&#39; | ...
    &quot;啊，是这样呀，而且我发现，其实我们也会做同样的事情呀。&quot;lambdaDef稍微有些
释然.
    &quot;哼，上次那个垃圾程序员以为自己在写JS, 写了一个 lambda x=&amp;gt;x，然后lambdaDef
姐姐就把我和大家辛苦合作完成的东西给扔掉了呢！&quot;

// 以上节选自某存在于我脑海的书 &amp;lt;&amp;lt;ParserGenerator娘的日常&amp;gt;&amp;gt;
    &lt;/code&gt;&lt;p&gt;好的，我觉得自己真有才呀。。&lt;/p&gt;&lt;p&gt;上面那个故事，基本讲清了所有的解析方法，最后lambdaDef和argList两位同学的对话，还稍微提到了一个我没有说但很重要的东西：&lt;b&gt;回溯。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为什么需要回溯？&lt;/p&gt;&lt;p&gt;因为有死结。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CppType ::= CppType &#39;(&#39; CppType* &#39;)&#39; | Name&lt;/code&gt;&lt;p&gt;很经典的死结是左递归。&lt;/p&gt;&lt;p&gt;我们怎么解决死结的呢？&lt;/p&gt;&lt;h2&gt;死结与周期&lt;/h2&gt;&lt;p&gt;如果，我们把每次解析出的新结果，和当前解析的词数对应起来，构成一个元组。用一个东西按顺序存储这些元组。&lt;/p&gt;&lt;p&gt;来，看官们，想想看，出现死结时，如果你打印最新的元组，会出现什么样的情况。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Name      ParsedCount
...       ...
CppType   50
CppType   50
CppType   50
CppType   50
CppType   50
...&lt;/code&gt;&lt;p&gt;为什么呢？&lt;/p&gt;&lt;p&gt;因为死结必然什么都没做。&lt;/p&gt;&lt;p&gt;我们看一个聪明的CppType。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// CppType ::= CppType &#39;(&#39; CppType* &#39;)&#39; | Name
CppType : 哈，我拿到词组和已解析数啦。打印一个。
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 好的，第一个就是我自己呀。继续。
CppType : 哈，我拿到词组和已解析数啦。打印一个。
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 好的，第一个就是我自己呀。继续——
CppType : 不对，这话我说过一样的，&quot;Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50&quot;.
CppType : 我去，玩我呢这是。。赶紧跳过。&lt;/code&gt;&lt;p&gt;好的，左递归问题解决了。应该说所有的死结问题都解决了。&lt;/p&gt;&lt;p&gt;但是左递归解析有时候还是需要的(暂时的EBNFParser还是会跳过，虽然我打补丁地很容易解决它，但出于性能考虑，我将加入新语法，使得可以指定某个Parser 能进行左递归解析。全局支持左递归会导致不必要的性能损失)。&lt;/p&gt;&lt;p&gt;我把我的想法告诉CppType，它真聪明，一学就懂。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// CppType ::= CppType &#39;(&#39; CppType* &#39;)&#39; | Name
CppType : 哈，我拿到词组和已解析数啦。打印一个。计数1.
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 好的，第一个就是我自己呀。继续。
CppType : 哈，我拿到词组和已解析数啦。打印一个。计数2大于1，发现重复.
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 按照红教主的指示，我现在应该处理保留计数1时的自己，然后对
当前计数2的自己，去解析后面其他的情况，解析失败就报个解析失败——计数2时
解析后面的情况失败的话，计数1时的自己就跳过左递归去看后面的情况。
...&lt;/code&gt;&lt;p&gt;是不是很简单呢？&lt;/p&gt;&lt;p&gt;原理暂时就讲到这里，我觉得差不多了呀。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;基本使用&lt;/h2&gt;&lt;p&gt;我想你已经看到项目上那个骚气的pypi了。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pip install EBNFParser&lt;/code&gt;&lt;p&gt;就ok了。&lt;/p&gt;&lt;p&gt;当然，因为Python3.6以下的版本不支持字符串插值，写起来比较不爽，我现在就只支持Python3.6+的Python。不需要任何语言及标准库以外的依赖。&lt;/p&gt;&lt;p&gt;不久的未来，EBNFParser会优化性能，还会渐渐推出无数新语言的版本。第二门支持EBNFParser的语言将会是C#，其实你如果不用自动代码生成，已经可以在C#手写ebnf来用parser了。&lt;/p&gt;&lt;p&gt;好的，我们看主页的第一个例子。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d054f5c2847425272e9f1ca69cce5b76_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1366&quot; data-rawheight=&quot;768&quot;&gt;&lt;p&gt;按照这个简介写一个Lisp的解析器就大概知道怎么用了。&lt;/p&gt;&lt;p&gt;然后介绍一下我的EEBNF的语法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;字面量Parser&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;l := R&#39;&amp;lt;正则表达式&amp;gt;&#39; 
# 该正则表达式将会按顺序加入token构造器

l := &#39;字符串&#39;  
# 该字符串会按顺序加入token构造器，
# 但所有的非R模式的字面量Parser的影响在R模式的Parser之前

l := K&#39;&amp;lt;正则表达式&amp;gt;&#39;
# 该Parser不对token做任何贡献.
&lt;/code&gt;&lt;p&gt;&lt;b&gt;AstParser&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 声明 l指代任意字面量Parser

X ::= l | l X l 
# 抽象语法书的Parser 可以由任意Parser 由 并运算符 | 组合。有先后顺序。
# 其中出现的字面量Parser将按出现顺序和字面量Parser模式, 去贡献token。

# 声明 y 是任意Parser(字面量或者Ast的)
X ::= y*
# *表示y至少出现0次，最多出现无穷次

X ::= y+
# +表示y至少出现1次，最多出现无穷次

X ::= y{n}
# 表示y至少出现n次，最多出现无穷次

X ::= y{n m}
# 表示y至少出现n次，最多出现m次

X ::= [y] z
# 表示 y 可能出现，等价于 X ::= y{0 1} z

X ::= (y z)+
X ::= (y z)*
X ::= (y z){1}
X ::= (y z){1 5}
# 把(y z)当成整体&lt;/code&gt;&lt;p&gt;&lt;b&gt;过滤&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Stmts Throw Newline ::=  (Newline* Stmt* Newline*)*
# 解析之后， Stmts不含有Newline  &lt;/code&gt;&lt;p&gt;暂时就这么多。&lt;/p&gt;&lt;p&gt;然后说明一下Ast的结构。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/blob/master/Python/Misakawa/ObjectRegex/Node.py&quot;&gt;看里面的Ast类&lt;/a&gt;&lt;/p&gt;&lt;p&gt;现在可以支持Dump到JSON或者SExpr。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a6ea2a38fe9228ce1ffd25aa88b45d89_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1366&quot; data-rawheight=&quot;768&quot;&gt;&lt;p&gt;现在，尝试用EBNFParser去写一点好玩的东西吧。&lt;/p&gt;&lt;p&gt;造语言的话，前端太枯燥无味。解决好Parser，后面都是在做有趣的分析。&lt;/p&gt;&lt;p&gt;祝为梦想奋斗的各位晚安。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;（添一句，EBNFParser的错误提示还是有点智能的呀...&lt;/p&gt;&lt;p&gt;(EEBNF默认不支持注释语法和多行语句，但有可选项。例子详见项目主页的testCm.sh文件。&lt;/p&gt;</description>
<author>NightyNight</author>
<guid isPermaLink="false">2017-10-07-29908056</guid>
<pubDate>Sat, 07 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>一个滑块游戏的计算复杂性分析初步</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-07-29835678.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;一个滑块游戏的计算复杂性分析初步&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29835678&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e034b3b006eac91666343c4c3594d679_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;前段时间波恩大学的Norbert Blum宣称证明了 &lt;equation&gt;\text{P} \ne \text{NP}&lt;/equation&gt; ，并将文章挂在了arXiv上。PvsNP问题是计算理论领域最重要的未解决难题，它也是Clay数学研究所悬赏的千禧年七大数学难题之一，成功解决它的人有很大概率能获得数学界的最高荣誉Fields奖。PvsNP问题是如此的重要，而且它理解起来不算困难。因此，多年来全世界挑战PvsNP问题的人趋之若鹜，其中很大一部分是来搞笑的但也不乏专业的研究人员。然而，至今为止NP是否等于P依旧悬而未决。大家也最好不要轻易去挑战PvsNP问题，它很有可能消耗掉你大量的人生和信用。&lt;/p&gt;&lt;p&gt;我在这不打算、也没能力讨论Norbert Blum的证明是不是对的。我只是想找一个游戏中的有趣问题，尝试证明该问题是NP完全的（或NP-hard），以此来测试一下自己的计算理论基础。我选择了经典益智游戏“华容道”，我想看看它到底有多“难”。“华容道”游戏是一个经典益智小游戏，它通常是木制的，由若干个小方块摆放在一个矩形的框中，如下图&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7e4a9c32afdd0bf1396f11443721fa33_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;386&quot; data-rawheight=&quot;400&quot;&gt;&lt;p&gt;玩家需要做的是通过移动小方块，帮助“曹操”方块从初始位置移到最下方中部的出口逃走。当然在移动过程中，不允许其他方块移出到框外，也不能用“飞跃”大法。“华容道”游戏虽然取名自三国轶事，但它其实应该是一个比较现代的玩具，而它最早的出处比较难考证了，具体可以参考wiki百科&lt;a href=&quot;https://en.wikipedia.org/wiki/Klotski&quot;&gt;Klotski&lt;/a&gt;词条。&lt;/p&gt;&lt;p&gt;原始“华容道”游戏的解法能够被计算机穷举，但是我没有找到关于它的推广问题的计算复杂性分析的材料。因此，我想自行尝试看看能不能证明它的推广问题是NP-hard的，经过几天的思考，还真“凑”出了一个简单的归约方法...&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0.计算复杂性理论基础&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们先来粗糙地介绍一些计算理论的基础知识。&lt;b&gt;计算复杂性理论&lt;/b&gt;（computational complexity theory）研究的是计算机求解计算问题所需要计算资源的量。将存在多项式时间算法的问题的集合记为&lt;b&gt;P&lt;/b&gt;，通常认为这个集合中的问题能被计算机有效解决。因为随着问题输入规模n的增长，算法的运行时间是n的多项式，相比于指数时间算法，多项式算法的运行时间增长速度要慢很多。将存在多项式检验算法的问题的集合记为&lt;b&gt;NP&lt;/b&gt;，检验算法指的是对于问题的某个解，算法能够检验该解是否符合要求。其实集合NP包含了集合P，这不难理解，因为如果一个问题都能被直接解决了，那验证它的解不是更容易嘛。PvsNP问题是指是否存在属于NP而不属于P的问题，即NP是否等于P。&lt;/p&gt;&lt;p&gt;容易发现，PvsNP取决于NP中最“难”的问题是不是属于P。那么怎么判断问题的难度呢，这就需要介绍“归约”了。对于问题a的每个实例，若可以构造问题b的实例，并且能够证明这两个实例的判定结果一致，就认为问题a可以归约到问题b。当这种归约能够在多项式时间内完成的话，则称为&lt;b&gt;多项式时间归约&lt;/b&gt;（polynomial-time reduction）。其意义在于，如果b属于P，那么存在b的多项式时间算法，而多项式时间归约的存在保证了该算法也可以用于求解a，从而可以说明a也属于P。a可以多项式时间归约到b可以形象地理解为b不会比a简单。多项式时间归约的一个重要性质是具有传递性，a可以归约到b，而b又可以归约到c，就意味着a可以归约到c。在证明某个问题可以多项式时间归约到另一问题时，利用传递性有时可以使得归约的难度大大降低。&lt;/p&gt;&lt;p&gt;接着可以定义一个问题集合&lt;b&gt;NP-hard&lt;/b&gt;，对于NP-hard中的任意一个问题a，所有NP中的问题都可以多项式时间归约到问题a。也就是说NP-hard中的任意一个问题都要比NP中的所有问题都“难”（或者说不简单）。这就很厉害了，NP-hard问题看起来很难啊，比所有NP问题都要难解决。然而，令人震惊的是NP中有些问题是NP-hard的！所有其他NP问题可以多项式时间归约到这些NP问题，他们是“最难”的NP问题。 20世纪60年代末至70年代初，Stephen Cook和Leonid Levin分别独立地意识到这些问题的存在。后来这些问题被称为NP完全（NP-Complete）问题，简记为&lt;b&gt;NPC&lt;/b&gt;，其定义直接就是NP和NP-hard的交集。由于NPC是NP中最难的问题集合，NPC中的任意一个问题有多项式时间算法就等价于P=NP了！&lt;/p&gt;&lt;p&gt;有了初始的NPC问题后，人们可以容易地寻找新的NPC问题。需要做的是先说明新问题是属于NP的（这一步通常比较简单），然后再从NP-hard中找一个问题，将它多项式时间归约到新问题，再加上NP-hard的定义和归约的传递性就能说明NP中的所有问题可以多项式时间归约到新问题了。自NP完全性理论提出以来，数以千计的问题被证明属于NPC。然而至今未能寻找到任意一个NPC问题的多项式时间算法，也未能证明NPC问题不存在多项式时间算法。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1.问题定义&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里我们想考察一下“华容道”游戏的一个推广问题是否属于NP-hard（或者NPC）。&lt;/p&gt;&lt;p&gt;显然，我们的问题是在平面方格上考虑的。我们将平面方格上不可移动的方格称为墙方格，将若干个相邻的可以整体移动的方格称为滑块，滑块只能水平或垂直滑动，每次滑动只能移动一个方块的距离。另外，滑块在移动时需要考虑“碰撞”，即一个滑块的任意部分不能和墙方块或其他滑块重叠。我们将&lt;b&gt;滑块游戏问题&lt;/b&gt;定义为：给定平面上若干墙方格和若干滑块，问是否能通过有限次移动滑块，使得指定的滑块到达指定的位置。&lt;/p&gt;&lt;p&gt;举个例子，下图是就是一个滑块游戏的实例，灰色方块是墙，白色方块是空方块，其他颜色的方块是滑块，现在问题是能否通过滑动滑块使得红色滑块向右移动一格。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3d5c150cce105329440447754df4e822_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;266&quot; data-rawheight=&quot;276&quot;&gt;&lt;p&gt;这是可以做到的，先将中间一列上的黄、蓝、黄三个滑块上移一格，下方绿色滑块就能左移了，然后右侧的黄滑块可以下移，最后中间一横行上的绿、蓝、红三个滑块就能一起右移了。&lt;/p&gt;&lt;p&gt;需要注意的是，这里我们没有对墙和滑块的形状作限制，他们可以是矩形也可以是曲折的甚至是镂空的，所以这个滑块问题是一个很困难的问题，它属于NP-hard的可能性是很高的。为了说明这个问题属于NP-hard，我们需要先找一个NP-hard（或者NPC）问题，然后将它在多项式时间内归约到滑块问题。&lt;/p&gt;&lt;p&gt;3-SAT问题就是一个经典的NPC问题，其形式简单又较为灵活，经常被作为归约问题用来证明其他问题属于NPC或NP-hard。一个3-合取范式是由若干个子句的合取（可以理解为“与”运算）构成的布尔公式，其中每个子句由3个项的析取（可以理解为“或”运算）构成。例如，&lt;equation&gt;(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)&lt;/equation&gt; 是一个含有两个子句的3-合取范式，该公式用到了变量x1~x3。&lt;b&gt;3-SAT&lt;/b&gt;（3-conjunctive normal form satisfiability，3-合取范式可满足问题）问题指的是给定一个3-合取范式，判断是否存在对变量的赋值（True或False）使得该公式可满足（真值为True）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2.归约基本思路&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们现在来尝试说明对于3-SAT的任意实例S，可以构造相应滑块游戏的实例T，使得S可满足等价于T有解。&lt;/p&gt;&lt;p&gt;对于合取范式S我们设置一个滑块来表示，该滑块可以移动到指定位置对应于S可满足，比如像下面这样&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aad59582e6905392a63eea2d2f13bdc9_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;169&quot; data-rawheight=&quot;206&quot;&gt;&lt;p&gt;黑色滑块能够右移一格表示S可满足。但是黑色滑块不能随便右移，它应该被限制在S可满足时才能右移，因此设置一个深紫色滑块予以限制。根据合取范式的结构容易明白深紫色滑块应当在S中的每个子句都满足时才能右移，这说明深紫色滑块代表一个与门，因此我们设置如下结构来模拟与运算&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b3acdcded9deeb4c66e5697a768f821e_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;190&quot; data-rawheight=&quot;243&quot;&gt;&lt;p&gt;上图中，如果我们能限制浅紫色滑块最多只能向右滑动一格的话，深紫色滑块想要右移必须让2个橙色滑块分别移动到浅紫色滑块右移后空出的空间中。当然，上图的与门可以简单地扩展到多个子句的情况上。接着，每个浅紫色滑块自然就应该代表着各个子句啦，它应该是一个或门&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9ce5e462153e91facc78255dc1a958a6_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;168&quot; data-rawheight=&quot;287&quot;&gt;&lt;p&gt;类似地，浅紫色滑块想要右移须让橙滑块移动到任意红色滑块右移后空出的空间中。浅紫色滑块相当于一个或门，对应于S中的3个项的析取构成的子句，而3个红滑块应该分别代表着子句中的3个项。&lt;/p&gt;&lt;p&gt;另外，对于S涉及到的每个变量xi，我们设置一个滑块与之对应，滑块的位置对应于变量的赋值情况。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0fc9a9fa682faa6fe6217536f18b87ff_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;508&quot; data-rawheight=&quot;134&quot;&gt;&lt;p&gt;上图中每个绿色滑块对应于一个变量，我们设定滑块在左侧对应于赋值False，在右侧则对应于Ture。容易看出，无论绿滑块的位置如何，每对黄滑块中只有一个滑块可以上移，这对应于变量的赋值只能是Ture和False中的一个。而每个黄滑块也正好对应于一个项xi或┐xi。&lt;/p&gt;&lt;p&gt;现在表示项xi和┐xi的滑块有了，表示子句中的项的滑块也有了，接下来的问题是如何把它们关联起来。因为简单地延长红滑块和黄滑块的长度来关联的话会出现一个问题，滑块可能会重叠相交。所以，我们&lt;b&gt;需要一个滑块结构来使得“信号”可以同时在垂直和水平两个方向上互不干扰地传递&lt;/b&gt;。其实，能完成这个任务的结构已经在第一个滑块问题例子中出现了，在一个3*3的空间中放上一个2*2的滑块便可以使“信号”在垂直和水平两个方向上传递。不过2*2的滑块只能传递一格的“信号”，若想传递更多的信号我们需要放大一下滑块。有了这样的“枢纽”结构，我们将所有黄滑块和红滑块重叠相交的地方都用这个结构来替代就能完成归约了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3.归约实例&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们用一个例子来说明具体的归约构造。对于3-合取范式 &lt;equation&gt;(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)&lt;/equation&gt; ，我们构造对应的滑块问题实例T如下图&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0df59a9cd697bb63a490abb43d33c99f_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;553&quot;&gt;&lt;p&gt;其中，灰色方格为墙方格，白色方格为空方格，其他颜色的方格是滑块，现在问题是黑色滑块能否向右移动一格。需要说明的是：每个子句中的项对应于一个横向的红滑块，与其关联的是对应项的黄滑块（例如第一个子句中的第二个项是x2，因此第二行红色滑块与第三列黄滑块关联，其中由于与第二列黄滑块交叉，因而加入了一个“枢纽”结构）；由于S由两个子句构成，每个子句都可能包含某个项xi或┐xi，因此我们在每个绿色变量滑块的两边预留了2格的空间；这造成垂直方向上需要传递的“信号”数量可能达到2，所以我们将蓝色的“枢纽”滑块放大到2*3；右侧中间的1*1橙色滑块用于“信号”的部分传递。&lt;/p&gt;&lt;p&gt;显然，这个归约可以在多项式时间内完成。而为了说明归约成立，我们还需要证明S可满足等价于图中的滑块问题有解，这其实也比较容易。&lt;/p&gt;&lt;p&gt;&lt;b&gt;必要性&lt;/b&gt;（S可满足→T有解）。那么存在对xi的赋值使得S满足，比如x1=False, x2=True, x3=False。我们根据赋值将绿色滑块移动到对应的位置，然后让所有的黄色滑块尽量的上移，腾出空间让红色滑块尽量的右移。由于S满足，根据我们的构造，每个浅紫色子句滑块对应的3个红滑块中至少有一个可以右移，因此每个子句滑块也能右移，从而深紫色滑块和黑色滑块可以右移，因而滑块问题有解。具体形状见下图&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5ccd56a24da2a51eba57509ec30a332e_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;686&quot; data-rawheight=&quot;548&quot;&gt;&lt;p&gt;&lt;b&gt;充分性&lt;/b&gt;（T有解→S可满足）。类似地，滑块问题有解说明黑色和深紫色滑块可以右移，说明每个浅紫色子句滑块可以&lt;b&gt;同时&lt;/b&gt;右移，说明每个子句滑块对应的3个红滑块至少有一个可以右移，说明与红滑块关联的黄色滑块可以上移，上移的黄滑块决定了绿色变量滑块的位置，这就给出了一组使得S满足的变量赋值。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4.更多的限制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;之前我们讨论的滑块问题没什么限制，现在我们来对滑块的形状做一些限制，看看它是否仍然属于NP-hard。我们将滑块的形状限制为和“华容道”游戏中一样，只允许有1*1、1*2和2*2的滑块。我们试图在上一节归约方法的基础上做一些改动，使得滑块的形状只有上述3种而归约依然有效。&lt;/p&gt;&lt;p&gt;我们先来处理比较简单的结构，将之前归约中的绿色变量滑块替换成1*2的形状，这并不会产生滑块功能的改变。其次红色和黄色这两类“长”滑块可以替换成若干个1*1的滑块，而在末端使用1*2的滑块来限制其移动距离。而蓝色“枢纽”滑块不太好处理，在新的限制下，我们只能使用2*2形状的滑块作为枢纽滑块，这将无法处理多个子句包含同一个项的情况。因此，我们尝试着增加每个项在滑块游戏实例中的“列数”来解决这一问题。&lt;/p&gt;&lt;p&gt;我们用下面这个只使用1*2滑块的结构来扩展“列数”&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1d4f3fde5416d36e93eafb498eace0d8_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;377&quot; data-rawheight=&quot;141&quot;&gt;&lt;p&gt;本来绿色变量滑块只能提供一个“信号”，而通过上面的&lt;b&gt;“复制”结构&lt;/b&gt;，使得“信号”数量可以增加到两个。当然重复使用这个结构可以使项的“列数”扩展到任意数量。另外凑巧的是，这个&lt;b&gt;结构逆向使用的话相当于一个与门&lt;/b&gt;！如果从右向左看，只有两个黄色滑块同时下移后，绿色滑块才能右移，这不就是一个与运算嘛。好了，之前归约中的与门也可以用限制型滑块替代了，那么只剩下或门了。幸运的是，1*1滑块天然就是或门。&lt;/p&gt;&lt;p&gt;我们将这些方法整合起来就可以将3-SAT多项式时间归约到有限制的滑块问题。 还是先前的那个例子，公式&lt;equation&gt;(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)&lt;/equation&gt; 对应的有限制的滑块问题T&#39;如下图&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcb22d537168e27b2421e0f801a58a2c_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;590&quot; data-rawheight=&quot;370&quot;&gt;&lt;p&gt;注意，这里所有的&lt;b&gt;橙色滑块全是1*1的滑块&lt;/b&gt;。公式可满足等价于有限制的滑块问题有解的证明与之前是完全类似的，不再重复了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5.总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们初步分析了“华容道”游戏的一个推广的滑块游戏问题的计算复杂性。构造了一个从3-SAT问题到滑块游戏问题的多项式时间归约，说明了滑块游戏问题属于NP-hard。对于限制滑块形状只能为1*1、1*2和2*2的滑块游戏问题，我们对归约作了一些改动使得归约依然成立。然而，对于墙方块有所限制（比如墙必须是矩形框不能镂空等）的问题，没想到构造归约的方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS. 1. 一开始我想直接从SAT即布尔公式可满足问题进行归约的，但是发现非门不好构造，后来就尝试了3-SAT，果然3-SAT不愧为“第一起点归约问题”；2. 我觉得那个“枢纽”结构是规约的关键，其他结构比较方便的，这个结构还有点像机械里面的星型发动机的构造；3. 其实我总觉得这种经典问题的计算复杂性分析应该有人做过了，但是搜了一下没找到，那个寻找N-puzzle问题最优解是NP-hard的，但是感觉N-puzzle和这里的滑块问题不太一样。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2017.10.7&lt;/p&gt;</description>
<author>终军弱冠</author>
<guid isPermaLink="false">2017-10-07-29835678</guid>
<pubDate>Sat, 07 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>搭建 Emacs 的 Haskell/Idris 环境教程</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-05-29881268.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;搭建 Emacs 的 Haskell/Idris 环境教程&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29881268&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-01d44acb509148aa16658d3590521dd1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;原文发表在我的博客： &lt;a href=&quot;http://ice1000.org/2017/10/03/EmacsIdrisHaskellEnv/&quot;&gt;搭建 Emacs 的 Haskell/Idris 环境教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最近看见 Haskell 群的萌新费尽心思也没成功搭建环境，而且很多都是用浏览器编程，很不清真。为了拯救苍生，顺便为考 SAT 攒人品，我决定写一篇搭建环境教程，来扩大 Emacs 势力。&lt;/p&gt;&lt;p&gt;由于 Idris 用户需要进行的操作基本上是 Haskell 用户的超集，因此未说明的地方就是都要进行的，针对 Idris 用户的额外步骤会说明。&lt;/p&gt;&lt;p&gt;编译 Idris 是一种浪漫，我的笔记本 5 分钟就编译好了，湛忠胜说编译了一下午。本文将讲述编译而不是下载二进制 Idris 的方法。&lt;/p&gt;&lt;p&gt;本文针对的操作系统是 Linux ，只要能用 apt 就可以了。&lt;/p&gt;&lt;h2&gt;本文使用的工具及版本&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Emacs 25&lt;/li&gt;&lt;li&gt;GHC 8.2.2&lt;/li&gt;&lt;li&gt;Cabal 1.24&lt;/li&gt;&lt;li&gt;Idris 1.1.1&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;本文使用的镜像源&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;&gt;清华大学 tuna 镜像源&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;tuna 在本文发布的时候暂时挂掉了，因此在国庆期间搭建环境的同学们可以把下文中的 tuna 源智能替换为 ustc 源。 但是你就会遇到很多其它问题，所以我还是推荐等 tuna 活过来后用 tuna 。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://mirrors.ustc.edu.cn/&quot;&gt;ustc 源&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;apt 准备&lt;/h2&gt;&lt;p&gt;先加源，然后安装，下面的指令直接复制进终端执行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ sudo add-apt-repository ppa:hvr/ghc
$ sudo add-apt-repository ppa:ubuntu-elisp/ppa
$ sudo apt-get update
$ sudo apt-get install emacs25
$ sudo apt-get install ghc-8.2.2
$ sudo apt-get install cabal-install-1.24&lt;/code&gt;&lt;h2&gt;配置&lt;/h2&gt;&lt;p&gt;打开你的 ~/.bashrc ，加入下面的配置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;alias ec=&quot;emacsclient25 -nw&quot;
alias en=&quot;emacs25 -nw&quot;
alias ecw=&quot;emacsclient25&quot;
export PATH=~/.cabal/bin:/opt/ghc/bin:/opt/cabal/bin:$PATH &lt;/code&gt;&lt;p&gt;以上代码节选自&lt;a href=&quot;https://github.com/ice1000/xjb-config/blob/master/.bashrc&quot;&gt;我的 bashrc&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;然后执行以下命令，以重新加载这些配置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ source ~/.bashrc&lt;/code&gt;&lt;h2&gt;配置 Cabal&lt;/h2&gt;&lt;p&gt;根据上面给出的 tuna 源的指示进行操作。 这对于 Haskell 来说不是必须的，但却是非常非常非常建议的。 Idris 用户请确保完成这一步。&lt;/p&gt;&lt;h2&gt;编译 Idris&lt;/h2&gt;&lt;p&gt;直接输指令就行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ cabal-1.24 update
$ cabal-1.24 install idris&lt;/code&gt;&lt;h2&gt;搞懂啥是 emacsclient&lt;/h2&gt;&lt;p&gt;其实是因为我使用了 linum-mode 这个插件，导致每次 Emacs 打开都特别慢 ，正好应了古人那句 EMACS == Emacs Makes A Computer Slower 。 因此我将会采用 Emacs Daemon 来加速 Emacs 启动。 这个东西的原理就是先开个 Emacs 进程，在后台运行，把插件啥的都加载好，蓝后每次使用 Emacs 的时候启动一个客户端，连上这个后台进程就是了。 于是就可以超级快了。&lt;/p&gt;&lt;p&gt;首先，在开始启动第一个 Emacs 前，先启动守护进程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ emacs25 --daemon&lt;/code&gt;&lt;p&gt;蓝后在命令行使用 Emacs 打开一个文件，请输入&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ ec [你要打开的文件路径]&lt;/code&gt;&lt;p&gt;若要在 GUI 下使用 Emacs ，请使用&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ ecw [你要打开的文件路径]&lt;/code&gt;&lt;p&gt;推荐使用命令行。&lt;/p&gt;&lt;p&gt;这时如果你更新了你的配置，需要重启 Emacs ，那么你需要杀了 Emacs 并让他复活：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ pkill emacs
$ emacs25 --daemon&lt;/code&gt;&lt;p&gt;这时候你的 Emacs 还是裸的，现在我们来配置它。&lt;/p&gt;&lt;p&gt;哦，差点忘了，为了防止一些悲剧发生，请在杀死 Emacs 前终止所有正在运行的 emacsclient 。&lt;/p&gt;&lt;p&gt;为了防止另一些悲剧的发生，请记下退出 Emacs 的快捷键： Ctrl+X Ctrl+C 。按法：按住 Ctrl 不放，然后分别按 X 和 C 。&lt;/p&gt;&lt;p&gt;你打开你的 Emacs 之后应该看到它是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;File Edit Options Buffers Tools Help
Welcome to GNU Emacs, one component of the GNU/Linux operating system.

Get help           C-h  (Hold down CTRL and press h)
Emacs manual       C-h r        Browse manuals     C-h i
Emacs tutorial     C-h t        Undo changes       C-x u
Buy manuals        C-h RET      Exit Emacs         C-x C-c
Activate menubar   M-`
(‘C-’ means use the CTRL key.  ‘M-’ means use the Meta (or Alt) key.
If you have no Meta key, you may instead type ESC followed by the character.)
Useful tasks:
Visit New File                  Open Home Directory
Customize Startup               Open *scratch* buffer

GNU Emacs 25.3.50.2 (x86_64-pc-linux-gnu, GTK+ Version 3.18.9)
 of 2017-09-16
Copyright (C) 2017 Free Software Foundation, Inc.

GNU Emacs comes with ABSOLUTELY NO WARRANTY; type C-h C-w for full details.
Emacs is Free Software--Free as in Freedom--so you can redistribute copies
of Emacs and modify it; type C-h C-c to see the conditions.
Type C-h C-o for information on getting the latest version.
-UUU:%%--F1  *GNU Emacs*    Top of 1.0k (1,0)      (Fundamental) ---------------
For information about GNU Emacs and the GNU system, type C-h C-a.
&lt;/code&gt;&lt;h2&gt;配置 Emacs&lt;/h2&gt;&lt;p&gt;把下面的东西原封不动地抄进 ~/.emacs 里面。&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(require &#39;package)
(setq package-archives
			&#39;((&quot;gnu&quot;   . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;)
				(&quot;melpa&quot; . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;)))

(package-initialize)
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won&#39;t work right.
 &#39;(ac-auto-show-menu 0.1)
 &#39;(ac-modes
	 (quote
		(emacs-lisp-mode lisp-mode lisp-interaction-mode slime-repl-mode nim-mode c-mode cc-mode c++-mode objc-mode
                     swift-mode go-mode java-mode malabar-mode clojure-mode clojurescript-mode scala-mode
                     scheme-mode ocaml-mode tuareg-mode coq-mode haskell-mode agda-mode agda2-mode perl-mode
                     cperl-mode python-mode ruby-mode lua-mode tcl-mode ecmascript-mode javascript-mode
                     js-mode js-jsx-mode js2-mode js2-jsx-mode coffee-mode php-mode css-mode scss-mode
                     less-css-mode elixir-mode makefile-mode sh-mode fortran-mode f90-mode ada-mode xml-mode
                     sgml-mode web-mode ts-mode sclang-mode verilog-mode qml-mode apples-mode
                     haskell-mode fundamental-mode
                     idris-mode ; 这一行仅 Idris 用户添加
  )))
 &#39;(blink-cursor-mode t)
 &#39;(column-number-mode t)
 &#39;(custom-enabled-themes nil)
 &#39;(flyspell-abbrev-p t)
 &#39;(flyspell-after-incorrect-word-string nil)
 &#39;(font-use-system-font t)
 &#39;(global-auto-complete-mode t)
 &#39;(global-linum-mode t)
 &#39;(idris-interpreter-path &quot;~/.cabal/bin/idris&quot;) ; 这一行仅 Idris 用户添加
 &#39;(show-paren-mode t)
 &#39;(size-indication-mode t))&lt;/code&gt;&lt;p&gt;上面的配置有两行是只有 Idris 用户需要添加的，请注意阅读注释。&lt;/p&gt;&lt;p&gt;配置节选自&lt;a href=&quot;https://github.com/ice1000/xjb-config/blob/master/.emacs&quot;&gt;我的 .emacs&lt;/a&gt; ，原本还有一些其他内容，与 Haskell Idris 无关我就删了。&lt;/p&gt;&lt;p&gt;这时候重启 Emacs ，你会发现你的配置可能加载不起，因为你没装对应的插件。 我们首先在 Emacs 里按下 Alt+X ，然后这时你的光标出现在最下面。&lt;br&gt;输入 package-list-package ，然后它应该是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-UUU:%%--F1  *GNU Emacs*    Top of 1.0k (1,0)      (Fundamental) ---------------
M-x package-list-packages&lt;/code&gt;&lt;p&gt;等一会(这时开始下载 tuna 上的 elpa/gnu 源的内容)，然后你会发现出现了插件列表。&lt;/p&gt;&lt;p&gt;大概是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt; 1  ace-window         0.9.0         available  Quickly switch windows.
  2  ack                1.5           available  interface to ack-like tools
  3  ada-mode           5.3.1         available  major-mode for editing Ada sou$
  4  ada-ref-man        2012.3        available  Ada Reference Manual 2012
  5  adaptive-wrap      0.5.1         available  Smart line-wrapping with wrap-$
  6  adjust-parens      3.0           available  Indent and dedent Lisp code, a$
  7  aggressive-indent  1.8.3         available  Minor mode to aggressively kee$
  8  ahungry-theme      1.5.0         available  Ahungry color theme for Emacs.$
  9  all                1.0           available  Edit all lines matching a give$
 10  ampc               0.2           available  Asynchronous Music Player Cont$
 11  arbitools          0.71          available  Package for chess tournaments $
 12  ascii-art-to-un... 1.11          available  a small artist adjunct
 13  async              1.9.2         available  Asynchronous processing in Ema$
 14  auctex             11.91.0       available  Integrated environment for *Te$
 15  aumix-mode         7             available  run the aumix program in a buf$
 16  auto-correct       1.1           available  Remembers and automatically fi$
 17  auto-overlays      0.10.9        available  Automatic regexp-delimited ove$
 18  beacon             1.3.2         available  Highlight the cursor whenever $
 19  bug-hunter         1.3.1         available  Hunt down errors by bisecting $
 20  caps-lock          1.0           available  Caps-lock as a minor mode
-UUU:%%--F1  *Packages*     Top of 25k  (1,0)      (Package Menu) --------------&lt;/code&gt;&lt;p&gt;使用快捷键 Ctrl+S 进入搜索，这时你的光标在最下面。 输入 auto-complete ，找到叫这个名字的插件。搜索结果之间用 Ctrl+S 切换。&lt;br&gt;蓝后对它按下回车，看到半个屏幕变成了它的安装说明。&lt;br&gt;我的是安装好了的，看起来和你们的会不大一样，不过基本上是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-UUU:%%--F1  *Packages*     65% of 25k  (199,9)    (Package Menu) --------------
 1auto-complete is a dependency package.
 2
 3     Status: Installed in ‘auto-complete-20170124.1845/’ (unsigned).
 4    Version: 20170124.1845
 5    Summary: Auto Completion for GNU Emacs
 6   Requires: popup-0.5.0, cl-lib-0.5
 7Required by: ac-c-headers-20151021.134
 8
 9This extension provides a way to complete with popup menu like:
10
-UU-:%%--F1  *Help*         Top of 618  (1,0)      (Help) ----------------------
Type C-x 1 to delete the help window, C-M-v to scroll help.&lt;/code&gt;&lt;p&gt;用 Ctrl+X O 切到这半个屏幕，然后把光标移动到 [Install] 上（上面就没有，因为我已经装好了），回车安装。&lt;/p&gt;&lt;p&gt;按理说安装是很快的，然后用 Ctrl+0 关掉这半个窗口。 你会发现原本的插件列表界面变成了一些编译信息。用 Ctrl+X K (输完这快捷键它会让你确认一下，这时回车就好)关掉它，回到原本的插件列表。&lt;/p&gt;&lt;p&gt;按照同样的步骤搜索并安装 haskell-mode 。 Idris 用户请安装 idris-mode 。&lt;/p&gt;&lt;p&gt;然后就什么都没有了！再用 Emacs 打开一个 .hs 结尾的文件，就可以看到漂亮的高亮了！&lt;/p&gt;&lt;h2&gt;快乐生活每一天&lt;/h2&gt;&lt;p&gt;你可以使用 Tab 键来调整缩进(而不是输入 Tab)， Haskell 插件会自动告诉你可以用哪些缩进，不会让你吃缩进的亏。&lt;/p&gt;&lt;p&gt;这个插件很牛逼。比如，你会发现，只有开启了 TypeFamilies 插件后，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;type family Xxx &lt;/code&gt;&lt;p&gt;才会高亮出来。&lt;/p&gt;&lt;h2&gt;对于 Idris&lt;/h2&gt;&lt;p&gt;一样的，只是可以用 Ctrl+C Ctrl+L 自动进行 type check ，而且报错时还会把报错那一行高亮出来。&lt;/p&gt;&lt;p&gt;填 hole 请用 Ctrl+C Ctrl+A 。&lt;/p&gt;&lt;h2&gt;健康生活一辈子&lt;/h2&gt;&lt;p&gt;建议开启一个终端里两个 Tab ，一个开 Emacs ，一个开 ghci 。 Idris 同理。&lt;/p&gt;</description>
<author>大笨蛋千里冰封</author>
<guid isPermaLink="false">2017-10-05-29881268</guid>
<pubDate>Thu, 05 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Simon Peyton Jones - Compiling without continuations</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-09-27-29722926.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Simon Peyton Jones - Compiling without continuations&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29722926&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-213c8aee9a2371e3336bb6eefc6f057c_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这是 SPJ 在 &lt;a href=&quot;https://pldi17.sigplan.org/&quot;&gt;PLDI 2017&lt;/a&gt;  上发表的关于 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points-pldi17.pdf&quot;&gt;join point&lt;/a&gt;  的 talk，十分有趣， &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/73c168246af1fab79b28736c311466e1&quot; data-hash=&quot;73c168246af1fab79b28736c311466e1&quot; data-hovercard=&quot;p$b$73c168246af1fab79b28736c311466e1&quot;&gt;@韩冬&lt;/a&gt;  听译整理。&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic2.zhimg.com/v2-b41bb43f595293c7db0cce11570fcefd.jpg&quot; data-sourceurl=&quot;http://www.iqiyi.com/w_19rvbow2a1.html&quot; data-name=&quot;Compiling without continuations&quot; data-video-id=&quot;896416823258537984&quot; data-video-playable=&quot;false&quot; data-lens-id=&quot;&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外欢迎关注本人开通的订阅号：冬的自由地。预计定期更新些编程相关文章 XD&lt;/p&gt;</description>
<author>韩冬</author>
<guid isPermaLink="false">2017-09-27-29722926</guid>
<pubDate>Wed, 27 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>0x05: SICP 的魔法 - 实例:数字电路模拟</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-09-26-29695168.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;0x05: SICP 的魔法 - 实例:数字电路模拟&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29695168&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3076ebc172bbb1203c811053d6b5872a_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;知乎的编辑器好烦啊，总是代码块语言总是掉。。。&lt;br&gt;我的github地址：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk&quot;&gt;lfkdsk &lt;/a&gt;&lt;br&gt;还创建了相关的仓库，可以clone下来看：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk/SICP-Magical-Book&quot;&gt;SICP 的魔法&lt;/a&gt; &lt;br&gt;这个仓库还绑定了 gitbook 可以去下载。&lt;br&gt;我的原文地址：&lt;a href=&quot;http://lfkdsk.github.io/2017/08/08/learn-sicp-5/&quot;&gt;0x05: SICP 的魔法 - 实例:数字电路模拟&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;在第二章我们学到的和 &lt;b&gt;数据抽象&lt;/b&gt; 相关的知识指出，如果想构造数据抽象，我们需要两个部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;创建构造函数包含数据&lt;/li&gt;&lt;li&gt;创建选择函数 &lt;b&gt;分派&lt;/b&gt; 数据&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;但是在经过了解了第三章相关的 &lt;i&gt;模块化、状态、环境&lt;/i&gt; 的知识之后，我们认识到了新的问题，在实际编程之中，需要依赖程序的状态进行编程，那么程序中就要根据我们的环境求值的方式进行计算，那我们在重新设计和模拟系统大的时候就要多考虑几点了：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在系统中我们带状态的数据抽象&lt;/li&gt;&lt;li&gt;创建 &lt;b&gt;改变函数(mutator)&lt;/b&gt; 去对数据进行重新修改&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;基于变动的模拟&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在构建复杂的系统之中，我们最先面对的部分就是关于 &lt;i&gt;同一性&lt;/i&gt; 的知识，这部分知识我们已经在上一章的 &lt;b&gt;同一性发生了变化&lt;/b&gt; 的那个小节中简单的讨论过一次，我们可以在这个再重新讨论一下 &lt;b&gt;共享和相等&lt;/b&gt; 的知识。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;共享和相等&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们通过引入赋值的方式为系统引入了状态，但是造成了引用透明的危机，我们没办法再通过相同的结构来判断对象西相同，两个相同结构的对象并不能确定两个对象是否相同：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define x (list &#39;a &#39;b))
(define z1 (cons x x))&lt;/code&gt;&lt;p&gt;我们定义了这样的一个结构，&lt;i&gt;x&lt;/i&gt; 是&#39;a 和 &#39;b 组成的序对，然后 &lt;i&gt;z1&lt;/i&gt; 是由两个 &lt;i&gt;x&lt;/i&gt; 的组成的序对，我们还要在另外定义一个 &lt;i&gt;z2&lt;/i&gt;：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define z2 (cons (list &#39;a &#39;b) (list &#39;a &#39;b)))&lt;/code&gt;&lt;p&gt;这两个结构的定义起来，看起来的结构是一样的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7cb8d6a314747e5d2827361f56b7d84d_r.jpg&quot; data-rawwidth=&quot;675&quot; data-rawheight=&quot;348&quot;&gt;&lt;p&gt;这里我们能看到放置 &#39;a 和 &#39;b 两个序对中的节点都指向了同一个节点，这是因为在 Scheme 中符号引用是共享的，因而他们都指向了同一个节点。但是很明显虽然 &lt;b&gt;符号引用&lt;/b&gt; 都指向了同一个节点，但是整体的结构是两个结构指向了两个结构，直接使用：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(eq? z1 z2)&lt;/code&gt;&lt;p&gt;的结果肯定是不相等的，这意味着我们每次使用 cons 方法结成一个新的序对都是生成了一个新的对象并返回的是可操作该对象的 &lt;i&gt;指针/引用&lt;/i&gt; （虽然 Scheme 中没有显示的这种概念）。&lt;/p&gt;&lt;p&gt;这时候我们需要考虑另一个问题，就是在整个 &lt;i&gt;数据抽象&lt;/i&gt; 都是不可变的情况下，我们对于数据结构是否使用了同样的引用是不可知的，但是当我们引入 &lt;i&gt;赋值&lt;/i&gt; 我们共享的数据因为使用了同一个贡献的结构而变得复杂起来，修改其中的一个会导致另一个收到影响。&lt;/p&gt;&lt;p&gt;比如我们上文中提到的 &lt;i&gt;z1&lt;/i&gt; 和 &lt;i&gt;z2&lt;/i&gt; 就是这样结构，z1 的两个子结构全都是 x ，如果我们修改一个另一个肯定会受到影响，但是 z2 序对中的两个元素是两个不同的序对，并不会有这个的问题。&lt;/p&gt;&lt;p&gt;引入共享结构会带来一些好处：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;扩充数据抽象能够定义的数据范围&lt;/li&gt;&lt;li&gt;作为内部状态引入的结构，能够在程序的运行过程中不断地变化，这就可以承担我们需要让他们模拟更为复杂可变的需求&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但是上面的这个例子（关于 z1 和 z2 的）也表明了，我们在构建复杂结构的时候需要自己清楚那些结构是共享的，在对这些共享的进行修改的时候我们也要谨慎。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;以赋值改变结构&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;Tips 基于改变函数的新 API，我们的数据依赖 &lt;b&gt;序对&lt;/b&gt; 进行构造，那我们的改造函数需要和构造函数类似的结构&lt;br&gt;set-car!  修改序对中的首项&lt;br&gt;set-cdr!  修改序对中的第二项&lt;/blockquote&gt;&lt;p&gt;在之前我们使用该通过过程来存储数据和模拟序对的表示，当时我们通过  作为 Tag 模拟了序对的分派，这里我们可以对这个程序略作修改：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m &#39;car) x)
          ((eq? m &#39;cdr) y)
          (else (error &quot;Undefined operation -- cons&quot; m))))
  dispatch)

(define (car z) (z &#39;car))
(define (cdr z) (z &#39;cdr))&lt;/code&gt;&lt;p&gt;这个程序的变化其实不大，我们这是利用了 Scheme 中的符号引用的唯一性的这点，本质上和用 &lt;b&gt;0 1&lt;/b&gt; 没有什么区别。我们再跟着这个改造的理念可以为这个程序进行扩充，添加我们之前提到的 set-car! 和 set-cdr! 函数：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m &#39;car) x)
          ((eq? m &#39;cdr) y)
          ((eq? m &#39;set-car!) set-x!)
          ((eq? m &#39;set-cdr!) set-y!)
          (else (error &quot;Undefined operation -- cons&quot; m))))
  dispatch)

(define (car z) (z &#39;car))
(define (cdr z) (z &#39;cdr))
(define (set-car! z new-value) ((z &#39;set-car!) new-value) z)
(define (set-cdr! z new-value) ((z &#39;set-cdr!) new-value) z)&lt;/code&gt;&lt;p&gt;这里面我们通过增加了程序的内部状态，并且增加了两个内部方法来搞定了这个问题。&lt;/p&gt;&lt;p&gt;接下来部分是几个非常有趣的实例学习，包括对表格，队列和数字电路的模拟。这里面前面的表格、队列的知识都比较的简单，这里我们主要关注这个 &lt;i&gt;数字电路模拟&lt;/i&gt; 的学习。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;数字电路模拟&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;本节中的代码可以到 Github 仓库 &lt;b&gt;&lt;a href=&quot;https://github.com/lfkdsk/SICP-Magical-Book&quot;&gt;SICP-Magical-Book&lt;/a&gt;&lt;/b&gt; 中获取&lt;/blockquote&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1f6fa8198befb0f82f9b3c6c6f78e306_r.jpg&quot; data-rawwidth=&quot;372&quot; data-rawheight=&quot;125&quot;&gt;&lt;p&gt;这是一个比较有趣的实例，一个数字电路的模拟器本身是完成一种基于状态的系统模拟，而且本身从设计构建系统的角度中来看数字电路的模拟也是非常好玩，因为本身数字电路是由更多的细小的部件来构成的，本身带有一种自底向上进行程序设计的思路。另外，数字电路模拟还包含了另一种思想，一种基于事件驱动的模拟系统，我们用 &lt;i&gt;事件信号&lt;/i&gt; 模拟实际的 &lt;i&gt;数字信号&lt;/i&gt; 流过整个模拟的电路程序。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;事件驱动设计&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;b&gt;事件驱动程序设计&lt;/b&gt;（英语：&lt;b&gt;Event-driven programming&lt;/b&gt;）是一种电脑&lt;a href=&quot;http://www.wikiwand.com/zh-sg/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88&quot;&gt;程序设计&lt;/a&gt;&lt;a href=&quot;http://www.wikiwand.com/zh-sg/%E6%A8%A1%E5%9E%8B&quot;&gt;模型&lt;/a&gt;。这种模型的程序运行流程是由用户的动作（如&lt;a href=&quot;http://www.wikiwand.com/zh-sg/%E6%BB%91%E9%BC%A0&quot;&gt;鼠标&lt;/a&gt;的按键，键盘的按键动作）或者是由其他程序的&lt;a href=&quot;http://www.wikiwand.com/zh-sg/%E8%A8%8A%E6%81%AF&quot;&gt;消息&lt;/a&gt;来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由&lt;a href=&quot;http://www.wikiwand.com/zh-sg/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%B8%AB&quot;&gt;程序员&lt;/a&gt;来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的。&lt;br&gt;—— Wikipedia&lt;/blockquote&gt;&lt;p&gt;从这段维基百科中摘取出来的关于 &lt;i&gt;事件驱动程序&lt;/i&gt; 的介绍，我们对事件驱动可能已经有了一定的理解。其实简单的去理解事件驱动设计，其实就是和传统的基于批处理的程序设计不同，因为那么去写过程式的程序，只能根据程序开发者的编写顺序对程序进行运行，但是事件驱动的程序设计，就像是设定了某些条件，当某些事件触发了这些条件的时候，程序会自动对事件进行处理。&lt;/p&gt;&lt;p&gt;这里我们的数字电路的模拟也是类似，一个数字电路由更细粒度的一系列的组件构成，在整个数字电路的操作中，各个部件的活动构成了这个整体的活动。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;电路系统的构建的过程中会遇到一些事件，这些事件是由某些部件遇到一些情况而引发的，并且引发可能是有时间顺序的（很正常，数字信号的传播肯定有顺序）。&lt;/li&gt;&lt;li&gt;还有一个是事件会引起状态的继续改变，状态的改变又会继续带来事件的产生和传播。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;基础部件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;实际的数字电路线路由一些电子元件和它们之间的连线组成，一个电子元件可能有几个输入端口和一个输出端口，功能就是从多个接入信号经过一系列处理然后输出一个信号：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5f6255b8492d6a228bc76d80fc58bdf_r.jpg&quot; data-rawwidth=&quot;261&quot; data-rawheight=&quot;432&quot;&gt;&lt;p&gt;就向我们上图的这些部件，可以提供一些 &lt;i&gt;与、或、非门&lt;/i&gt; 这些基础部件，另外我们还需要各种部件之间的连线，这些连线会需要传递 &lt;i&gt;0、1&lt;/i&gt; 这样的信号，除此之外各种功能块都会有不同的输出并且产生删除出信号都会有一些信号延迟。&lt;/p&gt;&lt;p&gt;在不断地通过基本构造块和连线进行数字链路的搭建的过程中，实际的数字电路程序已经实际成了一种结构设计语言，并且通过模块的不断构造我们语言的中使用的基本模块也在不断的在扩充，我们用这种语言能够构造结构任意复杂的数字电路：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;模块化&lt;/b&gt; —— 基本构造块是基本元素&lt;/li&gt;&lt;li&gt;&lt;b&gt;组合机制&lt;/b&gt; —— 通过基本元素和连线进行组合&lt;/li&gt;&lt;li&gt;&lt;b&gt;抽象机制&lt;/b&gt; —— 我们可以进一步将复杂的组合过程抽象成过程&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;连线&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;Tips 半加器：&lt;br&gt;半加器的功能是将两个一位二进制数相加。它具有两个输入和两个输出（分别是和、进位）。输出的进位信号代表了输入两个数相加溢出的高一位数值。因此，这两2个一位二级制数的和等于2&lt;i&gt;C&lt;/i&gt; + &lt;i&gt;S&lt;/i&gt;。根据两个一位二进制数相加的结果，可以通过真值表、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%A1%E8%AF%BA%E5%9B%BE&quot;&gt;卡诺图&lt;/a&gt;得到右图所描绘的简易半加器设计。它使用了一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96%E9%97%A8&quot;&gt;异或门&lt;/a&gt;来产生和&lt;i&gt;S&lt;/i&gt;，并使用了一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%8E%E9%97%A8&quot;&gt;与门&lt;/a&gt;来产生进位信号&lt;i&gt;C&lt;/i&gt;。如果再添加一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%88%96%E9%97%A8&quot;&gt;或门&lt;/a&gt;来接收低位的进位输出信号，则两个半加器就构成了一个全加器。&lt;/blockquote&gt;&lt;p&gt;电路需要由连线来连接我们的基础功能块，由基础的功能块组成更大的功能块，我们这里先使用一个定义生成基础连线的方法 &lt;i&gt;(make-wire)&lt;/i&gt; 生成一条连线，我们可以通过这个方法生成连线，然后把各个部件绑定在一起：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;; 生成六根连线
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))

; 使用与或非门构建半加器 参考之前的半加器图片
(or-gate a b d)
(and-gate a b c)
(inverter c e)
(and-gate d e s)&lt;/code&gt;&lt;p&gt;这里面的 A 和 B 是数据输入，S 和 C 是数据输出，其中S 是和，C 是进位，我们能看到抽象出来连接线、和与、或、非门之后我们对电路的的描述能被抽象到非常简洁形式，我们还可以把这几个过程结合成一个流程生成出一个 半加器的过程：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (half-adder a b s c)
  (let ((d (make-wire))
        (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    &#39;ok))&lt;/code&gt;&lt;p&gt;两个半加器和一个或门能够成一个全加器：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-43bd392258485a9d80a28b9c9a3828f5_r.jpg&quot; data-rawwidth=&quot;965&quot; data-rawheight=&quot;392&quot;&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    &#39;ok))&lt;/code&gt;&lt;p&gt;这就是像是我们之前提到的，使用抽象机制将全加器、半加器这些复杂组件封装成构建过程。&lt;/p&gt;&lt;p&gt;我们在这里还可以给出连线上的发送信号的基本操作：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(get-signal &amp;lt;wire&amp;gt;) ; 返回当前线上的信号值
(set-signal! &amp;lt;wire&amp;gt; &amp;lt;new-value&amp;gt;) ; 重设线上的信号值
(add-action! &amp;lt;wire&amp;gt; &amp;lt;procedure of no arguments&amp;gt;) ; 在线上的信号改变的时候运行过程
(after-delay &amp;lt;time&amp;gt; &amp;lt;procedure&amp;gt; ; 设定一个时间延迟和对应的过程，时间过后触发过程&lt;/code&gt;&lt;p&gt;这就能试着写出 make-wire 的定义，肯定是包含上面三个函数的 dispatch 的 &lt;b&gt;分发器&lt;/b&gt;，还要有针对多个属性的 &lt;b&gt;修改器&lt;/b&gt;。&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;; 创建一条连线
(define (make-wire)
  (let ((signal-value 0)
        (action-procedures &#39;()))
    ; set new value and call procedures
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          &#39;done))
    
    (define (accept-action-procedure! proc)
      (set! action-procedures
            (cons proc action-procedures))
      (proc))
    
    (define (dispatch m)
      (cond ((eq? m &#39;get-signal) signal-value)
            ((eq? m &#39;set-signal!) set-my-signal!)
            ((eq? m &#39;add-action!) accept-action-procedure!)
            (else (error &quot;Unknown operation -- WIRE&quot; m))))
    
    dispatch))&lt;/code&gt;&lt;p&gt;我们注意到刚才提到的东西我们几乎都有，并且通过过程 accept-action-proceduer 能知道每条线包含的过程不只有一个，是一个列表的形式，而且 set-my-signal! 中我们看到，每当有一个线上的数据修改，我们会重新调用所有监听这条线上的过程。&lt;/p&gt;&lt;p&gt;其中还有一些其他的方法：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;; 遍历调用
(define (call-each procedures)
  (if (null? procedures)
      &#39;done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))

(define (get-signal wire)
    (wire &#39;get-signal))

(define (set-signal! wire new-value)
    ((wire &#39;set-signal!) new-value))

(define (add-action! wire action-procedure)
    ((wire &#39;add-action!) action-procedure))&lt;/code&gt;&lt;p&gt;执行一些 dispatch 方法而已。&lt;/p&gt;&lt;blockquote&gt;Tips 书中的一到课后题也提到了，例如：&lt;br&gt;&lt;/blockquote&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (accept-action-proceduer! proc) 
   (set! action-procedures  (cons proc action-procedures))  (proc))&lt;/code&gt;&lt;blockquote&gt;这个方法，为什么要把 proc 在最后返回，其实这里就是为了让 proc 在那个返回的位置展开，在后面会调用 after-delay ，after-delay 会调用 add-to-agenda! ，将指定的动作添加到模拟器的待处理列表中，当调用 (propagate) 时，这个指定的动作会被执行。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;逻辑电路门&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;scheme&quot;&gt;; 算数逻辑非
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error &quot; Invalid signal &quot; s))))

; 算数逻辑与
(define (logical-and a b)
  (if (and (= a 1) (b = 1))
      1
      0))
      

; 逻辑或
(define (logical-or a b)
  (if (or (= a 1) (= b 1))
      1
      0))

; 与门 给两个线路都绑上一个监控器
; 当某个值变化的时候 会重新计算 new-value 设置到输出端口
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  &#39;ok)

; 或门 
(define (or-gate input-1 input-2 output)
  (define (or-action-procedure)
    (let ((new-value
           (logical-or (get-signal input-1) (get-signal input-2))))
      (after-delay or-gate-delay
                   (lambda ()
                     (set-sign! output new-new-value)))))
    (add-action! input-1 or-action-procedure)
    (add-action! input-2 or-action-procedure)
    &#39;ok)

; 反门
(define (inverter-gate input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! input invert-input)
  &#39;ok)         &lt;/code&gt;&lt;p&gt;如果我们理清了前面的给连线添加信号的内容，那逻辑电路门部分的代码就很简单了，甚至有点冗余。与或非门的唯一区别在于如何生成 new-value ，每个过程都包含一个内部过程，负责生成新的值，把这个过程绑定到输入线上，这里面我们的输入值一旦改变，就会重新进行计算，然后重设当前线路中的数值。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;待处理表&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;待处理表的问题主要是我们之前在程序中的使用 after-delay 操作控制程序在某个时间段之后执行一个过程，能控制一定的操作的时序性，这个功能本质上就是在维护一张 &lt;i&gt;待处理表&lt;/i&gt; ，使用队列的结构控制我们执行过程，先给出各个 API 的内容：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;; 返回新建的空待处理表
(make-agenda) 
; 判断待处理表是否为空
(empty-agenda? &amp;lt;agenda&amp;gt;) 
; 返回待处理表中第一个项
(first-agenda-item &amp;lt;agenda&amp;gt;) 
; 删除待处理表里的第一项
(remove-first-agenda-item! &amp;lt;agenda&amp;gt;) 
; 向待处理表中加入一 项，其意义是要求在给定时间运行的过程
(add-to-agenda! &amp;lt;time&amp;gt; &amp;lt;action&amp;gt; &amp;lt;agenda&amp;gt;) 
; 返回当前时间
(current-time &amp;lt;agenda&amp;gt;) &lt;/code&gt;&lt;p&gt;这些 API 的实现都很容易，我们可以逐个的来讲解一下：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;; segment

(define (make-time-segment time queue)
  (cons time queue))

(define (segment-time s) (car s))

(define (segment-queue s) (cdr s))

; agenda

(define (make-agenda) (list 0))

; 当前时间
(define (current-time agenda) (car agenda))

(define (set-current-time! agenda time)
  (set-car! agenda time))

(define (segments agenda) (cdr agenda))

(define (set-segments! agenda segments)
    (set-cdr! agenda segments))

(define (first-segment agenda) (car (segments agenda)))

(define (rest-segments agenda) (cdr (segments agenda)))

(define (empty-agenda? agenda)
  (null? (segments agenda)))&lt;/code&gt;&lt;p&gt;关于segment 这个几个过程式构建 &lt;i&gt;时间&lt;/i&gt; 和 &lt;i&gt;队列&lt;/i&gt; 的绑定关系，待处理表中的每一项是由时间和时间队列的一个绑定，agenda 本身是一个关于时间的一维表格，在表头存储当前的时间，表头之后存储的是 segments 的段落，还提供了几个 API 做存取。&lt;/p&gt;&lt;p&gt;还有就是如何插入处理表，通过时间片加队列的形式进行查找管理：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;; 向待处理表中添加一项
(define (add-to-agenda! time action agenda)
  ; 检查是否为空 或者当前时间小于 segment 的时间
    (define (belongs-before? segments)
        (or (null? segments)
            (&amp;lt; time (segment-time (car segments)))))
  ; 创建一个新的时间片 生成新的队列 插入过程
    (define (make-new-time-segment time action)
        (let ((q (make-queue)))
              (insert-queue! q action)
              (make-time-segment time q)))
  ; 添加时间片
    (define (add-to-segments! segments)
        ; 找到合适的时间插进去
        (if (= (segment-time (car segments)) time)
            (insert-queue! (segment-queue (car segments))
                           action)
            (let ((rest (cdr segments)))
                (if (belongs-before? rest)
                    (set-cdr!
                        segments
                        (cons (make-new-time-segment time action)
                              (cdr segments)))
                        (add-to-segments! rest)))))
    ; 遍历时间片 找到合适的时间插进去
        (let ((segments (segments agenda)))
            (if (belongs-before? segments)
                (set-segments!
                    agenda
                    (cons (make-new-time-segment time action)
                          segments))
                    (add-to-segments! segments))))&lt;/code&gt;&lt;p&gt;上面的注释应该是介绍的已经很详细的了，还提供了一些方法去对处理表进行一些管理，无非就是如何消耗处理事件之类的：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (remove-first-agenda-item! agenda)
    (let ((q (segment-queue (first-segment agenda))))
        (delete-queue! q)
        (if (empty-queue? q)
            (set-segments! agenda (rest-segments agenda)))))

(define (first-agenda-item agenda)
    (if (empty-agenda? agenda)
        (error &quot;Agenda is empty -- FIRST-AGENDA-ITEM&quot;)
        (let ((first-seg (first-segment agenda)))
            (set-current-time! agenda (segment-time first-seg))
            (front-queue (segment-queue first-seg)))))&lt;/code&gt;&lt;p&gt;最红我们终于要说到 after-delay 的实现定义了：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (after-delay delay action)
    (add-to-agenda! (+ delay (current-time the-agenda))
                    action
                    the-agenda))&lt;/code&gt;&lt;p&gt;可见我们为让某个事件延迟执行的本质就是给某个处理表添加一条处理事件，通过获取当前时间增加一定的延迟的把事件放进对应的序列。&lt;/p&gt;&lt;p&gt;我们还需要一个过程去模拟驱动整个表的执行过程，propagate 对整个待处理表进行操作，不断地处理其中的项目进行处理：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (propagate)
    (if (empty-agenda? the-agenda)
        &#39;done
        (let ((first-item (first-agenda-item the-agenda)))
            (first-item)
            (remove-first-agenda-item! the-agenda)
            (propagate))))&lt;/code&gt;&lt;h2&gt;&lt;b&gt;简单的模拟实例&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Github 仓库中提供了相应的代码，只需要 load 其中的 simular.rkt 就可以进行编写模拟实例的操作。这里面我们添加一个监控器过程放到线路上面，用来监听数字电路模拟中的数字电路模拟的运行情况：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (probe name wire)
    (add-action! wire
                 (lambda ()        
                    (newline)
                    (display name)
                    (display &quot; &quot;)
                    (display (current-time the-agenda))
                    (display &quot;  New-value = &quot;)
                    (display (get-signal wire)))))&lt;/code&gt;&lt;p&gt;这段代码很简单，就是给某根线注册名字和一个相应的回调，当数据发生变化的时候打印出目前的消息。&lt;/p&gt;&lt;p&gt;接下来的模拟是为了模拟一个半加器的运行情况：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;初始化待处理表，定义延迟相关的常量：&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;scheme&quot;&gt;(define the-agenda (make-agenda)) (define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)&lt;/code&gt;&lt;ol&gt;&lt;li&gt;定义四条线路，安装监控器：&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;scheme&quot;&gt;(define input-1 (make-wire)) 
(define input-2 (make-wire)) 
(define sum (make-wire)) 
(define carry (make-wire)) 
(probe &#39;sum sum)
(probe &#39;carry carry)&lt;/code&gt;&lt;p&gt;运行一次的效果是：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-18b78ab4ae784579e9fc3d37b202c983_r.jpg&quot; data-rawwidth=&quot;439&quot; data-rawheight=&quot;245&quot;&gt;&lt;ol&gt;&lt;li&gt;接着我们把线路连接到半加器上，测试半加器的输入：&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;scheme&quot;&gt;(half-adder input-1 input-2 sum carry)&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ebe449b11aa9dae246ecd0a4b254f58c_r.jpg&quot; data-rawwidth=&quot;379&quot; data-rawheight=&quot;67&quot;&gt;&lt;p&gt;测试输入，即将 input-1 设置为 1 ，然后将 input-2 设置为 1 ：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(set-signal! input-1 1)
(propagate)&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8998257ce80b89eb3b92000bfd3d1278_r.jpg&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;116&quot;&gt;&lt;p&gt;这时候时间片为 8 ，设定值为 1。&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(set-signal! input-2 2)
(propagate)&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-931c433974bb355f9af3b1d37b3bbf1a_r.jpg&quot; data-rawwidth=&quot;295&quot; data-rawheight=&quot;123&quot;&gt;&lt;p&gt;时间片为 11 时，carry 被设置为 1，之后 sum 被设置为 0，这表明我们在这的模拟是有效的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章的内容并没有特别多的复杂的理论知识内容没有特别多，主要是进行介绍了书中出现的第一个比较复杂的程序实例，但是这个稍有一些复杂的程序实例中包含了从本书开始就介绍的很多和抽象、模拟相关的知识，也算是用某种实例程序去又温习了之前的知识。&lt;/p&gt;&lt;p&gt;除了对之前的知识的温习之外，这个关于 数字电路模拟程序 的程序设计更多的是关注变动程序的程序设计，程序中和第二章不同的是整个程序都是基于状态变动建立起来的。基础模块和连线相互绑定，在数据出现变动的时候作出响应，使用待处理表对过程调用进行处理，使用时间排序建立时序性的程序设计，整个程序无处不体现着基于变动的程序模拟的思想。&lt;/p&gt;&lt;p&gt;上一篇专栏文章中说文章坑了很久，没想到这篇文章坑了更长时间，看了一下居然四个月过去了，这四个月基本上都是在杭州某厂实习，写文章的时间不是很多，而且这篇文章其实其中的很多文字都是很早就写好的，但是迟迟没有写完也是因为在思考怎么介绍这个实例的程序设计比较好，因为很久以前再读书的时候，感觉书里的步骤虽然由浅入深但是失于冗长，到读者能整的跑整个程序之前，对程序的理解仅限于能读懂书上的代码，所以这部最后还是打算从各个部分的代码分析入手，事先提供好能够跑通运行的程序，能让读者一步步的通过运行代码和阅读文章去理解整个程序。&lt;/p&gt;</description>
<author>刘丰恺</author>
<guid isPermaLink="false">2017-09-26-29695168</guid>
<pubDate>Tue, 26 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>【C++ 模板元编程入门】在编译期实现 Peano 数</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-09-22-29587930.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;【C++ 模板元编程入门】在编译期实现 Peano 数&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29587930&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-543b93b5d424a32ef501e544c6a29f9c_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;基本知识&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型的函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们都知道模板可以接受类型作为「参数」。同样地我们也可以有「返回值」，从而构造类型的函数。基本的范式是：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template&amp;lt;class T&amp;gt;
struct Computed {
  using type = T;
}&lt;/code&gt;&lt;p&gt;这就构造了一个名为 `Computed` 的，接收一个类型参数，返回这个类型本身的函数，用法如 `Computed&amp;lt;float&amp;gt;::type`，这个类型应当还是 `float`。&lt;/p&gt;&lt;p&gt;为什么要包一层 struct？这是因为 C++ 不支持对 using 的特化。这样的代码是不行的：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template &amp;lt;class T&amp;gt;
using computed&amp;lt;T&amp;gt; = T;

template&amp;lt;&amp;gt;
using computed&amp;lt;int&amp;gt; = double;&lt;/code&gt;&lt;p&gt;至于为什么不支持，我没有了解。&lt;/p&gt;&lt;p&gt;&lt;b&gt;特化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;什么是特化？你可以理解为模式匹配，就像 Haskell 中的写法一样。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template&amp;lt;class T&amp;gt;
struct Computed {
  using type = T;
}

template&amp;lt;&amp;gt;
struct Computed&amp;lt;int&amp;gt; {
  using type = double;
}&lt;/code&gt;&lt;p&gt;这样当你调用 `Computed&amp;lt;bool&amp;gt;::type` 时，得到的结果是 `bool`，而调用`Computed&amp;lt;int&amp;gt;::type`得到的结果却是`double`。当然这种匹配是遵循一定规则的，比如更「具体」的特化优先匹配，这跟 Haskell 谁在前谁先试着匹配不太一样。在 Haskell 中就好比：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Type = Bool | Double | Int

computed :: Type -&amp;gt; Type
computed Int = Double
computed t = t&lt;/code&gt;&lt;p&gt;实际上有了这层对应，如果你知道怎么在 Haskell 中实现 Peano 数，那么 C++ 中的实现基本就是无脑翻译了。如果你不知道怎么在 Haskell 中实现 Peano 数，那你知道 Peano 数是什么，也能大差不差知道答案了。&lt;/p&gt;&lt;h2&gt;Peano 数&lt;/h2&gt;&lt;p&gt;Peano 数是什么？Peano 数是归纳定义的自然数，准确地说应该是一个表现形如直觉中「自然数」的公理系统，也就是「自然数」的形式化。这个系统里只有两个符号，`Zero`——表示 0，以及 `Succ`——表示后继。那么 1 就是 `Succ&amp;lt;Zero&amp;gt;`，2 就是 `Succ&amp;lt;Succ&amp;lt;Zero&amp;gt;&amp;gt;`，以此类推（归纳，其实就是「以此类推」的形式化）。&lt;/p&gt;&lt;p&gt;我们可以在 C++ 中如此表述：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct Peano {};
struct Zero: Peano {};
template&amp;lt;class T&amp;gt;
struct Succ: Peano {};&lt;/code&gt;&lt;p&gt;那么加法又是什么呢？从例子出发，我们需要定义一个两个类型参数的模板：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template&amp;lt;class T1, class T2&amp;gt;
struct Add {
  using type = ???;
}&lt;/code&gt;&lt;p&gt;满足直觉中的运算规律，比如 2+1=3，翻译成 C++ 就是 `Add&amp;lt;Succ&amp;lt;Succ&amp;lt;Zero&amp;gt;&amp;gt;, Succ&amp;lt;Zero&amp;gt;&amp;gt;::type = Succ&amp;lt;Succ&amp;lt;Succ&amp;lt;Zero&amp;gt;&amp;gt;&amp;gt;`。当然类型之间没有等于号，准确地说应该用 `std::is_same&amp;lt;T1, T2&amp;gt;`，这其实也是通过偏特化实现的，比如（示意，非官方实现）：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template&amp;lt;class T, class U&amp;gt;
struct is_same {
  static constexpr bool value = false;
};
 
template&amp;lt;class T&amp;gt;
struct is_same&amp;lt;T, T&amp;gt; {
  static constexpr bool value = true;
};&lt;/code&gt;&lt;p&gt;那么如何定义加法呢？对于有限的元素，我们当然可以为每一个实例做特化，比如：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template&amp;lt;&amp;gt;
struct Add&amp;lt;Succ&amp;lt;Succ&amp;lt;Zero&amp;gt;&amp;gt;, Succ&amp;lt;Zero&amp;gt;&amp;gt; {
  using type = Succ&amp;lt;Succ&amp;lt;Succ&amp;lt;Zero&amp;gt;&amp;gt;&amp;gt;;
}&lt;/code&gt;&lt;p&gt;也就是打表。C++ 编译器的模板深度一般都是有限的，所以这理论上是可以在实际操作中覆盖所有用例的。但是这明显太傻了。其实加法的定义只需要两条规则就可以覆盖：`0 + b = b, (Succ a) + b = Succ (a + b)`。翻译成 C++ 就是：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template&amp;lt;class T1, class T2&amp;gt;
struct Add;

template&amp;lt;class T&amp;gt;
struct Add&amp;lt;Zero, T&amp;gt; {
  using type = T;
};

template&amp;lt;class T1, class T2&amp;gt;
struct Add&amp;lt;Succ&amp;lt;T1&amp;gt;, T2&amp;gt; {
  using type = Succ&amp;lt;typename Add&amp;lt;T1, T2&amp;gt;::type&amp;gt;
};&lt;/code&gt;&lt;p&gt;注意那个 `typename`，gcc 并不知道后面那个 `::type` 成员是类型还是变量，所以需要 `typename` 关键字的提示。&lt;/p&gt;&lt;p&gt;这就算写完了，你可以测试看看，是不是满足 `std::is_same&amp;lt;Add&amp;lt;Succ&amp;lt;Succ&amp;lt;Zero&amp;gt;&amp;gt;, Succ&amp;lt;Zero&amp;gt;&amp;gt;::type, Succ&amp;lt;Succ&amp;lt;Succ&amp;lt;Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;::value == true`（需要 `&amp;lt;type_traits&amp;gt;` 头文件，或者上面自己写的那个模板（那就不用加 std::）。这么嵌套着写 `Succ` 太繁琐了，也不方便看，你可以简单地写一个模板来从整数生成类型：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;template&amp;lt;int v&amp;gt;
struct peano {
  using type = Succ&amp;lt;typename peano&amp;lt;v - 1&amp;gt;::type&amp;gt;;
};

template&amp;lt;&amp;gt;
struct peano&amp;lt;0&amp;gt; {
  using type = Zero;
};&lt;/code&gt;&lt;p&gt;然后就可以去验证 `Add&amp;lt;&amp;lt;peano&amp;lt;2&amp;gt;::type, peano&amp;lt;1&amp;gt;::type&amp;gt;::type` 是不是等于 `peano&amp;lt;3&amp;gt;::type` 了。&lt;/p&gt;&lt;p&gt;至于加减乘除的其他运算，比较啊奇偶性啊其他的函数，只要你懂得了加法，恐怕就不难了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.codewars.com/kata/peano-numbers/train/cpp&quot;&gt;Peano numbers | Codewars&lt;/a&gt; 完成加减乘除、奇偶性和比较大小的撰写，并通过测试。&lt;/p&gt;&lt;p&gt;&lt;b&gt;广告时间：&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b1b3d0fbe1f3145b69f5d1b0d5388ded_r.jpg&quot; data-rawwidth=&quot;712&quot; data-rawheight=&quot;209&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://www.codewars.com/r/KvWTsA&quot;&gt;Codewars.com&lt;/a&gt; 是一个很好的综合性、游戏化 OJ，除了算法（多是入门级的）之外，考察语言特性（较为深入）是其一大亮点，同时有很多 Haskell 方面的内容，包括我们喜闻乐见的&lt;u&gt;读论文然后完形填空&lt;/u&gt;。题图是 Codewars 上上述练习的界面截图。&lt;/p&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p&gt;当然我们还可以进一步「证明」我们印象中的结论，比如加法是满足交换律的，加法和乘法是满足分配率的，等等。这就是后话了。&lt;/p&gt;</description>
<author>Colliot</author>
<guid isPermaLink="false">2017-09-22-29587930</guid>
<pubDate>Fri, 22 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>stateful metaprogramming不只是数数啊</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-09-20-29500606.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;stateful metaprogramming不只是数数啊&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29500606&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天看到最近还有人就如何更好的在编译期数数纠缠不清，比如&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29364746&quot;&gt;搞什么，函数重载也能叫stateful template metaprogramming??&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可是stateful metaprogramming不只是可以用来数数啊，我就举三个微小的例子，我英文烂，你们就将就着看吧&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;precise garbage collector&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@bhuztez/precise-garbage-collection-for-c-with-stateful-metaprogramming-726c7b3972fd&quot;&gt;https://medium.com/@bhuztez/precise-garbage-collection-for-c-with-stateful-metaprogramming-726c7b3972fd&lt;/a&gt;&lt;/p&gt;&lt;p&gt;代码在&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bhuztez/gc&quot;&gt;bhuztez/gc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模拟GLSL，特别是在编译期，链接VertexShader，FragmentShader&lt;/p&gt;&lt;p&gt;顺便 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/d073f194bcabc1cec5ef69d0b534de99&quot; data-hash=&quot;d073f194bcabc1cec5ef69d0b534de99&quot; data-hovercard=&quot;p$b$d073f194bcabc1cec5ef69d0b534de99&quot;&gt;@空明流转&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@bhuztez/emulate-glsl-in-c-with-stateful-metaprogramming-e77640d10d4d&quot;&gt;https://medium.com/@bhuztez/emulate-glsl-in-c-with-stateful-metaprogramming-e77640d10d4d&lt;/a&gt;&lt;/p&gt;&lt;p&gt;代码在&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bhuztez/triangle&quot;&gt;bhuztez/triangle&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模拟Rust的borrow checker&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@bhuztez/emulate-borrow-checker-in-c-with-stateful-metaprogramming-db4b5e94449f&quot;&gt;https://medium.com/@bhuztez/emulate-borrow-checker-in-c-with-stateful-metaprogramming-db4b5e94449f&lt;/a&gt;&lt;/p&gt;&lt;p&gt;代码在&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bhuztez/borrow&quot;&gt;bhuztez/borrow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;还要更多例子，你们还是另请高明吧。&lt;/p&gt;</description>
<author>6hu2t32</author>
<guid isPermaLink="false">2017-09-20-29500606</guid>
<pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>（如何（用Python）写一个（Lisp）解释器（下））</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-09-09-29186794.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;（如何（用Python）写一个（Lisp）解释器（下））&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29186794&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5940731697c13382291a0780984d10a6_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;上篇：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28989326&quot;&gt;（如何（用Python）写一个（Lisp）解释器（上））&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2号语言：完整的Lispy&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在我们来加上3个新的语法形式，构造一个更加完整的Scheme子集：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ff17e616e45c0909a2c1283355f1271f_r.png&quot; data-rawwidth=&quot;722&quot; data-rawheight=&quot;352&quot;&gt;&lt;p&gt;lambda特殊形式会创建一个过程(procedure)。（lambda这个名字来源于Alonzo Church的&lt;a href=&quot;http://en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;lambda calculus&lt;/a&gt;）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;lis.py&amp;gt; (define circle-area (lambda (r) (* pi (* r r)))
lis.py&amp;gt; (circle-area 10)
314.159265359&lt;/code&gt;&lt;p&gt;过程调用(circle-area 10)使我们对过程的主体部分(* pi (* r r))进行求值。求值所在的环境中pi与*的值同全局环境相同，而r的值为10。事实上，解释器并不会简单地在全局环境之中将r的值设为10。如果我们将r用于其他用途会怎么样？我们不希望对circle-area的调用改变r的值，因此我们希望将一个局部变量r设为10，这样就不会影响到其他同名的变量。因此，我们需要构建一种新的环境，允许同时创建局部和全局变量。&lt;/p&gt;&lt;p&gt;想法如下：在我们对(circle-area 10)求值时，首先提取过程主体部分(* pi (* r r))，随后在仅有一个本地变量r的环境中求值，但该环境同时也能访问全局环境。下图演示了这种环境模型，局部环境（蓝色）嵌套在全局环境（红色）之中：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4c7af0a1ae2d66ed796eeb27b4728583_r.png&quot; data-rawwidth=&quot;247&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;当我们在一个被嵌套的环境中查找变量时，首先在本层查找，如果没有找到对应值的话就到外一层查找。&lt;/p&gt;&lt;p&gt;显然，过程和环境相关，所以我们把他们放到一起：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class Procedure(object):
    &quot;用户定义的Scheme过程。&quot;
    def __init__(self, parms, body, env):
        self.parms, self.body, self.env = parms, body, env
    def __call__(self, *args): 
        return eval(self.body, Env(self.parms, args, self.env))

class Env(dict):
    &quot;环境是以{&#39;var&#39;:val}为键对的字典，它还带着一个指向外层环境的引用。&quot;
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms, args))
        self.outer = outer
    def find(self, var):
        &quot;寻找变量出现的最内层环境。&quot;
        return self if (var in self) else self.outer.find(var)

global_env = standard_env()&lt;/code&gt;&lt;p&gt;我们看到每个过程有3个组成部分：一个包含变量名的列表，一个主体表达式，以及一个外层环境。外层环境使得我们在局部环境中无法找到变量时有下一个地方可以寻找。&lt;/p&gt;&lt;p&gt;环境是dict的子类，因此它含有dict拥有的所有方法。除此之外还有两个额外的方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;构造器__init__接受一个变量名列表及对应的变量值列表，构造创造一个新环境，内部形式为{variable: value}键对，并拥有一个指向外层环境的引用。&lt;/li&gt;&lt;li&gt;find函数用于找到某个变量所在的正确环境，可能是内层环境也可能是更外层的环境。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;要想知道这部分的工作原理，我们首先来看看eval的定义。注意，现在我们需要调用env.find(x)来寻找变量处于哪一层环境之中；随后我们才能从那一层环境之中提取x。（define分支的定义没有改变，因为define总是向最内一层的环境添加变量。）同时我们还增加了两个判定分支：set!分支中，我们寻找变量所处的环境并将其设为新的值。通过lambda，我们可以传入参数列表、主体以及环境以创建一个新的过程。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def eval(x, env=global_env):
    &quot;在某环境中对一个表达式进行求值。&quot;
    if isinstance(x, Symbol):      # 变量引用
        return env.find(x)[x]
    elif not isinstance(x, List):  # 直面产量
        return x                
    elif x[0] == &#39;quote&#39;:          # 引用
        (_, exp) = x
        return exp
    elif x[0] == &#39;if&#39;:             # 条件判断
        (_, test, conseq, alt) = x
        exp = (conseq if eval(test, env) else alt)
        return eval(exp, env)
    elif x[0] == &#39;define&#39;:         # 定义
        (_, var, exp) = x
        env[var] = eval(exp, env)
    elif x[0] == &#39;set!&#39;:           # 赋值
        (_, var, exp) = x
        env.find(var)[var] = eval(exp, env)
    elif x[0] == &#39;lambda&#39;:         # 过程
        (_, parms, body) = x
        return Procedure(parms, body, env)
    else:                          # 过程调用
        proc = eval(x[0], env)
        args = [eval(arg, env) for arg in x[1:]]
        return proc(*args)&lt;/code&gt;&lt;p&gt;为了更好地理解过程和环境是怎样协同运作的，我们来看看下面这段程序。思考一下，在我们对(account1 -20.00)求值的时候，程序会生成一个怎样的环境呢？&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-661295633d0cd932e45f4ba22874758c_r.png&quot; data-rawwidth=&quot;768&quot; data-rawheight=&quot;208&quot;&gt;&lt;p&gt;每个矩形框代表一个环境，环境的颜色和程序中新定义变量的颜色相对应。在程序的最后两行中，我们定义了account1并调用了(account1 -20.00)，这表示我们创建了一个拥有100美金余额的账户，并从中取出20美金。在对(account1 -20.00)进行求值的过程中，我们会对黄色高亮部分进行求值。该表达式中有三个变量：amt可以直接在最内层环境（绿色）中找到。但balance不在那一层环境之中，我们需要查找绿色的外一层环境（蓝色）。然而变量‘+’依然不能在这两个环境之中找到，所以我们需要在更外一层环境中寻找（红色的全局环境）。这一先在内层环境查找，再在外层环境中查找的方式被称为“词法作用域”(Lexical Scoping)。Env.find(var)依照词法作用域规则查找变量所处的正确环境。&lt;/p&gt;&lt;p&gt;现在我们能做的事又多了不少：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; repl()
lis.py&amp;gt; (define circle-area (lambda (r) (* pi (* r r))))
lis.py&amp;gt; (circle-area 3)
28.274333877
lis.py&amp;gt; (define fact (lambda (n) (if (&amp;lt;= n 1) 1 (* n (fact (- n 1))))))
lis.py&amp;gt; (fact 10)
3628800
lis.py&amp;gt; (fact 100)
9332621544394415268169923885626670049071596826438162146859296389521759999322991
5608941463976156518286253697920827223758251185210916864000000000000000000000000
lis.py&amp;gt; (circle-area (fact 10))
4.1369087198e+13
lis.py&amp;gt; (define first car)
lis.py&amp;gt; (define rest cdr)
lis.py&amp;gt; (define count (lambda (item L) (if L (+ (equal? item (first L)) (count item (rest L))) 0)))
lis.py&amp;gt; (count 0 (list 0 1 2 3 0 0))
3
lis.py&amp;gt; (count (quote the) (quote (the more the merrier the bigger the better)))
4
lis.py&amp;gt; (define twice (lambda (x) (* 2 x)))
lis.py&amp;gt; (twice 5)
10
lis.py&amp;gt; (define repeat (lambda (f) (lambda (x) (f (f x)))))
lis.py&amp;gt; ((repeat twice) 10)
40
lis.py&amp;gt; ((repeat (repeat twice)) 10)
160
lis.py&amp;gt; ((repeat (repeat (repeat twice))) 10)
2560
lis.py&amp;gt; ((repeat (repeat (repeat (repeat twice)))) 10)
655360
lis.py&amp;gt; (pow 2 16)
65536.0
lis.py&amp;gt; (define fib (lambda (n) (if (&amp;lt; n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))
lis.py&amp;gt; (define range (lambda (a b) (if (= a b) (quote ()) (cons a (range (+ a 1) b)))))
lis.py&amp;gt; (range 0 10)
(0 1 2 3 4 5 6 7 8 9)
lis.py&amp;gt; (map fib (range 0 10))
(1 1 2 3 5 8 13 21 34 55)
lis.py&amp;gt; (map fib (range 0 20))
(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)&lt;/code&gt;&lt;p&gt;如此一来，我们的语言中就有了过程、变量、条件判断（if）和顺序执行（begin）。如果你熟悉其他语言的话，你可能会觉得我们还需要while或者for循环，但Scheme认为自己不需要这两种循环结构。Scheme标准中说：“Scheme展示了只需要极少量构造表达式的规则，无需规定表达式的组成方式，就足以构建出一个实用而高效的语言。”在Scheme中，我们通过构建递归函数的方式来实现迭代。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Lispy有多小/快/完整/好？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们以以下的标准来评判Lispy：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;小：&lt;/b&gt;Lispy十分简短：不算空行和注释的话一共只有117行，源码只有4K大小。（更早的一个版本只有90行，但包含的标准过程更少，也显得过于简陋了。）我用Java实现的最小Scheme（Jscheme）包含1664行代码，源码有57K大。Jscheme之前叫SILK（Scheme in Fifty Kilobytes，缩写对不上...anyway），不过实际上只有在编译成bytecode的情况下才小于50k。在“小”这一方面，Lispy做得要好很多，我想它符合&lt;a href=&quot;http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html&quot;&gt;Alan Kay在1972年所说的&lt;/a&gt;：“你可以用‘一页代码’定义出‘世界上最强大的语言’”。（其实我觉得Alan Kay本人不会同意，因为Python解释器的代码量远高于一页。）&lt;/li&gt;&lt;li&gt;&lt;b&gt;快：&lt;/b&gt;Lispy可以在0.003秒内计算出(fact 100)的值。对我来说够快了（尽管比大部分语言慢很多）。&lt;/li&gt;&lt;li&gt;&lt;b&gt;完整：&lt;/b&gt;Lispy和Scheme标准比起来算不上完整。一下是主要的一些缺少处：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;语法：&lt;/b&gt;缺少注释，quote符和quasiquote符，#常量，延伸的表达式（从if中延伸出的cond，从lambda中延伸出的let），和dotted list标记。&lt;/li&gt;&lt;li&gt;&lt;b&gt;语义：&lt;/b&gt;缺少call/cc和尾递归。&lt;/li&gt;&lt;li&gt;&lt;b&gt;数据类型：&lt;/b&gt;缺少String, character, boolean, ports, vectors, exact/inexact numbers。Python的列表相比于Scheme里的列表实际上更接近于Scheme里的vector。&lt;/li&gt;&lt;li&gt;&lt;b&gt;过程：&lt;/b&gt;少了100多种原始过程：包含与所有缺少的数据类型有关的过程，以及set-car!和set-cdr!之类的过程，因为我们没法用Python列表直接实现这一功能。&lt;/li&gt;&lt;li&gt;&lt;b&gt;错误修复：&lt;/b&gt;Lispy不会尝试去侦测，报告以及修复错误。想用Lispy编程的话你需要一个从不犯错的程序员。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;好：&lt;/b&gt;这项的评判就交由读者去定了。对我来说，它不错地完成了预定目标——解释Lisp解释器的工作原理。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;附录：完整代码&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;################ Lispy: Scheme Interpreter in Python

## (c) Peter Norvig, 2010-16; See http://norvig.com/lispy.html

from __future__ import division
import math
import operator as op

################ Types

Symbol = str          # A Lisp Symbol is implemented as a Python str
List   = list         # A Lisp List is implemented as a Python list
Number = (int, float) # A Lisp Number is implemented as a Python int or float

################ Parsing: parse, tokenize, and read_from_tokens

def parse(program):
    &quot;Read a Scheme expression from a string.&quot;
    return read_from_tokens(tokenize(program))

def tokenize(s):
    &quot;Convert a string into a list of tokens.&quot;
    return s.replace(&#39;(&#39;,&#39; ( &#39;).replace(&#39;)&#39;,&#39; ) &#39;).split()

def read_from_tokens(tokens):
    &quot;Read an expression from a sequence of tokens.&quot;
    if len(tokens) == 0:
        raise SyntaxError(&#39;unexpected EOF while reading&#39;)
    token = tokens.pop(0)
    if &#39;(&#39; == token:
        L = []
        while tokens[0] != &#39;)&#39;:
            L.append(read_from_tokens(tokens))
        tokens.pop(0) # pop off &#39;)&#39;
        return L
    elif &#39;)&#39; == token:
        raise SyntaxError(&#39;unexpected )&#39;)
    else:
        return atom(token)

def atom(token):
    &quot;Numbers become numbers; every other token is a symbol.&quot;
    try: return int(token)
    except ValueError:
        try: return float(token)
        except ValueError:
            return Symbol(token)

################ Environments

def standard_env():
    &quot;An environment with some Scheme standard procedures.&quot;
    env = Env()
    env.update(vars(math)) # sin, cos, sqrt, pi, ...
    env.update({
        &#39;+&#39;:op.add, &#39;-&#39;:op.sub, &#39;*&#39;:op.mul, &#39;/&#39;:op.truediv, 
        &#39;&amp;gt;&#39;:op.gt, &#39;&amp;lt;&#39;:op.lt, &#39;&amp;gt;=&#39;:op.ge, &#39;&amp;lt;=&#39;:op.le, &#39;=&#39;:op.eq, 
        &#39;abs&#39;:     abs,
        &#39;append&#39;:  op.add,  
        &#39;apply&#39;:   apply,
        &#39;begin&#39;:   lambda *x: x[-1],
        &#39;car&#39;:     lambda x: x[0],
        &#39;cdr&#39;:     lambda x: x[1:], 
        &#39;cons&#39;:    lambda x,y: [x] + y,
        &#39;eq?&#39;:     op.is_, 
        &#39;equal?&#39;:  op.eq, 
        &#39;length&#39;:  len, 
        &#39;list&#39;:    lambda *x: list(x), 
        &#39;list?&#39;:   lambda x: isinstance(x,list), 
        &#39;map&#39;:     map,
        &#39;max&#39;:     max,
        &#39;min&#39;:     min,
        &#39;not&#39;:     op.not_,
        &#39;null?&#39;:   lambda x: x == [], 
        &#39;number?&#39;: lambda x: isinstance(x, Number),   
        &#39;procedure?&#39;: callable,
        &#39;round&#39;:   round,
        &#39;symbol?&#39;: lambda x: isinstance(x, Symbol),
    })
    return env

class Env(dict):
    &quot;An environment: a dict of {&#39;var&#39;:val} pairs, with an outer Env.&quot;
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms, args))
        self.outer = outer
    def find(self, var):
        &quot;Find the innermost Env where var appears.&quot;
        return self if (var in self) else self.outer.find(var)

global_env = standard_env()

################ Interaction: A REPL

def repl(prompt=&#39;lis.py&amp;gt; &#39;):
    &quot;A prompt-read-eval-print loop.&quot;
    while True:
        val = eval(parse(raw_input(prompt)))
        if val is not None: 
            print(lispstr(val))

def lispstr(exp):
    &quot;Convert a Python object back into a Lisp-readable string.&quot;
    if isinstance(exp, List):
        return &#39;(&#39; + &#39; &#39;.join(map(lispstr, exp)) + &#39;)&#39; 
    else:
        return str(exp)

################ Procedures

class Procedure(object):
    &quot;A user-defined Scheme procedure.&quot;
    def __init__(self, parms, body, env):
        self.parms, self.body, self.env = parms, body, env
    def __call__(self, *args): 
        return eval(self.body, Env(self.parms, args, self.env))

################ eval

def eval(x, env=global_env):
    &quot;Evaluate an expression in an environment.&quot;
    if isinstance(x, Symbol):      # variable reference
        return env.find(x)[x]
    elif not isinstance(x, List):  # constant literal
        return x                
    elif x[0] == &#39;quote&#39;:          # (quote exp)
        (_, exp) = x
        return exp
    elif x[0] == &#39;if&#39;:             # (if test conseq alt)
        (_, test, conseq, alt) = x
        exp = (conseq if eval(test, env) else alt)
        return eval(exp, env)
    elif x[0] == &#39;define&#39;:         # (define var exp)
        (_, var, exp) = x
        env[var] = eval(exp, env)
    elif x[0] == &#39;set!&#39;:           # (set! var exp)
        (_, var, exp) = x
        env.find(var)[var] = eval(exp, env)
    elif x[0] == &#39;lambda&#39;:         # (lambda (var...) body)
        (_, parms, body) = x
        return Procedure(parms, body, env)
    else:                          # (proc arg...)
        proc = eval(x[0], env)
        args = [eval(exp, env) for exp in x[1:]]
        return proc(*args)&lt;/code&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>李愚</author>
<guid isPermaLink="false">2017-09-09-29186794</guid>
<pubDate>Sat, 09 Sep 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
