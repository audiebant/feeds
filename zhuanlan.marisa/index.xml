<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 09 Nov 2017 18:51:53 +0800</lastBuildDate>
<item>
<title>Folding infinite list through F-algebra</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-08-30833827.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Folding infinite list through F-algebra&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30833827&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6765c36a65c96091e2d1fb5522da91a0_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;嘛，在知乎写的第一篇文章，参考了很多现有文章的格式及表达思路www。主要目的还是讨论一些F-algebra的概念和锻炼自己的表达能力。起因是最近刷到codewars上一道题：&lt;a href=&quot;https://www.codewars.com/kata/folding-through-a-fixed-point&quot;&gt;Folding through a fixed point&lt;/a&gt;，其中涉及到一些以前接触过的F-algebra的概念，但题中并没有详细解释清楚F-algebra，评论区存在做完题但没明白到底发生了啥的评论。我也是在codewars上写了一个简单的解释，这里在不剧透题目的情况下搬运一些自己写的东西，并给出一个实际的例子：constructing, folding infinite list&lt;/p&gt;&lt;p&gt;注意：本文中存在一些伪代码，主要是类型签名用来说明类型。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;对范畴论的一个大概的认识会有很大帮助&lt;/li&gt;&lt;li&gt;Haskell的基础语法及Functor typeclass的使用&lt;/li&gt;&lt;li&gt;对交换图表的相关知识&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;什么是Algebra&lt;/h2&gt;&lt;p&gt;简单来说，Algebra可以理解为能以某种方式组织表达式，以及能以某种方式对表达式进行规约的结构。这里我们所关心的表达式是其中的一种：recursively defined的表达式。比如，在Haskell中我们可以通过如下语法来组织一个列表：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data List a = Nil | Cons a (List a)&lt;/code&gt;&lt;p&gt;接着，我们可以通过value constructor构造我们需要的列表，通过pattern matching以我们想要的方式对列表进行规约。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;list :: List String
list = Cons &quot;9&quot; $ Cons &quot;9&quot; $ Cons &quot;6&quot; $ Cons &quot;1&quot; $ Nil

stringify :: List String -&amp;gt; String
stringify Nil = &quot;&quot;
stringify (Cons x xs) = x ++ stringify xs

result :: String
result = stringify list&lt;/code&gt;&lt;h2&gt;非递归的定义我们的List&lt;/h2&gt;&lt;p&gt;我们可以将List中的递归定义提出来，增加一个Type constructor的参数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ListF a l = Nil | Cons a l&lt;/code&gt;&lt;p&gt;哪如何通过这个type来重新定义刚才的List呢？我们通过fixed point来实现，这里我们所选用的fixed point的定义least fixed point和greatest fixed point相等，且能直观的表现我们的意图：将非递归的type变成递归的。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Fix f = In (f (Fix f))&lt;/code&gt;&lt;p&gt;这样，我们可以重新定义我们的List：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type List a = Fix (ListF a)

list :: List String
list = In $ Cons &quot;9&quot; $ In $ Cons &quot;9&quot; $ In $ Cons &quot;6&quot; $ In $ Cons &quot;1&quot; $ In Nil&lt;/code&gt;&lt;h2&gt;一个F-Algebra的定义是什么&lt;/h2&gt;&lt;p&gt;不同代数结构会存在共有的特性，在猫论中，F-Algebra可以用来generalize algebraic structure，F-Algebra可以用来表示各种数据结构。具体的来说C是一个category，F: C → C是一个endofunctor，X是C中一个object，alg是C中F X → X的一个态射，那么F-Algebra就是一个(X, alg)的二元组。&lt;/p&gt;&lt;p&gt;对应到Haskell中则是在Hask范畴，f是一个Functor typeclass的instance，x是一个type，alg的类型则是：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;alg :: f x -&amp;gt; x&lt;/code&gt;&lt;h2&gt;一个F-Coalgebra的定义是什么&lt;/h2&gt;&lt;p&gt;既然名字里带co了，那么很容易想到是F-Algebra的dual。具体来说C是一个category，F: C → C是一个endofunctor，X是C中一个object，coalg是C中X → F X的一个态射，那么F-Coalgebra就是一个(X, coalg)的二元组。&lt;/p&gt;&lt;p&gt;对应到Haskell中则是在Hask范畴，f是一个Functor typeclass的instance，x是一个type，coalg的类型则是：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;coalg :: x -&amp;gt; f x&lt;/code&gt;&lt;h2&gt;理解Algebra间的态射&lt;/h2&gt;&lt;p&gt;根据不同的x的type，我们可以写出不同的algebra，猫论是一个研究不同东西间相同结构的理论，这里，我们要找出相同Functor间不同algebra的关系。&lt;/p&gt;&lt;p&gt;如果我们有以下两个type A和B，以及其algebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data A = A
newtype B = B A

mkA :: B -&amp;gt; A
mkA (B a) = a
mkB :: A -&amp;gt; B
mkB a = (B a)

algA :: F A -&amp;gt; A
algB :: F B -&amp;gt; B

coalgA :: A -&amp;gt; F A
coalgB :: B -&amp;gt; F B&lt;/code&gt;&lt;p&gt;那么我们有如下所示的态射关系，我们以Commutative Diagram表示：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \tag{F-Algebra} \begin{CD} {F A} @&amp;gt;{fmap \ mkB}&amp;gt;&amp;gt; {F B} \\ @V{algA}VV @VV{algB}V \\ {A} @&amp;gt;{mkB}&amp;gt;&amp;gt; {B} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;equation&gt;\begin{equation} \tag{F-Coalgebra} \begin{CD} {F A} @&amp;lt;{fmap \ mkA}&amp;lt;&amp;lt; {F B} \\ @A{coalgA}AA @AA{coalgB}A \\ {A} @&amp;lt;{mkA}&amp;lt;&amp;lt; {B} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;Initial F-Algebra和Terminal F-Coalgebra&lt;/h2&gt;&lt;p&gt;Initial F-Algebra和Terminal F-Coalgebra是一类具有特殊性质的F-Algebra和F-Coalgebra。对于一个endofunctor F: C → C来说，存在从其Initial F-Algebra到其他所有F-Algebra的唯一态射，存在从其他所有F-Coalgebra到其Terminal F-Coalgebra的唯一态射。我们将其分别称之为&lt;i&gt;catamorphism和&lt;/i&gt;anamorphism。&lt;/p&gt;&lt;p&gt;这里，我们的不动点Fix的In :: f (Fix f) -&amp;gt; Fix f就是Initial F-Algebra（和Terminal F-Coalgebra），根据Lambek’s Lemma我们可以知道存在unIn :: Fix f -&amp;gt; f (Fix f)，我们也很容易将其写出来，存在非常简单的isomorphism：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;In :: f (Fix f) -&amp;gt; Fix f
unIn :: Fix f -&amp;gt; f (Fix f)

newtype Fix f = In (f (Fix f))
unIn (In x) = x&lt;/code&gt;&lt;p&gt;那么如果我们构造出g和cog：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;g :: Fix f -&amp;gt; x
cog :: x -&amp;gt; Fix f&lt;/code&gt;&lt;p&gt;我们就可以很方便的将一个用Fix表示的代数表达式规约成我们想要的形式（或者反过来），我们用Commutative Diagram表示出来：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \tag{Initial F-Algebra} \begin{CD} {F (Fix \ F)} @&amp;gt;{fmap \ g}&amp;gt;&amp;gt; {F A} \\ @V{In}VV @VV{algA}V \\ {Fix \ F} @&amp;gt;{g}&amp;gt;&amp;gt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;equation&gt;\begin{equation} \tag{Terminal F-Coalgebra} \begin{CD} {F (Fix \ F)} @&amp;lt;{fmap \ cog}&amp;lt;&amp;lt; {F A} \\ @A{unIn}AA @AA{coalgA}A \\ {Fix \ F} @&amp;lt;{cog}&amp;lt;&amp;lt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;构造&lt;i&gt;catamorphism与&lt;/i&gt;anamorphism&lt;/h2&gt;&lt;p&gt;根据上面的Commutative Diagram，我们可以轻易发现，简单的将In和unIn交换，我们就能轻易从特定F-Algebra、F-Coalgebra构造出g和cog：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \tag{Initial F-Algebra} \begin{CD} {F (Fix \ F)} @&amp;gt;{fmap \ g}&amp;gt;&amp;gt; {F A} \\ @A{unIn}AA @VV{algA}V \\ {Fix \ F} @&amp;gt;{g}&amp;gt;&amp;gt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;equation&gt;\begin{equation} \tag{Terminal F-Coalgebra} \begin{CD} {F (Fix \ F)} @&amp;lt;{fmap \ cog}&amp;lt;&amp;lt; {F A} \\ @V{In}VV @AA{coalgA}A \\ {Fix \ F} @&amp;lt;{cog}&amp;lt;&amp;lt; {A} \\ \end{CD} \end{equation}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们将其用Haskell表示出来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: Functor f =&amp;gt; (f x -&amp;gt; x) -&amp;gt; (Fix f -&amp;gt; x)
cata alg = alg . fmap (cata alg) . unIn

ana :: Functor f =&amp;gt; (x -&amp;gt; f x) -&amp;gt; (x -&amp;gt; Fix f)
ana coalg = In . fmap (ana coalg) . coalg&lt;/code&gt;&lt;h2&gt;Folding infinite list through F-algebra&lt;/h2&gt;&lt;p&gt;我们可以用F-Coalgebra来构造Infinite data structures，并使用F-algebra对其进行fold。例如我们的List：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ListF a l = Nil | Cons a l&lt;/code&gt;&lt;p&gt;很容易将其Functor instance写出来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Functor (ListF a) where
    fmap f Nil = Nil
    fmap f (Cons a l) = Cons a (f l)&lt;/code&gt;&lt;p&gt;这里我们定义这样一个Coalgebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;coalg :: Int -&amp;gt; ListF Int Int
coalg x = Cons x (x + 1)&lt;/code&gt;&lt;p&gt;我们通过这个Coalgebra和Anamorphism定义一个Infinite的自增List：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;list :: Fix (ListF Int)
list = ana coalg 256&lt;/code&gt;&lt;p&gt;接着，我们定义一个可以从Infinite的List中规约出值的Algebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;alg :: ListF Int Int -&amp;gt; Int
alg Nil = 0
alg (Cons a b) = if a &amp;lt; 1024 then a + b else a&lt;/code&gt;&lt;p&gt;接着我们使用C&lt;i&gt;atamorphism和这个&lt;/i&gt;Algebra规约出我们表达式的值：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;result :: Int
result = cata alg list&lt;/code&gt;&lt;p&gt;这里跟foldr很相似，只要我们规约Infinite的List时某次没有使用Cons里b的的值，那么规约就能终止。&lt;/p&gt;&lt;h2&gt;结束&lt;/h2&gt;&lt;p&gt;很久没写过这种类型的文章了，难免出现码字错误或者表述不清。有什么问题评论区轻喷/w\&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>不可构造的雨轩菌</author>
<guid isPermaLink="false">2017-11-08-30833827</guid>
<pubDate>Wed, 08 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Agda 中的证明，从一点五到二</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-06-30790920.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Agda 中的证明，从一点五到二&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30790920&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-043f810573d217996a346e86be90677f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;最近突然忙了起来。这篇文章只是填一下上篇文章的坑。原文链接 &lt;a href=&quot;http://ice1000.org/2017/11/06/ProofInAgda3/&quot;&gt;Agda 中的证明，从一点五到二&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上一篇说了很多只有一种情况的证明，这一篇说个有两种情况的。 到目前为止，按理说所有的字符都还能正常显示。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://ice1000.org/2017/11/02/ProofInAgda2/&quot;&gt;上一篇文章&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以及，由于 Agda 语言的特殊性，本文将继续使用 LaTeX 和代码块来共同展示代码。 代码块唯一的作用在于便于复制，主要的呈现途径为 LaTeX 。&lt;/p&gt;&lt;h2&gt;上一篇的习题&lt;/h2&gt;&lt;p&gt;上一篇文章我留下了一个没提供证明的命题，现在给出完整答案：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; {\land}{-}{\assoc}_0 : \forall \{P\ Q\ R\} \rightarrow ((P \land Q) \land R) \rightarrow (P \land (Q \land R)) \\ &amp;amp; {\land}{-}{\assoc}_0 \ ({\land}{-}{\intro}\ ({\land}{-}{\intro}\ p\ q)\ r) = {\land}{-}{\intro}\ p\ ({\land}{-}{\intro}\ q\ r) \\ &amp;amp; \\ &amp;amp; {\land}{-}{\assoc}_1 : \forall \{P\ Q\ R\} \rightarrow (P \land (Q \land R)) \rightarrow ((P \land Q) \land R) \\ &amp;amp; {\land}{-}{\assoc}_1 \ ({\land}{-}{\intro}\ p\ ({\land}{-}{\intro}\ q\ r)) = {\land}{-}{\intro}\ ({\land}{-}{\intro}\ p\ q)\ r \\ &amp;amp; \\ &amp;amp; {\land}{-}{\assoc} : \forall \{P\ Q\ R\} \rightarrow (P \land (Q \land R)) \Leftrightarrow ((P \land Q) \land R) \\ &amp;amp; {\land}{-}{\assoc} ={\land}{-}{\intro} \ {\land}{-}{\assoc}_1 \ {\land}{-}{\assoc}_0 \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-assoc₀ : ∀ {P Q R} → ((P ∧ Q) ∧ R) → (P ∧ (Q ∧ R))
∧-assoc₀ (∧-intro (∧-intro p q) r) = ∧-intro p (∧-intro q r)

∧-assoc₁ : ∀ {P Q R} → (P ∧ (Q ∧ R)) → ((P ∧ Q) ∧ R)
∧-assoc₁ (∧-intro p (∧-intro q r)) = ∧-intro (∧-intro p q) r

∧-assoc : ∀ {P Q R} → (P ∧ (Q ∧ R)) ⇔ ((P ∧ Q) ∧ R)
∧-assoc = ∧-intro ∧-assoc₁ ∧-assoc₀ &lt;/code&gt;&lt;p&gt;确实没什么好说的，所以才能说是即得易见平凡，仿照上例显然。&lt;/p&gt;&lt;h2&gt;或相关的证明&lt;/h2&gt;&lt;p&gt;上一篇我有个东西没讲完，就是 “或” 。 它和 “与” 相对，它只要求两个命题中的一个成立。&lt;/p&gt;&lt;p&gt;因此，它对应着两个不同的情况：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;p \rightarrow (p \lor q) \\ q \rightarrow (p \lor q)&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;定义 GADT&lt;/h2&gt;&lt;p&gt;把这个关系写成 GADT ，就是这样：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; \data\ \_{\lor}\_\ (P\ Q : \Set) : \Set \where \\ &amp;amp; \ \ {\lor}{-}{\intro}_0 : P \rightarrow P \lor Q \\ &amp;amp; \ \ {\lor}{-}{\intro}_1 : Q \rightarrow P \lor Q \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data _∨_ (P Q : Set) : Set where
  ∨-intro₀ : P → P ∨ Q
  ∨-intro₁ : Q → P ∨ Q &lt;/code&gt;&lt;p&gt;这里我们遇到了一种和之前不一样的情况： 我们的 GADT 有了两种 instance 。 这意味着我们需要在证明的时候考虑两种不同的情况，分别针对这两种 instance 。&lt;/p&gt;&lt;h2&gt;证明一&lt;/h2&gt;&lt;p&gt;比如，我们可以证明一下这个命题：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(p \rightarrow r) \land (q \rightarrow r) \land (p \lor q) \rightarrow r &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;它的逻辑很简单，在 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 都能推出 &lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt; 的时候， &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 只需要成立一个， &lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt; 就成立。 这个命题写成 Agda 的类型，就是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim} : \forall \{P\ Q\} \{R : \Set\} \rightarrow (P \rightarrow R) \rightarrow (Q \rightarrow R) \rightarrow (P \lor Q) \rightarrow R&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim : ∀ {P Q} {R : Set} → (P → R) → (Q → R) → (P ∨ Q) → R &lt;/code&gt;&lt;p&gt;我们在证明中，需要同时对 &lt;equation&gt;(P \lor Q)&lt;/equation&gt; 的两种可能的情况进行处理 （因为这个类型的东西既可以是通过 &lt;code class=&quot;inline&quot;&gt;P&lt;/code&gt; 构造的，也可以是通过 &lt;code class=&quot;inline&quot;&gt;Q&lt;/code&gt; 构造的）， 不然 Agda 的 exhaustiveness check 会报错的 （这也是为什么 &lt;code class=&quot;inline&quot;&gt;postulate&lt;/code&gt; 不被推荐使用）。&lt;/p&gt;&lt;p&gt;首先考虑 &lt;code class=&quot;inline&quot;&gt;P&lt;/code&gt; 成立的情况，我们有：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim}\pr \_ \ ({\lor}{-}{\elim}_0 \ p) = \pr p &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim pr _ (∨-intro₀ p) = pr p &lt;/code&gt;&lt;p&gt;然后考虑 &lt;code class=&quot;inline&quot;&gt;Q&lt;/code&gt; 成立的情况，我们有：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim}\ \_ \qr \ ({\lor}{-}{\elim}_1 \ q) = \qr q &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim _ qr (∨-intro₁ q) = qr q &lt;/code&gt;&lt;p&gt;放在一起，就是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; {\lor}{-}{\elim} : \forall \{P\ Q\} \{R : \Set\} \rightarrow (P \rightarrow R) \rightarrow (Q \rightarrow R) \rightarrow (P \lor Q) \rightarrow R \\ &amp;amp; {\lor}{-}{\elim}\pr \_ \ ({\lor}{-}{\elim}_0 \ p) = \pr p \\ &amp;amp; {\lor}{-}{\elim}\ \_ \qr \ ({\lor}{-}{\elim}_1 \ q) = \qr q \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-elim : ∀ {P Q} {R : Set} → (P → R) → (Q → R) → (P ∨ Q) → R
∨-elim pr _ (∨-intro₀ p) = pr p
∨-elim _ qr (∨-intro₁ q) = qr q &lt;/code&gt;&lt;p&gt;这样，就 check 了。 十分简单。&lt;/p&gt;&lt;h2&gt;证明二&lt;/h2&gt;&lt;p&gt;和 &lt;equation&gt;\land&lt;/equation&gt; 一样， &lt;equation&gt;\lor&lt;/equation&gt; 也有交换律：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; {\lor}{-}{\comm}&#39; : \forall \{P\ Q\} \rightarrow (P \lor Q) \rightarrow (Q \lor R) \\ &amp;amp; {\lor}{-}{\comm}&#39; \ ({\lor}{-}{\intro}_0 \ p) = {\lor}{-}{\intro}_1 \ p \\ &amp;amp; {\lor}{-}{\comm}&#39; \ ({\lor}{-}{\intro}_1 \ q) = {\lor}{-}{\intro}_0 \ q \\ \\ &amp;amp; {\lor}{-}{\comm} : \forall \{P\ Q\} \rightarrow (P \lor Q) \Leftrightarrow (Q \lor R) \\ &amp;amp; {\lor}{-}{\comm} = {\land}{-}{\intro} \ {\lor}{-}{\comm}&#39; \ {\lor}{-}{\comm}&#39; \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∨-comm′ : ∀ {P Q} → (P ∨ Q) → (Q ∨ P)
∨-comm′ (∨-intro₀ p) = ∨-intro₁ p
∨-comm′ (∨-intro₁ q) = ∨-intro₀ q

∨-comm : ∀ {P Q} → (P ∨ Q) ⇔ (Q ∨ P)
∨-comm = ∧-intro ∨-comm′ ∨-comm′ &lt;/code&gt;&lt;h2&gt;结束&lt;/h2&gt;&lt;p&gt;这么快就没了？&lt;/p&gt;&lt;p&gt;其实只是填一下上一篇留下的坑。&lt;/p&gt;&lt;p&gt;是的，我说完了。&lt;/p&gt;</description>
<author>大笨蛋千里冰封</author>
<guid isPermaLink="false">2017-11-06-30790920</guid>
<pubDate>Mon, 06 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Agda 中的证明，从一到一点五</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-05-30749528.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Agda 中的证明，从一到一点五&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30749528&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-367c5bb1a32bb3ddc98041b0b5435fa1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;终于写完了，还请各位聚聚多多包涵哈。原文在这里&lt;a href=&quot;http://ice1000.org/2017/11/02/ProofInAgda2/&quot;&gt;Agda 中的证明，从一到一点五&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上一篇我们说到了一个只有一步的证明，这一篇我们来看一个稍微复杂点的，组合命题的例子。 到目前为止，按理说所有的字符都还能正常显示。&lt;/p&gt;&lt;p&gt;为什么是一点五？看完你就知道啦。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://127.0.0.1:4000/2017/11/01/ProofInAgda/&quot;&gt;上一篇文章&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以及，由于 Agda 语言的特殊性，本文将继续使用 LaTeX 和代码块来共同展示代码。 代码块唯一的作用在于便于复制，主要的呈现途径为 LaTeX 。 （其实是因为我的手机显示不出来很多字符，我又要自己看自己写的东西）&lt;/p&gt;&lt;h2&gt;关于复合命题&lt;/h2&gt;&lt;p&gt;这里修正一个概念。&lt;/p&gt;&lt;p&gt;前文说的 &quot;条件&quot; ，即前文一直强调的 &quot;类型则命题&quot; 中命题的最基本组成元素（好像 Wikipedia 上也称之为 “命题变元” ，反正我对这个名称不负责，就是用来表示命题 &lt;equation&gt;p \rightarrow q&lt;/equation&gt; 中的 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 的东西）其实也是一种命题，而我之前称为命题的东西则是 &quot;复合命题&quot; 。&lt;/p&gt;&lt;p&gt;下文将使用 &quot;命题&quot; 统称他们。&lt;/p&gt;&lt;h2&gt;介绍符号&lt;/h2&gt;&lt;p&gt;都是初中数学里面的，并且是只需要小学数学就可以看懂的符号。&lt;/p&gt;&lt;h2&gt;与和或&lt;/h2&gt;&lt;p&gt;我们知道，门电路里面都有与门和或门，对应逻辑上的与和或。 与的符号是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\land&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;，或的符号是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lor&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;。 比如， &lt;equation&gt;p \land q \rightarrow r&lt;/equation&gt; 表示 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 都必须成立， &lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt; 才成立。 而 &lt;equation&gt;p \lor q \rightarrow r&lt;/equation&gt; 表示 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 中任意成立一个， &lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt; 就成立。&lt;/p&gt;&lt;h2&gt;充要条件&lt;/h2&gt;&lt;p&gt;我们知道，如果两个条件 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 能使 &lt;equation&gt;p \rightarrow q&lt;/equation&gt; 和 &lt;equation&gt;q \rightarrow p&lt;/equation&gt; 同时成立，我们称他们互为充要条件，使用：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftrightarrow&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;表示，比如 &lt;equation&gt;p \Leftrightarrow q&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们将在接下来的代码里面使用这些符号。&lt;/p&gt;&lt;h2&gt;定义 GADT&lt;/h2&gt;&lt;p&gt;首先定义 &lt;equation&gt;\land&lt;/equation&gt; 对应的 GADT ：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; \data\ \_{\land}\_\ (P\ Q : \Set) : \Set \where \\ &amp;amp; \ \ {\land}{-}{\intro} : P \rightarrow Q \rightarrow (P \land Q) \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data _∧_ (P Q : Set) : Set where
  ∧-intro : P → Q → (P ∧ Q) &lt;/code&gt;&lt;p&gt;这个命题是两个其他命题的组合，它拿到两个命题变成一个新命题。这也体现在 Agda 代码中， &lt;equation&gt;\_{\land}\_&lt;/equation&gt; 这个类型拿到两个 &lt;code class=&quot;inline&quot;&gt;Set&lt;/code&gt; 作为 &lt;a href=&quot;http://people.inf.elte.hu/divip/AgdaTutorial/Sets.Parametric.html#1&quot;&gt;类型 _∧_ 的参数&lt;/a&gt;， 返回一个新类型。 对应的类型构造器我们称之为 &lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\land}{-}{\intro} &lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;有了这个类型，我们首先可以做一些很简单的证明。&lt;/p&gt;&lt;h2&gt;例〇：充要条件&lt;/h2&gt;&lt;p&gt;比如，根据充要条件 &lt;equation&gt;(p \rightarrow q) \land (q \rightarrow p)&lt;/equation&gt; 的定义，我们可以把它表达成一个函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; \_{\Leftrightarrow}\_ : (P\ Q : \Set) \rightarrow \Set \\ &amp;amp; p \Leftrightarrow q = (p \rightarrow q) \land (q \rightarrow p) \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇔_ : (P Q : Set) → Set
p ⇔ q = (p → q) ∧ (q → p) &lt;/code&gt;&lt;p&gt;这里我们在函数体（证明）里面使用了 &lt;equation&gt;\rightarrow&lt;/equation&gt; ，这样的话 &lt;equation&gt; (p \rightarrow q) &lt;/equation&gt; 就是一个类型为 &lt;equation&gt;\DeclareMathOperator{Set}{Set} \Set _1&lt;/equation&gt; 的东西。 因此，这实际上是一个 “命题组合” ，有点 “高阶函数” 感觉（顺带一提，这个名词也是我为了便于理解自己编的，不知道有没有其他人在用 （顺带一提，类型的阶（顺带一提， Agda 中表示类型的阶的类型正好是 &lt;code class=&quot;inline&quot;&gt;Level&lt;/code&gt; ，中文意思就有阶的意思， 因此这个说法可以说是很通用了） 在 dependent type 里面已经变得很模糊了，因此这个 “高阶” 的比喻是不太恰当的，这里就拿 Haskell 之类的简单语言的概念将就一下））。&lt;/p&gt;&lt;p&gt;再根据前文已经讲过的：&lt;/p&gt;&lt;blockquote&gt;只要有 &lt;equation&gt;p \rightarrow q&lt;/equation&gt; 这个函数成立，那么就证明了 “ &lt;equation&gt;p \rightarrow q&lt;/equation&gt; “ 这个命题&lt;/blockquote&gt;&lt;p&gt;这个函数的作用便变得很清晰了。 不理解没关系，下面会用到这个东西，然后你或许能从它的应用看懂它的意义。&lt;/p&gt;&lt;p&gt;另外，看到没有？函数体（证明）（下文不再进行这样的强调，感觉很辣鸡） 和定义 &lt;equation&gt;(p \rightarrow q) \land (q \rightarrow p) &lt;/equation&gt; 写起来都是完全一样的。 这里可以体现一些 Agda 语言的优势，就是因为 Unicode 语法的存在，它可以把代码写的很接近数学语言。&lt;/p&gt;&lt;p&gt;不过这并不代表 Agda 就只能用于学术，毕竟类型安全的社区和人气火爆的社区结合起来才是最好的， Idris 都用强大的 ffi 和官方强推的 &lt;code class=&quot;inline&quot;&gt;Control.ST&lt;/code&gt; 了，为什么 Agda 不能写成 imperative language 呢。&lt;/p&gt;&lt;h2&gt;例一：定义&lt;/h2&gt;&lt;p&gt;比如，在 &lt;equation&gt;p \land q&lt;/equation&gt; 成立的时候， &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 分别成立（就是 &lt;equation&gt;\land&lt;/equation&gt; 的定义啦，很简单的）。 用数学语言表达的话，就是（几乎就是废话）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;p \land q \rightarrow p \\ p \land q \rightarrow q&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;写成代码的话，就是（这里关于这个证明讲的比较略，是因为下文有个更详细的讲解， 已经完全覆盖了这个证明所需要用到的知识，这个证明放在前面只是因为它本身很简单，用 Haskell 知识即可理解， 如果读者看不懂这个证明可以先看后面的，不过我觉得应该都看得懂，因为它太简单了）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp;amp; \proof _3 : \forall \{P\ Q\} \rightarrow (P \land Q) \rightarrow P \\ &amp;amp; \proof _3\ ({\land}{-}{\intro}\ p\ q) = p \\ \\ &amp;amp; \proof _4 : \forall \{P\ Q\} \rightarrow (P \land Q) \rightarrow Q \\ &amp;amp; \proof _4\ ({\land}{-}{\intro}\ p\ q) = q \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;proof₃ : ∀ {P Q} → (P ∧ Q) → P
proof₃ (∧-intro p q) = p

proof₄ : ∀ {P Q} → (P ∧ Q) → Q
proof₄ (∧-intro p q) = q &lt;/code&gt;&lt;h2&gt;例二(详)：交换律&lt;/h2&gt;&lt;p&gt;然后还有一个很简单的例子——交换律（ Commutative Law ）。 用数学语言表达的话，就是（几乎也是废话）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(P \land Q) \Leftrightarrow (Q \land P) &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个命题写成 Agda 代码，就是这样的类型（我们称之为  &lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\land}{-}{\comm}&lt;/equation&gt; ）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\land}{-}{\comm} : \forall \{P\ Q\} \rightarrow (P \land Q) \Leftrightarrow (Q \land P) &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-comm : ∀ {P Q} → (P ∧ Q) ⇔ (Q ∧ P) &lt;/code&gt;&lt;p&gt;这里我们就已经使用到之前的定义—— &lt;equation&gt;\Leftrightarrow&lt;/equation&gt; 啦。&lt;/p&gt;&lt;p&gt;如何证明它呢？&lt;/p&gt;&lt;p&gt;首先，我们的证明需要返回一个由 &lt;equation&gt;\Leftrightarrow&lt;/equation&gt; 组合的两个类型（命题）。 由于这个组合类型是一个由 &lt;equation&gt;\land&lt;/equation&gt; 组合而成的两个类型，我们可以先把类型构造器写上，然后两个参数留白：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\land}{-}{\comm} = {\land}{-}{\intro}\ ?\ ? &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∧-comm = ∧-intro ? ?
&lt;/code&gt;&lt;p&gt;我们发现，在 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 两个变量可以互相交换的情况下， 这两个参数的类型（复合命题）都是 &lt;equation&gt; (p \land q) \rightarrow (q \land p)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因此，为了代码复用，我们不妨把这两部分提取出来，作为一个单独的命题去证明它。 这个命题写成 Agda 代码，就是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\land}{-}{\comm}&#39; : \forall \{P\ Q\} \rightarrow (P \land Q) \rightarrow (Q \land P) &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-comm′ : ∀ {P Q} → (P ∧ Q) → (Q ∧ P) &lt;/code&gt;&lt;p&gt;它的第一个显式参数（隐式参数就自动传递了，我们不用管）是 &lt;equation&gt;(P \land Q)&lt;/equation&gt; ，我们可以使用模式匹配将它拆开：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\land}{-}{\comm}&#39;\ ({\land}{-}{\intro}\ p\ q) =\ ? &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-comm′ (∧-intro p q) = ? &lt;/code&gt;&lt;p&gt;然后我们把 &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt; 换个顺序，重新使用类型构造器把它们组合起来：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} {\land}{-}{\comm}&#39;\ ({\land}{-}{\intro}\ p\ q) = ({\land}{-}{\intro}\ q\ p) &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-comm′ (∧-intro p q) = (∧-intro q p) &lt;/code&gt;&lt;p&gt;然后再把这个命题填入刚才的 ∧−comm∧−comm 中：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\land}{-}{\comm} = {\land}{-}{\intro}\ {\land}{-}{\comm}&#39;\ {\land}{-}{\comm}&#39; &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-comm = ∧-intro ∧-comm′ ∧-comm′ &lt;/code&gt;&lt;p&gt;然后我们就可以喊 Q.E.D. 啦。&lt;/p&gt;&lt;h2&gt;例三：结合律&lt;/h2&gt;&lt;p&gt;这个结合律（ Associative Law ）的例子其实已经不是例子了（因为我不想详细讲 （因为思路和交换律差不多）），我就只给出类型签名就可以了。&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} {\land}{-}{\assoc} : \forall \{P\ Q\ R\} \rightarrow (P \land (Q \land R)) \Leftrightarrow ((P \land Q) \land R) &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;∧-assoc : ∀ {P Q R} → (P ∧ (Q ∧ R)) ⇔ ((P ∧ Q) ∧ R) &lt;/code&gt;&lt;p&gt;为什么我只给类型签名呢？因为这个证明啊，&lt;/p&gt;&lt;blockquote&gt;即得易见平凡，仿照上例显然。留作习题答案略，读者自证不难。&lt;/blockquote&gt;&lt;h2&gt;为什么是一点五&lt;/h2&gt;&lt;p&gt;因为原计划是把 &lt;equation&gt;\land&lt;/equation&gt; 和 &lt;equation&gt;\lor&lt;/equation&gt; 放在一起讲的，但是我发现到目前为止的证明在模式匹配上都只有一个分支， 到了 &lt;equation&gt;\lor&lt;/equation&gt; 就有两个了，因此关于它和另外几个有两个分支的证明就单独再开一篇吧 （其实是因为这篇写长了，我写博客会控制篇幅的） 。&lt;/p&gt;&lt;p&gt;我说完了。&lt;/p&gt;</description>
<author>大笨蛋千里冰封</author>
<guid isPermaLink="false">2017-11-05-30749528</guid>
<pubDate>Sun, 05 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Agda 中的证明，从零到一</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-11-02-30686586.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Agda 中的证明，从零到一&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30686586&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-461e72ecf40a21b6804d43e7201d21de_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;最近在学 Agda ，感觉摸到了定理证明的门，希望各路大神不吝赐教。这是一个系列，这篇文章讲的太基础是因为它是第一篇哈。原文链接：&lt;a href=&quot;http://ice1000.org/2017/11/01/ProofInAgda/&quot;&gt;Agda 中的证明，从零到一&lt;/a&gt;&lt;/p&gt;&lt;p&gt;类型则命题，程序则证明。这句话表达了定理证明的一个很重要的思想。&lt;/p&gt;&lt;p&gt;我一开始就没有搞懂这句话在说什么。 在我自认为搞懂的时候，我把我以前没有搞懂的原因归结为我看的教程太垃圾了。&lt;/p&gt;&lt;p&gt;一开始我理解这个问题的同时，我以为我也理解了之前一个 Haskell 关于 &lt;code class=&quot;inline&quot;&gt;IO Monad&lt;/code&gt; 的问题，但实际上不是我想的那样。 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/30686586/h%3Ccode%3Ettps://h%3C/code%3Eackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-1173&quot;&gt;Haskell 的 IO Monad 的实现&lt;/a&gt; 比我想象的要复杂一些，因此本文不谈 Haskell 。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;p&gt;这是一篇面向略懂 dependent type 的人的定理证明教程，然后你要看得懂类 Haskell 的语法。 因为我在学这个的时候就是只会点 Haskell ，然后用过 GADT 和 type family 模拟过 dependent type 。&lt;/p&gt;&lt;p&gt;给出一些参考资料：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://learn%3Ci%3Eyouahaskell.com/cha%3C/i%3Epters&quot;&gt;一个比较简单的 Haskell 入门教程 Learn you a Haskell&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/67043774/answer/249019401&quot;&gt;虎哥介绍的 GADT&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.codewars.com/kata/singletons&quot;&gt;介绍 GADT 的 CodeWars Kata: Singletons&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.codewars.com/kata/scott-encoding&quot;&gt;介绍 GADT 的 CodeWars Kata: Scott Encoding&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;声明在前面&lt;/h2&gt;&lt;p&gt;由于 Agda 语言的特殊性，本文将使用 LaTeX 和代码块来共同展示代码。 前者是为了保证字符的正确显示，后者是为了方便读者复制代码。&lt;/p&gt;&lt;p&gt;本文不讲 Agda 基本语法和 Emacs 的使用。可能以后会有另外的文章。&lt;/p&gt;&lt;p&gt;本文主要内容是帮助一个没接触过定理证明但是接触过 dependent type 的人（这就是我接触定理证明之前的状态）理解一个非常非常简单的定理证明的例子。&lt;/p&gt;&lt;h2&gt;如何理解定理证明&lt;/h2&gt;&lt;p&gt;首先，我们已经知道，我们这是要用类型表达命题，类型对应的实现来证明这个命题的正确性。&lt;/p&gt;&lt;p&gt;命题中的基本元素一般是值的类型(而且很多时候都是代数数据类型)，也就是 &lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} p \rightarrow q&lt;/equation&gt; 的那个 &lt;equation&gt;p&lt;/equation&gt; 或者 &lt;equation&gt;q&lt;/equation&gt; 。 而这个 &lt;equation&gt;\rightarrow&lt;/equation&gt; 对应的就是 “函数” 这一概念，它组合了两个类型，表达了 “推出” 这一逻辑概念。&lt;/p&gt;&lt;p&gt;比如，我实现了一个这样的类型的函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;p \rightarrow q&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;p → q &lt;/code&gt;&lt;p&gt;那么这个函数的实现就是&lt;/p&gt;&lt;blockquote&gt;如果 p 成立，则 q 成立&lt;/blockquote&gt;&lt;p&gt;，或者说，&lt;/p&gt;&lt;blockquote&gt;&lt;equation&gt;p \rightarrow q&lt;/equation&gt; &lt;/blockquote&gt;&lt;p&gt;这个命题的证明。&lt;/p&gt;&lt;p&gt;再比如，我实现了一个这样的类型的函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;p \rightarrow q \rightarrow r &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;p → q → r &lt;/code&gt;&lt;p&gt;那么这个函数的实现就是&lt;/p&gt;&lt;blockquote&gt;如果 p 成立，那么 “如果 q 成立，那么 r 成立” 这一命题成立&lt;/blockquote&gt;&lt;p&gt;，或者说，&lt;/p&gt;&lt;blockquote&gt;&lt;equation&gt;p \rightarrow ( q \rightarrow r )&lt;/equation&gt; &lt;/blockquote&gt;&lt;p&gt;这个命题的证明。&lt;/p&gt;&lt;p&gt;其实我们原本想表达的意思是&lt;/p&gt;&lt;blockquote&gt;&lt;equation&gt; p\ \land \ q\rightarrow r &lt;/equation&gt; &lt;/blockquote&gt;&lt;p&gt;但是这个 &lt;equation&gt;\land&lt;/equation&gt; 关系暂时没讲所以先就这样。&lt;/p&gt;&lt;p&gt;这就是 “类型则命题，程序则证明” 的含义。&lt;/p&gt;&lt;p&gt;在 Agda 中，上面的代码应该写成这样：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \proof : \{p\ q\ r : \Set\} \rightarrow p \rightarrow q \rightarrow r &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;proof : {p q r : Set} → p → q → r &lt;/code&gt;&lt;p&gt;下面我们看一些实例。&lt;/p&gt;&lt;h2&gt;refl 与相等性&lt;/h2&gt;&lt;p&gt;之所以我没有再学习 Idris 就是因为那些教程没说 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 是啥 (Idris 叫 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ， Agda 叫 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt;) 就直接在代码里面用了，我看的时候就一脸蒙蔽，还以为是我智商太低没看懂他 implicit 的东西。 但是好在我看了一坨很友好的 Agda 代码后民白了。&lt;/p&gt;&lt;p&gt;首先，我们可以定义这样一个用来表示相等关系的 GADT ，它对于任何一个 Level 的任何一个实例都成立。 这里我们用了 Universal Polymorphism 表达这个 “对于任何一个 Level “ 的概念。&lt;/p&gt;&lt;p&gt;然后我们使用 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 这个类型构造器表达 “这个相等关系成立” 这一事实。&lt;/p&gt;&lt;p&gt;我们用 &lt;equation&gt;\equiv&lt;/equation&gt; 表示他（标准库的定义在 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;http://agda.readthedocs.io/en/v2.5.3/language/built-ins.html#equality&quot;&gt;Agda.Builtin.Equality&lt;/a&gt;&lt;/code&gt; 中）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp;amp; \data\ \_{\equiv}\_\ \{a\} \{A : \Set a\} (x : A) : A \rightarrow \Set a\where \\ &amp;amp;\ \ \refl : x \equiv x \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data _≡_ {a} {A : Set a} (x : A) : A → Set a where
  refl : x ≡ x &lt;/code&gt;&lt;p&gt;如果你看不懂这个类型签名也没有关系，只需要接受”这个 GADT 只有一个叫 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 的类型构造器”这一事实就好了。&lt;/p&gt;&lt;p&gt;然后我们可以用它进行一些证明。比如我们来证明相等性的传递性，也就是&lt;/p&gt;&lt;blockquote&gt;如果 a &lt;equation&gt;\equiv&lt;/equation&gt; b 并且 b &lt;equation&gt;\equiv&lt;/equation&gt; c ，那么 a &lt;equation&gt;\equiv&lt;/equation&gt; c&lt;/blockquote&gt;&lt;p&gt;。然后我们来看看这个命题对应的类型：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_ : \{A : \Set\} \{a\ b\ c : A\} \rightarrow a \equiv b \rightarrow b \equiv c \rightarrow a \equiv c &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆_ : {A : Set} {a b c : A} → a ≡ b → b ≡ c → a ≡ c &lt;/code&gt;&lt;p&gt;那么我们要怎么实现它，也就是证明它呢？&lt;/p&gt;&lt;p&gt;我一开始写下了这样的东西：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ ab\ bc = ? &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆_ ab bc = ? &lt;/code&gt;&lt;p&gt;然后我就不知道该怎么办了。&lt;/p&gt;&lt;p&gt;事实上，这个原本就很简单的证明被我想复杂了。 因为这个定理是不证则明的，那么我们要如何表达，如何通过 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 这两个模式匹配出来的结果进行变换得到这个不证则明的定理呢？&lt;/p&gt;&lt;p&gt;首先这个模式匹配的参数就不应该这样通配地用 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 来表达。 我们应该把这两个相等关系 (他们的本质是 GADT) 给模式匹配出来。&lt;/p&gt;&lt;p&gt;由于直接写 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 什么都得不出来，我于是尝试将 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 用模式匹配消耗掉，然后 Agda 直接在右边给我自动填入了 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; ，然后好像就 Q.E.D 了：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ \refl\ \refl =\refl &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;_⇆_ refl refl = refl -- 编译通过！ &lt;/code&gt;&lt;p&gt;这是为什么呢？我们来分别看下这两种写法的含义。&lt;/p&gt;&lt;h2&gt;使用 ab bc&lt;/h2&gt;&lt;p&gt;这样的话实际上是把 &lt;equation&gt;a \equiv b&lt;/equation&gt; 和 &lt;equation&gt; b \equiv c&lt;/equation&gt; 两个条件当成了”变量”而不是作为”条件”。 也就是说，当使用 &lt;code class=&quot;inline&quot;&gt;abbc&lt;/code&gt; 时，右边就需要”通过 &lt;equation&gt;a \equiv b&lt;/equation&gt; 和 &lt;equation&gt;b \equiv c&lt;/equation&gt; 这两个条件，再对这两个条件套用一些变换，得出 &lt;equation&gt;a \equiv c&lt;/equation&gt; ”。&lt;/p&gt;&lt;p&gt;在这个时候，编译器并没有把 &lt;equation&gt;a \equiv b&lt;/equation&gt; 和 &lt;equation&gt;b \equiv c &lt;/equation&gt; 当成既成条件，而是当成了 “变量” 。&lt;/p&gt;&lt;p&gt;这就回到了我们原本的需求，我们原本就是需要写出一个 &lt;equation&gt;a \equiv b\ \land\ b \equiv c \rightarrow a \equiv c&lt;/equation&gt; 的变换。&lt;/p&gt;&lt;p&gt;如果要用变换强行实现的话，可以使用 &lt;code class=&quot;inline&quot;&gt;with&lt;/code&gt; 语句（就是 Agda 的 &lt;code class=&quot;inline&quot;&gt;case of&lt;/code&gt;）把这两个变量模式匹配出来，然后直接得证。 这里给出一个代码实现。&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \begin{eqnarray} \_{\leftrightarrows}_1\_\ ab\ bc \with ab\ &amp;amp;|&amp;amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;amp;|&amp;amp;\refl = \refl \end{eqnarray}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆₁_ ab bc with ab   | bc
...           | refl | refl = refl &lt;/code&gt;&lt;p&gt;这种方法和下面的做法是等价的。&lt;/p&gt;&lt;p&gt;如果你没有看懂这一坨，可以尝试继续读下去，说不定看完下面那坨你就懂了。&lt;/p&gt;&lt;h2&gt;使用 refl&lt;/h2&gt;&lt;p&gt;由于 &lt;equation&gt;a \equiv b&lt;/equation&gt; 已经是一个条件了，我们直接把它的值取出来。 这时，右边的代码就 &lt;b&gt;已经是建立在&lt;/b&gt; &lt;equation&gt;a \equiv b&lt;/equation&gt; &lt;b&gt;和&lt;/b&gt; &lt;equation&gt;b \equiv c&lt;/equation&gt; &lt;b&gt;这两个既成条件下&lt;/b&gt; 的了，因此这时 Agda 已经认为 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;c&lt;/code&gt; 三者相等了。&lt;/p&gt;&lt;p&gt;利用这一点，我们直接使用 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 是没有问题的。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\_{\leftrightarrows}_0\_\ \refl\ \refl = \refl &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆₀_ refl refl = refl &lt;/code&gt;&lt;h2&gt;顺带一提&lt;/h2&gt;&lt;p&gt;当然我们也可以这样写，这是一个语法糖：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \refl {\leftrightarrows}_0\refl = \refl &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;refl ⇆₀ refl = refl&lt;/code&gt;&lt;p&gt;之前那个比较 trivial 的模式匹配也可以这样写：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect}\begin{eqnarray} ab\ {\leftrightarrows}_1\ ab \with ab\ &amp;amp;|&amp;amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;amp;|&amp;amp;\refl = \refl \end{eqnarray}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;ab ⇆₁ bc with ab   | bc
...         | refl | refl = refl &lt;/code&gt;&lt;h2&gt;另一个例子&lt;/h2&gt;&lt;p&gt;现在你肯定有点感觉了，但是这个例子太 trivial 你又感觉自己有点没懂， 那么我们再来看看这个稍微复杂点的例子帮你加深一下理解。&lt;/p&gt;&lt;p&gt;首先：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \forall\ \{ a \}\ \{ A : \Set a \} &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;表示 Universal Polymorphism 。然后考虑一个函数，我们有：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp;amp; \ggg : \forall\ \{a\ b\}\ \{A : \Set a\}\ \{B : \Set b\} \{m\ n\} \{f : A \rightarrow B\} \rightarrow m \equiv n \rightarrow f\ m \equiv f\ n \\ &amp;amp; \ggg \refl = \refl \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;⋙ : ∀ {a b} {A : Set a} {B : Set b} {m n} {f : A → B} → m ≡ n → f m ≡ f n
⋙ refl = refl &lt;/code&gt;&lt;p&gt;和上面一样，在建立了 &lt;equation&gt;m \equiv n&lt;/equation&gt; 的基础上，可以直接用 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 表达他们对于同一个函数应用的结果相等。&lt;/p&gt;&lt;p&gt;我是在 &lt;a href=&quot;https://stackoverflow.com/questions/27091668/refl-in-agda-explaining-congruence-property&quot;&gt;这个 StackOverflow 问题&lt;/a&gt; 里看到这个代码的，唯一的回答里面还有更多的解释。&lt;/p&gt;&lt;p&gt;这个我就暂时不作过多讲解了，以后再说。&lt;/p&gt;&lt;h2&gt;结束&lt;/h2&gt;&lt;p&gt;这个证明太简单了，只有一步，没有什么实际意义，仅用于入门理解。 下一篇文章我们将会进行一个稍微复杂点的关于与或关系的证明。&lt;/p&gt;&lt;p&gt;我说完了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;执壶的代码块高亮竟然支持 Agda ，感动中国简直&lt;/p&gt;</description>
<author>大笨蛋千里冰封</author>
<guid isPermaLink="false">2017-11-02-30686586</guid>
<pubDate>Thu, 02 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Lens：从入门到入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-29-30544410.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Lens：从入门到入门&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30544410&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aaf2eb05bd1a9cdd7418bb083208767d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;概览&lt;/h2&gt;&lt;p&gt;Haskell 语言中操作一个复杂的数据结构往往会成为一个问题。&lt;/p&gt;&lt;p&gt;例如我们用 Haskell 做一个RPG游戏，有下面的定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Hero = Hero {
  heroLevel :: Int, weapon :: Weapon
}

data Weapon = Weapon {
  basicAttack :: Int, weaponLevel :: Int, magicGem :: Gem
}
data Gem = Gem {
  gemLevel :: Int,
  gemName :: String
} 
setHeroLevel :: Hero -&amp;gt; Int -&amp;gt; Hero
setWeapon    :: Weapon -&amp;gt; Hero -&amp;gt; Hero
-- and so on. &lt;/code&gt;&lt;p&gt;对于简单的从深层结构中提取出一个值仍然是可接受的：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;gemLevel.magicGem.weapon $ hero
-- Or
hero &amp;amp; (weapon&amp;gt;&amp;gt;&amp;gt;magicGem&amp;gt;&amp;gt;&amp;gt;gemLevel)&lt;/code&gt;&lt;p&gt;但修改内层数据（并返回一个新的对象）则显得过于繁杂：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;hero&#39; = hero {
    weapon = (weapon hero) {
        magicGem = (magicGem.weapon $ hero){
            gemName = &quot;WTF&quot; }}}&lt;/code&gt;&lt;p&gt;可以看到，这里仅仅三层嵌套，一个修改的操作就已经及其复杂了。&lt;/p&gt;&lt;p&gt;为了解决这个问题 Haskell 语言中有一种被称为「Lens」的工具，可是实现下面这样的写法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;view (weaponLens.magicGemLens.gemLevelLens) hero
hero&#39;  = set (weaponLens.magicGemLens.gemNameLens) &quot;Gem&quot; hero
hero&#39;&#39; = over (weaponLens.magicGemLens.gemLevelLens) (+1) hero

-- 中缀版本
hero .^ weaponLens.magicGemLens.gemLevelLens 
hero&#39;  = hero &amp;amp; weaponLens.magicGemLens.gemNameLens .~ &quot;Gem&quot; 
hero&#39;&#39; = hero &amp;amp; weaponLens.magicGemLens.gemLevelLens) %~ (+1)&lt;/code&gt;&lt;p&gt;这里的代码已经非常接近于普通的命令式语言中的写法了，非常自然、易用。&lt;/p&gt;&lt;p&gt;普通的命令式语言中用 &lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 从一个结构中提取它的一个子域，而这里我们在 Haskell 中通过 Lens 实现了类似的效果。同时我们注意到，这里的&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 不是凭空出现的，而是我们熟悉的 Haskell 中的函数复合。即 Lens 完成上面这些复杂操作的一个基本思路是复合。&lt;/p&gt;&lt;h2&gt;简版 Lens   &lt;/h2&gt;&lt;p&gt;实际上，如果我们已经有了这些对象对应的 getter 和 setter 函数，那么我们不难将他们之间互相复合形成操作深层数据的新的 getter 和 setter。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type L a b = (a -&amp;gt; b, b -&amp;gt; a -&amp;gt; a)

(.&amp;gt;) :: L a b -&amp;gt; L b c -&amp;gt; L a c
(g1, s1) .&amp;gt; (g2, s2) = (g2 . g1, \c a -&amp;gt; s1 (s2 c (g1 a)) a)

viewL :: L a b -&amp;gt; a -&amp;gt; b
viewL (g, _) = g

setL :: L a b -&amp;gt; b -&amp;gt; a -&amp;gt; a
setL (_, s) = s

overL :: L a b -&amp;gt; (b -&amp;gt; b) -&amp;gt; a -&amp;gt; a 
overL (g, s) f a = s (f $ g a) a&lt;/code&gt;&lt;p&gt;我们直接将一个 getter 与 setter 包装成二元组。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponL   = (weapon, setWeapon)
gemLevelL = (gemLevel, setGemLevel) &lt;/code&gt;&lt;p&gt;这种情况下，我们定义的“简版 Lens ”的使用与前文演示的 Lens 是极其相似的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;viewL (weaponL.&amp;gt;magicGemL.&amp;gt;gemLevelL) hero
hero&#39; = setL (weaponL.&amp;gt;magicGemL.&amp;gt;gemLevelL) 2 hero&lt;/code&gt;&lt;p&gt;我们的实现仍然借助了复合的思想，但是需要我们自己来实现针对 getter 和 setter 的复合，而前文演示的却是真正的函数复合。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;实现 Lens 的准备工作&lt;/h2&gt;&lt;p&gt;我们已经注意到文章开头的 Lens 有几个特点&lt;/p&gt;&lt;ul&gt;&lt;li&gt;是普通的函数类型，可以互相复合；&lt;/li&gt;&lt;li&gt;与对象类型&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; 和域类型 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 相关；&lt;/li&gt;&lt;li&gt;可以用来实现看似相反的两个操作 get 和 set。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面我们尝试找出这个类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = (???  ) -&amp;gt; (???)&lt;/code&gt;&lt;p&gt;考虑它的复合特点，按照结构的嵌套顺序，从前向后依次是从内向外：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;aL :: Lens b a
cL :: Lens a c
aL.cL :: Lens b c&lt;/code&gt;&lt;p&gt;要实现这样的复合特性，应当是&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type SomeType a = ...

aL :: SomeType a -&amp;gt; SomeType b
cL :: SomeType c -&amp;gt; SoemType a
aL.cL :: SomeType c -&amp;gt; SomeType b&lt;/code&gt;&lt;p&gt;即上面的第一个 (???) 与&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;有关，第二个与&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;有关。&lt;/p&gt;&lt;p&gt;同时，&lt;code class=&quot;inline&quot;&gt;Lens b a&lt;/code&gt;一定会接受一个&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;类型的参数作为要操作的主体对象，我们可以进一步写成&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = (???) -&amp;gt; (b -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;而上面的复合特性要求前后是两个类似的类型&lt;code class=&quot;inline&quot;&gt;SomeType&lt;/code&gt;，我们进一步改写为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = (a -&amp;gt; ???) -&amp;gt; (b -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;我们可以猜测到，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt; 等函数调用&lt;code class=&quot;inline&quot;&gt;Lens&lt;/code&gt;，传递进一个函数&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; ???)&lt;/code&gt;来实现了不同的操作。&lt;/p&gt;&lt;h2&gt;View Lens 的实现&lt;/h2&gt;&lt;p&gt;我们先尝试写出一个特定类型的 Lens ，来只支持&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;操作，根据上文的分析，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数的定义应该形如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: VLens b a -&amp;gt; b -&amp;gt; a
view lens b = lens ??? b&lt;/code&gt;&lt;p&gt;考虑我们之前的例子&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens   :: (Weapon -&amp;gt; ???) -&amp;gt; (Hero -&amp;gt; ???)
magicGemVLens :: (Gem -&amp;gt; ???)    -&amp;gt; (Weapon -&amp;gt; ???)
gemLevelVLens :: (Int -&amp;gt; ???)    -&amp;gt; (Gem -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;如果我们想要获得英雄的武器上的宝石的宝石等级，那么我们想要的可能是这样的东西：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens.magicGemVLens.gemLevelVLens :: (Int -&amp;gt; Int) -&amp;gt; (Hero -&amp;gt; Int)&lt;/code&gt;&lt;p&gt;这样，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数便可以对这个复合的&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;传入某个函数，再传入我们的英雄，就可以得到宝石等级了。为了让这样的复合成为可能，上面的所有 ??? 都必须是&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;。我们可以想象到那个代表&lt;code class=&quot;inline&quot;&gt;GemLevel&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;在函数间传递的效果。&lt;/p&gt;&lt;p&gt;同理，如果我们只想得到武器上的宝石的话，我们需要的是这样的东西：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens.magicGemVLens :: (Gem -&amp;gt; Gem) -&amp;gt; (Hero -&amp;gt; Gem)&lt;/code&gt;&lt;p&gt;这时候这些&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;又成为了&lt;code class=&quot;inline&quot;&gt;Gem&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;由此可见，在&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的场合下，这里的类型&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;随着提取的东西不同而变化，并且等于我们要提取的东西的类型。这样&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;的类型定义便得到了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type VLens b a = forall c. (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; c)&lt;/code&gt;&lt;p&gt;所有的&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;在复合时都接受内层的一个提取操作，并返回一个嵌套了的提取操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens  :: VLens Hero Weapon
weaponVLens f = \h -&amp;gt; f (weapon h)

magicGemVLens :: VLens Weapon Gem
magicGemVLens f = \w -&amp;gt; f (magicGem w)

gemLevelVLens :: VLens Gem Int
gemLevelVLens f = \g -&amp;gt; f (gemLevel g)&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eb3ff4069ec471c1c69250a6355a85a1_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;503&quot; data-rawheight=&quot;417&quot;&gt;&lt;p&gt;而最终传入我们要操作的外层对象之后，则用相仿的顺序，一层层地完成了提取操作，直到最内层，这时我们只需要使用&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;函数使其原样返回即可。&lt;/p&gt;&lt;p&gt;由此，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数的定义便可以得到了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;viewV vlens b = vlens id b&lt;/code&gt;&lt;h2&gt;Over Lens 的实现&lt;/h2&gt;&lt;p&gt;再次考虑我们的例子&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens   :: (Weapon -&amp;gt; ???) -&amp;gt; (Hero -&amp;gt; ???)
magicGemOLens :: (Gem -&amp;gt; ???)    -&amp;gt; (Weapon -&amp;gt; ???)
gemNameOLens  :: (Int -&amp;gt; ???)    -&amp;gt; (Gem -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;现在我们希望对一个对象的某个域进行修改，并返回修改过了的对象。那么后面的 ??? 则应该与和它紧靠着的类型相同，而为了使这些&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;可以互相复合，前面的 ??? 应该与紧靠着的前面类型相同。例如：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens.magicGemOLens :: (Gem -&amp;gt; Gem) -&amp;gt; (Hero -&amp;gt; Hero)&lt;/code&gt;&lt;p&gt;可以看到 &lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;的类型比较简单&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type OLens b a =  (a -&amp;gt; a) -&amp;gt; (b -&amp;gt; b)&lt;/code&gt;&lt;p&gt;观察一下便可以得到，第一个参数&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; a)&lt;/code&gt;便是我们对域进行操作的更新函数了。此时&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;函数不需要再做其他多余的事情，只需要将&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;原样返回。而各个&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;的定义也只不过是产生一个新的修改函数，这个修改函数将自己管辖的域修改为已经被修改过了的内层对象。而最内层则会使用用户传入的修改函数f来完成相应的操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens ::  OLens Hero Weapon
weaponOLens f = \h -&amp;gt; (`setWeapon` h) $ f (weapon h)

magicGemOLens :: OLens Weapon Gem
magicGemOLens f = \w -&amp;gt; (`setMagicGem` w) $ f (magicGem w)

gemLevelOLens :: OLens Gem Int
gemLevelOLens f = \g -&amp;gt; (`setGemLevel` g) $ f (gemLevel g)&lt;/code&gt;&lt;p&gt;这样，当最终传入需要处理的外层对象时，&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;便会一层层地完成修改的工作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;而言，只不过是一种特殊的&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;setO vlens s = vlens (const s)&lt;/code&gt;&lt;h2&gt;最终实现 Lens&lt;/h2&gt;&lt;p&gt;现在，我们已经分别实现了&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;，而且发现他们之间有相似之处。实际上他们都是从一个相同的&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; ???) -&amp;gt; (b -&amp;gt; ???)&lt;/code&gt; 经过我们一系列对其性质的分析得到的。我们的最终目的是通过单一的&lt;code class=&quot;inline&quot;&gt;Lens&lt;/code&gt;类型，来实现&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;这样不同的行为，即需要某种多态。而下面的类型却无法为这种多态提供帮助。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a -&amp;gt; forall c d. (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; d)&lt;/code&gt;&lt;p&gt;我们需要某种类型，我们可以对其中的内容进行操作，并且这种操作的行为随使用者的需求而可以多态变化。符合这样特点的，正是我们熟悉的 Functor 。所以我们便可以这样做了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; (b -&amp;gt; f b)&lt;/code&gt;&lt;p&gt;这个类型定义非常类似前面的&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;，同时这里的f具有任意性，又可以满足&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;的需求。而实际上，如果这里的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;是 Identity Functor 的话，这个类型所表达的与&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;毫无区别。我们只需要对原有&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;进行一层 Identity Functor 的包装就保证了其语义不变：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;over lens f = runIdentity . lens (Identity . f)&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens ::  (a -&amp;gt; a) -&amp;gt; (b -&amp;gt; b)
weaponOLens f h = (`setWeapon` h) $ f (weapon h)&lt;/code&gt;&lt;p&gt;我们也仅需要对调用的修改本层次域的函数进行升格，上下结构保持了极好的相似性。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponLens ::  Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; (b -&amp;gt; f b)
weaponLens f h = (`setWeapon` h) &amp;lt;$&amp;gt; f (weapon h)&lt;/code&gt;&lt;p&gt;那么我们剩余的问题就在于如何利用 Functor 提供的多态能力来实现&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的语义了。&lt;/p&gt;&lt;p&gt;我们观察一下先前的&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;实现&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type VLens b a = forall c. (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; c)
viewV vlens b = vlens id b&lt;/code&gt;&lt;p&gt;我们发现&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的实现有如下特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对象的内容完全没有被改变&lt;/li&gt;&lt;li&gt;每一层的作用是返回内层的内容&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们只要找到一个Functor符合上面的特点就可以实现&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;，而 Const Functor 恰好符合我们的需求。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Const a b = Const {getConst :: a}
instance Functor (Const a) where
  fmap f c = c&lt;/code&gt;&lt;p&gt;Const Functor 的&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;并不改变值，实际上，其中根本没有值。一个 Const Functor 在创建之后，经历过多次&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;可能其类型发生变化，但getConst所取出的内容永远不会变化。&lt;/p&gt;&lt;p&gt;考虑下面的&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;定义，最内层的值被应用到&lt;code class=&quot;inline&quot;&gt;Const&lt;/code&gt;构建函数上。之后经历过若干次&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;，最后&lt;code class=&quot;inline&quot;&gt;getConst&lt;/code&gt;取得的仍是原来的值，于是便实现了&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的行为。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Lens b a -&amp;gt; b -&amp;gt; a
view lens b = getConst $ lens Const b&lt;/code&gt;&lt;p&gt;到这里为止，我们便实现了文章开头所演示的 Lens 的功能。&lt;/p&gt;&lt;p&gt;附上在Zju Lambda报告的Slides：&lt;a href=&quot;https://github.com/zju-lambda/slides/blob/master/The%20Overview%20of%20Lens.pdf&quot;&gt;The Overview of Lens&lt;/a&gt;&lt;/p&gt;</description>
<author>孙浩然</author>
<guid isPermaLink="false">2017-10-29-30544410</guid>
<pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Dafny与程序验证</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-21-30321583.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Dafny与程序验证&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30321583&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8f49af88768b20c6808b564c74a43abe_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;B大以前写过一个&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25568785&quot;&gt;怎样写出没有 bug 的程序：程序证明的简单例子&lt;/a&gt; ，是用Idris写的，我也来写一个，不过方法不太一样。&lt;/p&gt;&lt;p&gt;Dafny是MSR开发的程序设计语言，它混合了OOP和FP编程范式，并且自带程序验证功能，可以通过霍尔逻辑证明程序正确性。&lt;/p&gt;&lt;p&gt;它的语法非常简单，看起来就像C++，Scala和Haskell的混合。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;变量(scala风格，只是没有val)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;var x:Tree;
var y:nat := 0;&lt;/code&gt;&lt;ul&gt;&lt;li&gt;ADT(Haskell风格)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)
datatype List&amp;lt;T&amp;gt; = Nil | Cons(head: T, tail: List&amp;lt;T&amp;gt;)
Cons(5,Nil).Cons? &amp;amp;&amp;amp; Cons(5, Nil).head == 5&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Methed/Lemma(命令式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;expr表示表达式，col表示集合&lt;/p&gt;&lt;p&gt;modifies用来标记函数的副作用，requires是前置命题，ensures是后置命题，decreses用来证明递归函数可终止。&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method/lemma Abs(x: int) returns (y: int)
    modifies &amp;lt;col&amp;gt;
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 { return -x;}
    else {return x;}
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Function/Predicate(函数式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;reads用来标记函数捕获的外部变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;function abs(x: int):int
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    reads &amp;lt;col&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 then -x else x
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Assert用来下断言，只不过这个断言不是运行期的，而是编译期的，支持forall和exist量词以及基本的逻辑运算符。把Assert改为Assume，可以用来假定某些命题成立。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;assert forall x :: P(x) ==&amp;gt; Q(x)
assert forall(i | 0 &amp;lt;= i&amp;lt; n - m) { b[i] := a[m + i];}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;模式匹配(Scala风格，match的位置略有差异)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;match t
	case Empty =&amp;gt; …
	case Node(l:Empty,v,r) =&amp;gt; …&lt;/code&gt;&lt;ul&gt;&lt;li&gt;循环&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可用invariant标记循环不变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;var i:=0
while i&amp;lt;n
	invariant i&amp;lt;=n
	decreases n-i
{}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;支持C++类的写法，支持Lambda表达式，支持Trait，支持yield惰性流，有复杂的模块系统，支持泛型类和高阶类型（都是用&amp;lt;&amp;gt;表达）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上就是Dafny常用的语法，还有一些不常用的语法可以参考&lt;a href=&quot;https://github.com/Microsoft/dafny/blob/master/Docs/DafnyRef/out/DafnyRef.pdf&quot;&gt;DafnyRef&lt;/a&gt;&lt;/p&gt;&lt;p&gt;一起来看一个稍微复杂一点的例子吧！写一个二叉搜索树的插入函数&lt;/p&gt;&lt;p&gt;定义二叉树&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)&lt;/code&gt;&lt;p&gt;在类里定义变量&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class BST
{
    var tree:Tree;&lt;/code&gt;&lt;p&gt;定义in_tree和is_ordered函数，分别表示某个元素在树内和树符合二叉搜索树的条件&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;predicate method is_intree(t:Tree,x:real)
{
    match t
        case Empty =&amp;gt; false
        case Node(l,v,r) =&amp;gt; x==v || is_intree(l,x) || is_intree(r,x)
}
predicate is_ordered(t:Tree)
{
    match t
        case Empty =&amp;gt; true
        case Node(l,v,r) =&amp;gt; is_ordered(l) &amp;amp;&amp;amp; is_ordered(r) &amp;amp;&amp;amp;
            (forall x::is_intree(l,x) ==&amp;gt; x&amp;lt;v) &amp;amp;&amp;amp;
            (forall y::is_intree(r,y) ==&amp;gt; y&amp;gt;=v)
}&lt;/code&gt;&lt;p&gt;定义函数insert_into_left和insert_into_right&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;protected function method insert_into_left(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_left(t,x))
{
    match t.left
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.left,x)
            else
                insert_into_left(t.left,x)
}

protected function method insert_into_right(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_right(t,x))
{
    match t.right
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.right,x)
            else
                insert_into_left(t.right,x)
}
&lt;/code&gt;&lt;p&gt;以上全是pure function，最后，我们回到oop的世界，定义dirty的类成员函数&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method insert(x:real)
    requires is_ordered(tree)
    modifies this
    ensures is_ordered(tree)
{
    match tree
        case Empty =&amp;gt; {tree:=Node(Empty,x,Empty);}
        case Node(l,v,r) =&amp;gt; 
        {
            if x&amp;gt;=v
            {
                tree:=insert_into_right(tree,x);
            }
            else
            {
                tree:=insert_into_left(tree,x);
            }
        }
}&lt;/code&gt;&lt;p&gt;编译的时候，编译器会帮你验证你写的那些requires,ensures,assert是否满足，如果不满足，它会告诉你哪些命题无法证明。经过验证之后，你可以选择将Dafny代码编译为C#或编译成dll被其他.Net程序调用。&lt;/p&gt;&lt;p&gt;以上只是一个简单介绍，具体代码在&lt;a href=&quot;https://github.com/NiceKingWei/algorithm/blob/master/dafny/bst.dfy&quot;&gt;bst.dfy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我的slides &lt;a href=&quot;https://github.com/zju-lambda/slides/blob/master/Verification%20in%20Dafny.pdf&quot;&gt;Verification in Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;关于Dafny的更多精彩内容， 可以关注Dafny的项目主页，里面有一些学习资源 &lt;a href=&quot;https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Fdafny%2Freference.aspx&quot;&gt;MSR:Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>魏王雅望非常</author>
<guid isPermaLink="false">2017-10-21-30321583</guid>
<pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>关于AlphaGo</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-21-30319620.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;关于AlphaGo&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30319620&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近被Zero刷屏了，我也来蹭热点。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;既然大家都分析得差不多了，我就不分析，提一个问题。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;无可置疑，AlphaGo战胜李世石，柯洁，无人能胜，是一个成功。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是，为什么AlphaGo成功了，然而其他跟推理有关的任务没有？（假设，成功=达到顶尖人类水平）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如说，OpenAI搞Dota，1V1下失败：被找出漏洞，当ATM刷。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如说，Deepmind搞星际争霸，失败：打不过bot，连小任务（控制几个小兵消灭对方的小兵）都很困难。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如说，MS搞程序生成，失败（或者更准确的说，根本没尝试更难的task）：DeepCoder的确取得好成绩，但是无法scale到普通程序员。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;又比如说，Visual Question Answering，Natrual Language Processing也不能在复杂的数据集上超越人类。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我拿这个问题问了很多人，得到各个不同的答案，先别跳到‘Go搜索空间很低，并且是Partial Information上去’，我们想想有什么理论，然后能如何测试这些理论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案0：Go空间很低。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;按照这个答案，我们可以试试看把各个问题的空间再降低，差不多的时候就能超越人类了。&lt;/p&gt;&lt;p&gt;或者相反的，我们可以试试看39*39 Go棋盘，199*199 Go棋盘等等。。。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不过其实我挺不买账的，因为我可以很简单的给出一个搜索空间巨大，但是很简单的例子：ShakeSphere游戏。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ShakeSphere游戏很简单，你可以打a-z，还有空格，各类标点等，要求打出一个莎士比亚全集。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;很明显这个空间巨大，并且可以任意大（打两次，打三次），如果加入del键还能到达无限搜索空间，但是这个问题任何一个编程入门的人都会解。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更何况，人类也怕大的搜索空间啊。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案1：Partial Information疼&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果是这样，试试看给Go加上迷雾，或者给Dota, StarCraft去掉迷雾呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这也无法解释VQA，NLP等task。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案2：Go能利用CNN架构，但是NLP，Dota，套CNN，LSTM没有太大意义，都不能很好的encode信息。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得有点靠谱。如果是这样，我们是不是应该去更多研究GraphCNN，然后找LSTM的替代品？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案3：推理需要搜索，而AlphaGo成功的把搜索外包出去，由神经网络做&lt;/p&gt;&lt;p&gt;答案4：越需要推理的task越离散，越不平滑，于是NN不喜欢，也不stable。搜索能变得stable一些。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Dota/StarCraft或许能通过imagination做搜索，但是什么叫‘在阅读理解上搜索’？Hmmm。。。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当然，很可能答案是多个上面解释的组合，或者是上面没有列举的。如果你有想法，评论/私信我！&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-10-21-30319620</guid>
<pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>EBNFParser的原理解析以及使用教程</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-07-29908056.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;EBNFParser的原理解析以及使用教程&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29908056&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-78761dc79f02fa543f016e8cceedf4ba_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;(题图的来源，图上就有&lt;/p&gt;&lt;p&gt;前段时间有人在我答案底下说看不懂，所以我今天来讲一下我是怎么写成某个Parser框架的。&lt;/p&gt;&lt;p&gt;在此之前，我说一点别的话。&lt;/p&gt;&lt;p&gt;非常感谢CPython项目，深入阅读了Python码源的一部分，我从中获益良多。&lt;/p&gt;&lt;p&gt;虽然我并没有学过编译原理，但我想，我从这份源代码里得到的东西，应该能够囊括很多编译相关的东西，教会了我许多关于编程语言设计、C和Python的令人智熄的操作。当然还有一些非思想层面的的收获，比如，阅读Python码源的课后作业就是我的&lt;a href=&quot;https://github.com/thautwarm/flowpython&quot;&gt;Flowpython&lt;/a&gt;，作为一个完全兼容CPython3.5和CPython3.6的解释器，它提供了一些强力而有用的语法(糖)，应该说是个非常实用的东西。&lt;/p&gt;&lt;p&gt;向开源世界的一切贡献者(包括我自己hhh)致敬！&lt;/p&gt;&lt;p&gt;然后我们来看看EBNFParser效果。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;EBNFParser的作用可不仅仅是快速写出一门语言的前端，平常像解析json啊，yaml啊，xml啊这种数据文件，也是可以秒着玩的。更有甚者，你要是觉得正则表达式用着不够自由，你可以通过折中执行效率和功能来写一个用起来更顺手的正则引擎。&lt;/p&gt;&lt;p&gt;我的github项目有一个简短的介绍，让你用几行代码写一个Lisp的Parser。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser&quot;&gt;EBNFParser主页&lt;/a&gt;&lt;/p&gt;&lt;p&gt;当然，要解析完整的Lisp, 不考虑注释，应该需要5行。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/blob/master/tests/Python/Lang/Lisp/grammar&quot;&gt;较为完整的Lisp语法解析文件&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在完成EBNFParser的稳定版本后，除开上面的Lisp，我给出的示例还有以下几门语言的。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/Python&quot;&gt;Python表达式&lt;/a&gt;&lt;br&gt;Python的全部语法在&lt;a href=&quot;https://github.com/python/cpython/blob/master/Grammar/Grammar&quot;&gt;CPython的Grammar文件&lt;/a&gt;里有定义，你按照这个来，完成整个Python的解析仅仅是小菜一碟。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/EBNF&quot;&gt;旧版本的EEBNF语言自省&lt;/a&gt;。&lt;br&gt;我所使用的EBNF语法并不是标准的，为了区别我打算暂时称呼其为&lt;b&gt;EEBNF&lt;/b&gt;, 它比起标准的EBNF更像是一门编程语言，扩展能力更加强大。此处的&lt;b&gt;旧版本的EEBNF&lt;/b&gt;缺少了一些新的非常有用的语法，比如AST的过滤，以及取消字面量Parser对自动生成的Tokenizer的影响(后者对于实现类似Java的嵌套多重注释(/*.../*...*/...*/)非常方便)。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/Expy&quot;&gt;Extra Py&lt;/a&gt;&lt;br&gt;这是一门还未诞生的语言，我创造它的意图是解决使用科学计算语言的混乱现状。除开能力碾压其它的Julia，其他科学计算语言的特性都非常接近，而且都有些不太令人愉悦的地方。而Extra Py是一门语法及特性更加合理(内部结构的一致性，在这一点上Matlab非常的糟糕)的语言，应该可以符合很多人的口味。&lt;br&gt;同时，因为Extra Py非常的合理、优雅以及简单，解析到其他语言的方法可能非常得灵活。&lt;b&gt;非常欢迎有兴趣和能力的朋友参与Extra Py的后端开发，这会是又一个有趣又有用的开源项目&lt;/b&gt;。&lt;br&gt;未来，如果Extra Py如期出现，我打算弄一个科学计算主题的公共项目，该项目的Extra Py代码轻易地编译或解释到R、 Python、Matlab、Julia、C++甚至Mathematica(甚至如果你会写Perl和Fortran...)，接受任何人符合标准的、任何科学领域的代码。&lt;br&gt;我并不是要去取代这些科学计算语言，我要做的是让新手学会一门能很快转向这些语言的轻量级语言。然后，很多时候，库的编写者只需要写写Extra Py，就可以发布多门语言的库了(按照R语言的三方库代码质量，我相信即便是简单的代码转换生成，也算得上是质量上乘的库了，更何况我相信未来的后端处理者们一定有很多骚操作的，比如我会把Extra Py的代码编译到Cython然后使用gcc优化，就非常棒了)。&lt;br&gt;这是我的宏愿，暂且说这么多。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/tree/master/tests/Python/Lang/Cm&quot;&gt;EBNFParser.tests.Cm&lt;/a&gt;  以及 &lt;a href=&quot;https://github.com/Cm-lang&quot;&gt;Cm-lang项目&lt;/a&gt;&lt;br&gt;这是一门非常非常非常非常非常优雅的、高性能的、静态编译的语言。虽然它暂时还没发布。它的创建者是伟大的后宫王，世界Online的主角 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hash=&quot;67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hovercard=&quot;p$b$67ebe1bd8e4a63f17a42572e40afaac7&quot;&gt;@大笨蛋千里冰封&lt;/a&gt; 。&lt;br&gt;我有一个愿望，就是&lt;b&gt;让小括号可以远离这门可以表现得像C一样迅捷&lt;/b&gt;的语言。虽然我暂时并没有想到一个没有语意冲突又没有小括号的解决方案。&lt;br&gt;Cm应该是EBNFParser的第一个挑战，&lt;b&gt;事实上我是为了给Cm写Parser&lt;/b&gt;(在此控诉某号称图形学帝球，有商业级音乐才能的无良be)&lt;b&gt;才写的EBNFParser。&lt;br&gt;&lt;/b&gt;Cm的&lt;b&gt;语法优雅，但设计上有相当程度的复杂&lt;/b&gt;，&lt;b&gt;可能是它吸取了kotlin、scala、rust的很多特点。&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;rust&quot;&gt;let $ = i:i32 -&amp;gt; (f:[i32=&amp;gt;i32]) -&amp;gt; f(i)  // 我倾向于可以不要分号，Parser不需要...
var x = 1;  // 但是大佬近期考sat，关于分号的事情未下结论。
until ({x&amp;gt;1})  //其实， until是个函数哦，你可以用这种方式造DSL啊
{
   doSomething
}   &lt;/code&gt;&lt;p&gt;      来个类型标注的完全版(&lt;b&gt;虽然你实际上一定不需要写这么多&lt;/b&gt;)，但我觉得&lt;b&gt;真是超好看&lt;/b&gt;...&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let F:[[i32=&amp;gt;i32]=&amp;gt;i32=&amp;gt;i32] = (f:[i32=&amp;gt;i32])=&amp;gt;[i32=&amp;gt;i32]-&amp;gt;{
      (x:i32)=&amp;gt;i32 -&amp;gt; f(x)*x
} :[[i32=&amp;gt;i32]=&amp;gt;i32=&amp;gt;i32]  //好吧这个尾标注我抄了一下scala
// 这个类型标注是我想出来的哇哈哈，详见我的Squirrel语言，那是我搞编译器的开始...
// https://github.com/thautwarm/SquirrelLanguage&lt;/code&gt;&lt;p&gt;好的，效果预览完毕。&lt;/p&gt;&lt;p&gt;让我们进入EBNFParser的原理解析。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;模式匹配&lt;/h2&gt;&lt;p&gt;在早些的时候，我非常恨Python为什么没有模式匹配。于是呢，我造了一个轮子。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/Stardust&quot;&gt;thautwarm/Stardust&lt;/a&gt; 看ReadMe的Pattern Matching部分。&lt;/p&gt;&lt;p&gt;这个轮子还是挺强的，比如一个对象，你可以用简单的语法匹配它是否有某些成员或者，对这些成员的值在匹配。同时你可以去匹配像列表啊、元组啊、字典啊这样的结构。总之万事万物都可以匹配。&lt;/p&gt;&lt;p&gt;不到两百行代码，还是很短的(但当时代码太丑了…)。&lt;/p&gt;&lt;p&gt;然后在我写这个Parser框架的时候，经过半天的瞎搞(我已经忘了那半天我在想什么策略了...)，我的脑袋里涌出了两个东西，一个是Python的Grammar文件(当时flowpython项目已经完成)，一个是我曾经给Python写的那个模式匹配扩展。&lt;/p&gt;&lt;p&gt;来我们看看EBNF是如何定义语法的。(具体语法我参照的是Python的Grammar文件和我数理逻辑书上的BNF语法...)&lt;/p&gt;&lt;code lang=&quot;ebnf&quot;&gt;lambdaDef ::= &#39;lambda&#39; argList &#39;:&#39; test&lt;/code&gt;&lt;p&gt;啊！这不就是个模式匹配嘛。。&lt;/p&gt;&lt;p&gt;来一个token好的词组&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[&#39;lambda&#39;,
&#39;x&#39;,&#39;,&#39;,&#39;y&#39;,
&#39;:&#39;,
&#39;x&#39;,&#39;+&#39;,&#39;y&#39;,...]&lt;/code&gt;&lt;p&gt;你看看你看看。看不出来的话，我们来个模式匹配。&lt;/p&gt;&lt;p&gt;我用Python的部分语法做一个可爱的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    好的，现在先把词组交到我们的lambdaDef小可爱手上。
    哇！第一个匹配成功,正好是我们要的 lambda 啊！
    好的，lambdaDef同学把lambda放到一个叫做AST的东西的第一个位置。
    继续...
    啊，下一个单元好像需要别人的帮助了，lambdaDef同学查了查自己的模式表，找到
一个熟悉的名字。
    &quot;argList同学在吗？&quot;lambdaDef大声地朝某索引区域喊道。
    &quot;啊？找我嘛？姐姐你把当前的词组递给我一下，对了，把当前解析到第几个词也说一下.&quot;
    索引区域里传来argList同学的声音，她把自己的一个方法委托到某个lambdaDef也
能碰到的地方。
    lambdaDef见状，急忙将词组和已解析词数1放到了argList同学的委托里。
    之后，argList同学那里发生了很多事情，她和argDef同学、Name同学以及Test老
师一起处理了词组，得到了一个结果(如下)。
----------------------------
    argList[argDef[Name[x]]]
----------------------------
// 注: argList ::= argDef (&#39;,&#39; argDef)*
//     argDef  ::= Name [&#39;=&#39; Test]
//     Test为Python表达式语法的最高级节点，能表述一切表达式。

同时，这个结果使得已解析词数变成了4。
    当然，这些事情，lambdaDef同学是不知道的，她看着argList同学满脸大汗地,
把结果和已解析词数交给了自己。
    &quot;谢谢你了，&quot;lambdaDef同学把这个结果放到了AST的第二个位置，然后更新了已解析
词数，&quot;辛苦啦... 不过，我听说我们的努力会被更高层的人给扔掉了。他们说选择我们一开
始就错了呢。&quot;
    &quot;啊咧，为什么要说这个呢，我们最高层的人是Test老师吧，不过我听说，有时候，较低
层的Atom妹妹也会把Test老师的工作扔掉呢。她说有些时候, 左括号匹配了，Test老师
也递交了结果，但是之后却没有跟着一个右括号呢。&quot;
// Atom的简化定义(去除列表解析等) ::= ... | &#39;(&#39; Test &#39;)&#39; | ...
    &quot;啊，是这样呀，而且我发现，其实我们也会做同样的事情呀。&quot;lambdaDef稍微有些
释然.
    &quot;哼，上次那个垃圾程序员以为自己在写JS, 写了一个 lambda x=&amp;gt;x，然后lambdaDef
姐姐就把我和大家辛苦合作完成的东西给扔掉了呢！&quot;

// 以上节选自某存在于我脑海的书 &amp;lt;&amp;lt;ParserGenerator娘的日常&amp;gt;&amp;gt;
    &lt;/code&gt;&lt;p&gt;好的，我觉得自己真有才呀。。&lt;/p&gt;&lt;p&gt;上面那个故事，基本讲清了所有的解析方法，最后lambdaDef和argList两位同学的对话，还稍微提到了一个我没有说但很重要的东西：&lt;b&gt;回溯。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为什么需要回溯？&lt;/p&gt;&lt;p&gt;因为有死结。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CppType ::= CppType &#39;(&#39; CppType* &#39;)&#39; | Name&lt;/code&gt;&lt;p&gt;很经典的死结是左递归。&lt;/p&gt;&lt;p&gt;我们怎么解决死结的呢？&lt;/p&gt;&lt;h2&gt;死结与周期&lt;/h2&gt;&lt;p&gt;如果，我们把每次解析出的新结果，和当前解析的词数对应起来，构成一个元组。用一个东西按顺序存储这些元组。&lt;/p&gt;&lt;p&gt;来，看官们，想想看，出现死结时，如果你打印最新的元组，会出现什么样的情况。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Name      ParsedCount
...       ...
CppType   50
CppType   50
CppType   50
CppType   50
CppType   50
...&lt;/code&gt;&lt;p&gt;为什么呢？&lt;/p&gt;&lt;p&gt;因为死结必然什么都没做。&lt;/p&gt;&lt;p&gt;我们看一个聪明的CppType。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// CppType ::= CppType &#39;(&#39; CppType* &#39;)&#39; | Name
CppType : 哈，我拿到词组和已解析数啦。打印一个。
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 好的，第一个就是我自己呀。继续。
CppType : 哈，我拿到词组和已解析数啦。打印一个。
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 好的，第一个就是我自己呀。继续——
CppType : 不对，这话我说过一样的，&quot;Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50&quot;.
CppType : 我去，玩我呢这是。。赶紧跳过。&lt;/code&gt;&lt;p&gt;好的，左递归问题解决了。应该说所有的死结问题都解决了。&lt;/p&gt;&lt;p&gt;但是左递归解析有时候还是需要的(暂时的EBNFParser还是会跳过，虽然我打补丁地很容易解决它，但出于性能考虑，我将加入新语法，使得可以指定某个Parser 能进行左递归解析。全局支持左递归会导致不必要的性能损失)。&lt;/p&gt;&lt;p&gt;我把我的想法告诉CppType，它真聪明，一学就懂。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// CppType ::= CppType &#39;(&#39; CppType* &#39;)&#39; | Name
CppType : 哈，我拿到词组和已解析数啦。打印一个。计数1.
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 好的，第一个就是我自己呀。继续。
CppType : 哈，我拿到词组和已解析数啦。打印一个。计数2大于1，发现重复.
Name =&amp;gt; CppType, ParsedCount =&amp;gt; 50
CppType : 按照红教主的指示，我现在应该处理保留计数1时的自己，然后对
当前计数2的自己，去解析后面其他的情况，解析失败就报个解析失败——计数2时
解析后面的情况失败的话，计数1时的自己就跳过左递归去看后面的情况。
...&lt;/code&gt;&lt;p&gt;是不是很简单呢？&lt;/p&gt;&lt;p&gt;原理暂时就讲到这里，我觉得差不多了呀。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;基本使用&lt;/h2&gt;&lt;p&gt;我想你已经看到项目上那个骚气的pypi了。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pip install EBNFParser&lt;/code&gt;&lt;p&gt;就ok了。&lt;/p&gt;&lt;p&gt;当然，因为Python3.6以下的版本不支持字符串插值，写起来比较不爽，我现在就只支持Python3.6+的Python。不需要任何语言及标准库以外的依赖。&lt;/p&gt;&lt;p&gt;不久的未来，EBNFParser会优化性能，还会渐渐推出无数新语言的版本。第二门支持EBNFParser的语言将会是C#，其实你如果不用自动代码生成，已经可以在C#手写ebnf来用parser了。&lt;/p&gt;&lt;p&gt;好的，我们看主页的第一个例子。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d054f5c2847425272e9f1ca69cce5b76_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1366&quot; data-rawheight=&quot;768&quot;&gt;&lt;p&gt;按照这个简介写一个Lisp的解析器就大概知道怎么用了。&lt;/p&gt;&lt;p&gt;然后介绍一下我的EEBNF的语法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;字面量Parser&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;l := R&#39;&amp;lt;正则表达式&amp;gt;&#39; 
# 该正则表达式将会按顺序加入token构造器

l := &#39;字符串&#39;  
# 该字符串会按顺序加入token构造器，
# 但所有的非R模式的字面量Parser的影响在R模式的Parser之前

l := K&#39;&amp;lt;正则表达式&amp;gt;&#39;
# 该Parser不对token做任何贡献.
&lt;/code&gt;&lt;p&gt;&lt;b&gt;AstParser&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 声明 l指代任意字面量Parser

X ::= l | l X l 
# 抽象语法书的Parser 可以由任意Parser 由 并运算符 | 组合。有先后顺序。
# 其中出现的字面量Parser将按出现顺序和字面量Parser模式, 去贡献token。

# 声明 y 是任意Parser(字面量或者Ast的)
X ::= y*
# *表示y至少出现0次，最多出现无穷次

X ::= y+
# +表示y至少出现1次，最多出现无穷次

X ::= y{n}
# 表示y至少出现n次，最多出现无穷次

X ::= y{n m}
# 表示y至少出现n次，最多出现m次

X ::= [y] z
# 表示 y 可能出现，等价于 X ::= y{0 1} z

X ::= (y z)+
X ::= (y z)*
X ::= (y z){1}
X ::= (y z){1 5}
# 把(y z)当成整体&lt;/code&gt;&lt;p&gt;&lt;b&gt;过滤&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Stmts Throw Newline ::=  (Newline* Stmt* Newline*)*
# 解析之后， Stmts不含有Newline  &lt;/code&gt;&lt;p&gt;暂时就这么多。&lt;/p&gt;&lt;p&gt;然后说明一下Ast的结构。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/EBNFParser/blob/master/Python/Misakawa/ObjectRegex/Node.py&quot;&gt;看里面的Ast类&lt;/a&gt;&lt;/p&gt;&lt;p&gt;现在可以支持Dump到JSON或者SExpr。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a6ea2a38fe9228ce1ffd25aa88b45d89_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1366&quot; data-rawheight=&quot;768&quot;&gt;&lt;p&gt;现在，尝试用EBNFParser去写一点好玩的东西吧。&lt;/p&gt;&lt;p&gt;造语言的话，前端太枯燥无味。解决好Parser，后面都是在做有趣的分析。&lt;/p&gt;&lt;p&gt;祝为梦想奋斗的各位晚安。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;（添一句，EBNFParser的错误提示还是有点智能的呀...&lt;/p&gt;&lt;p&gt;(EEBNF默认不支持注释语法和多行语句，但有可选项。例子详见项目主页的testCm.sh文件。&lt;/p&gt;</description>
<author>NightyNight</author>
<guid isPermaLink="false">2017-10-07-29908056</guid>
<pubDate>Sat, 07 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>一个滑块游戏的计算复杂性分析初步</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-07-29835678.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;一个滑块游戏的计算复杂性分析初步&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29835678&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e034b3b006eac91666343c4c3594d679_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;前段时间波恩大学的Norbert Blum宣称证明了 &lt;equation&gt;\text{P} \ne \text{NP}&lt;/equation&gt; ，并将文章挂在了arXiv上。PvsNP问题是计算理论领域最重要的未解决难题，它也是Clay数学研究所悬赏的千禧年七大数学难题之一，成功解决它的人有很大概率能获得数学界的最高荣誉Fields奖。PvsNP问题是如此的重要，而且它理解起来不算困难。因此，多年来全世界挑战PvsNP问题的人趋之若鹜，其中很大一部分是来搞笑的但也不乏专业的研究人员。然而，至今为止NP是否等于P依旧悬而未决。大家也最好不要轻易去挑战PvsNP问题，它很有可能消耗掉你大量的人生和信用。&lt;/p&gt;&lt;p&gt;我在这不打算、也没能力讨论Norbert Blum的证明是不是对的。我只是想找一个游戏中的有趣问题，尝试证明该问题是NP完全的（或NP-hard），以此来测试一下自己的计算理论基础。我选择了经典益智游戏“华容道”，我想看看它到底有多“难”。“华容道”游戏是一个经典益智小游戏，它通常是木制的，由若干个小方块摆放在一个矩形的框中，如下图&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7e4a9c32afdd0bf1396f11443721fa33_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;386&quot; data-rawheight=&quot;400&quot;&gt;&lt;p&gt;玩家需要做的是通过移动小方块，帮助“曹操”方块从初始位置移到最下方中部的出口逃走。当然在移动过程中，不允许其他方块移出到框外，也不能用“飞跃”大法。“华容道”游戏虽然取名自三国轶事，但它其实应该是一个比较现代的玩具，而它最早的出处比较难考证了，具体可以参考wiki百科&lt;a href=&quot;https://en.wikipedia.org/wiki/Klotski&quot;&gt;Klotski&lt;/a&gt;词条。&lt;/p&gt;&lt;p&gt;原始“华容道”游戏的解法能够被计算机穷举，但是我没有找到关于它的推广问题的计算复杂性分析的材料。因此，我想自行尝试看看能不能证明它的推广问题是NP-hard的，经过几天的思考，还真“凑”出了一个简单的归约方法...&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0.计算复杂性理论基础&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们先来粗糙地介绍一些计算理论的基础知识。&lt;b&gt;计算复杂性理论&lt;/b&gt;（computational complexity theory）研究的是计算机求解计算问题所需要计算资源的量。将存在多项式时间算法的问题的集合记为&lt;b&gt;P&lt;/b&gt;，通常认为这个集合中的问题能被计算机有效解决。因为随着问题输入规模n的增长，算法的运行时间是n的多项式，相比于指数时间算法，多项式算法的运行时间增长速度要慢很多。将存在多项式检验算法的问题的集合记为&lt;b&gt;NP&lt;/b&gt;，检验算法指的是对于问题的某个解，算法能够检验该解是否符合要求。其实集合NP包含了集合P，这不难理解，因为如果一个问题都能被直接解决了，那验证它的解不是更容易嘛。PvsNP问题是指是否存在属于NP而不属于P的问题，即NP是否等于P。&lt;/p&gt;&lt;p&gt;容易发现，PvsNP取决于NP中最“难”的问题是不是属于P。那么怎么判断问题的难度呢，这就需要介绍“归约”了。对于问题a的每个实例，若可以构造问题b的实例，并且能够证明这两个实例的判定结果一致，就认为问题a可以归约到问题b。当这种归约能够在多项式时间内完成的话，则称为&lt;b&gt;多项式时间归约&lt;/b&gt;（polynomial-time reduction）。其意义在于，如果b属于P，那么存在b的多项式时间算法，而多项式时间归约的存在保证了该算法也可以用于求解a，从而可以说明a也属于P。a可以多项式时间归约到b可以形象地理解为b不会比a简单。多项式时间归约的一个重要性质是具有传递性，a可以归约到b，而b又可以归约到c，就意味着a可以归约到c。在证明某个问题可以多项式时间归约到另一问题时，利用传递性有时可以使得归约的难度大大降低。&lt;/p&gt;&lt;p&gt;接着可以定义一个问题集合&lt;b&gt;NP-hard&lt;/b&gt;，对于NP-hard中的任意一个问题a，所有NP中的问题都可以多项式时间归约到问题a。也就是说NP-hard中的任意一个问题都要比NP中的所有问题都“难”（或者说不简单）。这就很厉害了，NP-hard问题看起来很难啊，比所有NP问题都要难解决。然而，令人震惊的是NP中有些问题是NP-hard的！所有其他NP问题可以多项式时间归约到这些NP问题，他们是“最难”的NP问题。 20世纪60年代末至70年代初，Stephen Cook和Leonid Levin分别独立地意识到这些问题的存在。后来这些问题被称为NP完全（NP-Complete）问题，简记为&lt;b&gt;NPC&lt;/b&gt;，其定义直接就是NP和NP-hard的交集。由于NPC是NP中最难的问题集合，NPC中的任意一个问题有多项式时间算法就等价于P=NP了！&lt;/p&gt;&lt;p&gt;有了初始的NPC问题后，人们可以容易地寻找新的NPC问题。需要做的是先说明新问题是属于NP的（这一步通常比较简单），然后再从NP-hard中找一个问题，将它多项式时间归约到新问题，再加上NP-hard的定义和归约的传递性就能说明NP中的所有问题可以多项式时间归约到新问题了。自NP完全性理论提出以来，数以千计的问题被证明属于NPC。然而至今未能寻找到任意一个NPC问题的多项式时间算法，也未能证明NPC问题不存在多项式时间算法。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1.问题定义&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里我们想考察一下“华容道”游戏的一个推广问题是否属于NP-hard（或者NPC）。&lt;/p&gt;&lt;p&gt;显然，我们的问题是在平面方格上考虑的。我们将平面方格上不可移动的方格称为墙方格，将若干个相邻的可以整体移动的方格称为滑块，滑块只能水平或垂直滑动，每次滑动只能移动一个方块的距离。另外，滑块在移动时需要考虑“碰撞”，即一个滑块的任意部分不能和墙方块或其他滑块重叠。我们将&lt;b&gt;滑块游戏问题&lt;/b&gt;定义为：给定平面上若干墙方格和若干滑块，问是否能通过有限次移动滑块，使得指定的滑块到达指定的位置。&lt;/p&gt;&lt;p&gt;举个例子，下图是就是一个滑块游戏的实例，灰色方块是墙，白色方块是空方块，其他颜色的方块是滑块，现在问题是能否通过滑动滑块使得红色滑块向右移动一格。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3d5c150cce105329440447754df4e822_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;266&quot; data-rawheight=&quot;276&quot;&gt;&lt;p&gt;这是可以做到的，先将中间一列上的黄、蓝、黄三个滑块上移一格，下方绿色滑块就能左移了，然后右侧的黄滑块可以下移，最后中间一横行上的绿、蓝、红三个滑块就能一起右移了。&lt;/p&gt;&lt;p&gt;需要注意的是，这里我们没有对墙和滑块的形状作限制，他们可以是矩形也可以是曲折的甚至是镂空的，所以这个滑块问题是一个很困难的问题，它属于NP-hard的可能性是很高的。为了说明这个问题属于NP-hard，我们需要先找一个NP-hard（或者NPC）问题，然后将它在多项式时间内归约到滑块问题。&lt;/p&gt;&lt;p&gt;3-SAT问题就是一个经典的NPC问题，其形式简单又较为灵活，经常被作为归约问题用来证明其他问题属于NPC或NP-hard。一个3-合取范式是由若干个子句的合取（可以理解为“与”运算）构成的布尔公式，其中每个子句由3个项的析取（可以理解为“或”运算）构成。例如，&lt;equation&gt;(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)&lt;/equation&gt; 是一个含有两个子句的3-合取范式，该公式用到了变量x1~x3。&lt;b&gt;3-SAT&lt;/b&gt;（3-conjunctive normal form satisfiability，3-合取范式可满足问题）问题指的是给定一个3-合取范式，判断是否存在对变量的赋值（True或False）使得该公式可满足（真值为True）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2.归约基本思路&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们现在来尝试说明对于3-SAT的任意实例S，可以构造相应滑块游戏的实例T，使得S可满足等价于T有解。&lt;/p&gt;&lt;p&gt;对于合取范式S我们设置一个滑块来表示，该滑块可以移动到指定位置对应于S可满足，比如像下面这样&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aad59582e6905392a63eea2d2f13bdc9_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;169&quot; data-rawheight=&quot;206&quot;&gt;&lt;p&gt;黑色滑块能够右移一格表示S可满足。但是黑色滑块不能随便右移，它应该被限制在S可满足时才能右移，因此设置一个深紫色滑块予以限制。根据合取范式的结构容易明白深紫色滑块应当在S中的每个子句都满足时才能右移，这说明深紫色滑块代表一个与门，因此我们设置如下结构来模拟与运算&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b3acdcded9deeb4c66e5697a768f821e_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;190&quot; data-rawheight=&quot;243&quot;&gt;&lt;p&gt;上图中，如果我们能限制浅紫色滑块最多只能向右滑动一格的话，深紫色滑块想要右移必须让2个橙色滑块分别移动到浅紫色滑块右移后空出的空间中。当然，上图的与门可以简单地扩展到多个子句的情况上。接着，每个浅紫色滑块自然就应该代表着各个子句啦，它应该是一个或门&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9ce5e462153e91facc78255dc1a958a6_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;168&quot; data-rawheight=&quot;287&quot;&gt;&lt;p&gt;类似地，浅紫色滑块想要右移须让橙滑块移动到任意红色滑块右移后空出的空间中。浅紫色滑块相当于一个或门，对应于S中的3个项的析取构成的子句，而3个红滑块应该分别代表着子句中的3个项。&lt;/p&gt;&lt;p&gt;另外，对于S涉及到的每个变量xi，我们设置一个滑块与之对应，滑块的位置对应于变量的赋值情况。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0fc9a9fa682faa6fe6217536f18b87ff_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;508&quot; data-rawheight=&quot;134&quot;&gt;&lt;p&gt;上图中每个绿色滑块对应于一个变量，我们设定滑块在左侧对应于赋值False，在右侧则对应于Ture。容易看出，无论绿滑块的位置如何，每对黄滑块中只有一个滑块可以上移，这对应于变量的赋值只能是Ture和False中的一个。而每个黄滑块也正好对应于一个项xi或┐xi。&lt;/p&gt;&lt;p&gt;现在表示项xi和┐xi的滑块有了，表示子句中的项的滑块也有了，接下来的问题是如何把它们关联起来。因为简单地延长红滑块和黄滑块的长度来关联的话会出现一个问题，滑块可能会重叠相交。所以，我们&lt;b&gt;需要一个滑块结构来使得“信号”可以同时在垂直和水平两个方向上互不干扰地传递&lt;/b&gt;。其实，能完成这个任务的结构已经在第一个滑块问题例子中出现了，在一个3*3的空间中放上一个2*2的滑块便可以使“信号”在垂直和水平两个方向上传递。不过2*2的滑块只能传递一格的“信号”，若想传递更多的信号我们需要放大一下滑块。有了这样的“枢纽”结构，我们将所有黄滑块和红滑块重叠相交的地方都用这个结构来替代就能完成归约了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3.归约实例&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们用一个例子来说明具体的归约构造。对于3-合取范式 &lt;equation&gt;(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)&lt;/equation&gt; ，我们构造对应的滑块问题实例T如下图&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0df59a9cd697bb63a490abb43d33c99f_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;553&quot;&gt;&lt;p&gt;其中，灰色方格为墙方格，白色方格为空方格，其他颜色的方格是滑块，现在问题是黑色滑块能否向右移动一格。需要说明的是：每个子句中的项对应于一个横向的红滑块，与其关联的是对应项的黄滑块（例如第一个子句中的第二个项是x2，因此第二行红色滑块与第三列黄滑块关联，其中由于与第二列黄滑块交叉，因而加入了一个“枢纽”结构）；由于S由两个子句构成，每个子句都可能包含某个项xi或┐xi，因此我们在每个绿色变量滑块的两边预留了2格的空间；这造成垂直方向上需要传递的“信号”数量可能达到2，所以我们将蓝色的“枢纽”滑块放大到2*3；右侧中间的1*1橙色滑块用于“信号”的部分传递。&lt;/p&gt;&lt;p&gt;显然，这个归约可以在多项式时间内完成。而为了说明归约成立，我们还需要证明S可满足等价于图中的滑块问题有解，这其实也比较容易。&lt;/p&gt;&lt;p&gt;&lt;b&gt;必要性&lt;/b&gt;（S可满足→T有解）。那么存在对xi的赋值使得S满足，比如x1=False, x2=True, x3=False。我们根据赋值将绿色滑块移动到对应的位置，然后让所有的黄色滑块尽量的上移，腾出空间让红色滑块尽量的右移。由于S满足，根据我们的构造，每个浅紫色子句滑块对应的3个红滑块中至少有一个可以右移，因此每个子句滑块也能右移，从而深紫色滑块和黑色滑块可以右移，因而滑块问题有解。具体形状见下图&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5ccd56a24da2a51eba57509ec30a332e_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;686&quot; data-rawheight=&quot;548&quot;&gt;&lt;p&gt;&lt;b&gt;充分性&lt;/b&gt;（T有解→S可满足）。类似地，滑块问题有解说明黑色和深紫色滑块可以右移，说明每个浅紫色子句滑块可以&lt;b&gt;同时&lt;/b&gt;右移，说明每个子句滑块对应的3个红滑块至少有一个可以右移，说明与红滑块关联的黄色滑块可以上移，上移的黄滑块决定了绿色变量滑块的位置，这就给出了一组使得S满足的变量赋值。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4.更多的限制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;之前我们讨论的滑块问题没什么限制，现在我们来对滑块的形状做一些限制，看看它是否仍然属于NP-hard。我们将滑块的形状限制为和“华容道”游戏中一样，只允许有1*1、1*2和2*2的滑块。我们试图在上一节归约方法的基础上做一些改动，使得滑块的形状只有上述3种而归约依然有效。&lt;/p&gt;&lt;p&gt;我们先来处理比较简单的结构，将之前归约中的绿色变量滑块替换成1*2的形状，这并不会产生滑块功能的改变。其次红色和黄色这两类“长”滑块可以替换成若干个1*1的滑块，而在末端使用1*2的滑块来限制其移动距离。而蓝色“枢纽”滑块不太好处理，在新的限制下，我们只能使用2*2形状的滑块作为枢纽滑块，这将无法处理多个子句包含同一个项的情况。因此，我们尝试着增加每个项在滑块游戏实例中的“列数”来解决这一问题。&lt;/p&gt;&lt;p&gt;我们用下面这个只使用1*2滑块的结构来扩展“列数”&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1d4f3fde5416d36e93eafb498eace0d8_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;377&quot; data-rawheight=&quot;141&quot;&gt;&lt;p&gt;本来绿色变量滑块只能提供一个“信号”，而通过上面的&lt;b&gt;“复制”结构&lt;/b&gt;，使得“信号”数量可以增加到两个。当然重复使用这个结构可以使项的“列数”扩展到任意数量。另外凑巧的是，这个&lt;b&gt;结构逆向使用的话相当于一个与门&lt;/b&gt;！如果从右向左看，只有两个黄色滑块同时下移后，绿色滑块才能右移，这不就是一个与运算嘛。好了，之前归约中的与门也可以用限制型滑块替代了，那么只剩下或门了。幸运的是，1*1滑块天然就是或门。&lt;/p&gt;&lt;p&gt;我们将这些方法整合起来就可以将3-SAT多项式时间归约到有限制的滑块问题。 还是先前的那个例子，公式&lt;equation&gt;(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)&lt;/equation&gt; 对应的有限制的滑块问题T&#39;如下图&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcb22d537168e27b2421e0f801a58a2c_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;590&quot; data-rawheight=&quot;370&quot;&gt;&lt;p&gt;注意，这里所有的&lt;b&gt;橙色滑块全是1*1的滑块&lt;/b&gt;。公式可满足等价于有限制的滑块问题有解的证明与之前是完全类似的，不再重复了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5.总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们初步分析了“华容道”游戏的一个推广的滑块游戏问题的计算复杂性。构造了一个从3-SAT问题到滑块游戏问题的多项式时间归约，说明了滑块游戏问题属于NP-hard。对于限制滑块形状只能为1*1、1*2和2*2的滑块游戏问题，我们对归约作了一些改动使得归约依然成立。然而，对于墙方块有所限制（比如墙必须是矩形框不能镂空等）的问题，没想到构造归约的方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS. 1. 一开始我想直接从SAT即布尔公式可满足问题进行归约的，但是发现非门不好构造，后来就尝试了3-SAT，果然3-SAT不愧为“第一起点归约问题”；2. 我觉得那个“枢纽”结构是规约的关键，其他结构比较方便的，这个结构还有点像机械里面的星型发动机的构造；3. 其实我总觉得这种经典问题的计算复杂性分析应该有人做过了，但是搜了一下没找到，那个寻找N-puzzle问题最优解是NP-hard的，但是感觉N-puzzle和这里的滑块问题不太一样。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2017.10.7&lt;/p&gt;</description>
<author>终军弱冠</author>
<guid isPermaLink="false">2017-10-07-29835678</guid>
<pubDate>Sat, 07 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>搭建 Emacs 的 Haskell/Idris 环境教程</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-10-05-29881268.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;搭建 Emacs 的 Haskell/Idris 环境教程&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29881268&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-01d44acb509148aa16658d3590521dd1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;原文发表在我的博客： &lt;a href=&quot;http://ice1000.org/2017/10/03/EmacsIdrisHaskellEnv/&quot;&gt;搭建 Emacs 的 Haskell/Idris 环境教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最近看见 Haskell 群的萌新费尽心思也没成功搭建环境，而且很多都是用浏览器编程，很不清真。为了拯救苍生，顺便为考 SAT 攒人品，我决定写一篇搭建环境教程，来扩大 Emacs 势力。&lt;/p&gt;&lt;p&gt;由于 Idris 用户需要进行的操作基本上是 Haskell 用户的超集，因此未说明的地方就是都要进行的，针对 Idris 用户的额外步骤会说明。&lt;/p&gt;&lt;p&gt;编译 Idris 是一种浪漫，我的笔记本 5 分钟就编译好了，湛忠胜说编译了一下午。本文将讲述编译而不是下载二进制 Idris 的方法。&lt;/p&gt;&lt;p&gt;本文针对的操作系统是 Linux ，只要能用 apt 就可以了。&lt;/p&gt;&lt;h2&gt;本文使用的工具及版本&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Emacs 25&lt;/li&gt;&lt;li&gt;GHC 8.2.2&lt;/li&gt;&lt;li&gt;Cabal 1.24&lt;/li&gt;&lt;li&gt;Idris 1.1.1&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;本文使用的镜像源&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;&gt;清华大学 tuna 镜像源&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;tuna 在本文发布的时候暂时挂掉了，因此在国庆期间搭建环境的同学们可以把下文中的 tuna 源智能替换为 ustc 源。 但是你就会遇到很多其它问题，所以我还是推荐等 tuna 活过来后用 tuna 。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://mirrors.ustc.edu.cn/&quot;&gt;ustc 源&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;apt 准备&lt;/h2&gt;&lt;p&gt;先加源，然后安装，下面的指令直接复制进终端执行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ sudo add-apt-repository ppa:hvr/ghc
$ sudo add-apt-repository ppa:ubuntu-elisp/ppa
$ sudo apt-get update
$ sudo apt-get install emacs25
$ sudo apt-get install ghc-8.2.2
$ sudo apt-get install cabal-install-1.24&lt;/code&gt;&lt;h2&gt;配置&lt;/h2&gt;&lt;p&gt;打开你的 ~/.bashrc ，加入下面的配置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;alias ec=&quot;emacsclient25 -nw&quot;
alias en=&quot;emacs25 -nw&quot;
alias ecw=&quot;emacsclient25&quot;
export PATH=~/.cabal/bin:/opt/ghc/bin:/opt/cabal/bin:$PATH &lt;/code&gt;&lt;p&gt;以上代码节选自&lt;a href=&quot;https://github.com/ice1000/xjb-config/blob/master/.bashrc&quot;&gt;我的 bashrc&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;然后执行以下命令，以重新加载这些配置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ source ~/.bashrc&lt;/code&gt;&lt;h2&gt;配置 Cabal&lt;/h2&gt;&lt;p&gt;根据上面给出的 tuna 源的指示进行操作。 这对于 Haskell 来说不是必须的，但却是非常非常非常建议的。 Idris 用户请确保完成这一步。&lt;/p&gt;&lt;h2&gt;编译 Idris&lt;/h2&gt;&lt;p&gt;直接输指令就行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ cabal-1.24 update
$ cabal-1.24 install idris&lt;/code&gt;&lt;h2&gt;搞懂啥是 emacsclient&lt;/h2&gt;&lt;p&gt;其实是因为我使用了 linum-mode 这个插件，导致每次 Emacs 打开都特别慢 ，正好应了古人那句 EMACS == Emacs Makes A Computer Slower 。 因此我将会采用 Emacs Daemon 来加速 Emacs 启动。 这个东西的原理就是先开个 Emacs 进程，在后台运行，把插件啥的都加载好，蓝后每次使用 Emacs 的时候启动一个客户端，连上这个后台进程就是了。 于是就可以超级快了。&lt;/p&gt;&lt;p&gt;首先，在开始启动第一个 Emacs 前，先启动守护进程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ emacs25 --daemon&lt;/code&gt;&lt;p&gt;蓝后在命令行使用 Emacs 打开一个文件，请输入&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ ec [你要打开的文件路径]&lt;/code&gt;&lt;p&gt;若要在 GUI 下使用 Emacs ，请使用&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ ecw [你要打开的文件路径]&lt;/code&gt;&lt;p&gt;推荐使用命令行。&lt;/p&gt;&lt;p&gt;这时如果你更新了你的配置，需要重启 Emacs ，那么你需要杀了 Emacs 并让他复活：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ pkill emacs
$ emacs25 --daemon&lt;/code&gt;&lt;p&gt;这时候你的 Emacs 还是裸的，现在我们来配置它。&lt;/p&gt;&lt;p&gt;哦，差点忘了，为了防止一些悲剧发生，请在杀死 Emacs 前终止所有正在运行的 emacsclient 。&lt;/p&gt;&lt;p&gt;为了防止另一些悲剧的发生，请记下退出 Emacs 的快捷键： Ctrl+X Ctrl+C 。按法：按住 Ctrl 不放，然后分别按 X 和 C 。&lt;/p&gt;&lt;p&gt;你打开你的 Emacs 之后应该看到它是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;File Edit Options Buffers Tools Help
Welcome to GNU Emacs, one component of the GNU/Linux operating system.

Get help           C-h  (Hold down CTRL and press h)
Emacs manual       C-h r        Browse manuals     C-h i
Emacs tutorial     C-h t        Undo changes       C-x u
Buy manuals        C-h RET      Exit Emacs         C-x C-c
Activate menubar   M-`
(‘C-’ means use the CTRL key.  ‘M-’ means use the Meta (or Alt) key.
If you have no Meta key, you may instead type ESC followed by the character.)
Useful tasks:
Visit New File                  Open Home Directory
Customize Startup               Open *scratch* buffer

GNU Emacs 25.3.50.2 (x86_64-pc-linux-gnu, GTK+ Version 3.18.9)
 of 2017-09-16
Copyright (C) 2017 Free Software Foundation, Inc.

GNU Emacs comes with ABSOLUTELY NO WARRANTY; type C-h C-w for full details.
Emacs is Free Software--Free as in Freedom--so you can redistribute copies
of Emacs and modify it; type C-h C-c to see the conditions.
Type C-h C-o for information on getting the latest version.
-UUU:%%--F1  *GNU Emacs*    Top of 1.0k (1,0)      (Fundamental) ---------------
For information about GNU Emacs and the GNU system, type C-h C-a.
&lt;/code&gt;&lt;h2&gt;配置 Emacs&lt;/h2&gt;&lt;p&gt;把下面的东西原封不动地抄进 ~/.emacs 里面。&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(require &#39;package)
(setq package-archives
			&#39;((&quot;gnu&quot;   . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;)
				(&quot;melpa&quot; . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;)))

(package-initialize)
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won&#39;t work right.
 &#39;(ac-auto-show-menu 0.1)
 &#39;(ac-modes
	 (quote
		(emacs-lisp-mode lisp-mode lisp-interaction-mode slime-repl-mode nim-mode c-mode cc-mode c++-mode objc-mode
                     swift-mode go-mode java-mode malabar-mode clojure-mode clojurescript-mode scala-mode
                     scheme-mode ocaml-mode tuareg-mode coq-mode haskell-mode agda-mode agda2-mode perl-mode
                     cperl-mode python-mode ruby-mode lua-mode tcl-mode ecmascript-mode javascript-mode
                     js-mode js-jsx-mode js2-mode js2-jsx-mode coffee-mode php-mode css-mode scss-mode
                     less-css-mode elixir-mode makefile-mode sh-mode fortran-mode f90-mode ada-mode xml-mode
                     sgml-mode web-mode ts-mode sclang-mode verilog-mode qml-mode apples-mode
                     haskell-mode fundamental-mode
                     idris-mode ; 这一行仅 Idris 用户添加
  )))
 &#39;(blink-cursor-mode t)
 &#39;(column-number-mode t)
 &#39;(custom-enabled-themes nil)
 &#39;(flyspell-abbrev-p t)
 &#39;(flyspell-after-incorrect-word-string nil)
 &#39;(font-use-system-font t)
 &#39;(global-auto-complete-mode t)
 &#39;(global-linum-mode t)
 &#39;(idris-interpreter-path &quot;~/.cabal/bin/idris&quot;) ; 这一行仅 Idris 用户添加
 &#39;(show-paren-mode t)
 &#39;(size-indication-mode t))&lt;/code&gt;&lt;p&gt;上面的配置有两行是只有 Idris 用户需要添加的，请注意阅读注释。&lt;/p&gt;&lt;p&gt;配置节选自&lt;a href=&quot;https://github.com/ice1000/xjb-config/blob/master/.emacs&quot;&gt;我的 .emacs&lt;/a&gt; ，原本还有一些其他内容，与 Haskell Idris 无关我就删了。&lt;/p&gt;&lt;p&gt;这时候重启 Emacs ，你会发现你的配置可能加载不起，因为你没装对应的插件。 我们首先在 Emacs 里按下 Alt+X ，然后这时你的光标出现在最下面。&lt;br&gt;输入 package-list-package ，然后它应该是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-UUU:%%--F1  *GNU Emacs*    Top of 1.0k (1,0)      (Fundamental) ---------------
M-x package-list-packages&lt;/code&gt;&lt;p&gt;等一会(这时开始下载 tuna 上的 elpa/gnu 源的内容)，然后你会发现出现了插件列表。&lt;/p&gt;&lt;p&gt;大概是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt; 1  ace-window         0.9.0         available  Quickly switch windows.
  2  ack                1.5           available  interface to ack-like tools
  3  ada-mode           5.3.1         available  major-mode for editing Ada sou$
  4  ada-ref-man        2012.3        available  Ada Reference Manual 2012
  5  adaptive-wrap      0.5.1         available  Smart line-wrapping with wrap-$
  6  adjust-parens      3.0           available  Indent and dedent Lisp code, a$
  7  aggressive-indent  1.8.3         available  Minor mode to aggressively kee$
  8  ahungry-theme      1.5.0         available  Ahungry color theme for Emacs.$
  9  all                1.0           available  Edit all lines matching a give$
 10  ampc               0.2           available  Asynchronous Music Player Cont$
 11  arbitools          0.71          available  Package for chess tournaments $
 12  ascii-art-to-un... 1.11          available  a small artist adjunct
 13  async              1.9.2         available  Asynchronous processing in Ema$
 14  auctex             11.91.0       available  Integrated environment for *Te$
 15  aumix-mode         7             available  run the aumix program in a buf$
 16  auto-correct       1.1           available  Remembers and automatically fi$
 17  auto-overlays      0.10.9        available  Automatic regexp-delimited ove$
 18  beacon             1.3.2         available  Highlight the cursor whenever $
 19  bug-hunter         1.3.1         available  Hunt down errors by bisecting $
 20  caps-lock          1.0           available  Caps-lock as a minor mode
-UUU:%%--F1  *Packages*     Top of 25k  (1,0)      (Package Menu) --------------&lt;/code&gt;&lt;p&gt;使用快捷键 Ctrl+S 进入搜索，这时你的光标在最下面。 输入 auto-complete ，找到叫这个名字的插件。搜索结果之间用 Ctrl+S 切换。&lt;br&gt;蓝后对它按下回车，看到半个屏幕变成了它的安装说明。&lt;br&gt;我的是安装好了的，看起来和你们的会不大一样，不过基本上是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-UUU:%%--F1  *Packages*     65% of 25k  (199,9)    (Package Menu) --------------
 1auto-complete is a dependency package.
 2
 3     Status: Installed in ‘auto-complete-20170124.1845/’ (unsigned).
 4    Version: 20170124.1845
 5    Summary: Auto Completion for GNU Emacs
 6   Requires: popup-0.5.0, cl-lib-0.5
 7Required by: ac-c-headers-20151021.134
 8
 9This extension provides a way to complete with popup menu like:
10
-UU-:%%--F1  *Help*         Top of 618  (1,0)      (Help) ----------------------
Type C-x 1 to delete the help window, C-M-v to scroll help.&lt;/code&gt;&lt;p&gt;用 Ctrl+X O 切到这半个屏幕，然后把光标移动到 [Install] 上（上面就没有，因为我已经装好了），回车安装。&lt;/p&gt;&lt;p&gt;按理说安装是很快的，然后用 Ctrl+0 关掉这半个窗口。 你会发现原本的插件列表界面变成了一些编译信息。用 Ctrl+X K (输完这快捷键它会让你确认一下，这时回车就好)关掉它，回到原本的插件列表。&lt;/p&gt;&lt;p&gt;按照同样的步骤搜索并安装 haskell-mode 。 Idris 用户请安装 idris-mode 。&lt;/p&gt;&lt;p&gt;然后就什么都没有了！再用 Emacs 打开一个 .hs 结尾的文件，就可以看到漂亮的高亮了！&lt;/p&gt;&lt;h2&gt;快乐生活每一天&lt;/h2&gt;&lt;p&gt;你可以使用 Tab 键来调整缩进(而不是输入 Tab)， Haskell 插件会自动告诉你可以用哪些缩进，不会让你吃缩进的亏。&lt;/p&gt;&lt;p&gt;这个插件很牛逼。比如，你会发现，只有开启了 TypeFamilies 插件后，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;type family Xxx &lt;/code&gt;&lt;p&gt;才会高亮出来。&lt;/p&gt;&lt;h2&gt;对于 Idris&lt;/h2&gt;&lt;p&gt;一样的，只是可以用 Ctrl+C Ctrl+L 自动进行 type check ，而且报错时还会把报错那一行高亮出来。&lt;/p&gt;&lt;p&gt;填 hole 请用 Ctrl+C Ctrl+A 。&lt;/p&gt;&lt;h2&gt;健康生活一辈子&lt;/h2&gt;&lt;p&gt;建议开启一个终端里两个 Tab ，一个开 Emacs ，一个开 ghci 。 Idris 同理。&lt;/p&gt;</description>
<author>大笨蛋千里冰封</author>
<guid isPermaLink="false">2017-10-05-29881268</guid>
<pubDate>Thu, 05 Oct 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
