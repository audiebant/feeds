<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 08 Sep 2017 11:59:38 +0800</lastBuildDate>
<item>
<title>如何编译函数闭包</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-09-04-28787934.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;如何编译函数闭包&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28787934&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;b&gt;闭包&lt;/b&gt;（英语：Closure），又称&lt;b&gt;词法闭包&lt;/b&gt;（Lexical Closure）或&lt;b&gt;函数闭包&lt;/b&gt;（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。&lt;/blockquote&gt;&lt;p&gt;想要实现一个同时支持词法作用域与 first-class function 的编程语言，一个重要的转换就是所谓的 lambda-lifting：把嵌套函数定义（包括匿名函数）转换为独立的全局函数定义；把自由变量的引用转换为参数传递。&lt;/p&gt;&lt;p&gt;P.S.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;代码有省略&lt;/li&gt;&lt;li&gt;出于简化的目的，这里只考虑了最简单的情况，并且没有做任何有效性的检查，假设了表达式中出现的变量全都是定义过的。&lt;/li&gt;&lt;li&gt;同样是为了简化，这里不考虑类型。涉及到类型的情况下，需要在函数定义处保存自由变量的类型信息；这样视需求可能又要在转换过程中维护一个变量环境表来查找变量的类型。这里不累述，具体可以参考后附的一个简单的 OCaml 子集实现的源码。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;函数定义&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里首先定义一个简单的语言表示&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} exp\ ::=\ &amp;amp;Lam(id,exp)\\ &amp;amp;App(exp,exp)\\ &amp;amp;Let(id,exp,exp)\\ &amp;amp;Var(id) \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个语言类似于 untyped lambda calculus，有 lambda、apply 语句，只是多了一个 let 语句用于绑定一个变量。一般语言中的一些表达式形式（如 binary operator）一般则可以看作是 apply 的特殊形式。&lt;/p&gt;&lt;p&gt;用 Rust 代码写出来大概是这样&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;enum Exp {
    /// Lambda 抽象，参数名 -&amp;gt; 函数体
    Abs(Id, Box&amp;lt;Exp&amp;gt;),
    /// Let 定义，let 变量名 = 变量值 in 表达式
    Let(Id, Box&amp;lt;Exp&amp;gt;, Box&amp;lt;Exp&amp;gt;),
    /// 函数应用，变量名(参数)
    App(Box&amp;lt;Exp&amp;gt;, Box&amp;lt;Exp&amp;gt;),
    Var(Id),
}&lt;/code&gt;&lt;p&gt;我们要做的事情是提取出一个匿名函数定义（lambda）中的自由变量，把匿名函数定义转换为全局函数定义，并将函数定义入口和自由变量列表打包成一个实体（即所谓闭包），替换原来的 lambda 节点。&lt;/p&gt;&lt;p&gt;这样，转换之后的 AST 中没有了 lambda 节点，取而代之的是类似 let 节点的闭包 closure 定义节点。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} term\ ::= \ &amp;amp;Cls(id,cls,term)\\ &amp;amp;App(term,term)\\ &amp;amp;Let(id,term,term)\\ &amp;amp;Var(id) \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;enum Term {
    Cls(Id, Box&amp;lt;Cls&amp;gt;, Box&amp;lt;Term&amp;gt;),
    App(Box&amp;lt;Term&amp;gt;, Box&amp;lt;Term&amp;gt;),
    Let(Id, Box&amp;lt;Term&amp;gt;, Box&amp;lt;Term&amp;gt;),
    Var(Id),
}&lt;/code&gt;&lt;p&gt;闭包实体 Cls 中需要保存全局函数定义的入口和当前环境中自由变量的列表。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;cls\ ::=\ (label,(fv_1,fv_2,...,fv_n))&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct Cls {
    label: Id,
    fvs: Vec&amp;lt;Id&amp;gt;,
}&lt;/code&gt;&lt;p&gt;由于需要保持自由变量的信息，全局函数定义需要保存一个自由变量的列表。&lt;/p&gt;&lt;p&gt;这样我们有了全局函数定义的表示——入口 label，参数名，函数体，自由变量列表&lt;/p&gt;&lt;p&gt;&lt;equation&gt;fundef\ ::=\ fun(label,id,exp,(fv_1,fv_2,...,fv_n))&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct Fundef {
    pub label: Id,
    pub param: Id,
    pub body: Term,
    pub fvs: Vec&amp;lt;Id&amp;gt;,
}&lt;/code&gt;&lt;h2&gt;&lt;b&gt;自由变量的提取&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;自由变量的提取规则其实就是把变量加入符号表（环境）的逆过程。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;变量表达式（Var）的自由变量就是变量自己；&lt;/li&gt;&lt;li&gt;函数应用（Apply）的自由变量是 callee 的自由变量和参数的自由变量取并集；&lt;/li&gt;&lt;li&gt;Let 节点和 Cls 节点定义的变量，从其后继表达式的自由变量中剔除，然后与初始化值表达式的自由变量合并。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;即&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} fv(Var(v))&amp;amp;=\{v\}\\ fv(App(callee,arg))&amp;amp;=fv(callee) \ \cup \ fv(arg)\\ fv(Let(v,val,exp))&amp;amp;=(fv(exp)\ -\ \{v\}) \ \cup\ fv(val) \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;最后，作为一个整体的函数定义，其参数要从自由变量中剔除。这个可以留到之后的转换过程中实现。&lt;/p&gt;&lt;p&gt;在 rust 中同样可以直截了当的实现。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn fv(&amp;amp;mut self, source: &amp;amp;Term) -&amp;gt; HashSet&amp;lt;Id&amp;gt; {
    use self::Term::*;
    match source {
        &amp;amp;App(box ref callee, box ref body) =&amp;gt; {
            let mut ret = fv(body);
            ret.extend(fv(callee));
            ret
        }
        &amp;amp;Let(ref var, box ref val, box ref body) =&amp;gt; {
            let mut ret = fv(body);
            ret.remove(var);
            ret.extend(fv(val));
            ret
        }
        &amp;amp;Cls(ref var, box ref cls, box ref body) =&amp;gt; {
            let mut ret = cls.fv();
            ret.extend(fv(body));
            ret.remove(var);
        }
        &amp;amp;Var(v) =&amp;gt; HashSet::new(v)
    }
}
impl Cls {
    pub fn fv(&amp;amp;self) -&amp;gt; HashSet&amp;lt;Id&amp;gt; {
        self.fvs.clone()
    }
}&lt;/code&gt;&lt;h2&gt;&lt;b&gt;函数闭包转化&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;显然，为了实现 lambda 到全局定义的转换，我们需要保持一个全局定义表。为了之后方便的生成函数名和临时变量名之类可能还需要一个生成器，这里省略。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct Conversion {
    global: HashMap&amp;lt;Id, Fundef&amp;gt;,
}&lt;/code&gt;&lt;p&gt;综上所述，很容易写出转换过程。我们定义的 cls 节点有着类似与 let 的语义；当 lambda 单独出现时，这里直接将其转换成一个单独的定义了一个临时变量的 cls 子表达式（类似于嵌套 let）。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl Conversion {
    fn define(&amp;amp;mut self, fun: Fundef) {
        self.global.insert(fun.label.clone(), fun);
    }
    fn cvrt_cls(&amp;amp;mut self, param: Id, body: Exp) -&amp;gt; (Id, Vec&amp;lt;Id&amp;gt;) {
        let cls_name = self.gen_cls_name();
        let body = self.go(_body);
        let fvs = {
            let _fvs = self.fv(&amp;amp;body);
            _fvs.remove(param);
            _fvs.into_iter().collect()
        };
        self.define(Fundef {
            label: cls_name.clone(),
            param,
            body,
            fvs.clone()
        });
        (cls_name, fvs)
    }
    pub fn go(&amp;amp;mut self, exp: Exp) -&amp;gt; Term {
        use self::Exp::*;
        match exp {
            Abs(param, box _body) =&amp;gt; {
                let (cls_name, fvs) = self.cvrt_cls(param, _body);
                let tmp_var = self.gen_tmp_name();
                Term::Cls(tmp_var, Cls {
                    label: cls_name,
                    fvs
                }, Term::Var(tmp_var))
            }
            Let(var, box _val, box _body) =&amp;gt; {
                let body = self.go(_body);
                if let Abs(param, box _body) = _val {
                    let (cls_name, fvs) = self.cvrt_cls(param, _body);
                    Term::Cls(var, Cls {
                        label: cls_name,
                        fvs
                    }, body)
                } else {
                    let val = self.go(_val);
                    Term::Let(var, box val, box body)
                }
            }
            App(box _callee, box _arg) =&amp;gt; {
                let callee = self.go(_callee);
                let arg = self.go(_arg);
                Term::App(callee, arg)
            }
            Var(v) =&amp;gt; Term::Var(v)
        }
    }
}&lt;/code&gt;&lt;p&gt;这里对于 let 绑定 lambda 的处理是不把绑定的变量名剔除出自由变量。由于这里的 let 语义默认是不允许递归绑定的，而 lambda 很多时候有递归的需求，所以这里使用了灵活的办法：把lambda 自己的名称作为自由变量传进去。这样便可以通过后续代码生成的顺序控制能否递归：如果在完成函数名的绑定前先完成自由变量的绑定，便不允许递归，否则允许递归。&lt;/p&gt;&lt;p&gt;这样便完成了闭包转换的过程。后续便可以使用常规的编译技术生成所有的全局函数定义。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/esumii/min-caml&quot;&gt;min-caml&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://jeapostrophe.github.io/courses/2017/spring/406/notes/book.pdf&quot;&gt;Essentials of Compilation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://matt.might.net/articles/closure-conversion/&quot;&gt;Closure conversion: How to compile lambda&lt;/a&gt;&lt;/p&gt;</description>
<author>nameoverflow</author>
<guid isPermaLink="false">2017-09-04-28787934</guid>
<pubDate>Mon, 04 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>（如何（用Python）写一个（Lisp）解释器（上））</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-09-01-28989326.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;（如何（用Python）写一个（Lisp）解释器（上））&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28989326&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt; 译自&lt;a href=&quot;http://norvig.com/lispy.html&quot;&gt;Peter Norvig的博客&lt;/a&gt;，有少量魔改&lt;/p&gt;&lt;p&gt;这篇文章有两个目的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通用地介绍如何实现计算机语言的解释器。&lt;/li&gt;&lt;li&gt;介绍如何利用Python实现Lisp方言Scheme的一个子集。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;Scheme程序的语法和语义&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;一门语言的语法（syntax）指的是字母排列成正确表达式或声明的顺序；语义（semantics）则是这些表达式或声明的意义。例如在数学和许多编程语言之中，一加二的语法是“1 + 2”， 语义则是将加法运算符应用于数字1和2之上，得到结果3。我们将计算表达式的值称之为求值（evaluating）；“1 + 2”求值得到结果3，我们将之记为“1 + 2” =&amp;gt; 3。&lt;/p&gt;&lt;p&gt;Scheme的语法与你熟悉的大部分语言不同。例如：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;// Java
if (x.val() &amp;gt; 0) { 
  fn(A[i] + 1, 
     return new String[] {&quot;one&quot;, &quot;two&quot;}); 
}&lt;/code&gt;&lt;p&gt;-&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;;; Scheme
(if (&amp;gt; (val x) 0) 
    (fn (+ (aref A i) 1) 
        (quote (one two)))&lt;/code&gt;&lt;p&gt;Java有大量不同的语法约规（关键字、中置操作符、三种括号、操作符优先级、点、引号、逗号、分号等等），而Scheme的语法则简单很多：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Scheme程序中只有表达式。表达式和声明之间并无区别。&lt;/li&gt;&lt;li&gt;数字（例如 1）和符号（例如 A）被称之为原子表达式（atomic expression）；他们无法被拆分成更小的表达式。这部分和Java类似，但在Scheme中，诸如 + 和 &amp;gt; 这种操作符也被认为是符号（symbol），处理方式与A或是fn这种符号别无二致。&lt;/li&gt;&lt;li&gt;除此之外的一切都是列表表达式（list expression）：以“(”为首，“)”为尾，中间包括着零个或更多表达式。列表的第一个元素决定了它的含义：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;若第一个元素是关键字，例如(if ...)，那这个列表是一个特殊形式（special form）；特殊形式的意义取决于关键字。&lt;/li&gt;&lt;li&gt;若第一个元素并非关键字，例如(fn ...)，那这个列表则是函数调用。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Scheme之美在于她的简洁性：整个语言由5个关键字和8个语法形式构成。相较之下，Python有33个关键字和110个语法形式，Java有50个关键字和133个语法形式。Scheme中的大量括号初看起来可能显得古怪陌生，但括号为Scheme提供了简洁性和一致性。（有些人开玩笑说Lisp的意思是“大量又蠢又烦的括号（Lots of Irritating Silly Parentheses）”；我觉得应该是“Lisp拥有纯净的语法（Lisp Is Syntactically Pure）。”）&lt;/p&gt;&lt;p&gt;在这篇文章中我们会涉及到Scheme中所有的关键点（除了一些琐碎的细节）。但罗马城不是一天建成的，我们需要分两步。首先，我们会定义一个相对简单的语言，再在它的基础上定义一个几近完整的Scheme语言。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1号语言：Lispy计算器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Lispy计算器是Scheme语言的一个子集，它只包含五种语法形式（两种原子，两个特殊形式，以及过程调用）。只要你习惯了Lisp前置运算符的古怪语法，你就能利用Lispy计算器干一般计算器的活。你还能干一般计算器干不了的活：使用&quot;if&quot;表达式进行条件判断以及定义新的变量。我们来举个例子，以下是一个计算圆面积的程序，圆的半径为10，计算公式为πr^2：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(begin
    (define r 10)
    (* pi (* r r)))&lt;/code&gt;&lt;p&gt;下面这张表列举了所有可用的语法形式：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dd978e5bb96fff4a144b3a27fef70c21_r.png&quot; data-rawwidth=&quot;725&quot; data-rawheight=&quot;567&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在表中“语法”一列中，&lt;i&gt;var&lt;/i&gt;必须为一个符号，&lt;i&gt;number&lt;/i&gt;必须为一个整数或浮点数，其他斜体字可以是任何表达式。其中的“&lt;i&gt;arg...&lt;/i&gt;”表示零个或更多个&quot;&lt;i&gt;arg&lt;/i&gt;&quot;。在“真正”的Scheme中，begin是一个语法关键字，但在这个Scheme实现中，它只是一个普通的函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;语言解释器做些什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;一个计算机语言的解释器分为两部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;分析(parse)&lt;/b&gt;：解释器的分析部分将程序以一串字符的形式读入，依照语法规则(&lt;i&gt;syntactic rules&lt;/i&gt;)验证其正确性并将程序转换成一种内部表达形式。在一个简单的解释器中，内部表达形式是一个树形结构，人们一般将其称之为&lt;i&gt;抽象语法树 (abstract syntax tree)&lt;/i&gt;。抽象语法树的结构和程序中层层嵌套的声明及表达式非常相近，几乎可以说是完美对应。在编译器之中往往存在多个内部表达形式，一开始先转换成抽象语法树，随后再转换成可以直接被计算器执行的指令序列。Lispy的语法分析器由parse函数实现。&lt;/li&gt;&lt;li&gt;&lt;b&gt;执行(execution)&lt;/b&gt;：内部表达形式被按照语言的语法规则进行处理，以此来进行计算。Lispy的执行函数叫做eval （注意，这会覆盖Python的同名内置函数）。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;以下是对解释器工作流程的一个简单的演示：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;程序 ---&amp;gt; [parse] ---&amp;gt; 抽象语法树 ---&amp;gt; [eval] ---&amp;gt; 结果&lt;/code&gt;&lt;p&gt;下面这个例子则展示了我们希望eval和parse实现的功能：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; program = &quot;(begin (define r 10) (* pi (* r r)))&quot;

&amp;gt;&amp;gt;&amp;gt; parse(program)
[&#39;begin&#39;, [&#39;define&#39;, &#39;r&#39;, 10], [&#39;*&#39;, &#39;pi&#39;, [&#39;*&#39;, &#39;r&#39;, &#39;r&#39;]]]

&amp;gt;&amp;gt;&amp;gt; eval(parse(program))
314.1592653589793&lt;/code&gt;&lt;h2&gt;&lt;b&gt;分析：parse, tokenize 以及 read_from_tokens&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;依照传统，分析被分为两个部分:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;词法分析(lexical analysis)：在这一部分中，输入的字符串被拆分为一系列的token。&lt;/li&gt;&lt;li&gt;语法分析(syntactic analysis)：将token汇编为抽象语法树。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Lispy token们由括号，符号和数字组成。由许多用来进行词法分析的工具（例如Mike Lesk和Eric Schmidt写的lex），但我们只需要用到一个十分简单的工具：Python的str.split函数。tokenize函数接受一个字符串，并在括号周围加上空格；随后调用str.split来得到一个由token组成的列表：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def tokenize(chars):
    &quot;将字符串转换成由token组成的列表。&quot;
    return chars.replace(&#39;(&#39;, &#39; ( &#39;).replace(&#39;)&#39;, &#39; ) &#39;).split()
&amp;gt;&amp;gt;&amp;gt; program = &quot;(begin (define r 10) (* pi (* r r)))&quot;
&amp;gt;&amp;gt;&amp;gt; tokenize(program)
[&#39;(&#39;, &#39;begin&#39;, &#39;(&#39;, &#39;define&#39;, &#39;r&#39;, &#39;10&#39;, &#39;)&#39;, &#39;(&#39;, &#39;*&#39;, &#39;pi&#39;, &#39;(&#39;, &#39;*&#39;, &#39;r&#39;, &#39;r&#39;, &#39;)&#39;, &#39;)&#39;, &#39;)&#39;]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们的parse函数接收一个字符串作为输入，然后调用tokenize函数获得一个由token组成的列表，再调用read_from_tokens来将token列表汇编成抽象语法树。read_from_token函数会查看第一个token，如果是“)”，那就报出一个语法错误。如果是“(”，那我们就开始构建一个由子表达式组成的列表，直到匹配到对应的“)”。所有非括号的token必须是符号或者数字。我们会让Python来识别它们之间的区别：对任何一个非括号token，先尝试将之转为整数，若失败则尝试转为浮点数，若还是失败，则转为符号。下边是parser的代码：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def parse(program):
    &quot;从字符串中读取Scheme表达式&quot;
    return read_from_tokens(tokenize(program))

def read_from_tokens(tokens):
    &quot;从一串token之中读取表达式&quot;
    if len(tokens) == 0:
        raise SyntaxError(&#39;unexpected EOF while reading&#39;)
    token = tokens.pop(0)
    if &#39;(&#39; == token:
        L = []
        while tokens[0] != &#39;)&#39;:
            L.append(read_from_tokens(tokens))
        tokens.pop(0) # pop off &#39;)&#39;
        return L
    elif &#39;)&#39; == token:
        raise SyntaxError(&#39;unexpected )&#39;)
    else:
        return atom(token)

def atom(token):
    &quot;数字转为对应的Python数字，其余的转为符号&quot;
    try: return int(token)
    except ValueError:
        try: return float(token)
        except ValueError:
            return Symbol(token)&lt;/code&gt;&lt;p&gt;parse函数的工作方式如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; program = &quot;(begin (define r 10) (* pi (* r r)))&quot;

&amp;gt;&amp;gt;&amp;gt; parse(program)
[&#39;begin&#39;, [&#39;define&#39;, &#39;r&#39;, 10], [&#39;*&#39;, &#39;pi&#39;, [&#39;*&#39;, &#39;r&#39;, &#39;r&#39;]]]&lt;/code&gt;&lt;p&gt;我们还需要决定一下各种Scheme对象在Python中的表示方法：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;Symbol = str          # Scheme符号由Python str表示
List   = list         # Scheme列表由Python list表示
Number = (int, float) # Scheme数字由Python的整数或浮点数表示&lt;/code&gt;&lt;p&gt;好了！定义eval的准备工作基本都做好了。但我们需要先了解更多的概念。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;环境(Environments)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;eval函数接受两个参数：一个我们想要求值的表达式x，还有一个环境env，x将在这个环境中被求值。&lt;i&gt;环境&lt;/i&gt;指的是变量名和他们的值之间的映射。eval默认会使用全局环境(global environment)进行求值，全局环境包含着一系列的标准函数（比如sqrt, max和 * 这类操作符）。这一环境可以用用户定义的变量拓展，语法为 (&lt;i&gt;define variable value&lt;/i&gt;)。我们可以用Python自带的字典来实现环境，字典中的键对为{变量: 值}的形式。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import math
import operator as op

Env = dict          # 环境是{变量: 值}之间的映射

def standard_env():
    &quot;一个包含着一些Scheme标准过程的环境。&quot;
    env = Env()
    env.update(vars(math)) # sin, cos, sqrt, pi, ...
    env.update({
        &#39;+&#39;:op.add, &#39;-&#39;:op.sub, &#39;*&#39;:op.mul, &#39;/&#39;:op.div, 
        &#39;&amp;gt;&#39;:op.gt, &#39;&amp;lt;&#39;:op.lt, &#39;&amp;gt;=&#39;:op.ge, &#39;&amp;lt;=&#39;:op.le, &#39;=&#39;:op.eq, 
        &#39;abs&#39;:     abs,
        &#39;append&#39;:  op.add,  
        &#39;apply&#39;:   apply,
        &#39;begin&#39;:   lambda *x: x[-1],
        &#39;car&#39;:     lambda x: x[0],
        &#39;cdr&#39;:     lambda x: x[1:], 
        &#39;cons&#39;:    lambda x,y: [x] + y,
        &#39;eq?&#39;:     op.is_, 
        &#39;equal?&#39;:  op.eq, 
        &#39;length&#39;:  len, 
        &#39;list&#39;:    lambda *x: list(x), 
        &#39;list?&#39;:   lambda x: isinstance(x,list), 
        &#39;map&#39;:     map,
        &#39;max&#39;:     max,
        &#39;min&#39;:     min,
        &#39;not&#39;:     op.not_,
        &#39;null?&#39;:   lambda x: x == [], 
        &#39;number?&#39;: lambda x: isinstance(x, Number),   
        &#39;procedure?&#39;: callable,
        &#39;round&#39;:   round,
        &#39;symbol?&#39;: lambda x: isinstance(x, Symbol),
    })
    return env

global_env = standard_env()&lt;/code&gt;&lt;h2&gt;&lt;b&gt;求值：eval&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在，我们已经做好了实现eval函数的准备。来让我们重新看一遍Lispy计算器的语法形式表以加深一下记忆：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dd978e5bb96fff4a144b3a27fef70c21_r.png&quot; data-rawwidth=&quot;725&quot; data-rawheight=&quot;567&quot;&gt;&lt;p&gt;来和eval的代码对比一下，是不是觉得很像？&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def eval(x, env=global_env):
    &quot;对在某个环境下的表达式进行求值&quot;
    if isinstance(x, Symbol):      # 变量引用
        return env[x]
    elif not isinstance(x, List):  # 字面常量
        return x                
    elif x[0] == &#39;if&#39;:             # 条件
        (_, test, conseq, alt) = x
        exp = (conseq if eval(test, env) else alt)
        return eval(exp, env)
    elif x[0] == &#39;define&#39;:         # 定义
        (_, var, exp) = x
        env[var] = eval(exp, env)
    else:                          # 过程调用
        proc = eval(x[0], env)
        args = [eval(arg, env) for arg in x[1:]]
        return proc(*args)&lt;/code&gt;&lt;p&gt;搞定！来试试吧：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; eval(parse(&quot;(define r 10)&quot;))
&amp;gt;&amp;gt;&amp;gt; eval(parse(&quot;(* pi (* r r))&quot;))
314.1592653589793&lt;/code&gt;&lt;h2&gt;&lt;b&gt;交互：来做一个REPL&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;一直打“eval(parse(...))”的话即便是耐心再好的人也会嫌烦。Lisp最伟大的遗产之一就是引入了read-eval-print loop（读取-求值-输出 循环，缩写为REPL，译者注）。运用REPL，程序员们可以即时地读取、求值、输出，而不用麻烦地先编译再运行。我们先定义一个名为repl的函数以实现这个功能，然后再定义一个schemestr函数来输出Scheme对象的字符串表示。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def repl(prompt=&#39;lis.py&amp;gt; &#39;):
    &quot;REPL的懒人实现。&quot;
    while True:
        val = eval(parse(raw_input(prompt)))
        if val is not None: 
            print(schemestr(val))

def schemestr(exp):
    &quot;将一个Python对象转换回可以被Scheme读取的字符串。&quot;
    if isinstance(exp, List):
        return &#39;(&#39; + &#39; &#39;.join(map(schemestr, exp)) + &#39;)&#39; 
    else:
        return str(exp)&lt;/code&gt;&lt;p&gt;老样子，做完以后来试试：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; repl()
lis.py&amp;gt; (define r 10)
lis.py&amp;gt; (* pi (* r r))
314.159265359
lis.py&amp;gt; (if (&amp;gt; (* 11 11) 120) (* 7 6) oops)
42
lis.py&amp;gt; &lt;/code&gt;&lt;p&gt;这一章中，我们实现了一个简单的Lisp计算器，在下半部分中，我们将在此基础上写一个更完整的Scheme解释器。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;（破乎什么时候才能支持Markdown，不能插表格也就算了，图的质量还压得那么差。）&lt;/p&gt;</description>
<author>李愚</author>
<guid isPermaLink="false">2017-09-01-28989326</guid>
<pubDate>Fri, 01 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Continuation 与 Monad</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-08-28-28860343.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Continuation 与 Monad&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28860343&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;结构&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Monad 与 Continuation 都用于表示计算。用两个例子可以看到它们的结构非常相似：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;foo :: Maybe Int
foo =
    Just 5 &amp;gt;&amp;gt;= \x -&amp;gt;
    Just 4 &amp;gt;&amp;gt;= \y -&amp;gt;
    return $ x + y
add :: Int -&amp;gt; Int -&amp;gt; (Int -&amp;gt; Int) -&amp;gt; Int
add x y k = k (x + y)

bar :: Int
bar =
    add 1 2 $ \x -&amp;gt;
    add x 4 $ \y -&amp;gt;
    y&lt;/code&gt;&lt;p&gt;两者都有类似于 bind 的操作：Monad 中，&amp;gt;&amp;gt;= 用于将 context 中的值绑定到另一个函数的参数；而 CPS 里，函数主动将当前计算的结果传递给 continuation。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Monad of continuation&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;看到结构上的相似性之后我们可以尝试定义与 continuation 有关的 monad。出于历史原因，大多数文章都用 Scheme 介绍 continuation，而在 Haskell 这样的静态类型语言中 continuation 需要被赋予类型。显然，continuation 可以简单地表示为函数：a -&amp;gt; Answer 代表接受 a 类型的值的 continuation，而 Answer 则是计算的最终结果的类型。而 Haskell 定义的 Cont monad 形式如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Cont r a = Cont { runCont :: (a -&amp;gt; r) -&amp;gt; r }&lt;/code&gt;&lt;p&gt;Cont r a 代表一个 CPS 计算，其中 a -&amp;gt; r 表示一个 continuation， r 表示最终结果的类型（即 continuation 返回的类型），而 a 表示该计算本身的结果，它会将某个 a 类型的值传递给 continuation。只有当外界给它传递一个 continuation 时它才会将结果进一步传递，某种程度上这也是一种延迟计算（suspended computation），类似于 lazy-evalution 中的 thunk。看两个简单的例子：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;calculateLength :: [a] -&amp;gt; Cont r Int
calculateLength l = return (length l)

double :: Int -&amp;gt; Cont r Int
double n = return (n * 2)&lt;/code&gt;&lt;p&gt;它们对应的 Lisp 代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (calculate-length xs k)
  (k (length xs)))

(define (double n k)
  (k (* n 2)))&lt;/code&gt;&lt;p&gt;可以看到，CPS 式的函数不再是直接返回值，而是返回一个由  Cont monad 表示的计算过程。与 Scheme 代码相比，不用显式地在函数签名中指出额外需要的 continuation 参数，这也是 monad 这种抽象手段的好处之一。而 monad 的其他方便之处，则在于 return 和 bind 操作可以方便地构造、串联这种结构。Cont monad 的相关操作定义如下&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;return :: a -&amp;gt; Cont r a
return a = Cont $ \c -&amp;gt; c a

(&amp;gt;&amp;gt;=) :: Cont r a -&amp;gt; (a -&amp;gt; Cont r b) -&amp;gt; (Cont r b)
m &amp;gt;&amp;gt;= k = Cont $ \c -&amp;gt; runCont m (\a -&amp;gt; runCont (k a) c)&lt;/code&gt;&lt;p&gt;可以看到，return 只是简单地将某个值传入 continuation，而 &amp;gt;&amp;gt;= 里则是通过 continuation-passing 的方式将 m 得到的结果绑定到了 a 然后传入函数 k 作进一步计算。下面的例子展示了如何用 bind 操作串联 Cont monad：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;main = do
  runCont (calculateLength &quot;123&quot; &amp;gt;&amp;gt;= double) print&lt;/code&gt;&lt;p&gt;这个例子中，double 是 calculateLength 函数的 continuation，两者通过 bind 串联成为一个更大的 CPS 计算，最终由 runCont 将其结果输出。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;callCC&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作了 CPS 变换之后，call-with-current-continuation 就很容易实现。假设在 Scheme 中我们已经对所有代码作了 CPS 变换，那么 call/cc 就可以这样实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (call/cc f k)
  (f (lambda (x) (lambda (dc) (k x))) k))&lt;/code&gt;&lt;p&gt;其中，dc 即 escape function 被调用时的 continuation，它会被直接丢弃，转而将值传递给 call/cc 的 continuation 即 k，从而实现 escape。假如 escape function 没有被调用，那么 f 执行结束之后就会继续执行 call/cc 后面的部分，亦即 k。&lt;/p&gt;&lt;p&gt;同样地，在 Haskell 里，我们有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;calCC :: ((a -&amp;gt; Cont r b) -&amp;gt; Cont r a) -&amp;gt; Cont r a
callCC f = Cont $ \h -&amp;gt; runCont (f (\a -&amp;gt; Cont $ \_ -&amp;gt; h a)) h&lt;/code&gt;&lt;p&gt;这里的 _ 即指明了调用 escape function 处的 continuation 会被丢弃。&lt;/p&gt;&lt;p&gt;而有了 callCC 之后我们就可以显式地合成各种控制流，可以参见知乎用户&lt;a href=&quot;https://www.zhihu.com/people/syntacticlosure&quot;&gt;御坂黒子&lt;/a&gt;的专栏文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25749077&quot;&gt;《用callcc合成控制流》&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;P. Wadler, The essence of functional programming&lt;/li&gt;&lt;li&gt;Wikibooks, &lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style&quot;&gt;Haskell/Continuation passing style&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</description>
<author>lsdsjy</author>
<guid isPermaLink="false">2017-08-28-28860343</guid>
<pubDate>Mon, 28 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Erlang并发进阶</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-08-28-28859183.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Erlang并发进阶&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28859183&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Getting Started with Erlang User’s Guide Version 9.0&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;写在前面的话&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;本文来源于官方教程 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//erlang.org/doc/getting_started/conc_prog.html&quot;&gt;Erlang -- Concurrent Programming&lt;/a&gt;。虽然没有逻辑上的关系，但建议在掌握了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28154714&quot;&gt;Erlang入门系列教程&lt;/a&gt;的一些前置知识后继续阅读。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://w&quot;&gt;之前我是逐小结翻译然后发布，写到后面感觉并发这篇文章连贯性较强，分开不便于阅读，所以现在把它合并为一篇文章，刚好赶在开学前完成，也算对自己一个交待。希望能读得开心，如有错误恳请指正。&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;1. 进程&lt;/h2&gt;&lt;p&gt;使用Erlang而不是其他函数式编程语言的主要原因之一就是Erlang的并发处理能力和分布式编程。并发意味着程序可以在同一时刻执行多个线程。举个例子，操作系统允许你在同一时刻运行文字处理程序，电子表格程序，邮件客户端，和打印任务。系统中的每个处理器（CPU）有可能只处理一个线程，但是它以一定频率交换这些线程，给我们造成一种多个程序是在同一时刻执行的假象。在一个Erlang程序中很容易创建&lt;b&gt;并行执行（parallel execution）&lt;/b&gt;的线程，并且运行这些这些线程互相通信。Erlang中，每个执行线程称之为&lt;b&gt;进程（process）&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;（旁白：术语“进程（process）”通常用于各个执行线程不共享数据，术语‘’线程（thread）”用于当它们以某种方式共享数据。Erlang执行线程不共享数据，这就是为什么它们叫做进程的原因）&lt;/p&gt;&lt;p&gt;Erlang内置函数&lt;b&gt;spawn&lt;/b&gt;用于创建一个新进程：&lt;b&gt;spawn(Module, Exported_Function, List of Arguments)。&lt;/b&gt;考虑下面的模块&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut14).

-export([start/0, say_something/2]).

say_something(What, 0) -&amp;gt;
    done;
say_something(What, Times) -&amp;gt;
    io:format(&quot;~p~n&quot;, [What]),
    say_something(What, Times - 1).

start() -&amp;gt;
    spawn(tut14, say_something, [hello, 3]),
    spawn(tut14, say_something, [goodbye, 3]).
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;5&amp;gt; c(tut14).
{ok,tut14}
6&amp;gt; tut14:say_something(hello, 3).
hello
hello
hello
done
&lt;/code&gt;&lt;p&gt;如上所示，函数&lt;b&gt;say_something&lt;/b&gt;输出第一个参数，输出次数由第二个参数指定。函数&lt;b&gt;start&lt;/b&gt;启动两个进程，一个输出“hello”三次，一个输出“goodbye”三次。每个进程都使用&lt;b&gt;say_something&lt;/b&gt;函数。注意用spawn这种方式启动一个进程所用到的函数，必须从该模块导出。（即写在模块开头的&lt;b&gt;-export&lt;/b&gt;里面）&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;9&amp;gt; tut14:start().
hello
goodbye
&amp;lt;0.63.0&amp;gt;
hello
goodbye
hello
goodbye
&lt;/code&gt;&lt;p&gt;注意它没有先输出三次“hello”再输出三次“goodbye”。相反，第一个进程输出“hello”，第二个进程输出“goodbye”，然后第一个进程再输出“hello”，如此继续。但是&lt;b&gt;&amp;lt;0.63.0&amp;gt;&lt;/b&gt;从哪里来？一个函数的返回值是最后一行表达式的返回值。在start中最后一个表达式是&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;spawn(tut14, say_something, [goodbye, 3]).
&lt;/code&gt;&lt;p&gt;spawn返回一个&lt;b&gt;进程标识符（process identifier）&lt;/b&gt; , 或者说&lt;b&gt;pid&lt;/b&gt;, 标明独一无二的进程。所以&amp;lt;0.63.0&amp;gt;是上面spawn函数调用返回的pid。下一个例子展示了怎么使用pid。&lt;/p&gt;&lt;p&gt;同时还要注意在&lt;b&gt;io:format&lt;/b&gt;中用~p代替~w。引用手册的话：“~p和~w以相同的方式输出标准语，但是如果输出表示的项比一行长会合理的折断成多行。它也尝试去检测一个可输出的字符列表并将至以字符串的形式输出。”&lt;/p&gt;&lt;p&gt;（译注：这里举个例子（数据来源于官方），在shell中输入：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;4&amp;gt; F = [{attributes,[[{id,age,1.50000},{mode,explicit},{typename,&quot;INTEGER&quot;}], [{id,cho},{mode,explicit},{typename,&#39;Cho&#39;}]]}, {typename,&#39;Person&#39;},{tag,{&#39;PRIVATE&#39;,3}},{mode,implicit}].
5&amp;gt; io:format(&quot;~p&quot;,[F]).
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,&quot;INTEGER&quot;}],
              [{id,cho},{mode,explicit},{typename,&#39;Cho&#39;}]]},
 {typename,&#39;Person&#39;},
 {tag,{&#39;PRIVATE&#39;,3}},
 {mode,implicit}]ok
6&amp;gt; io:format(&quot;~w&quot;,[F]).
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,[73,78,84,69,71,69,82]}],[{id,cho},{mode,explicit},{typename,&#39;Cho&#39;}]]},{typename,&#39;Person&#39;},{tag,{&#39;PRIVATE&#39;,3}},{mode,implicit}]ok
&lt;/code&gt;&lt;p&gt;）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;2. 消息传递&lt;/h2&gt;&lt;p&gt;在接下来的例子中创建了两个进程，它们互相发送一些消息。&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut15).

-export([start/0, ping/2, pong/0]).

ping(0, Pong_PID) -&amp;gt;
    Pong_PID ! finished,
    io:format(&quot;ping finished~n&quot;, []);

ping(N, Pong_PID) -&amp;gt;
    Pong_PID ! {ping, self()},
    receive
        pong -&amp;gt;
            io:format(&quot;Ping received pong~n&quot;, [])
    end,
    ping(N - 1, Pong_PID).

pong() -&amp;gt; receive
        finished -&amp;gt;
            io:format(&quot;Pong finished~n&quot;, []);
        {ping, Ping_PID} -&amp;gt;
            io:format(&quot;Pong received ping~n&quot;, []),
            Ping_PID ! pong,
            pong()
    end.

start() -&amp;gt;
    Pong_PID = spawn(tut15, pong, []),
    spawn(tut15, ping, [3, Pong_PID]).
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;1&amp;gt; c(tut15).
{ok,tut15}
2&amp;gt; tut15: start().
&amp;lt;0.36.0&amp;gt;
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
ping finished
Pong finished
&lt;/code&gt;&lt;p&gt;函数start创建了一个进程，让我们把它叫做“pong”：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;Pong_PID = spawn(tut15, pong, [])
&lt;/code&gt;&lt;p&gt;这个进程执行tut15:pong()。&lt;b&gt;Pong_PID&lt;/b&gt;是pong进程的进程标识符。接着创建一个名为“ping”的进程：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;spawn(tut15, ping, [3, Pong_PID]),
&lt;/code&gt;&lt;p&gt;这个进程执行：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;tut15:ping(3, Pong_PID)
&lt;/code&gt;&lt;p&gt;&lt;b&gt;&amp;lt;0.36.0&amp;gt;&lt;/b&gt;是start函数的返回值。&lt;/p&gt;&lt;p&gt;“pong”进程现在这样：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;receive
    finished -&amp;gt;
        io:format(&quot;Pong finished~n&quot;, []);
    {ping, Ping_PID} -&amp;gt;
        io:format(&quot;Pong received ping~n&quot;, []),
        Ping_PID ! pong,
        pong()
end.
&lt;/code&gt;&lt;p&gt;&lt;b&gt;receive&lt;/b&gt; 结构用于使进程等待另一个进程的消息。它有下面的格式：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;receive
   pattern1 -&amp;gt;
       actions1;
   pattern2 -&amp;gt;
       actions2;
   ....
   patternN
       actionsN
end.
&lt;/code&gt;&lt;p&gt;注意在&lt;b&gt;end.&lt;/b&gt;前面没有&lt;b&gt;“;”&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Erlang进程之间传递的消息简单的被认为是有效的erlang项（term）。也即是说，它们可以是列表，tuple，整数，原子，pid等等。&lt;/p&gt;&lt;p&gt;每个进程有它自己的消息队列，用于接收消息。当新消息到达时会放入队列的尾部。当一个进程执行一个receive表达式，消息队列第一个接收到的消息（头部）会和receive结构进行模式匹配。如果匹配成功，消息将会移出队列并且执行模式后面指定的&lt;b&gt;action&lt;/b&gt;&lt;/p&gt;&lt;p&gt;然而，如果第一个模式没有匹配，第二个模式将会继续，如果成功就执行它对应的action，如果没有成功，继续匹配第三个模式，如此继续。如果到最后都没有模式匹配成功，第一个消息将会保留在消息队列，然后消息队列的第二个消息（头部下一个）继续进行匹配，如果有任何一个模式匹配成功，相应的action就会执行，然后第二个消息会移出队列（除第二个以外的消息全都保留）。如果第二个消息没有匹配，尝试第三个，如此继续。直到到达消息队列尾部。如果到达队列尾部，进程会阻塞（停止执行）并等待一个新消息到达，然后重复上述过程。&lt;/p&gt;&lt;p&gt;Erlang的实现是很机智的，在每个receive中它会尽可能的最小化每个消息的模式匹配次数。&lt;/p&gt;&lt;p&gt;现在回到ping pong的例子。&lt;/p&gt;&lt;p&gt;&quot;Pong&quot;等待消息。如果接收到原子&lt;b&gt;finished&lt;/b&gt;，“pong”就会输出“Pong finished”，然后什么也不做，终止。如果收到一个&lt;b&gt;{ping，Ping_PID}&lt;/b&gt;格式的消息，它会输出&quot;Pong received ping&quot; 并向“ping”进程发送一个原子pong消息：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;Ping_PID ! pong
&lt;/code&gt;&lt;p&gt;注意“！”运算符是如何发送消息的。“！”的语法是：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;Pid ! Message
&lt;/code&gt;&lt;p&gt;即将消息（任何Erlang项）发送到Pid表示的进程。&lt;/p&gt;&lt;p&gt;在向“ping”进程发送了pong消息后，“pong”函数会调用自身，导致它重新回到receive结构等待另一条消息。&lt;/p&gt;&lt;p&gt;现在让我们看看“ping”进程。回忆一下它是这样开始的：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;tut15:ping(3, Pong_PID)
&lt;/code&gt;&lt;p&gt;请看函数ping/2，因为第一个参数是3（不是0）（第一个clause是 ping(0,Pong_PID)，第二个clause是ping(N,Pong_PID)，所以N成为3），所以ping/2的第二个clause被执行。&lt;/p&gt;&lt;p&gt;第二个clause向pong进程发送一条消息：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;Pong_PID ! {ping, self()},
&lt;/code&gt;&lt;p&gt;&lt;b&gt;self()返回执行self()的进程的pid&lt;/b&gt;，在这个是“ping”进程的pid。（回忆一下“pong”的代码，self()的值最终会到达之前所说的receive结构中的Ping_PID变量。）&lt;/p&gt;&lt;p&gt;现在&quot;Ping&quot;等待一个来自“pong”的答复：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;receive
    pong -&amp;gt;
        io:format(&quot;Ping received pong~n&quot;, [])
end,
&lt;/code&gt;&lt;p&gt;当收到回复时它会输出&quot;Ping received pong&quot;，在这之后ping函数也会调用自己。&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;ping(N - 1, Pong_PID)
&lt;/code&gt;&lt;p&gt;N-1使得第一个参数减一，直到它变成零。 当变成零时，ping/2的第一个clause就会被执行：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;ping(0, Pong_PID) -&amp;gt;
    Pong_PID !  finished,
    io:format(&quot;ping finished~n&quot;, []);
&lt;/code&gt;&lt;p&gt;该函数会向pong进程发送原子finished（正如上面描述的这会使得pong结束进程），接着会输 &quot;ping finished&quot;。 然后&quot;Ping&quot;会因为没有事情做而终止。&lt;/p&gt;&lt;h2&gt;3. 进程名注册&lt;/h2&gt;&lt;p&gt;在之前的例子中，“pong”进程最先被创建，并将它的进程标识符给接下来创建的“ping”进程作为参数。也即是说，“ping”必须通过某种方式知道“pong”进程才能向它发送消息。有时独立启动的进程需要知道彼此的标识符。鉴于此Erlang提供了一种进程机制来给进程命名而不是在一堆函数中混乱传递PID参数，这种机制是通过内置函数&lt;b&gt;register&lt;/b&gt;完成的。&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;register(some_atom, Pid)
&lt;/code&gt;&lt;p&gt;现在让我们使用下面的代码来重写ping pong 例子，给“pong”进程一个名字：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut16).

-export([start/0, ping/1, pong/0]).

ping(0) -&amp;gt;
    pong ! finished,
    io:format(&quot;ping finished~n&quot;, []);

ping(N) -&amp;gt;
    pong ! {ping, self()},
    receive
        pong -&amp;gt;
            io:format(&quot;Ping received pong~n&quot;, [])
    end,
    ping(N - 1).

pong() -&amp;gt; receive
        finished -&amp;gt;
            io:format(&quot;Pong finished~n&quot;, []);
        {ping, Ping_PID} -&amp;gt;
            io:format(&quot;Pong received ping~n&quot;, []),
            Ping_PID ! pong,
            pong()
    end.

start() -&amp;gt;
    register(pong, spawn(tut16, pong, [])),
    spawn(tut16, ping, [3]).
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;2&amp;gt; c(tut16).
{ok, tut16}
3&amp;gt; tut16:start().
&amp;lt;0.38.0&amp;gt;
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
ping finished
Pong finished
&lt;/code&gt;&lt;p&gt;这是&lt;b&gt;start/0&lt;/b&gt;函数，&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;register(pong, spawn(tut16, pong, [])),
&lt;/code&gt;&lt;p&gt;同时做了启动“pong”线程，给线程命名两件事。在“ping”进程中，可以这样给“pong”进程发送消息：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;pong ! {ping, self()},
&lt;/code&gt;&lt;p&gt;&lt;b&gt;ping/2&lt;/b&gt; 现在变成了&lt;b&gt;ping/1&lt;/b&gt;，省去了&lt;b&gt;Pong_PID&lt;/b&gt;参数（避免在各个函数中混乱传递Ping_PID/Pong_PID参数）&lt;/p&gt;&lt;h2&gt;4. 分布式编程&lt;/h2&gt;&lt;p&gt;让我们重写ping pong这个例子，使“ping”和“pong”在不同电脑上运行。第一件事是&lt;b&gt;设置&lt;/b&gt;。Erlang的分布式实现提供了一个非常基础的验证机制来避免一台电脑不小心连接到Erlang分布式集群。Erlang集群的交流必须有一个相同的&lt;b&gt;magic cookie&lt;/b&gt;。要实现这个最简单的方法是通过一个&lt;b&gt;.erlang.cookie&lt;/b&gt;文件，将它放置于集群中的各台电脑（译注：即服务器，后文也译做“电脑（computer）”）的home目录，这样它们就能相互通信：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Windows系统上home目录可以由环境变量$HOME指定——你可能需要自行设置一下&lt;/li&gt;&lt;li&gt;Linux或UNIX可以忽略，只需要在你启动shell并执行cd（不附带任何参数）命令后所显示的目录下创建一个.erlang.cookie文件&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;.erlang.cookie&lt;/b&gt;文件包含了一行相同的原子。举个例子，在Linux或UNIX系统shell中&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;$ cd
$ cat &amp;gt; .erlang.cookie
this_is_very_secret
$ chmod 400 .erlang.cookie
&lt;/code&gt;&lt;p&gt;chmod命令将只允许文件的拥有者访问.erlang.cookie文件。这是需求不是必要。&lt;/p&gt;&lt;p&gt;当你启动一个Erlang系统，想和另一个Erlang系统通信，你必须给它一个名字，比如：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;$ erl -sname my_name&lt;/code&gt;&lt;p&gt;在后面我们会讨论更多关于这个的细节。如果你想实验一下分布式Erlang，但是你只有一台电脑，你可以在这台电脑上启动两个独立的Erlang系统，只需要给它们指定不同的名字。每个运行着Erlang系统的电脑叫做&lt;b&gt;Erlang节点（Erlang node）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;(注意: erl -sname假定所有节点都是用相同的IP，如果我们想在不同的IP上运行Erlang系统请使用 -name代替。但是IP地址必须给全。)&lt;/p&gt;&lt;p&gt;像下面一样修改ping pong例子使之运行在不同的节点：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut17).

-export([start_ping/1, start_pong/0,  ping/2, pong/0]).

ping(0, Pong_Node) -&amp;gt;
    {pong, Pong_Node} ! finished,
    io:format(&quot;ping finished~n&quot;, []);

ping(N, Pong_Node) -&amp;gt;
    {pong, Pong_Node} ! {ping, self()},
    receive
        pong -&amp;gt;
            io:format(&quot;Ping received pong~n&quot;, [])
    end,
    ping(N - 1, Pong_Node).

pong() -&amp;gt; receive
        finished -&amp;gt;
            io:format(&quot;Pong finished~n&quot;, []);
        {ping, Ping_PID} -&amp;gt;
            io:format(&quot;Pong received ping~n&quot;, []),
            Ping_PID ! pong,
            pong()
    end.

start_pong() -&amp;gt;
    register(pong, spawn(tut17, pong, [])).

start_ping(Pong_Node) -&amp;gt;
    spawn(tut17, ping, [3, Pong_Node]).
&lt;/code&gt;&lt;p&gt;假设这两台电脑叫做gollum和kosken。第一个节点是kosken，启动ping，第二个是gollum，启动pong。&lt;/p&gt;&lt;p&gt;kosken如下：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;kosken&amp;gt; erl -sname ping
Erlang (BEAM) emulator version 5.2.3.7 [hipe] [threads:0]

Eshell V5.2.3.7  (abort with ^G)
(ping@kosken)1&amp;gt;
&lt;/code&gt;&lt;p&gt;这是 gollum:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;gollum&amp;gt; erl -sname pong
Erlang (BEAM) emulator version 5.2.3.7 [hipe] [threads:0]

Eshell V5.2.3.7  (abort with ^G)
(pong@gollum)1&amp;gt;
&lt;/code&gt;&lt;p&gt;接着在gollum上启动pong：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(pong@gollum)1&amp;gt; tut17:start_pong(). true
&lt;/code&gt;&lt;p&gt;在kosken节点上启动ping进程：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(ping@kosken)1&amp;gt; tut17:start_ping(pong@gollum).
&amp;lt;0.37.0&amp;gt;
Ping received pong
Ping received pong 
Ping received pong
ping finished
&lt;/code&gt;&lt;p&gt;如上所示，ping pong都已经在运行了。在“pong”那边：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(pong@gollum)2&amp;gt;
Pong received ping                 
Pong received ping                 
Pong received ping                 
Pong finished                      
(pong@gollum)2&amp;gt;
&lt;/code&gt;&lt;p&gt;注意tut17的代码，你会注意到pong函数的代码没有改变，下面的代码也一样，它不关心ping进程所在的节点：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;{ping, Ping_PID} -&amp;gt;
    io:format(&quot;Pong received ping~n&quot;, []),
    Ping_PID ! pong,
&lt;/code&gt;&lt;p&gt;因此，Erlang pid包含了进程在哪执行的信息。如果你知道一个进程的pid，就可以用“！”运算符发送消息，而不用考虑进程在不在相同的节点。&lt;br&gt;有一点不同是消息怎样发送给另一个节点上已注册的进程：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;{pong, Pong_Node} ! {ping, self()},
&lt;/code&gt;&lt;p&gt;一个元组tuple {registered_name,node_name}用来代替 registered_name。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在钱的例子中，‘’ping”和“pong”由两个独立的Erlang节点的shell中启动，也就是说spawn可以在不同的节点上启动进程。&lt;/p&gt;&lt;p&gt;下面的例子又是ping pong程序，但是这一次“ping”在另一个节点启动：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut18).

-export([start/1,  ping/2, pong/0]).

ping(0, Pong_Node) -&amp;gt;
    {pong, Pong_Node} ! finished,
    io:format(&quot;ping finished~n&quot;, []);

ping(N, Pong_Node) -&amp;gt;
    {pong, Pong_Node} ! {ping, self()},
    receive
        pong -&amp;gt;
            io:format(&quot;Ping received pong~n&quot;, [])
    end,
    ping(N - 1, Pong_Node).

pong() -&amp;gt; receive
        finished -&amp;gt;
            io:format(&quot;Pong finished~n&quot;, []);
        {ping, Ping_PID} -&amp;gt;
            io:format(&quot;Pong received ping~n&quot;, []),
            Ping_PID ! pong,
            pong()
    end.

start(Ping_Node) -&amp;gt;
    register(pong, spawn(tut18, pong, [])),
    spawn(Ping_Node, tut18, ping, [3, node()]).
&lt;/code&gt;&lt;p&gt;假设在kosken上被名为ping的Erlang系统已经启动，然后在gollum上这样做：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(pong@gollum)1&amp;gt; tut18:start(ping@kosken).
&amp;lt;3934.39.0&amp;gt;
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong finished
ping finished
&lt;/code&gt;&lt;p&gt;注意gollum接收所有的输出。这是因为I/O系统会找到进程从哪启动，然后在那输出。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;5. 一个完整的例子&lt;/h2&gt;&lt;p&gt;现在写一个完整的例子，叫做“messenger”。messenger这个程序运行在不同的Erlang节点上登陆然后互相发送消息（message）。&lt;/p&gt;&lt;p&gt;在开始前，注意下面几点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这个例子只显示了消息传递的逻辑——并不打算提供一个友好的GUI，虽然这也可以用Erlang完成&lt;/li&gt;&lt;li&gt;这类问题用OTP的一些设施更容易解决，因为它们能提供一些方法进行代码热更新等 (参见 &lt;b&gt;&lt;a href=&quot;http://erlang.org/doc/design_principles/des_princ.html#otp%20design%20principles&quot;&gt;OTP Design Principles&lt;/a&gt;&lt;/b&gt;).&lt;/li&gt;&lt;li&gt;第一个程序有一些缺陷。后续版本会逐步修复它。The first program contains some inadequacies regarding handling of nodes which disappear. These are corrected in a later version of the program.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;messenger允许创建客户端然后连接中央服务器，并服务器会知晓客户端是哪些、它们在哪。也就是说，用户不需要关系当前节点的名字和其他节点在哪就能发送消息。&lt;/p&gt;&lt;p&gt;messenger.erl文件如下:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;%%% Message passing utility.  
%%% User interface:
%%% logon(Name)
%%%     One user at a time can log in from each Erlang node in the
%%%     system messenger: and choose a suitable Name. If the Name
%%%     is already logged in at another node or if someone else is
%%%     already logged in at the same node, login will be rejected
%%%     with a suitable error message.
%%% logoff()
%%%     Logs off anybody at that node
%%% message(ToName, Message)
%%%     sends Message to ToName. Error messages if the user of this 
%%%     function is not logged on or if ToName is not logged on at
%%%     any node.
%%%
%%% One node in the network of Erlang nodes runs a server which maintains
%%% data about the logged on users. The server is registered as &quot;messenger&quot;
%%% Each node where there is a user logged on runs a client process registered
%%% as &quot;mess_client&quot; 
%%%
%%% Protocol between the client processes and the server
%%% ----------------------------------------------------
%%% 
%%% To server: {ClientPid, logon, UserName}
%%% Reply {messenger, stop, user_exists_at_other_node} stops the client
%%% Reply {messenger, logged_on} logon was successful
%%%
%%% To server: {ClientPid, logoff}
%%% Reply: {messenger, logged_off}
%%%
%%% To server: {ClientPid, logoff}
%%% Reply: no reply
%%%
%%% To server: {ClientPid, message_to, ToName, Message} send a message
%%% Reply: {messenger, stop, you_are_not_logged_on} stops the client
%%% Reply: {messenger, receiver_not_found} no user with this name logged on
%%% Reply: {messenger, sent} Message has been sent (but no guarantee)
%%%
%%% To client: {message_from, Name, Message},
%%%
%%% Protocol between the &quot;commands&quot; and the client
%%% ----------------------------------------------
%%%
%%% Started: messenger:client(Server_Node, Name)
%%% To client: logoff
%%% To client: {message_to, ToName, Message}
%%%
%%% Configuration: change the server_node() function to return the
%%% name of the node where the messenger server runs

-module(messenger).
-export([start_server/0, server/1, logon/1, logoff/0, message/2, client/2]).

%%% Change the function below to return the name of the node where the
%%% messenger server runs
server_node() -&amp;gt;
    messenger@bill.

%%% This is the server process for the &quot;messenger&quot;
%%% the user list has the format [{ClientPid1, Name1},{ClientPid22, Name2},...]
server(User_List) -&amp;gt;
    receive
        {From, logon, Name} -&amp;gt;
            New_User_List = server_logon(From, Name, User_List),
            server(New_User_List);
        {From, logoff} -&amp;gt;
            New_User_List = server_logoff(From, User_List),
            server(New_User_List);
        {From, message_to, To, Message} -&amp;gt;
            server_transfer(From, To, Message, User_List),
            io:format(&quot;list is now: ~p~n&quot;, [User_List]),
            server(User_List)
    end.

%%% Start the server
start_server() -&amp;gt;
    register(messenger, spawn(messenger, server, [[]])).


%%% Server adds a new user to the user list
server_logon(From, Name, User_List) -&amp;gt;
    %% check if logged on anywhere else
    case lists:keymember(Name, 2, User_List) of
        true -&amp;gt;
            From ! {messenger, stop, user_exists_at_other_node},  %reject logon
            User_List;
        false -&amp;gt;
            From ! {messenger, logged_on},
            [{From, Name} | User_List]        %add user to the list
    end.

%%% Server deletes a user from the user list
server_logoff(From, User_List) -&amp;gt;
    lists:keydelete(From, 1, User_List).


%%% Server transfers a message between user
server_transfer(From, To, Message, User_List) -&amp;gt;
    %% check that the user is logged on and who he is
    case lists:keysearch(From, 1, User_List) of
        false -&amp;gt;
            From ! {messenger, stop, you_are_not_logged_on};
        {value, {From, Name}} -&amp;gt;
            server_transfer(From, Name, To, Message, User_List)
    end.
%%% If the user exists, send the message
server_transfer(From, Name, To, Message, User_List) -&amp;gt;
    %% Find the receiver and send the message
    case lists:keysearch(To, 2, User_List) of
        false -&amp;gt;
            From ! {messenger, receiver_not_found};
        {value, {ToPid, To}} -&amp;gt;
            ToPid ! {message_from, Name, Message}, 
            From ! {messenger, sent} 
    end.


%%% User Commands
logon(Name) -&amp;gt;
    case whereis(mess_client) of 
        undefined -&amp;gt;
            register(mess_client, 
                     spawn(messenger, client, [server_node(), Name]));
        _ -&amp;gt; already_logged_on
    end.

logoff() -&amp;gt;
    mess_client ! logoff.

message(ToName, Message) -&amp;gt;
    case whereis(mess_client) of % Test if the client is running
        undefined -&amp;gt;
            not_logged_on;
        _ -&amp;gt; mess_client ! {message_to, ToName, Message},
             ok
end.


%%% The client process which runs on each server node
client(Server_Node, Name) -&amp;gt;
    {messenger, Server_Node} ! {self(), logon, Name},
    await_result(),
    client(Server_Node).

client(Server_Node) -&amp;gt;
    receive
        logoff -&amp;gt;
            {messenger, Server_Node} ! {self(), logoff},
            exit(normal);
        {message_to, ToName, Message} -&amp;gt;
            {messenger, Server_Node} ! {self(), message_to, ToName, Message},
            await_result();
        {message_from, FromName, Message} -&amp;gt;
            io:format(&quot;Message from ~p: ~p~n&quot;, [FromName, Message])
    end,
    client(Server_Node).

%%% wait for a response from the server
await_result() -&amp;gt;
    receive
        {messenger, stop, Why} -&amp;gt; % Stop the client 
            io:format(&quot;~p~n&quot;, [Why]),
            exit(normal);
        {messenger, What} -&amp;gt;  % Normal response
            io:format(&quot;~p~n&quot;, [What])
    end.&lt;/code&gt;&lt;p&gt;要运行这个程序，你需要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;配置server_node()函数&lt;/li&gt;&lt;li&gt;把编译后的字节码 (messenger.beam) 复制到其它电脑，这样它们才能使用这些函数&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;接下来的例子是使用这个程序，在四个不同电脑上启动Erlang节点。如果你没有那么多电脑那么可以考虑在一台机器上启动不同的节点（译注：-sname，具体可以参见前面小结）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;四个Erlang节点分别是：messenger@super, c1@bilbo, c2@kosken, c3@gollum.&lt;/p&gt;&lt;p&gt;首先启动服务器节点messenger@supe:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(messenger@super)1&amp;gt; messenger:start_server(). true&lt;/code&gt;&lt;p&gt;接着在c1@bilbo上登陆Peter:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(c1@bilbo)1&amp;gt; messenger:logon(peter). true
logged_on&lt;/code&gt;&lt;p&gt;在c2@kosken上登陆James:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(c2@kosken)1&amp;gt; messenger:logon(james). true
logged_on&lt;/code&gt;&lt;p&gt;Fred在c3@gollum上登陆:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(c3@gollum)1&amp;gt; messenger:logon(fred). true
logged_on&lt;/code&gt;&lt;p&gt;现在Peter给Fred发送消息：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(c1@bilbo)2&amp;gt; messenger:message(fred, &quot;hello&quot;).
ok
sent&lt;/code&gt;&lt;p&gt;Fred收到消息并回复Peter一条消息然后注销：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;Message from peter: &quot;hello&quot;
(c3@gollum)2&amp;gt; messenger:message(peter, &quot;go away, I&#39;m busy&quot;).
ok
sent
(c3@gollum)3&amp;gt; messenger:logoff().
logoff&lt;/code&gt;&lt;p&gt;James现在尝试向Fred发送消息:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;(c2@kosken)2&amp;gt; messenger:message(fred, &quot;peter doesn&#39;t like you&quot;).
ok
receiver_not_found&lt;/code&gt;&lt;p&gt;但是失败了，因为Fred早就离线了。&lt;/p&gt;&lt;p&gt;让我们先看看这里引进的新概念。&lt;/p&gt;&lt;p&gt;有两个版本的server_transfer函数：一个有四个参数(server_transfer/4) 一个有五个参数(server_transfer/5)。Erlang将他们视作不同的函数。 &lt;/p&gt;&lt;p&gt;注意怎样写server函数让它调用自己，通过server(User_List)形成一个循环结构。Erlang编译器很“聪明”，它会进行代码优化，以至于它真的会变成一个循环而不是函数调用。但是这只限于在这个调用后没有其它工作。这会导致进程（译注：的内存占用）在每次循环后变得越来越大。&lt;/p&gt;&lt;p&gt;也使用了一些lists模块的函数。这是一个非常有用的模块，建议看看它的使用手册（erl -man lists）。lists:keymember(Key,Position,Lists)遍历tuple列表然后检查tuple的Position位置是否和Key匹配，tuple的第一个元素是1.如果寻找成功返回true，否则返回false。&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;
3&amp;gt; lists:keymember(a, 2, [{x,y,z},{b,b,b},{b,a,c},{q,r,s}]).
true
4&amp;gt; lists:keymember(p, 2, [{x,y,z},{b,b,b},{b,a,c},{q,r,s}]).
false&lt;/code&gt;&lt;p&gt;lists:keydelete的工作方式类似，只是如果找到就删除它并返回剩余列表： &lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;5&amp;gt; lists:keydelete(a, 2, [{x,y,z},{b,b,b},{b,a,c},{q,r,s}]).
[{x,y,z},{b,b,b},{q,r,s}]&lt;/code&gt;&lt;p&gt;lists:keysearch类似于lists:keymember，但是返回 {value,Tuple_Found}，或者寻找失败返回false原子。&lt;/p&gt;&lt;p&gt;在lists模块有很多有用的函数。&lt;/p&gt;&lt;p&gt;一个Erlang进程（概念上的）会一直运行直到它执行receive结构，直到遍历消息队列后没有发现和receive结构中的模式相匹配的消息。之所以说是“概念上的”是因为Erlang系统执行各个进程其实是会共享CPU时间的。&lt;/p&gt;&lt;p&gt;当一个进程没有事做的时候它会终止，即它调用的最后一个函数简单返回且不再调用其他函数。另一个终止进程的方法是调用exit/1,。exit/1的参数有特别的意义，我们将会在后面讨论。在这个例子中，调用exit(normal)即可，它会进程运行到没有事做再终止是一样的效果。&lt;/p&gt;&lt;p&gt;内置函数whereis(RegisteredName)检查一个名为RegisteredName的具名进程是否存在。如果存在，返回它的pid，如果不存在， ，返回原子undefined。&lt;/p&gt;&lt;p&gt;到目前为止你应该已经理解了messenger模块的大部分代码。让我们取一个片段看看它的细节。&lt;/p&gt;&lt;p&gt;第一个用户“发送”消息：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;messenger:message(fred, &quot;hello&quot;)&lt;/code&gt;&lt;p&gt;在测试了客户端进程存在之后：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;whereis(mess_client) &lt;/code&gt;&lt;p&gt;将会发送一条消息给mess_client：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;mess_client ! {message_to, fred, &quot;hello&quot;}&lt;/code&gt;&lt;p&gt;它的实现是客户端向服务器发送消息：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;{messenger, messenger@super} ! {self(), message_to, fred, &quot;hello&quot;},&lt;/code&gt;&lt;p&gt;然后等待服务器的回复。&lt;/p&gt;&lt;p&gt;把目光转向服务器，它收到消息然后调用：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;server_transfer(From, fred, &quot;hello&quot;, User_List),&lt;/code&gt;&lt;p&gt;它检查User_List中的pid:&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;lists:keysearch(From, 1, User_List) &lt;/code&gt;&lt;p&gt;如果keysearch返回原子false，引发错误，服务器会这样回复： &lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;From ! {messenger, stop, you_are_not_logged_on}&lt;/code&gt;&lt;p&gt;它将被客户端收到，然后客户端执行exit(normal)终止。如果keysearch返回{value,{From,Name}}，很明显用户已经登录，他的名字（peter）会被绑定到Name上。&lt;/p&gt;&lt;p&gt;现在让我们调用：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;server_transfer(From, peter, fred, &quot;hello&quot;, User_List)&lt;/code&gt;&lt;p&gt;注意server_transfer/5，它不同于server_transfer/4。另一个keysearch会在User_List上进行，然后返回fred客户端的pid：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;lists:keysearch(fred, 2, User_List)&lt;/code&gt;&lt;p&gt;这次Position指定为2，也就是tuple的第二个元素和fred进行匹配。如果返回原子false，fred就没有登录然后发送下面的消息：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;From ! {messenger, receiver_not_found};&lt;/code&gt;&lt;p&gt;客户端会收到该条消息。&lt;/p&gt;&lt;p&gt;如果keysearch返回：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;{value, {ToPid, fred}}&lt;/code&gt;&lt;p&gt;会向fred发送：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;ToPid ! {message_from, peter, &quot;hello&quot;}, &lt;/code&gt;&lt;p&gt;向peter发送：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;From ! {messenger, sent} &lt;/code&gt;&lt;p&gt;Fred&#39;收到该条消息然后输出：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;{message_from, peter, &quot;hello&quot;} -&amp;gt;
    io:format(&quot;Message from ~p: ~p~n&quot;, [peter, &quot;hello&quot;])&lt;/code&gt;&lt;p&gt;Peter客户端在await_result函数调用中接收消息。 &lt;/p&gt;</description>
<author>racaljk</author>
<guid isPermaLink="false">2017-08-28-28859183</guid>
<pubDate>Mon, 28 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>最近一星期忙着做实验没看paper，愧对大家</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-08-27-28832682.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;最近一星期忙着做实验没看paper，愧对大家&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28832682&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每周的paper导读这周就取笑掉吧，不过这周看到个很有意思的帖子，是rust他爹说编译语言的下一个热点是啥，可以自己慢慢爬&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://graydon2.dreamwidth.org/253769.html&quot;&gt;graydon2 | &quot;What next?&quot;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其实paper还是看了一半的，可惜完读懂了一小半，就没办法写笔记，大家有兴趣的可以自己读读看，是&lt;a href=&quot;https://pdfs.semanticscholar.org/130c/a6c6b876d1bdce81e0f0c2e7b5e1498579c1.pdf&quot;&gt;The Development of the Emerald Programming Language&lt;/a&gt;，讲的是一个叫Emerald的分布式OO语言，里面有三个大特点：&lt;/p&gt;&lt;p&gt;0：任意一个object可以在运行中从一台机器move到另一台机器（不一定要是同种archeticture），并且不中断执行，move后也不会损失性能&lt;/p&gt;&lt;p&gt;1：在girard paradox出现以前就用type in type这设定。。。没有martin lof早，不过也很离谱了（换句话说，他们的generic就是靠type function搞的，什么鬼）&lt;/p&gt;&lt;p&gt;2：是UW的！他们里面有个Paul Allen building的黑白，然后竟然还在the ave画emerald的饼，想到自己学校搞过这么有意思的东西，荣誉感++（然而管你啥事，那年你还没出生233）&lt;/p&gt;&lt;p&gt;决定了，以后不吹smalltalk改吹emerald（特大雾）&lt;/p&gt;</description>
<author>帅气可爱魔理沙</author>
<guid isPermaLink="false">2017-08-27-28832682</guid>
<pubDate>Sun, 27 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Dependently Typed Programming with Singletons</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-08-14-28496113.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Dependently Typed Programming with Singletons&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28496113&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这星期的文章是&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf&quot;&gt;http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这paper在codewars上，可以做做看：&lt;a href=&quot;http://www.codewars.com/kata/singletons/train/haskell&quot;&gt;Singletons | Codewars&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这文章在说两件事情：&lt;/p&gt;&lt;p&gt;0：用一种design pattern来做DT&lt;/p&gt;&lt;p&gt;1：这个design pattern可以用库automate一大部分&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;0：&lt;/p&gt;&lt;p&gt;假设我们有普普通通的data Nat = Z | S Nat。&lt;/p&gt;&lt;p&gt;首先，如果我们要把这用上type level（因为dependent type就是value可以在typelevel使用），我们需要额外的两个类型，一个ZType :: *，一个SType :: * -&amp;gt; *，来表示Nat的type level表示。然后，type level的Nat函数，可以用type family写出。&lt;/p&gt;&lt;p&gt;然后，可以用GADT表示inductive dependent type，比如Vec之类的。如果不支持GADT（什么鬼，不支持还想玩奇怪特性）可以考虑考虑用gadtless programming，换句话说用Leibniz Equality手动解constraint。。。&lt;/p&gt;&lt;p&gt;但是，由于parametricity，这无法做到：给入一个type level Nat，输出一个该长度的Vec。。。所以，做法是，再弄一个GADT inductive type，这个GADT的value是indexed on type level nat的。换言之，每一个type level nat，都能在这个GADT中找到一个unique的对应值。这就叫singleton&lt;/p&gt;&lt;p&gt;最后，很多时候singleton可以隐式推出，所以可以弄成一个constraint。&lt;/p&gt;&lt;p&gt;总结，一个datatype有4种做法：普通的，type level的，singleton，singleton变成constraint（换句话说，typeclass）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1：&lt;/p&gt;&lt;p&gt;type level的可以由GHC的DataKinds扩展自动生成。&lt;/p&gt;&lt;p&gt;singleton constraint可以统一到一个typeclass&lt;/p&gt;&lt;p&gt;由template haskell可以从普通函数生成singleton函数跟type level函数（type family）&lt;/p&gt;&lt;p&gt;最后：singleton constraint跟Data.Constraint有异曲同工之妙:)&lt;/p&gt;&lt;p&gt;还有，下期想看啥接着私信我。。。no monad tutorial，no 女装=/\=&lt;/p&gt;</description>
<author>帅气可爱魔理沙</author>
<guid isPermaLink="false">2017-08-14-28496113</guid>
<pubDate>Mon, 14 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>大家想看我写啥私信/回复</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-08-09-28398964.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;大家想看我写啥私信/回复&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28398964&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近搞了个笔记/导读？&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28346196?group_id=878257381073641472&quot;&gt;Embedded Probabilistic Programming&lt;/a&gt;，觉得这样挺不错的，大家可以向我题些paper去读（太难的读不来了DAZE&amp;gt;&amp;lt;）&lt;/p&gt;</description>
<author>帅气可爱魔理沙</author>
<guid isPermaLink="false">2017-08-09-28398964</guid>
<pubDate>Wed, 09 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Embedded Probabilistic Programming</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-08-06-28346196.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Embedded Probabilistic Programming&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28346196&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于一直没找到好的并且能答得上的问题，以后打算时不时往这发点paper，然后对之进行一定的解释，练练手&amp;amp;降低阅读门槛（希望）。&lt;/p&gt;&lt;p&gt;这次的是 &lt;a href=&quot;http://okmij.org/ftp/kakuritu/dsl-paper.pdf&quot;&gt;Embedded Probabilistic Programming&lt;/a&gt;&lt;/p&gt;&lt;p&gt;建议前置知识：Probability Distribution，Monad，Continuation&lt;/p&gt;&lt;p&gt;P1-P6：我们想造一个编程语言，在这语言里面，所有变量都不是传统意义上的变量，而是Probability Distribution（PD）。&lt;/p&gt;&lt;p&gt;在本文中，一个a的PD&lt;b&gt;可以看成&lt;/b&gt;一个List (probability, a)，其中，probability（简称prob）是double的别名，一个PD的元素，(probability, a)，代表在该概率下a的可能性是多小（这文章不考虑无限&amp;amp;连续的PD）&lt;/p&gt;&lt;p&gt;一个PD要满足两个条件：所有prob加起来是1，所有不同元素的a都不一样&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这定义下，我们可以定义多个PD下的函数：（此文皆为伪代码）&lt;/p&gt;&lt;p&gt;return : a -&amp;gt; PD a，接受一个非随机的值，变成一个PD&lt;/p&gt;&lt;p&gt;return x = [(1.0, x)] （这个随机变量只可能取一个值，就是传进来的那个）&lt;/p&gt;&lt;p&gt;map : (a -&amp;gt; b) -&amp;gt; (PD a -&amp;gt; PD b)，把PD里的所有a 都变成b&lt;/p&gt;&lt;p&gt;map f [] = []&lt;/p&gt;&lt;p&gt;map f ((prob, value):: rest) = (prob, f value):: map f rest&lt;/p&gt;&lt;p&gt;join : PD (PD a) -&amp;gt; PD a，把一个概率分布的概率分布变成概率分布&lt;/p&gt;&lt;p&gt;join [] = []&lt;/p&gt;&lt;p&gt;join (prob_of_prob, prob_value): rest = loop prob_value ++join rest&lt;/p&gt;&lt;p&gt; where&lt;/p&gt;&lt;p&gt;    loop [] = []&lt;/p&gt;&lt;p&gt;    loop ((prob, value): rest) = (prob * prob_of_prob, value) : loop rest&lt;/p&gt;&lt;p&gt;（对于每一个PD of PD里面的a，都有两个概率，一个是这个a的概率，一个是a的PD的概率，两个相乘就能扁平化）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对于所有M，符合这些定义&lt;/p&gt;&lt;p&gt;（return: a -&amp;gt; M a, map : (a -&amp;gt; b) -&amp;gt; (M a -&amp;gt; M b), join : M (M a) -&amp;gt; M a）的，&lt;/p&gt;&lt;p&gt;就叫一个Monad。&lt;/p&gt;&lt;p&gt;另一套定义法是，(return : a -&amp;gt; M a, bind : M a -&amp;gt; (a -&amp;gt; M b) -&amp;gt; M b)），&lt;/p&gt;&lt;p&gt;两者等价，自己可以试试看从一套推出另一套。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过使用return，我们可以把普通的值看成PD，再通过bind，我们可以把任意PD的值当成普通的值使用，然后得出更多的PD。然后，需要随机性的时候，我们可以直接（通过构造列表）构造PD。比如说，如果要抛硬币，可以写[(0.5, Head), (0.5, Tail)]。这样，我们就可以在PD里面编程了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有的时候，我们需要对我们的程序做一些限制（比如说，如果我们抛了两次硬币，然后被告知不可能两个都是Head）。这个时候，我们可以生成一个空的PD来代表‘不可能发生’。&lt;/p&gt;&lt;p&gt;例如，刚刚那个例子，可以表达为&lt;/p&gt;&lt;p&gt;let a = [(0.5, Head), (0.5, Tail)] （第零个硬币）&lt;/p&gt;&lt;p&gt;let b = [(0.5, Head), (0.5, Tail)] （第一个硬币）&lt;/p&gt;&lt;p&gt;bind a (\a_obs -&amp;gt; （观察第零个硬币）&lt;/p&gt;&lt;p&gt;bind b (\b_obs -&amp;gt; （观察第二个硬币）&lt;/p&gt;&lt;p&gt;  if a_obs == Head &amp;amp;&amp;amp; b_obs == Head then [] （空的PD，代表不可能） else return (a, b) （把观察到的a, b记录下来）))&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这样，我们就有两个问题：&lt;/p&gt;&lt;p&gt;0：map, bind, join可能使得返回的PD（换句话说，List (prob, a)）中，两个元素的a一样的&lt;/p&gt;&lt;p&gt;1：bind x (\y -&amp;gt; [])会导致整个PD的概率的和不为1（如果只有特定的情况会fail，概率和就不是0也不是1）&lt;/p&gt;&lt;p&gt;这些问题都可以通过输出时，把同样的结果会合一起，再把整个PD的每一个prob乘一个数（使得概率和为1）解决。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P7:我们把这个语言放进OCaml里面，这样整个语言就是一推OCaml函数。这样就不需要自己写parser，typechecker，gc，然后OCaml也能自动帮你优化，还能用OCaml的库。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后，由于可以用很多种方法实现PD，我们把一个PD的需求变成个模块签名，这样就可以用不同的实现。在这里面，PD实现者可以自定义什么是一个PD（叫做pm，因为PD是个Monad）这种方法叫做Finally Tagless。用Finally Tagless而不是用一个AST有两个好处：一是AST不可扩展（不可增加新的constructor），一是Int的AST跟Bool的AST（往往）是同一类型，所以是unsafe的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P8:由于上面所述的PD的实现太慢，并且只能暴力算，无法做任何优化，所以用的是另一种数据结构。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P9:explore是尾递归的，susp是剩下的计算，ans是一个Map，用以把多个PD中一样的a会合到一起，解决问题0&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P12:一个continuation可以看成：给定一个（算出a在一个值下，符合observation的概率，的函数），返回一个a的PD符合该observation的概率&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P16-17:我们可以（通过explore）事先展开一个stochastic function，得出他的exact PD，然后就可以避免重复计算。这叫variable elimination。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P18:当Branching很大的时候，完全的展开不现实，这时候可以以一个branch的概率选择性的展开：这叫sampling。naive的sampling会很受指数爆炸的影响，所以可以只展开没展开过的，这叫importance sampling。&lt;/p&gt;</description>
<author>帅气可爱魔理沙</author>
<guid isPermaLink="false">2017-08-06-28346196</guid>
<pubDate>Sun, 06 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>你的类型，0：基本的合一 详尽注释</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-08-04-28300506.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;你的类型，0：基本的合一 详尽注释&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28300506&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;原址: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/24181997&quot;&gt;你的类型，0：基本的合一&lt;/a&gt;&lt;br&gt;&lt;br&gt;作者：Belleve&lt;br&gt;链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24181997&quot;&gt;你的类型，0：基本的合一&lt;/a&gt;&lt;br&gt;来源：知乎&lt;br&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/blockquote&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;本文可认为是个人笔记、代码注释，尽量以通俗易懂的方式解释 Belleve 的原文，由于水平有限以及深夜精神恍惚，可能会存在较多错漏，可在评论区指出。&lt;/p&gt;&lt;p&gt;引用部分为 Belleve 原文。&lt;/p&gt;&lt;h2&gt;导读&lt;/h2&gt;&lt;p&gt;第零章，基本的合一，本章实现一个简单的合一算法，能够为两个类型生成一个替换，这个替换在 js 中体现为一个 map。&lt;/p&gt;&lt;p&gt;为了方便地使用这个函数，我们还定义了一些类型构造器，用于构造需要的类型。&lt;/p&gt;&lt;p&gt;我们使用两个不同的类型生成一个替换（映射），将这个替换应用在这个两个不同的类型上，就可以得到两个相同的类型，这就是合一。&lt;/p&gt;&lt;h2&gt;预备知识&lt;/h2&gt;&lt;p&gt;如果你想更好地理解合一的概念，可以参考这个问题：&lt;a href=&quot;https://www.zhihu.com/question/22256149&quot;&gt;如何通俗的解释计算机中“合一(unification)”这个概念 ？&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;1 目标与基本思路&lt;/h2&gt;&lt;blockquote&gt;简单粗暴的开始：用 JS 实现一个 ML 类的程序语言的类型推理系统。&lt;br&gt;在我们这里，所有的类型属于以下形式之一：&lt;br&gt;&lt;br&gt;一个基础类型（Primitive）&lt;br&gt;一个自由变量（Slot）&lt;br&gt;一个复合类型（Composite），由一个构造器（ctor）和一个参数（argument）复合得到。对于 (-&amp;gt;)、(\*) 之类的二元构造器，使用 Curryize 将他变换为嵌套的 Composite。&lt;/blockquote&gt;&lt;p&gt;ML 系的语言使用的是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Hindley-Milner%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA&quot;&gt;Hindley-Milner类型推论&lt;/a&gt;算法来推测大多数值的类型，而不需要四处使用注解。有关 HM 类型推论算法，可以参考我的这篇翻译：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26076902&quot;&gt;(译) Algorithm W Step By Step&lt;/a&gt;，这篇文章原文的代码简单易懂，但是我觉得我翻译得很不好（哭）。&lt;/p&gt;&lt;h2&gt;2 概念介绍&lt;/h2&gt;&lt;blockquote&gt;所谓的合一，指的是：给出两个类型 A 和 B，找到一组变量替换，使得两者的自由变量经过替换之后可以得到一个相同的类型 C。考虑&lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;A = ((α → β) × [γ]) → [β]， B = ((γ → δ) × [γ]) → ε&lt;/code&gt;&lt;blockquote&gt;这两个类型可以合一，对应的替换是&lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;〈α → α, β → β, γ → α, δ → β, ε → [β]〉&lt;/code&gt;&lt;p&gt;这是一个范例，无需注解。&lt;/p&gt;&lt;h2&gt;3 合一算法&lt;/h2&gt;&lt;blockquote&gt;实现合一的算法基本思路就是维护一个 slot 的映射。对于任意的类型 a 和 b，以及「当前状态」的映射 m：&lt;br&gt;&lt;br&gt;如果 a 和 b 都是 slot 并且 m[a] == m[b]，那么 a b 可以合一，m 不变。&lt;br&gt;如果 a 和 b 都是 primitive 并且相同，那么 a b 可以合一，m 不变。&lt;br&gt;如果 a 是 slot，可以合一，并且需要 m[a] 设置为 b；反之亦然。&lt;br&gt;如果 a 和 b 都是 composite，检查两者的构造器和参数是否都能合一，m 会最多被设置两次。&lt;br&gt;对于其他一切情况，a 和 b 不能合一。&lt;/blockquote&gt;&lt;p&gt;对于第一条，如果给定自由变量 a 与 b，而且均被记入映射表（替换）中，并且记录在映射表中的值依旧相等，那么显然，a 与 b 可以直接消去（合一）。例如，若 m[a] == m[b] == c，那么我们不再需要 a 与 b 了，因为 c 可以取代二者。&lt;/p&gt;&lt;p&gt;对于第二条，是因为基本类型不记入映射表，也不被替换，因此只有在二者相等时才能消去。&lt;/p&gt;&lt;p&gt;第三条，如果 a 或者 b 二者之一是自由变量，我们可以变可以构造一个映射使得二者可以等价。例如我们有 a 与 b，那么无论是 m[a] = b 还是 m[b] = a 都是可以接受的；若我们有 a 与 [b]，那么只要 m[a] = [b] 即可完成消去（合一）。&lt;/p&gt;&lt;p&gt;第四条，如果是复合类型，显然，由于柯里化，我们需要同时检查构造器与参数能否合一。&lt;/p&gt;&lt;h2&gt;4 具体实现&lt;/h2&gt;&lt;code lang=&quot;js&quot;&gt;// A monomorphic type
class Monomorphic {
	constructor() {}
	inspect() {} // Pretty print type
	applySub(m) {} // Apply a substitution m
	equalTo(t) {
		return false;
	}
}&lt;/code&gt;&lt;p&gt;没有什么特别的基类。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// Slots for free variables
class Slot extends Monomorphic {
	constructor(name) {
		super();
                this.name = name;
	}
	inspect() {
		return &quot;#&quot; + this.name;
	}
	applySub(m) {
		const r = m.get(this);
		if (!r || r === this) return this;
		return r.applySub(m);
	}
	equalTo(t) {
		return t &amp;amp;&amp;amp; t instanceof Slot &amp;amp;&amp;amp; this.name === t.name;
	}
}
&lt;/code&gt;&lt;p&gt;inspect 为 pretty print方法，可以不去理会。&lt;/p&gt;&lt;p&gt;当我们对一个自由变量 a 套用替换（映射表）时，我们首先应当寻找是否有过记录过的替换，如果有，则返回 m[a].applySub(m)，再应用一次替换，因为我们需要保证 m[a] 也被完全合一了。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;if (!r || r === this) return this;&lt;/code&gt;&lt;p&gt;代表 a → a。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// Primitive types
class Primitive extends Monomorphic {
	constructor(name, kind) {
		super();
                this.name = name;
	}
	inspect() {
		return this.name;
	}
	applySub(m) {
		return this;
	}
	equalTo(t) {
		return t &amp;amp;&amp;amp; t instanceof Primitive &amp;amp;&amp;amp; this.name === t.name;
	}
}&lt;/code&gt;&lt;p&gt;因为是基本类型（相当于上面范例中的箭头和×），不能应用替换，所以 applySub 直接原样返回就行了。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// Composite types, like [(-&amp;gt;) a b] or [List a]
class Composite extends Monomorphic {
	constructor(ctor, argument) {
		super();
		this.ctor = ctor;
		this.argument = argument;
	}
	inspect() {
		if (this.argument instanceof Composite) {
			return this.ctor.inspect() + &quot; (&quot; + this.argument.inspect() + &quot;)&quot;;
		} else {
			return this.ctor.inspect() + &quot; &quot; + this.argument.inspect() + &quot;&quot;;
		}
	}
	applySub(m) {
		return new Composite(this.ctor.applySub(m), this.argument.applySub(m));
	}
	equalTo(t) {
		return t &amp;amp;&amp;amp; t instanceof Composite &amp;amp;&amp;amp; this.ctor.equalTo(t.ctor) &amp;amp;&amp;amp; this.argument.equalTo(t.argument);
	}
}&lt;/code&gt;&lt;p&gt;定义了“复合类型”，其构造是手动柯里化的，具体构造方式可以参考下文。&lt;/p&gt;&lt;p&gt;因此，在applySub中，由于柯里化，构造器 `ctor`和参数 argument 都应当能被执行合一。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// Unify two monomorphic types, p and q with slot mapping m.
function unify(m, s, t) {
	if (s instanceof Slot &amp;amp;&amp;amp; t instanceof Slot &amp;amp;&amp;amp; s.applySub(m).equalTo(t.applySub(m))) {
		return true;
	} else if (s instanceof Primitive &amp;amp;&amp;amp; t instanceof Primitive &amp;amp;&amp;amp; s.name === t.name &amp;amp;&amp;amp; s.kind === t.kind) {
		return true;
	} else if (s instanceof Composite &amp;amp;&amp;amp; t instanceof Composite) {
		return unify(m, s.ctor, t.ctor) &amp;amp;&amp;amp; unify(m, s.argument, t.argument);
	} else if (s instanceof Slot) {
		m.set(s, t);
		return true;
	} else if (t instanceof Slot) {
		m.set(t, s);
		return true;
	} else {
		return false;
	}
}&lt;/code&gt;&lt;p&gt;这个方法就是对合一算法的一一对应。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// Slot symbol table
let st = {};
function slot(name) {
	if (st[name])return st[name];
	const t = new Slot(name);
	st[name] = t;
	return t;
}
// Primitive symbol table
let pt = {};
function pm(name, kind) {
	if (pt[name])return pt[name];
	const t = new Primitive(name, kind);
	pt[name] = t;
	return t;
}
// Composite types
function ct(ctor, argument) {
	const t = new Composite(ctor, argument);
	return t;
}
function arrow(p, q) {
	return ct(ct(pm(&quot;[-&amp;gt;]&quot;), p), q);
}
function product(p, q) {
	return ct(ct(pm(&quot;[*]&quot;), p), q);
}&lt;/code&gt;&lt;p&gt;slot/pm 方法之前定义了变量表，方法内部只是往自由变量/基本类型表里加东西并返回一个构造出来的值而已。&lt;/p&gt;&lt;p&gt;ct 用于构造一个复合类型，注意到在使用方式上，是类似于手动柯里化的，可以方便我们处理。&lt;/p&gt;&lt;p&gt;arrow/product 用于构造我们较为复杂的类型，最后的结果是 `→ p q` 或者 `× p q`，也就是范例中的箭头与 ×。当然，可能更为直观的写法是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;p → q 与 p × q&lt;/code&gt;&lt;p&gt;但其实上面的写法只是省略了括号而已，正如前文所说，→ 与 × 是二元函数。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const type1 =
arrow(
	product(
 		arrow(slot(&quot;a1&quot;), slot(&quot;a2&quot;)),
 		ct(pm(&quot;list&quot;), slot(&quot;a3&quot;))),
 ct(pm(&quot;list&quot;), slot(&quot;a2&quot;)));&lt;/code&gt;&lt;p&gt;它制造的类型是 `→ (× (→ a1 a2) ([] a3)) ([] a2)`。我们可以直观地理解为如下形式：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;( (a1 → a2) × [a3] ) → [a2]&lt;/code&gt;&lt;p&gt;并不复杂。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const type2 =
arrow(
	product(
 		arrow(slot(&quot;a3&quot;), slot(&quot;a4&quot;)),
 		ct(pm(&quot;list&quot;), slot(&quot;a3&quot;))),
 slot(&quot;a5&quot;));&lt;/code&gt;&lt;p&gt;它制造的类型是 `→ (× (→ a3 a4) ([] a3)) a5`，也就是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;( (a3 → a4) × [a3] ) → a5&lt;/code&gt;&lt;h2&gt;5 测试&lt;/h2&gt;&lt;p&gt;测试代码就不贴了。&lt;/p&gt;&lt;p&gt;为更清除地理解这一算法，现在手动分析 `unify(m, type1, type2)` 这一过程。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;( (a1 → a2) × [a3] ) → [a2] 合一 ( (a3 → a4) × [a3] ) → a5，两者均为复合类型，因此检查构造器与参数是否能够合一。&lt;/li&gt;&lt;li&gt;也就是拆分成为 (a1 → a2) × [a3] → 合一 (a3 → a4) × [a3] → 以及 [a2] 合一 a5 两个问题。&lt;/li&gt;&lt;li&gt;首先检查 (a1 → a2) × [a3] → 合一 (a3 → a4) × [a3] →，两者均为复合类型，继续拆分，将基本类型 → 消去，得到 (a1 → a2) × [a3] 合一 (a3 → a4) × [a3]，继续拆分。&lt;/li&gt;&lt;li&gt;同理消去 ×，检查 a1 → a2 合一 a3 → a4，继续拆分。&lt;/li&gt;&lt;li&gt;检查 a1→ 合一 a3，可以合一，因此将 a1 → a3 写入映射表。&lt;/li&gt;&lt;li&gt;上溯到 a2 合一 a4，显然可以合一，将 a2 → a4 写入映射表。&lt;/li&gt;&lt;li&gt;上溯到 [] a3 合一 [] a3，消去基本类型 [] 后，消去成功，不修改映射表。&lt;/li&gt;&lt;li&gt;上溯到 [] a2 合一 a5，由于 a5 是 slot，因此可以合一，将 a5 → [a2] 写入映射表。&lt;/li&gt;&lt;li&gt;合一完成，合一替换为 a1 =&amp;gt; a3，a2 =&amp;gt; a4，a5 =&amp;gt; [a2]。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现考虑对 `type1`&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;( (a1 → a2) × [a3] ) → [a2] &lt;/code&gt;&lt;p&gt;进行替换&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;a1 =&amp;gt; a3，a2 =&amp;gt; a4，a5 =&amp;gt; [a2]&lt;/code&gt;&lt;ul&gt;&lt;li&gt;首先，它是复合类型。因此我们需要对构造器 ( (a1 → a2) × [a3] ) → 和参数 [a2] 均进行替换。&lt;/li&gt;&lt;li&gt;由于基本类型不能进行合一替换，因此当我们遇到一个 →、×或者 [] 做构造器的时候，可以直接消去它。因此我们可以对上一部的构造器进行简化，得到 (a1 → a2) × [a3]。&lt;/li&gt;&lt;li&gt;继续考虑替换，我们拿到 (a1 → a2) × [a3] 后，检查 a1 → a2 与 [a3]。&lt;/li&gt;&lt;li&gt;检查 a1 → 与 a2，分别替换成 a3 与 a4，并且重新组合为一个复合类型，a3 → a4。&lt;/li&gt;&lt;li&gt;上溯，[] a3 无法替换，重新组合出 (a3 → a4) × [a3]。&lt;/li&gt;&lt;li&gt;上溯，[] a2 替换为 [] a4，与 (a3 → a4) × [a3] 重新组合出 ( (a3 → a4) × [a3] ) → [a4]。&lt;/li&gt;&lt;li&gt;替换完成。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;结语与预告&lt;/h2&gt;&lt;p&gt;我觉得最后一段的行文方式特别像老师上课一样，一步一步的讲……（&lt;/p&gt;&lt;p&gt;由于 Belleve 暴力而有效的行文方式（短句解释+直接贴代码），可能会劝退不少人，因此作了一些注释。后面几章也会慢慢更新。&lt;/p&gt;&lt;p&gt;本文没有经过任何人的校对，如有错误请直接指出。&lt;/p&gt;&lt;p&gt;一年前的东西重新挖出来，感觉就像盗墓贼一样。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下一篇《你的类型，1：基础推理》较长，我可能会分成几篇发出来。&lt;/p&gt;</description>
<author>霜月琉璃</author>
<guid isPermaLink="false">2017-08-04-28300506</guid>
<pubDate>Fri, 04 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Erlang入门教程 - 11. List进阶</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-07-30-28194753.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Erlang入门教程 - 11. List进阶&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28194753&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;记住”|”运算符可以用于获取列表的头元素：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;47&amp;gt; [M1|T1] = [paris, london, rome].
[paris,london,rome]
48&amp;gt; M1.
paris
49&amp;gt; T1.
[london,rome]&lt;/code&gt;&lt;p&gt;“|”运算符也可以用于向列表头添加一个元素：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;50&amp;gt; L1 = [madrid | T1].
[madrid,london,rome]
51&amp;gt; L1.
[madrid,london,rome]&lt;/code&gt;&lt;p&gt;现在举个例子说明它是如何工作的——反转列表：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut8).

-export([reverse/1]).

reverse(List) -&amp;gt;
    reverse(List, []).

reverse([Head | Rest], Reversed_List) -&amp;gt;
    reverse(Rest, [Head | Reversed_List]);
reverse([], Reversed_List) -&amp;gt;
    Reversed_List.&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;52&amp;gt; c(tut8).
{ok,tut8}
53&amp;gt; tut8:reverse([1,2,3]).
[3,2,1]&lt;/code&gt;&lt;p&gt;考虑一下&lt;b&gt;Reversed_List&lt;/b&gt;是如何构造出来的。它最开始是空列表”[]”，然后列表头元素被取走并添加到&lt;b&gt;Reversed_List&lt;/b&gt;里，如下所示：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;reverse([1|2,3], []) =&amp;gt;
    reverse([2,3], [1|[]])

reverse([2|3], [1]) =&amp;gt;
    reverse([3], [2|[1])

reverse([3|[]], [2,1]) =&amp;gt;
    reverse([], [3|[2,1]])

reverse([], [3,2,1]) =&amp;gt;
    [3,2,1]&lt;/code&gt;&lt;p&gt;lists模块包含了很多操纵列表的函数，比如反转列表。所以在写一个列表操纵的函数之前最好先检查一下是否它早已存在。&lt;/p&gt;&lt;p&gt;现在让我们回到城市温度的例子，但使用更结构化的方法。首先让我们把列表转化成只包含摄氏度：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&amp;gt;
    convert_list_to_c(List_of_cities).

convert_list_to_c([{Name, {f, F}} | Rest]) -&amp;gt;
    Converted_City = {Name, {c, (F -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&amp;gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&amp;gt;
    [].&lt;/code&gt;&lt;p&gt;测试这个函数：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;54&amp;gt; c(tut7).
{ok, tut7}.
55&amp;gt; tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},
{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).
[{moscow,{c,-10}},
 {cape_town,{c,21.11111111111111}},
 {stockholm,{c,-4}},
 {paris,{c,-2.2222222222222223}},
 {london,{c,2.2222222222222223}}]&lt;/code&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;format_temps(List_of_cities) -&amp;gt;
    convert_list_to_c(List_of_cities).&lt;/code&gt;&lt;p&gt;在这里&lt;b&gt;format_temps/1&lt;/b&gt;调用&lt;b&gt;convert_list_to_c/1&lt;/b&gt;。而&lt;i&gt;convert_list_to_c/1&lt;/i&gt;取列表&lt;b&gt;List_of_cities&lt;/b&gt;头元素，如果是摄氏度就什么也不做如果是华氏度还需要转化为摄氏度。 “|”运算符用于把转化后的元素添加到转换后的列表中，像这样：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;[Converted_City | convert_list_to_c(Rest)];&lt;/code&gt;&lt;p&gt;或者：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;[City | convert_list_to_c(Rest)];&lt;/code&gt;&lt;p&gt;这个操作将会持续到到达列表尾部，即列表为空。&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;convert_list_to_c([]) -&amp;gt;
    [].&lt;/code&gt;&lt;p&gt;当列表完成转换后，添加一个输出的函数：&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&amp;gt;
    Converted_List = convert_list_to_c(List_of_cities),
    print_temp(Converted_List).

convert_list_to_c([{Name, {f, F}} | Rest]) -&amp;gt;
    Converted_City = {Name, {c, (F -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&amp;gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&amp;gt;
    [].

print_temp([{Name, {c, Temp}} | Rest]) -&amp;gt;
    io:format(&quot;~-15w ~w c~n&quot;, [Name, Temp]),
    print_temp(Rest);
print_temp([]) -&amp;gt;
    ok.&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;56&amp;gt; c(tut7).
{ok,tut7}
57&amp;gt; tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},
{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
ok&lt;/code&gt;&lt;p&gt;还必须添加一个函数寻找城市最高气温最低气温。下面的程序不是最佳解决方案，因为它遍历了列表四次。但最好是先力求清晰和正确，并且只有在需要时才改善程序效率。&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&amp;gt;
    Converted_List = convert_list_to_c(List_of_cities),
    print_temp(Converted_List),
    {Max_city, Min_city} = find_max_and_min(Converted_List),
    print_max_and_min(Max_city, Min_city).

convert_list_to_c([{Name, {f, Temp}} | Rest]) -&amp;gt;
    Converted_City = {Name, {c, (Temp -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&amp;gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&amp;gt;
    [].

print_temp([{Name, {c, Temp}} | Rest]) -&amp;gt;
    io:format(&quot;~-15w ~w c~n&quot;, [Name, Temp]),
    print_temp(Rest);
print_temp([]) -&amp;gt;
    ok.

find_max_and_min([City | Rest]) -&amp;gt;
    find_max_and_min(Rest, City, City).

find_max_and_min([{Name, {c, Temp}} | Rest], 
         {Max_Name, {c, Max_Temp}}, 
         {Min_Name, {c, Min_Temp}}) -&amp;gt;
    if 
        Temp &amp;gt; Max_Temp -&amp;gt;
            Max_City = {Name, {c, Temp}};           % Change
        true -&amp;gt; 
            Max_City = {Max_Name, {c, Max_Temp}} % Unchanged
    end,
    if
         Temp &amp;lt; Min_Temp -&amp;gt;
            Min_City = {Name, {c, Temp}};           % Change
        true -&amp;gt; 
            Min_City = {Min_Name, {c, Min_Temp}} % Unchanged
    end,
    find_max_and_min(Rest, Max_City, Min_City);

find_max_and_min([], Max_City, Min_City) -&amp;gt;
    {Max_City, Min_City}.

print_max_and_min({Max_name, {c, Max_temp}}, {Min_name, {c, Min_temp}}) -&amp;gt;
    io:format(&quot;Max temperature was ~w c in ~w~n&quot;, [Max_temp, Max_name]),
    io:format(&quot;Min temperature was ~w c in ~w~n&quot;, [Min_temp, Min_name]).&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;erlang&quot;&gt;58&amp;gt; c(tut7).
{ok, tut7}
59&amp;gt; tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},
{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
Max temperature was 21.11111111111111 c in cape_town
Min temperature was -10 c in moscow
ok&lt;/code&gt;</description>
<author>racaljk</author>
<guid isPermaLink="false">2017-07-30-28194753</guid>
<pubDate>Sun, 30 Jul 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
